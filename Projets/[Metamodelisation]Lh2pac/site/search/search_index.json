{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Design a liquid hydrogen powered aircraft","text":"<p>The aim of this project is to  design a liquid hydrogen powered aircraft (LH2PAC) by combining a numerical simulator  with three mathematical fields, namely surrogate modeling, uncertainty quantification and optimization:</p> <ul> <li>optimization algorithms are commonly used to solve design problems,</li> <li>uncertainty quantification (UQ) is becoming increasingly popular    to take into account various sources of uncertainties   that may occur during the design cycle,</li> <li>surrogate models are enablers for optimization and UQ   because the numerical simulators are often computationally expensive   and do not allow a sufficient number of evaluations to be obtained    to estimate statistics properly or to converge a numerical optimization algorithm.</li> </ul>"},{"location":"#problems","title":"Problems","text":""},{"location":"#introduction","title":"Introduction","text":"<p>The design problem aims to minimize the maximal take-off weight of an aircraft whilst ensuring some constraints such as a maximal take-off field length and a maximal approach speed.</p> <p>For this purpose, it will be possible to play with four design parameters.</p> <p>By the way, the design takes place in an uncertain environment where the technological choices can be probabilized.</p> <p>In the following, we will note \\(f:x,u\\mapsto f(x,u)\\) the MARILib-based model of a liquid hydrogen powered model where \\(x\\) are the design parameters and \\(u\\) the uncertain ones.</p> <p>We will assume that its computational cost is too high  and we will try to replace it with a surrogate model to address the following problem. </p>"},{"location":"#problem-1-surrogate-modeling-and-optimization","title":"Problem 1 - Surrogate modeling and optimization","text":"<p>We will create a surrogate model of \\(g:x\\mapsto g(x)=f(x,u_{\\mathrm{default}})\\) to approximate the objective and constraints of the design problem with respect to the design parameters \\(x\\). Then, we will use this surrogate model in an optimization process to minimize the objective whilst ensuring the constraints by varying the design parameters.</p>"},{"location":"#problem-2-surrogate-modeling-and-uncertainty-quantification","title":"Problem 2 - Surrogate modeling and uncertainty quantification","text":"<p>We will create a surrogate model of \\(h:u\\mapsto h(x)=f(x_{\\mathrm{default}},u)\\) to approximate the objective and constraints of the design problem with respect to the uncertain parameters \\(u\\). Then, we will use this surrogate model in an uncertainty study to propagate the uncertainty related to the technological choices, quantify the resulting output uncertainty and explain it from the uncertainty sources (sensitivity analysis).</p>"},{"location":"#problem-3-surrogate-modeling-and-robust-optimization","title":"Problem 3 - Surrogate modeling and robust optimization","text":"<p>We will create a surrogate model of \\(h:x,u\\mapsto h(x)=f(x,u)\\) to approximate the objective and constraints of the design problem with respect to both design parameters \\(x\\) and uncertain parameters \\(u\\). Then, we will use this surrogate model to to seek the best aircraft concept taking into account the uncertainty of technological choices.</p>"},{"location":"#software","title":"Software","text":"<p>To solve these problems, we will combine the MARILib Python library  for aircraft modeling, and the GEMSEO Python library  for problem definition, optimization, surrogate modeling and uncertainty quantification.</p> <p>GEMSEO relies on popular Python libraries, such as  scikit-learn for surrogate modeling, OpenTURNS for uncertainty quantification, NumPy and SciPy for scientific computing and matplotlib for visualization.</p>"},{"location":"generated/scripts/examples/","title":"Examples","text":""},{"location":"generated/scripts/examples/#examples","title":"Examples","text":"<p> Unit conversion </p> <p> Draw an aircraft </p> <p> The H2TurboFan discipline </p> <p> Create a design space </p> <p> Design of experiments </p> <p> Sensitivity analysis </p> <p> Optimization </p> <p> Uncertain space </p> <p> Uncertainty propagation </p> <p> Surrogate model </p> <p> Download all examples in Python source code: examples_python.zip</p> <p> Download all examples in Jupyter notebooks: examples_jupyter.zip</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/scripts/examples/mg_execution_times/","title":"Computation times","text":"<p>00:22.616 total execution time for generated_scripts_examples files:</p> <p>+---------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | plot_sensitivity_analysis (docs/scripts/examples/plot_sensitivity_analysis.py)          | 00:10.176 | 0.0 MB | +---------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | plot_draw_aicraft (docs/scripts/examples/plot_draw_aicraft.py)                                  | 00:05.538 | 0.0 MB | +---------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | plot_h2turbo_fan (docs/scripts/examples/plot_h2turbo_fan.py)                                     | 00:04.029 | 0.0 MB | +---------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | plot_optimization (docs/scripts/examples/plot_optimization.py)                                  | 00:01.367 | 0.0 MB | +---------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | plot_doe (docs/scripts/examples/plot_doe.py)                                                             | 00:00.703 | 0.0 MB | +---------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | plot_uncertainty_propagation (docs/scripts/examples/plot_uncertainty_propagation.py) | 00:00.605 | 0.0 MB | +---------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | plot_surrogate (docs/scripts/examples/plot_surrogate.py)                                           | 00:00.178 | 0.0 MB | +---------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | plot_uncertain_space (docs/scripts/examples/plot_uncertain_space.py)                         | 00:00.008 | 0.0 MB | +---------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | plot_unit_conversion (docs/scripts/examples/plot_unit_conversion.py)                         | 00:00.007 | 0.0 MB | +---------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | plot_design_space (docs/scripts/examples/plot_design_space.py)                                  | 00:00.004 | 0.0 MB | +---------------------------------------------------------------------------------------------------------------------------+-----------+--------+</p>"},{"location":"generated/scripts/examples/plot_design_space/","title":"Create a design space","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/scripts/examples/plot_design_space/#create-a-design-space","title":"Create a design space","text":"<p>A <code>DesignSpace</code> defines the space in which the design variables belongs and is required to set the optimization problem, in the same way as the objective and the constraints.</p>"},{"location":"generated/scripts/examples/plot_design_space/#create-a-design-space_1","title":"Create a design space","text":"<p>The simplest is to use the function <code>create_design_space</code>:</p> <pre><code>from gemseo import create_design_space\n\ndesign_space = create_design_space()\n</code></pre> <p>This design space can include a design variable \\(x\\) without bounds and without current value:</p> <pre><code>design_space.add_variable(\"x\")\n</code></pre> <p>a design variable \\(y\\) of dimension 2 with a lower bound and a current value:</p> <pre><code>from numpy import array\n\ndesign_space.add_variable(\"y\", size=2, l_b=0.0, value=array([0.5, 0.75]))\n</code></pre> <p>as well as a design variable \\(z\\) with both lower and upper bounds but without default value:</p> <pre><code>design_space.add_variable(\"z\", l_b=-1.0, u_b=1.0)\n</code></pre> <p>Let's take a look at this design space:</p> <pre><code>design_space\n</code></pre> Design space: Name Lower bound Value Upper bound Type x -inf None inf float y[0] 0 0.5 inf float y[1] 0 0.75 inf float z -1 None 1 float"},{"location":"generated/scripts/examples/plot_design_space/#create-a-class-of-design-space","title":"Create a class of design space","text":"<p>If we want to use this design space more than once, it can be more convenient and Pythonic to use the object-oriented paradigm and subclass <code>DesignSpace</code>:</p> <pre><code>from gemseo.algos.design_space import DesignSpace\n\n\nclass MyDesignSpace(DesignSpace):\n    def __init__(self):\n        super().__init__(name=\"foo\")\n        self.add_variable(\"x\")\n        self.add_variable(\"y\", size=2, l_b=0.0, value=array([0.5, 0.75]))\n        self.add_variable(\"z\", l_b=-1.0, u_b=1.0)\n</code></pre> <p>Then, we only have to instantiate <code>MyDesignSpace</code>:</p> <pre><code>design_space = MyDesignSpace()\ndesign_space\n</code></pre> My design space: foo Name Lower bound Value Upper bound Type x -inf None inf float y[0] 0 0.5 inf float y[1] 0 0.75 inf float z -1 None 1 float <p>Total running time of the script: ( 0 minutes  0.004 seconds)</p> <p> Download Python source code: plot_design_space.py</p> <p> Download Jupyter notebook: plot_design_space.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/scripts/examples/plot_doe/","title":"Design of experiments","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/scripts/examples/plot_doe/#design-of-experiments","title":"Design of experiments","text":"<p>The <code>DOEScenario</code> defines an evaluation problem from one or more disciplines, a design space and a DOE (design of experiments) algorithm.</p> <p>In this example, we want to sample the Rosenbrock function \\(f(x,y)=(1-x)^2+100*(y-x^2)^2\\) over the design space \\([-2,2]^2\\) with a latin hypercube sampling (LHS) algorithm improved by simulated annealing.</p> <pre><code>from gemseo import configure_logger\nfrom gemseo import create_design_space\nfrom gemseo import create_discipline\nfrom gemseo import create_scenario\n</code></pre> <p>First, we activate the logger.</p> <pre><code>configure_logger()\n</code></pre> <p>Out:</p> <pre><code>&lt;RootLogger root (INFO)&gt;\n</code></pre> <p>Then, we create a discipline to evaluate \\((1-x)^2+100*(y-x^2)^2\\):</p> <pre><code>discipline = create_discipline(\n    \"AnalyticDiscipline\",\n    expressions={\"z\": \"(1-x)**2+100*(y-x**2)**2\"},\n    name=\"Rosenbrock\",\n)\n</code></pre> <p>Note</p> <p>The <code>AnalyticDiscipline</code> allows us to define functions from strings and automatically get the expression of the derivatives, based on sympy, a Python library for symbolic mathematics.</p> <p>Then, we create the design space \\([-2,2]^2\\):</p> <pre><code>design_space = create_design_space()\ndesign_space.add_variable(\"x\", l_b=-2, u_b=2)\ndesign_space.add_variable(\"y\", l_b=-2, u_b=2)\n</code></pre> <p>Thirdly, we create a <code>DOEScenario</code> from this discipline and this design space:</p> <pre><code>disciplines = [discipline]\nscenario = create_scenario(\n    disciplines, \"DisciplinaryOpt\", \"z\", design_space, scenario_type=\"DOE\"\n)\n</code></pre> <p>Out:</p> <pre><code>/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/pyDOE2/doe_factorial.py:16: DeprecationWarning: the imp module is deprecated in favour of importlib; see the module's documentation for alternative uses\n  import imp\n</code></pre> <p>Note</p> <p><code>\"DisciplinaryOpt\"</code> means that we evaluate the <code>disciplines</code> sequentially; then, if the output of a discipline is the input of one of the following, its value will be used (in this case, there is only one discipline but the argument is mandatory).</p> <p>Note</p> <p>In the case where there is more than one output of interest, you can use the method <code>add_observable</code> to store the evaluations of the other outputs of interest:</p> <pre><code>   scenario = create_scenario(\n       disciplines, \"DisciplinaryOpt\", \"foo\", design_space, scenario_type=\"DOE\"\n   )\n   scenario.add_observable(\"bar\")\n   scenario.add_observable(\"baz\")\n</code></pre> <p>Now, we can sample the discipline to get 100 evaluations of the triple \\((x,y,z)\\):</p> <pre><code>scenario.execute({\"algo\": \"OT_OPT_LHS\", \"n_samples\": 100})\n</code></pre> <p>Out:</p> <pre><code>    INFO - 15:01:28:  \n    INFO - 15:01:28: *** Start DOEScenario execution ***\n    INFO - 15:01:28: DOEScenario\n    INFO - 15:01:28:    Disciplines: Rosenbrock\n    INFO - 15:01:28:    MDO formulation: DisciplinaryOpt\n    INFO - 15:01:28: Optimization problem:\n    INFO - 15:01:28:    minimize z(x, y)\n    INFO - 15:01:28:    with respect to x, y\n    INFO - 15:01:28:    over the design space:\n    INFO - 15:01:28:       +------+-------------+-------+-------------+-------+\n    INFO - 15:01:28:       | Name | Lower bound | Value | Upper bound | Type  |\n    INFO - 15:01:28:       +------+-------------+-------+-------------+-------+\n    INFO - 15:01:28:       | x    |      -2     |  None |      2      | float |\n    INFO - 15:01:28:       | y    |      -2     |  None |      2      | float |\n    INFO - 15:01:28:       +------+-------------+-------+-------------+-------+\n    INFO - 15:01:28: Solving optimization problem with algorithm OT_OPT_LHS:\n    INFO - 15:01:28:      1%|          | 1/100 [00:00&lt;00:00, 477.87 it/sec, obj=2.19e+3]\n    INFO - 15:01:28:      2%|\u258f         | 2/100 [00:00&lt;00:00, 692.13 it/sec, obj=1.07e+3]\n    INFO - 15:01:28:      3%|\u258e         | 3/100 [00:00&lt;00:00, 882.14 it/sec, obj=675]\n    INFO - 15:01:28:      4%|\u258d         | 4/100 [00:00&lt;00:00, 1026.19 it/sec, obj=1.15e+3]\n    INFO - 15:01:28:      5%|\u258c         | 5/100 [00:00&lt;00:00, 1150.51 it/sec, obj=2.51e+3]\n    INFO - 15:01:28:      6%|\u258c         | 6/100 [00:00&lt;00:00, 1254.09 it/sec, obj=30.7]\n    INFO - 15:01:28:      7%|\u258b         | 7/100 [00:00&lt;00:00, 1343.96 it/sec, obj=2.18e+3]\n    INFO - 15:01:28:      8%|\u258a         | 8/100 [00:00&lt;00:00, 1420.77 it/sec, obj=885]\n    INFO - 15:01:28:      9%|\u2589         | 9/100 [00:00&lt;00:00, 1484.94 it/sec, obj=53.1]\n    INFO - 15:01:28:     10%|\u2588         | 10/100 [00:00&lt;00:00, 1541.68 it/sec, obj=994]\n    INFO - 15:01:28:     11%|\u2588         | 11/100 [00:00&lt;00:00, 1592.70 it/sec, obj=169]\n    INFO - 15:01:28:     12%|\u2588\u258f        | 12/100 [00:00&lt;00:00, 1635.90 it/sec, obj=735]\n    INFO - 15:01:28:     13%|\u2588\u258e        | 13/100 [00:00&lt;00:00, 1665.93 it/sec, obj=0.9]\n    INFO - 15:01:28:     14%|\u2588\u258d        | 14/100 [00:00&lt;00:00, 1701.30 it/sec, obj=244]\n    INFO - 15:01:28:     15%|\u2588\u258c        | 15/100 [00:00&lt;00:00, 1732.90 it/sec, obj=266]\n    INFO - 15:01:28:     16%|\u2588\u258c        | 16/100 [00:00&lt;00:00, 1764.54 it/sec, obj=26.2]\n    INFO - 15:01:28:     17%|\u2588\u258b        | 17/100 [00:00&lt;00:00, 1795.10 it/sec, obj=203]\n    INFO - 15:01:28:     18%|\u2588\u258a        | 18/100 [00:00&lt;00:00, 1823.65 it/sec, obj=435]\n    INFO - 15:01:28:     19%|\u2588\u2589        | 19/100 [00:00&lt;00:00, 1848.27 it/sec, obj=186]\n    INFO - 15:01:28:     20%|\u2588\u2588        | 20/100 [00:00&lt;00:00, 1872.83 it/sec, obj=501]\n    INFO - 15:01:28:     21%|\u2588\u2588        | 21/100 [00:00&lt;00:00, 1893.71 it/sec, obj=82.9]\n    INFO - 15:01:28:     22%|\u2588\u2588\u258f       | 22/100 [00:00&lt;00:00, 1912.03 it/sec, obj=8.31]\n    INFO - 15:01:28:     23%|\u2588\u2588\u258e       | 23/100 [00:00&lt;00:00, 1909.94 it/sec, obj=6.15]\n    INFO - 15:01:28:     24%|\u2588\u2588\u258d       | 24/100 [00:00&lt;00:00, 1928.12 it/sec, obj=60.3]\n    INFO - 15:01:28:     25%|\u2588\u2588\u258c       | 25/100 [00:00&lt;00:00, 1946.49 it/sec, obj=323]\n    INFO - 15:01:28:     26%|\u2588\u2588\u258c       | 26/100 [00:00&lt;00:00, 1960.94 it/sec, obj=94.4]\n    INFO - 15:01:28:     27%|\u2588\u2588\u258b       | 27/100 [00:00&lt;00:00, 1974.41 it/sec, obj=2.01]\n    INFO - 15:01:28:     28%|\u2588\u2588\u258a       | 28/100 [00:00&lt;00:00, 1988.43 it/sec, obj=1.87]\n    INFO - 15:01:28:     29%|\u2588\u2588\u2589       | 29/100 [00:00&lt;00:00, 2002.05 it/sec, obj=1.93e+3]\n    INFO - 15:01:28:     30%|\u2588\u2588\u2588       | 30/100 [00:00&lt;00:00, 2012.88 it/sec, obj=247]\n    INFO - 15:01:28:     31%|\u2588\u2588\u2588       | 31/100 [00:00&lt;00:00, 2022.04 it/sec, obj=58.4]\n    INFO - 15:01:28:     32%|\u2588\u2588\u2588\u258f      | 32/100 [00:00&lt;00:00, 2028.68 it/sec, obj=3.72]\n    INFO - 15:01:28:     33%|\u2588\u2588\u2588\u258e      | 33/100 [00:00&lt;00:00, 2039.40 it/sec, obj=160]\n    INFO - 15:01:28:     34%|\u2588\u2588\u2588\u258d      | 34/100 [00:00&lt;00:00, 2051.51 it/sec, obj=335]\n    INFO - 15:01:28:     35%|\u2588\u2588\u2588\u258c      | 35/100 [00:00&lt;00:00, 2062.39 it/sec, obj=333]\n    INFO - 15:01:28:     36%|\u2588\u2588\u2588\u258c      | 36/100 [00:00&lt;00:00, 2070.64 it/sec, obj=590]\n    INFO - 15:01:28:     37%|\u2588\u2588\u2588\u258b      | 37/100 [00:00&lt;00:00, 2080.34 it/sec, obj=1.5e+3]\n    INFO - 15:01:28:     38%|\u2588\u2588\u2588\u258a      | 38/100 [00:00&lt;00:00, 2088.74 it/sec, obj=67.5]\n    INFO - 15:01:28:     39%|\u2588\u2588\u2588\u2589      | 39/100 [00:00&lt;00:00, 2096.51 it/sec, obj=848]\n    INFO - 15:01:28:     40%|\u2588\u2588\u2588\u2588      | 40/100 [00:00&lt;00:00, 2104.86 it/sec, obj=688]\n    INFO - 15:01:28:     41%|\u2588\u2588\u2588\u2588      | 41/100 [00:00&lt;00:00, 2114.27 it/sec, obj=8.1]\n    INFO - 15:01:28:     42%|\u2588\u2588\u2588\u2588\u258f     | 42/100 [00:00&lt;00:00, 2117.75 it/sec, obj=2.39e+3]\n    INFO - 15:01:28:     43%|\u2588\u2588\u2588\u2588\u258e     | 43/100 [00:00&lt;00:00, 2124.45 it/sec, obj=1.06e+3]\n    INFO - 15:01:28:     44%|\u2588\u2588\u2588\u2588\u258d     | 44/100 [00:00&lt;00:00, 2131.97 it/sec, obj=22]\n    INFO - 15:01:28:     45%|\u2588\u2588\u2588\u2588\u258c     | 45/100 [00:00&lt;00:00, 2138.91 it/sec, obj=294]\n    INFO - 15:01:28:     46%|\u2588\u2588\u2588\u2588\u258c     | 46/100 [00:00&lt;00:00, 2145.40 it/sec, obj=1.04e+3]\n    INFO - 15:01:28:     47%|\u2588\u2588\u2588\u2588\u258b     | 47/100 [00:00&lt;00:00, 2149.45 it/sec, obj=29.5]\n    INFO - 15:01:28:     48%|\u2588\u2588\u2588\u2588\u258a     | 48/100 [00:00&lt;00:00, 2156.06 it/sec, obj=165]\n    INFO - 15:01:28:     49%|\u2588\u2588\u2588\u2588\u2589     | 49/100 [00:00&lt;00:00, 2161.78 it/sec, obj=261]\n    INFO - 15:01:28:     50%|\u2588\u2588\u2588\u2588\u2588     | 50/100 [00:00&lt;00:00, 2167.44 it/sec, obj=55.2]\n    INFO - 15:01:28:     51%|\u2588\u2588\u2588\u2588\u2588     | 51/100 [00:00&lt;00:00, 2172.51 it/sec, obj=388]\n    INFO - 15:01:28:     52%|\u2588\u2588\u2588\u2588\u2588\u258f    | 52/100 [00:00&lt;00:00, 2174.32 it/sec, obj=358]\n    INFO - 15:01:28:     53%|\u2588\u2588\u2588\u2588\u2588\u258e    | 53/100 [00:00&lt;00:00, 2178.18 it/sec, obj=1.04e+3]\n    INFO - 15:01:28:     54%|\u2588\u2588\u2588\u2588\u2588\u258d    | 54/100 [00:00&lt;00:00, 2183.21 it/sec, obj=16.7]\n    INFO - 15:01:28:     55%|\u2588\u2588\u2588\u2588\u2588\u258c    | 55/100 [00:00&lt;00:00, 2187.74 it/sec, obj=21.5]\n    INFO - 15:01:28:     56%|\u2588\u2588\u2588\u2588\u2588\u258c    | 56/100 [00:00&lt;00:00, 2192.57 it/sec, obj=84.9]\n    INFO - 15:01:28:     57%|\u2588\u2588\u2588\u2588\u2588\u258b    | 57/100 [00:00&lt;00:00, 2197.06 it/sec, obj=338]\n    INFO - 15:01:28:     58%|\u2588\u2588\u2588\u2588\u2588\u258a    | 58/100 [00:00&lt;00:00, 2202.09 it/sec, obj=869]\n    INFO - 15:01:28:     59%|\u2588\u2588\u2588\u2588\u2588\u2589    | 59/100 [00:00&lt;00:00, 2205.34 it/sec, obj=400]\n    INFO - 15:01:28:     60%|\u2588\u2588\u2588\u2588\u2588\u2588    | 60/100 [00:00&lt;00:00, 2209.93 it/sec, obj=160]\n    INFO - 15:01:28:     61%|\u2588\u2588\u2588\u2588\u2588\u2588    | 61/100 [00:00&lt;00:00, 2214.48 it/sec, obj=370]\n    INFO - 15:01:28:     62%|\u2588\u2588\u2588\u2588\u2588\u2588\u258f   | 62/100 [00:00&lt;00:00, 2215.56 it/sec, obj=274]\n    INFO - 15:01:28:     63%|\u2588\u2588\u2588\u2588\u2588\u2588\u258e   | 63/100 [00:00&lt;00:00, 2220.27 it/sec, obj=48.1]\n    INFO - 15:01:28:     64%|\u2588\u2588\u2588\u2588\u2588\u2588\u258d   | 64/100 [00:00&lt;00:00, 2223.75 it/sec, obj=1.25]\n    INFO - 15:01:28:     65%|\u2588\u2588\u2588\u2588\u2588\u2588\u258c   | 65/100 [00:00&lt;00:00, 2227.86 it/sec, obj=167]\n    INFO - 15:01:28:     66%|\u2588\u2588\u2588\u2588\u2588\u2588\u258c   | 66/100 [00:00&lt;00:00, 2231.48 it/sec, obj=91.1]\n    INFO - 15:01:28:     67%|\u2588\u2588\u2588\u2588\u2588\u2588\u258b   | 67/100 [00:00&lt;00:00, 2235.84 it/sec, obj=845]\n    INFO - 15:01:28:     68%|\u2588\u2588\u2588\u2588\u2588\u2588\u258a   | 68/100 [00:00&lt;00:00, 2238.63 it/sec, obj=5.05]\n    INFO - 15:01:28:     69%|\u2588\u2588\u2588\u2588\u2588\u2588\u2589   | 69/100 [00:00&lt;00:00, 2238.85 it/sec, obj=96]\n    INFO - 15:01:28:     70%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588   | 70/100 [00:00&lt;00:00, 2241.68 it/sec, obj=1.35e+3]\n    INFO - 15:01:28:     71%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588   | 71/100 [00:00&lt;00:00, 2241.80 it/sec, obj=74.5]\n    INFO - 15:01:28:     72%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f  | 72/100 [00:00&lt;00:00, 2243.13 it/sec, obj=463]\n    INFO - 15:01:28:     73%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e  | 73/100 [00:00&lt;00:00, 2245.26 it/sec, obj=25.2]\n    INFO - 15:01:28:     74%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d  | 74/100 [00:00&lt;00:00, 2248.42 it/sec, obj=540]\n    INFO - 15:01:28:     75%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c  | 75/100 [00:00&lt;00:00, 2250.84 it/sec, obj=59.6]\n    INFO - 15:01:28:     76%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c  | 76/100 [00:00&lt;00:00, 2254.08 it/sec, obj=43.9]\n    INFO - 15:01:28:     77%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b  | 77/100 [00:00&lt;00:00, 2256.75 it/sec, obj=211]\n    INFO - 15:01:28:     78%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a  | 78/100 [00:00&lt;00:00, 2257.65 it/sec, obj=641]\n    INFO - 15:01:28:     79%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589  | 79/100 [00:00&lt;00:00, 2259.03 it/sec, obj=101]\n    INFO - 15:01:28:     80%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588  | 80/100 [00:00&lt;00:00, 2262.12 it/sec, obj=723]\n    INFO - 15:01:28:     81%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588  | 81/100 [00:00&lt;00:00, 2263.16 it/sec, obj=82.6]\n    INFO - 15:01:28:     82%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f | 82/100 [00:00&lt;00:00, 2265.15 it/sec, obj=580]\n    INFO - 15:01:28:     83%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e | 83/100 [00:00&lt;00:00, 2267.89 it/sec, obj=35.6]\n    INFO - 15:01:28:     84%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d | 84/100 [00:00&lt;00:00, 2270.63 it/sec, obj=1.72e+3]\n    INFO - 15:01:28:     85%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c | 85/100 [00:00&lt;00:00, 2273.51 it/sec, obj=4.25]\n    INFO - 15:01:28:     86%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c | 86/100 [00:00&lt;00:00, 2271.33 it/sec, obj=113]\n    INFO - 15:01:28:     87%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b | 87/100 [00:00&lt;00:00, 2271.45 it/sec, obj=54.1]\n    INFO - 15:01:28:     88%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a | 88/100 [00:00&lt;00:00, 2272.05 it/sec, obj=2.36e+3]\n    INFO - 15:01:28:     89%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589 | 89/100 [00:00&lt;00:00, 2273.90 it/sec, obj=119]\n    INFO - 15:01:28:     90%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | 90/100 [00:00&lt;00:00, 2276.65 it/sec, obj=227]\n    INFO - 15:01:28:     91%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | 91/100 [00:00&lt;00:00, 2277.04 it/sec, obj=951]\n    INFO - 15:01:28:     92%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f| 92/100 [00:00&lt;00:00, 2279.04 it/sec, obj=246]\n    INFO - 15:01:28:     93%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e| 93/100 [00:00&lt;00:00, 2280.06 it/sec, obj=76.2]\n    INFO - 15:01:28:     94%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d| 94/100 [00:00&lt;00:00, 2281.66 it/sec, obj=0.75]\n    INFO - 15:01:28:     95%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c| 95/100 [00:00&lt;00:00, 2282.36 it/sec, obj=123]\n    INFO - 15:01:28:     96%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c| 96/100 [00:00&lt;00:00, 2284.22 it/sec, obj=957]\n    INFO - 15:01:28:     97%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b| 97/100 [00:00&lt;00:00, 2286.05 it/sec, obj=187]\n    INFO - 15:01:28:     98%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a| 98/100 [00:00&lt;00:00, 2288.03 it/sec, obj=122]\n    INFO - 15:01:28:     99%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589| 99/100 [00:00&lt;00:00, 2289.33 it/sec, obj=146]\n    INFO - 15:01:28:    100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [00:00&lt;00:00, 2289.63 it/sec, obj=167]\n    INFO - 15:01:28: Optimization result:\n    INFO - 15:01:28:    Optimizer info:\n    INFO - 15:01:28:       Status: None\n    INFO - 15:01:28:       Message: None\n    INFO - 15:01:28:       Number of calls to the objective function by the optimizer: 100\n    INFO - 15:01:28:    Solution:\n    INFO - 15:01:28:       Objective: 0.7502023831914535\n    INFO - 15:01:28:       Design space:\n    INFO - 15:01:28:          +------+-------------+--------------------+-------------+-------+\n    INFO - 15:01:28:          | Name | Lower bound |       Value        | Upper bound | Type  |\n    INFO - 15:01:28:          +------+-------------+--------------------+-------------+-------+\n    INFO - 15:01:28:          | x    |      -2     | 0.6290200784167475 |      2      | float |\n    INFO - 15:01:28:          | y    |      -2     | 0.3173990065780083 |      2      | float |\n    INFO - 15:01:28:          +------+-------------+--------------------+-------------+-------+\n    INFO - 15:01:28: *** End DOEScenario execution (time: 0:00:00.063026) ***\n\n{'eval_jac': False, 'n_samples': 100, 'algo': 'OT_OPT_LHS'}\n</code></pre> <p>Note</p> <p><code>DOEScenario</code> is mainly used to solve an optimization problem with a DOE algorithm instead of an optimization algorithm. This is the reason why the log presents an optimization problem and optimization result.</p> <p>Lastly, we can export the result to an <code>IODataset</code> which is a subclass of <code>Dataset</code>, which is a subclass of <code>pandas.DataFrame</code>:</p> <pre><code>dataset = scenario.to_dataset(opt_naming=False)\ndataset\n</code></pre> <p>Out:</p> <pre><code>/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to IODataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to IODataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n</code></pre> GROUP inputs outputs VARIABLE x y z COMPONENT 0 0 0 0 1.922870 -0.983117 2191.602002 1 -1.623831 -0.631063 1074.794249 2 -1.284228 -0.939310 675.278032 3 -1.404675 -1.412094 1151.744652 4 -1.948194 -1.200895 2505.048222 ... ... ... ... 95 -1.529573 -0.743620 957.019782 96 -0.030064 -1.364104 187.385541 97 1.278946 0.531163 122.078532 98 -0.501204 1.450870 146.173021 99 0.100055 1.297336 166.530600 <p>100 rows \u00d7 3 columns</p> <p>Seealso</p> <ul> <li>Dataset examples</li> <li>DOE examples</li> </ul> <p>Total running time of the script: ( 0 minutes  0.703 seconds)</p> <p> Download Python source code: plot_doe.py</p> <p> Download Jupyter notebook: plot_doe.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/scripts/examples/plot_draw_aicraft/","title":"Draw an aircraft","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/scripts/examples/plot_draw_aicraft/#draw-an-aircraft","title":"Draw an aircraft","text":"<pre><code>from lh2pac.gemseo.utils import draw_aircraft\n</code></pre> <p>First, we draw the default aircraft:</p> <pre><code>draw_aircraft()\n</code></pre> <p></p> <p>Out:</p> <pre><code>/home/mickael/ModIA_5A/Metamodelisation/lh2pac/src/lh2pac/marilib/aircraft/tool/drawing.py:287: UserWarning: FigureCanvasAgg is non-interactive, and thus cannot be shown\n  plt.show()\n</code></pre> <p>Then, we draw an aircraft with a higher aspect ratio:</p> <pre><code>draw_aircraft({\"aspect_ratio\": 12}, \"Higher aspect ratio\")\n</code></pre> <p></p> <p>Out:</p> <pre><code>/home/mickael/ModIA_5A/Metamodelisation/lh2pac/src/lh2pac/marilib/aircraft/tool/drawing.py:287: UserWarning: FigureCanvasAgg is non-interactive, and thus cannot be shown\n  plt.show()\n</code></pre> <p>Lastly, we draw an aircraft with a lower aspect ratio:</p> <pre><code>draw_aircraft({\"aspect_ratio\": 7}, \"Lower aspect ratio\")\n</code></pre> <p></p> <p>Out:</p> <pre><code>/home/mickael/ModIA_5A/Metamodelisation/lh2pac/src/lh2pac/marilib/aircraft/tool/drawing.py:287: UserWarning: FigureCanvasAgg is non-interactive, and thus cannot be shown\n  plt.show()\n</code></pre> <p>Total running time of the script: ( 0 minutes  5.538 seconds)</p> <p> Download Python source code: plot_draw_aicraft.py</p> <p> Download Jupyter notebook: plot_draw_aicraft.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/scripts/examples/plot_h2turbo_fan/","title":"The H2TurboFan discipline","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/scripts/examples/plot_h2turbo_fan/#the-h2turbofan-discipline","title":"The H2TurboFan discipline","text":"<pre><code>from numpy import array\n\nfrom lh2pac.gemseo.discipline import H2TurboFan\nfrom lh2pac.gemseo.utils import draw_aircraft\nfrom lh2pac.gemseo.utils import get_aircraft_data\n</code></pre> <p>First, we instantiate the discipline:</p> <pre><code>discipline = H2TurboFan()\n</code></pre> <p>Then, we can have a look at its input names:</p> <pre><code>discipline.get_input_data_names()\n</code></pre> <p>Out:</p> <pre><code>['thrust', 'bpr', 'area', 'aspect_ratio', 'tgi', 'tvi', 'sfc', 'mass', 'drag']\n</code></pre> <p>output names:</p> <pre><code>discipline.get_output_data_names()\n</code></pre> <p>Out:</p> <pre><code>['mtow', 'tofl', 'vapp', 'vz_mcl', 'vz_mcr', 'oei_path', 'ttc', 'far', 'fuel', 'coc']\n</code></pre> <p>and default input values:</p> <pre><code>discipline.default_inputs\n</code></pre> <p>Out:</p> <pre><code>{'area': array([160.]), 'aspect_ratio': array([9.5]), 'thrust': array([125000.]), 'bpr': array([8.5]), 'drag': array([1.]), 'tgi': array([0.3]), 'tvi': array([0.845]), 'sfc': array([1.]), 'mass': array([1.])}\n</code></pre> <p>and execute the discipline with these values:</p> <pre><code>discipline.execute()\n</code></pre> <p>Out:</p> <pre><code>{'area': array([160.]), 'aspect_ratio': array([9.5]), 'thrust': array([125000.]), 'bpr': array([8.5]), 'drag': array([1.]), 'tgi': array([0.3]), 'tvi': array([0.845]), 'sfc': array([1.]), 'mass': array([1.]), 'vapp': array([70.64663708]), 'mtow': array([84264.87197867]), 'coc': array([5790.24820306]), 'vz_mcr': array([1.11425584]), 'far': array([13.14324743]), 'fuel': array([994.73460336]), 'vz_mcl': array([5.53241387]), 'oei_path': array([0.01700101]), 'tofl': array([2144.18746791]), 'ttc': array([1094.19026816])}\n</code></pre> <p>We can print the aircraft data:</p> <pre><code>aircraft_data = get_aircraft_data(discipline)\nprint(aircraft_data)\n</code></pre> <p>Out:</p> <pre><code>---------------------------------------------------------------------------\nDrag factor =    1.000 (0.99 =&lt; kcx =&lt; 1.03)\nSFC factor =    1.000 (0.99 =&lt; ksfc =&lt; 1.03)\nMass factor =    1.000 (0.99 =&lt; kmass =&lt; 1.03)\nTank Volumetric Index =    0.845 m3-LH2 / m3-(LH2+Tank), (0.6 =&lt; vi =&lt; 0.85)\nTank Gravimetric Index =    0.300 kg-LH2 / kg-(LH2+Tank), (0.25 =&lt; gi =&lt; 0.305)\n\nReference thrust =    125.0 kN, (100 =&lt; thrust =&lt; 150)\nBy Pass Ratio =      8.5 (5 =&lt; bpr =&lt; 12)\nReference area =    160.0 m2, (120 =&lt; area =&lt; 200)\nAspect ratio =      9.5 (7 =&lt; ar =&lt; 12)\n---------------------------------------------------------------------------\nCriterion, Max Take Off Weight =  84264.9 kg\nCriterion, Cost mission fuel block =    994.7 kg\nCriterion, Cash Operating Cost =   5790.2 $/trip\n\nConstraint, Take Off Field Length =   2144.2 m (must be =&lt; 2200 m)\nConstraint, Approach speed =    137.3 kt (must be =&lt; 137 kt)\nConstraint, Vertical speed, MCL rating, TOC =   1089.1 ft/min (must be &gt;= 300 ft/min)\nConstraint, Vertical speed, MCR rating, TOC =    219.3 ft/min (must be &gt;= 0 ft/min)\nConstraint, One Engine Inoperative climb path =     1.70 % (must be &gt;= 1.1%)\nConstraint, Time To Climb =     18.2 min (must be =&lt; 25 min)\nConstraint, fuselage aspect ratio =   13.143 (must be =&lt; 13.4)\n</code></pre> <p>and draw the aircraft:</p> <pre><code>draw_aircraft(discipline, \"The default A/C\")\n</code></pre> <p></p> <p>Out:</p> <pre><code>/home/mickael/ModIA_5A/Metamodelisation/lh2pac/src/lh2pac/marilib/aircraft/tool/drawing.py:287: UserWarning: FigureCanvasAgg is non-interactive, and thus cannot be shown\n  plt.show()\n</code></pre> <p>Lastly, we can execute the discipline with a higher aspect ratio:</p> <pre><code>discipline.execute({\"aspect_ratio\": array([12])})\n</code></pre> <p>Out:</p> <pre><code>{'thrust': array([125000.]), 'bpr': array([8.5]), 'area': array([160.]), 'aspect_ratio': array([12]), 'tgi': array([0.3]), 'tvi': array([0.845]), 'sfc': array([1.]), 'mass': array([1.]), 'drag': array([1.]), 'vapp': array([70.64457577]), 'mtow': array([83953.10807835]), 'coc': array([5787.04862876]), 'vz_mcr': array([2.02629216]), 'far': array([12.96364774]), 'fuel': array([943.30955561]), 'vz_mcl': array([6.20068054]), 'oei_path': array([0.02229883]), 'tofl': array([2130.16395761]), 'ttc': array([1014.59863128])}\n</code></pre> <p>print the aircraft data:</p> <pre><code>aircraft_data = get_aircraft_data(discipline)\nprint(aircraft_data)\n</code></pre> <p>Out:</p> <pre><code>---------------------------------------------------------------------------\nDrag factor =    1.000 (0.99 =&lt; kcx =&lt; 1.03)\nSFC factor =    1.000 (0.99 =&lt; ksfc =&lt; 1.03)\nMass factor =    1.000 (0.99 =&lt; kmass =&lt; 1.03)\nTank Volumetric Index =    0.845 m3-LH2 / m3-(LH2+Tank), (0.6 =&lt; vi =&lt; 0.85)\nTank Gravimetric Index =    0.300 kg-LH2 / kg-(LH2+Tank), (0.25 =&lt; gi =&lt; 0.305)\n\nReference thrust =    125.0 kN, (100 =&lt; thrust =&lt; 150)\nBy Pass Ratio =      8.5 (5 =&lt; bpr =&lt; 12)\nReference area =    160.0 m2, (120 =&lt; area =&lt; 200)\nAspect ratio =     12.0 (7 =&lt; ar =&lt; 12)\n---------------------------------------------------------------------------\nCriterion, Max Take Off Weight =  83953.1 kg\nCriterion, Cost mission fuel block =    943.3 kg\nCriterion, Cash Operating Cost =   5787.0 $/trip\n\nConstraint, Take Off Field Length =   2130.2 m (must be =&lt; 2200 m)\nConstraint, Approach speed =    137.3 kt (must be =&lt; 137 kt)\nConstraint, Vertical speed, MCL rating, TOC =   1220.6 ft/min (must be &gt;= 300 ft/min)\nConstraint, Vertical speed, MCR rating, TOC =    398.9 ft/min (must be &gt;= 0 ft/min)\nConstraint, One Engine Inoperative climb path =     2.23 % (must be &gt;= 1.1%)\nConstraint, Time To Climb =     16.9 min (must be =&lt; 25 min)\nConstraint, fuselage aspect ratio =   12.964 (must be =&lt; 13.4)\n</code></pre> <p>and draw the aircraft:</p> <pre><code>draw_aircraft(discipline, \"An A/C with an higher AR\")\n</code></pre> <p></p> <p>Out:</p> <pre><code>/home/mickael/ModIA_5A/Metamodelisation/lh2pac/src/lh2pac/marilib/aircraft/tool/drawing.py:287: UserWarning: FigureCanvasAgg is non-interactive, and thus cannot be shown\n  plt.show()\n</code></pre> <p>Total running time of the script: ( 0 minutes  4.029 seconds)</p> <p> Download Python source code: plot_h2turbo_fan.py</p> <p> Download Jupyter notebook: plot_h2turbo_fan.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/scripts/examples/plot_optimization/","title":"Optimization","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/scripts/examples/plot_optimization/#optimization","title":"Optimization","text":"<p>We want to minimize the Rosenbrock function \\(f(x,y)=(1-x)^2+100(y-x**2)^2\\) over the domain \\([-2,2]^2\\).</p> <pre><code>from gemseo import configure_logger\nfrom gemseo import create_design_space\nfrom gemseo import create_discipline\nfrom gemseo import create_scenario\n</code></pre> <p>Before starting, we activate the logger as an optimization process logs meaningful information.</p> <pre><code>configure_logger()\n</code></pre> <p>Out:</p> <pre><code>&lt;RootLogger root (INFO)&gt;\n</code></pre> <p>Firstly, we define the discipline computing the Rosenbrock function and the Euclidean distance to the optimum:</p> <pre><code>discipline = create_discipline(\n    \"AnalyticDiscipline\",\n    expressions={\"z\": \"(1-x)**2+100*(y-x**2)**2\", \"c\": \"((x-1)**2+(y-1)**2)**0.5\"},\n    name=\"Rosenbrock\"\n)\n</code></pre> <p>Then, we create the design space:</p> <pre><code>design_space = create_design_space()\ndesign_space.add_variable(\"x\", l_b=-2., u_b=2., value=0.)\ndesign_space.add_variable(\"y\", l_b=-2., u_b=2., value=0.)\n</code></pre> <p>Thirdly, we put these elements together in a scenario to minimize the Rosenbrock function under the constraint that the distance between the design point and the solution of the unconstrained problem is greater or equal to 1.</p> <pre><code>scenario = create_scenario([discipline], \"DisciplinaryOpt\", \"z\", design_space)\nscenario.add_constraint(\"c\", constraint_type=\"ineq\", positive=True, value=1.)\n</code></pre> <p>Note</p> <p>GEMSEO is a Python library dedicated to multidisciplinary design optimization (MDO) based on the notion of MDO formulation. This is why the second positional argument <code>formulation</code> is mandatory. But when using the scenario with a unique discipline, don't bother and consider <code>\"DisciplinaryOpt\"</code>.</p> <p>before executing it with a gradient-free optimizer:</p> <pre><code>scenario.execute({\"algo\": \"NLOPT_COBYLA\", \"max_iter\": 100})\n</code></pre> <p>Out:</p> <pre><code>    INFO - 15:01:39:  \n    INFO - 15:01:39: *** Start MDOScenario execution ***\n    INFO - 15:01:39: MDOScenario\n    INFO - 15:01:39:    Disciplines: Rosenbrock\n    INFO - 15:01:39:    MDO formulation: DisciplinaryOpt\n    INFO - 15:01:39: Optimization problem:\n    INFO - 15:01:39:    minimize z(x, y)\n    INFO - 15:01:39:    with respect to x, y\n    INFO - 15:01:39:    subject to constraints:\n    INFO - 15:01:39:       c(x, y) &gt;= 1.0\n    INFO - 15:01:39:    over the design space:\n    INFO - 15:01:39:       +------+-------------+-------+-------------+-------+\n    INFO - 15:01:39:       | Name | Lower bound | Value | Upper bound | Type  |\n    INFO - 15:01:39:       +------+-------------+-------+-------------+-------+\n    INFO - 15:01:39:       | x    |      -2     |   0   |      2      | float |\n    INFO - 15:01:39:       | y    |      -2     |   0   |      2      | float |\n    INFO - 15:01:39:       +------+-------------+-------+-------------+-------+\n    INFO - 15:01:39: Solving optimization problem with algorithm NLOPT_COBYLA:\n    INFO - 15:01:39:      1%|          | 1/100 [00:00&lt;00:00, 370.98 it/sec, obj=1]\n    INFO - 15:01:39:      2%|\u258f         | 2/100 [00:00&lt;00:00, 512.34 it/sec, obj=100]\n    INFO - 15:01:39:      3%|\u258e         | 3/100 [00:00&lt;00:00, 643.82 it/sec, obj=101]\n    INFO - 15:01:39:      4%|\u258d         | 4/100 [00:00&lt;00:00, 676.69 it/sec, obj=148]\n    INFO - 15:01:39:      5%|\u258c         | 5/100 [00:00&lt;00:00, 705.97 it/sec, obj=24.8]\n    INFO - 15:01:39:      6%|\u258c         | 6/100 [00:00&lt;00:00, 731.05 it/sec, obj=3.64]\n    INFO - 15:01:39:      7%|\u258b         | 7/100 [00:00&lt;00:00, 750.46 it/sec, obj=6.11]\n    INFO - 15:01:39:      8%|\u258a         | 8/100 [00:00&lt;00:00, 764.37 it/sec, obj=1.88]\n    INFO - 15:01:39:      9%|\u2589         | 9/100 [00:00&lt;00:00, 775.65 it/sec, obj=1.4]\n    INFO - 15:01:39:     10%|\u2588         | 10/100 [00:00&lt;00:00, 786.75 it/sec, obj=0.954]\n    INFO - 15:01:39:     11%|\u2588         | 11/100 [00:00&lt;00:00, 795.43 it/sec, obj=1.21]\n    INFO - 15:01:39:     12%|\u2588\u258f        | 12/100 [00:00&lt;00:00, 799.24 it/sec, obj=0.861]\n    INFO - 15:01:39:     13%|\u2588\u258e        | 13/100 [00:00&lt;00:00, 805.23 it/sec, obj=0.88]\n    INFO - 15:01:39:     14%|\u2588\u258d        | 14/100 [00:00&lt;00:00, 811.34 it/sec, obj=0.841]\n    INFO - 15:01:39:     15%|\u2588\u258c        | 15/100 [00:00&lt;00:00, 810.23 it/sec, obj=0.833]\n    INFO - 15:01:39:     16%|\u2588\u258c        | 16/100 [00:00&lt;00:00, 814.59 it/sec, obj=0.784]\n    INFO - 15:01:39:     17%|\u2588\u258b        | 17/100 [00:00&lt;00:00, 818.78 it/sec, obj=0.762]\n    INFO - 15:01:39:     18%|\u2588\u258a        | 18/100 [00:00&lt;00:00, 821.96 it/sec, obj=0.742]\n    INFO - 15:01:39:     19%|\u2588\u2589        | 19/100 [00:00&lt;00:00, 824.50 it/sec, obj=0.749]\n    INFO - 15:01:39:     20%|\u2588\u2588        | 20/100 [00:00&lt;00:00, 828.76 it/sec, obj=0.729]\n    INFO - 15:01:39:     21%|\u2588\u2588        | 21/100 [00:00&lt;00:00, 831.84 it/sec, obj=0.727]\n    INFO - 15:01:39:     22%|\u2588\u2588\u258f       | 22/100 [00:00&lt;00:00, 832.65 it/sec, obj=0.745]\n    INFO - 15:01:39:     23%|\u2588\u2588\u258e       | 23/100 [00:00&lt;00:00, 834.49 it/sec, obj=0.713]\n    INFO - 15:01:39:     24%|\u2588\u2588\u258d       | 24/100 [00:00&lt;00:00, 837.37 it/sec, obj=0.7]\n    INFO - 15:01:39:     25%|\u2588\u2588\u258c       | 25/100 [00:00&lt;00:00, 838.84 it/sec, obj=0.688]\n    INFO - 15:01:39:     26%|\u2588\u2588\u258c       | 26/100 [00:00&lt;00:00, 839.80 it/sec, obj=0.675]\n    INFO - 15:01:39:     27%|\u2588\u2588\u258b       | 27/100 [00:00&lt;00:00, 842.34 it/sec, obj=0.664]\n    INFO - 15:01:39:     28%|\u2588\u2588\u258a       | 28/100 [00:00&lt;00:00, 843.63 it/sec, obj=0.652]\n    INFO - 15:01:39:     29%|\u2588\u2588\u2589       | 29/100 [00:00&lt;00:00, 844.76 it/sec, obj=0.64]\n    INFO - 15:01:39:     30%|\u2588\u2588\u2588       | 30/100 [00:00&lt;00:00, 846.70 it/sec, obj=0.629]\n    INFO - 15:01:39:     31%|\u2588\u2588\u2588       | 31/100 [00:00&lt;00:00, 848.68 it/sec, obj=0.618]\n    INFO - 15:01:39:     32%|\u2588\u2588\u2588\u258f      | 32/100 [00:00&lt;00:00, 849.73 it/sec, obj=0.607]\n    INFO - 15:01:39:     33%|\u2588\u2588\u2588\u258e      | 33/100 [00:00&lt;00:00, 850.13 it/sec, obj=0.596]\n    INFO - 15:01:39:     34%|\u2588\u2588\u2588\u258d      | 34/100 [00:00&lt;00:00, 851.23 it/sec, obj=0.585]\n    INFO - 15:01:39:     35%|\u2588\u2588\u2588\u258c      | 35/100 [00:00&lt;00:00, 851.50 it/sec, obj=0.576]\n    INFO - 15:01:39:     36%|\u2588\u2588\u2588\u258c      | 36/100 [00:00&lt;00:00, 852.40 it/sec, obj=0.566]\n    INFO - 15:01:39:     37%|\u2588\u2588\u2588\u258b      | 37/100 [00:00&lt;00:00, 853.81 it/sec, obj=0.544]\n    INFO - 15:01:39:     38%|\u2588\u2588\u2588\u258a      | 38/100 [00:00&lt;00:00, 855.34 it/sec, obj=0.524]\n    INFO - 15:01:39:     39%|\u2588\u2588\u2588\u2589      | 39/100 [00:00&lt;00:00, 855.57 it/sec, obj=0.513]\n    INFO - 15:01:39:     40%|\u2588\u2588\u2588\u2588      | 40/100 [00:00&lt;00:00, 856.11 it/sec, obj=0.491]\n    INFO - 15:01:39:     41%|\u2588\u2588\u2588\u2588      | 41/100 [00:00&lt;00:00, 857.30 it/sec, obj=0.511]\n    INFO - 15:01:39:     42%|\u2588\u2588\u2588\u2588\u258f     | 42/100 [00:00&lt;00:00, 857.88 it/sec, obj=0.577]\n    INFO - 15:01:39:     43%|\u2588\u2588\u2588\u2588\u258e     | 43/100 [00:00&lt;00:00, 858.22 it/sec, obj=0.527]\n    INFO - 15:01:39:     44%|\u2588\u2588\u2588\u2588\u258d     | 44/100 [00:00&lt;00:00, 859.30 it/sec, obj=0.493]\n    INFO - 15:01:39:     45%|\u2588\u2588\u2588\u2588\u258c     | 45/100 [00:00&lt;00:00, 860.50 it/sec, obj=0.485]\n    INFO - 15:01:39:     46%|\u2588\u2588\u2588\u2588\u258c     | 46/100 [00:00&lt;00:00, 860.58 it/sec, obj=0.483]\n    INFO - 15:01:39:     47%|\u2588\u2588\u2588\u2588\u258b     | 47/100 [00:00&lt;00:00, 861.14 it/sec, obj=0.511]\n    INFO - 15:01:39:     48%|\u2588\u2588\u2588\u2588\u258a     | 48/100 [00:00&lt;00:00, 861.95 it/sec, obj=0.47]\n    INFO - 15:01:39:     49%|\u2588\u2588\u2588\u2588\u2589     | 49/100 [00:00&lt;00:00, 862.87 it/sec, obj=0.468]\n    INFO - 15:01:39:     50%|\u2588\u2588\u2588\u2588\u2588     | 50/100 [00:00&lt;00:00, 862.71 it/sec, obj=0.457]\n    INFO - 15:01:39:     51%|\u2588\u2588\u2588\u2588\u2588     | 51/100 [00:00&lt;00:00, 863.13 it/sec, obj=0.449]\n    INFO - 15:01:39:     52%|\u2588\u2588\u2588\u2588\u2588\u258f    | 52/100 [00:00&lt;00:00, 864.02 it/sec, obj=0.44]\n    INFO - 15:01:39:     53%|\u2588\u2588\u2588\u2588\u2588\u258e    | 53/100 [00:00&lt;00:00, 864.28 it/sec, obj=0.431]\n    INFO - 15:01:39:     54%|\u2588\u2588\u2588\u2588\u2588\u258d    | 54/100 [00:00&lt;00:00, 863.64 it/sec, obj=0.415]\n    INFO - 15:01:39:     55%|\u2588\u2588\u2588\u2588\u2588\u258c    | 55/100 [00:00&lt;00:00, 864.20 it/sec, obj=0.411]\n    INFO - 15:01:39:     56%|\u2588\u2588\u2588\u2588\u2588\u258c    | 56/100 [00:00&lt;00:00, 864.12 it/sec, obj=0.394]\n    INFO - 15:01:39:     57%|\u2588\u2588\u2588\u2588\u2588\u258b    | 57/100 [00:00&lt;00:00, 864.38 it/sec, obj=0.422]\n    INFO - 15:01:39:     58%|\u2588\u2588\u2588\u2588\u2588\u258a    | 58/100 [00:00&lt;00:00, 864.96 it/sec, obj=0.403]\n    INFO - 15:01:39:     59%|\u2588\u2588\u2588\u2588\u2588\u2589    | 59/100 [00:00&lt;00:00, 865.52 it/sec, obj=0.393]\n    INFO - 15:01:39:     60%|\u2588\u2588\u2588\u2588\u2588\u2588    | 60/100 [00:00&lt;00:00, 865.61 it/sec, obj=0.391]\n    INFO - 15:01:39:     61%|\u2588\u2588\u2588\u2588\u2588\u2588    | 61/100 [00:00&lt;00:00, 865.85 it/sec, obj=0.382]\n    INFO - 15:01:39:     62%|\u2588\u2588\u2588\u2588\u2588\u2588\u258f   | 62/100 [00:00&lt;00:00, 866.42 it/sec, obj=0.375]\n    INFO - 15:01:39:     63%|\u2588\u2588\u2588\u2588\u2588\u2588\u258e   | 63/100 [00:00&lt;00:00, 866.84 it/sec, obj=0.371]\n    INFO - 15:01:39:     64%|\u2588\u2588\u2588\u2588\u2588\u2588\u258d   | 64/100 [00:00&lt;00:00, 866.99 it/sec, obj=0.363]\n    INFO - 15:01:39:     65%|\u2588\u2588\u2588\u2588\u2588\u2588\u258c   | 65/100 [00:00&lt;00:00, 867.38 it/sec, obj=0.364]\n    INFO - 15:01:39:     66%|\u2588\u2588\u2588\u2588\u2588\u2588\u258c   | 66/100 [00:00&lt;00:00, 867.75 it/sec, obj=0.362]\n    INFO - 15:01:39:     67%|\u2588\u2588\u2588\u2588\u2588\u2588\u258b   | 67/100 [00:00&lt;00:00, 867.72 it/sec, obj=0.357]\n    INFO - 15:01:39:     68%|\u2588\u2588\u2588\u2588\u2588\u2588\u258a   | 68/100 [00:00&lt;00:00, 867.89 it/sec, obj=0.355]\n    INFO - 15:01:39:     69%|\u2588\u2588\u2588\u2588\u2588\u2588\u2589   | 69/100 [00:00&lt;00:00, 868.40 it/sec, obj=0.351]\n    INFO - 15:01:39:     70%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588   | 70/100 [00:00&lt;00:00, 868.31 it/sec, obj=0.347]\n    INFO - 15:01:39:     71%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588   | 71/100 [00:00&lt;00:00, 868.42 it/sec, obj=0.34]\n    INFO - 15:01:39:     72%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f  | 72/100 [00:00&lt;00:00, 868.56 it/sec, obj=0.334]\n    INFO - 15:01:39:     73%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e  | 73/100 [00:00&lt;00:00, 868.50 it/sec, obj=0.334]\n    INFO - 15:01:39:     74%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d  | 74/100 [00:00&lt;00:00, 868.98 it/sec, obj=0.334]\n    INFO - 15:01:39:     75%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c  | 75/100 [00:00&lt;00:00, 869.46 it/sec, obj=0.337]\n    INFO - 15:01:39:     76%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c  | 76/100 [00:00&lt;00:00, 869.67 it/sec, obj=0.332]\n    INFO - 15:01:39:     77%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b  | 77/100 [00:00&lt;00:00, 869.94 it/sec, obj=0.331]\n    INFO - 15:01:39:     78%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a  | 78/100 [00:00&lt;00:00, 870.54 it/sec, obj=0.329]\n    INFO - 15:01:39:     79%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589  | 79/100 [00:00&lt;00:00, 870.99 it/sec, obj=0.331]\n    INFO - 15:01:39:     80%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588  | 80/100 [00:00&lt;00:00, 871.17 it/sec, obj=0.328]\n    INFO - 15:01:39:     81%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588  | 81/100 [00:00&lt;00:00, 871.39 it/sec, obj=0.329]\n    INFO - 15:01:39:     82%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f | 82/100 [00:00&lt;00:00, 871.70 it/sec, obj=0.329]\n    INFO - 15:01:39:     83%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e | 83/100 [00:00&lt;00:00, 872.34 it/sec, obj=0.328]\n    INFO - 15:01:39:     84%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d | 84/100 [00:00&lt;00:00, 872.30 it/sec, obj=0.328]\n    INFO - 15:01:39:     85%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c | 85/100 [00:00&lt;00:00, 872.43 it/sec, obj=0.329]\n    INFO - 15:01:39:     86%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c | 86/100 [00:00&lt;00:00, 872.20 it/sec, obj=0.328]\n    INFO - 15:01:39:     87%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b | 87/100 [00:00&lt;00:00, 872.08 it/sec, obj=0.328]\n    INFO - 15:01:39:     88%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a | 88/100 [00:00&lt;00:00, 872.16 it/sec, obj=0.328]\n    INFO - 15:01:39:     89%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589 | 89/100 [00:00&lt;00:00, 872.56 it/sec, obj=0.328]\n    INFO - 15:01:39:     90%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | 90/100 [00:00&lt;00:00, 872.99 it/sec, obj=0.328]\n    INFO - 15:01:39:     91%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | 91/100 [00:00&lt;00:00, 873.00 it/sec, obj=0.328]\n    INFO - 15:01:39:     92%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f| 92/100 [00:00&lt;00:00, 873.32 it/sec, obj=0.328]\n    INFO - 15:01:39:     93%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e| 93/100 [00:00&lt;00:00, 873.34 it/sec, obj=0.328]\n    INFO - 15:01:39:     94%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d| 94/100 [00:00&lt;00:00, 873.15 it/sec, obj=0.328]\n    INFO - 15:01:39:     95%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c| 95/100 [00:00&lt;00:00, 873.21 it/sec, obj=0.328]\n    INFO - 15:01:39:     96%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c| 96/100 [00:00&lt;00:00, 873.42 it/sec, obj=0.328]\n    INFO - 15:01:39:     97%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b| 97/100 [00:00&lt;00:00, 873.37 it/sec, obj=0.328]\n    INFO - 15:01:39:     98%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a| 98/100 [00:00&lt;00:00, 873.66 it/sec, obj=0.328]\n    INFO - 15:01:39:     99%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589| 99/100 [00:00&lt;00:00, 873.98 it/sec, obj=0.328]\n    INFO - 15:01:39:    100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [00:00&lt;00:00, 873.92 it/sec, obj=0.328]\n    INFO - 15:01:39: Optimization result:\n    INFO - 15:01:39:    Optimizer info:\n    INFO - 15:01:39:       Status: None\n    INFO - 15:01:39:       Message: Maximum number of iterations reached. GEMSEO Stopped the driver\n    INFO - 15:01:39:       Number of calls to the objective function by the optimizer: 102\n    INFO - 15:01:39:    Solution:\n    INFO - 15:01:39:       The solution is feasible.\n    INFO - 15:01:39:       Objective: 0.3283010611441774\n    INFO - 15:01:39:       Standardized constraints:\n    INFO - 15:01:39:          -[c-1.0] = 6.591815177348082e-05\n    INFO - 15:01:39:       Design space:\n    INFO - 15:01:39:          +------+-------------+--------------------+-------------+-------+\n    INFO - 15:01:39:          | Name | Lower bound |       Value        | Upper bound | Type  |\n    INFO - 15:01:39:          +------+-------------+--------------------+-------------+-------+\n    INFO - 15:01:39:          | x    |      -2     | 0.4281647812612155 |      2      | float |\n    INFO - 15:01:39:          | y    |      -2     | 0.1797118490118108 |      2      | float |\n    INFO - 15:01:39:          +------+-------------+--------------------+-------------+-------+\n    INFO - 15:01:39: *** End MDOScenario execution (time: 0:00:00.126928) ***\n\n{'max_iter': 100, 'algo': 'NLOPT_COBYLA'}\n</code></pre> <p>Lastly, we can plot the optimization history:</p> <pre><code>scenario.post_process(\"OptHistoryView\", save=False, show=True)\n</code></pre> <p>Out:</p> <pre><code>/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/gemseo/utils/matplotlib_figure.py:57: UserWarning: FigureCanvasAgg is non-interactive, and thus cannot be shown\n  plt.show()\n\n&lt;gemseo.post.opt_history_view.OptHistoryView object at 0x7a7f63307ee0&gt;\n</code></pre> <p>Total running time of the script: ( 0 minutes  1.367 seconds)</p> <p> Download Python source code: plot_optimization.py</p> <p> Download Jupyter notebook: plot_optimization.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/scripts/examples/plot_sensitivity_analysis/","title":"Sensitivity analysis","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/scripts/examples/plot_sensitivity_analysis/#sensitivity-analysis","title":"Sensitivity analysis","text":"<p>In this example, we will use the Sobol' analysis to quantify the sensitivity of the output of the Ishigami function to its inputs:</p> \\[f(x_1,x_2,x_3)=\\sin(x_1)+7\\sin(x_2)^2+0.1*x_3^4\\sin(x_1)\\] <p>where \\(x_1,x_2,x_3\\in[-\\pi,\\pi]\\).</p> <pre><code>import pprint\n\nfrom gemseo.algos.parameter_space import ParameterSpace\nfrom gemseo import create_discipline\nfrom gemseo.uncertainty.sensitivity.sobol.analysis import SobolAnalysis\nfrom numpy import pi\n</code></pre> <p>Firstly, we create the Ishigami function:</p> <pre><code>discipline = create_discipline(\n    \"AnalyticDiscipline\",\n    expressions={\"y\": \"sin(x2)+7*sin(x1)**2+0.1*x3**4*sin(x2)\"},\n    name=\"Ishigami\",\n)\n</code></pre> <p>Then, we define the uncertain space with uniform distributions:</p> <pre><code>uncertain_space = ParameterSpace()\nfor name in [\"x1\", \"x2\", \"x3\"]:\n    uncertain_space.add_random_variable(\n        name, \"OTUniformDistribution\", minimum=-pi, maximum=pi\n    )\n</code></pre> <p>From that, we launch a Sobol' analysis with a maximum of 10000 samples:</p> <p>Warning</p> <p>The estimation of Sobol' indices relies on the pick-and-freeze (PF) DOE algorithm and most of the UQ libraries generates \\((1+p)N\\) evaluations where \\(p\\) is the dimension of the input space and \\(N\\) is presented as the number of samples. In fact, \\(N\\) is not the number of samples of the simulators but the number of samples in the sense of the PF-based estimators, which is misleading. This is reason why GEMSEO considers a maximum number of samples \\(n\\), i.e a maximum number of simulations, and then \\(N\\) is deduced from this number: \\(N=\\lceil n/(1+p)\\rceil\\).</p> <pre><code>sobol = SobolAnalysis([discipline], uncertain_space, 10000)\nsobol.compute_indices()\n</code></pre> <p>Out:</p> <pre><code>/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to IODataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to IODataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to IODataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n\n{&lt;Method.FIRST: 'first'&gt;: {'y': [{'x1': array([0.43704383]), 'x2': array([0.25794631]), 'x3': array([0.01847323])}]}, 'second': {'y': [{'x1': {'x1': array([[0.]]), 'x2': array([[-0.03347684]]), 'x3': array([[-0.02292812]])}, 'x2': {'x1': array([[-0.03347684]]), 'x2': array([[0.]]), 'x3': array([[0.25936497]])}, 'x3': {'x1': array([[-0.02292812]]), 'x2': array([[0.25936497]]), 'x3': array([[0.]])}}]}, &lt;Method.TOTAL: 'total'&gt;: {'y': [{'x1': array([0.41479788]), 'x2': array([0.59310361]), 'x3': array([0.26454354])}]}}\n</code></pre> <p>and print the results:</p> <pre><code>pprint.pprint(sobol.first_order_indices)\npprint.pprint(sobol.total_order_indices)\n</code></pre> <p>Out:</p> <pre><code>{'y': [{'x1': array([0.43704383]),\n        'x2': array([0.25794631]),\n        'x3': array([0.01847323])}]}\n{'y': [{'x1': array([0.41479788]),\n        'x2': array([0.59310361]),\n        'x3': array([0.26454354])}]}\n</code></pre> <p>We can also visualize both first-order and total Sobol' indices that are automatically sorted by magnitude:</p> <pre><code>sobol.plot(\"y\", save=False, show=True)\n</code></pre> <p></p> <p>Out:</p> <pre><code>/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to IODataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/gemseo/utils/matplotlib_figure.py:57: UserWarning: FigureCanvasAgg is non-interactive, and thus cannot be shown\n  plt.show()\n\n&lt;Figure size 640x480 with 1 Axes&gt;\n</code></pre> <p>Total running time of the script: ( 0 minutes  10.176 seconds)</p> <p> Download Python source code: plot_sensitivity_analysis.py</p> <p> Download Jupyter notebook: plot_sensitivity_analysis.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/scripts/examples/plot_surrogate/","title":"Surrogate model","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/scripts/examples/plot_surrogate/#surrogate-model","title":"Surrogate model","text":"<p>In this example, we will build a surrogate model of the Rosenbrock function and a constraint related to an Rosenbrock-based optimization problem.</p> <pre><code>import pickle\nfrom pathlib import Path\n\nfrom gemseo import create_design_space\nfrom gemseo import create_discipline\nfrom gemseo import create_surrogate\nfrom gemseo import import_discipline\nfrom gemseo.mlearning.quality_measures.r2_measure import R2Measure\nfrom gemseo.mlearning.quality_measures.rmse_measure import RMSEMeasure\nfrom gemseo_mlearning.api import sample_discipline\n</code></pre> <p>Firstly, we define the discipline computing the Rosenbrock function and the Euclidean distance to the optimum:</p> <pre><code>from numpy import array\n\ndiscipline = create_discipline(\n    \"AnalyticDiscipline\",\n    expressions={\"z\": \"(1-x)**2+100*(y-x**2)**2\", \"c\": \"((x-1)**2+(y-1)**2)**0.5\"},\n    name=\"Rosenbrock\",\n)\n</code></pre> <p>Then, we create the design space:</p> <pre><code>design_space = create_design_space()\ndesign_space.add_variable(\"x\", l_b=-2.0, u_b=2.0, value=0.0)\ndesign_space.add_variable(\"y\", l_b=-2.0, u_b=2.0, value=0.0)\n</code></pre> <p>Then, we sample the discipline with an optimal LHS:</p> <pre><code>dataset = sample_discipline(discipline, design_space, [\"z\", \"c\"], \"OT_OPT_LHS\", 30)\n</code></pre> <p>Out:</p> <pre><code>/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to IODataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n</code></pre> <p>before creating a surrogate discipline:</p> <pre><code>surrogate_discipline = create_surrogate(\"RBFRegressor\", dataset)\n</code></pre> <p>Out:</p> <pre><code>/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to IODataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to IODataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to IODataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to IODataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to IODataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n</code></pre> <p>and using it for prediction:</p> <pre><code>surrogate_discipline.execute({\"x\": array([1.0])})\nsurrogate_discipline.cache.last_entry\n</code></pre> <p>Out:</p> <pre><code>/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to IODataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n\nCacheEntry(inputs={'x': array([1.]), 'y': array([0.01176985])}, outputs={'c': array([0.95861794]), 'z': array([97.71890412])}, jacobian={})\n</code></pre> <p>This surrogate discipline can be used in a scenario. The underlying regression model can also be assessed, with the R2 measure for instance:</p> <pre><code>r2 = R2Measure(surrogate_discipline.regression_model, True)\nr2.compute_learning_measure()\nr2.compute_cross_validation_measure()\n</code></pre> <p>Out:</p> <pre><code>/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to IODataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to IODataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to IODataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to IODataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to IODataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to IODataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to IODataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to IODataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to IODataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to IODataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to IODataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to IODataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to IODataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to IODataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to IODataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to IODataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to IODataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to IODataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to IODataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to IODataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to IODataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to IODataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to IODataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to IODataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to IODataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to IODataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to IODataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to IODataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to IODataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to IODataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to IODataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to IODataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n\narray([0.99621966, 0.78601484])\n</code></pre> <p>or with the root mean squared error:</p> <pre><code>rmse = RMSEMeasure(surrogate_discipline.regression_model, True)\nrmse.compute_learning_measure()\nrmse.compute_cross_validation_measure()\n\nwith Path(\"my_surrogate.pkl\").open(\"wb\") as f:\n    pickle.dump(surrogate_discipline, f)\n\ndiscipline = import_discipline(\"my_surrogate.pkl\")\ndiscipline.execute({\"x\": array([1.0])})\ndiscipline.get_output_data()\n</code></pre> <p>Out:</p> <pre><code>/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to IODataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to IODataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to IODataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to IODataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to IODataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to IODataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to IODataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to IODataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to IODataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to IODataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to IODataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to IODataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to IODataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to IODataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to IODataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to IODataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to IODataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to IODataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to IODataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to IODataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to IODataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to IODataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to IODataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to IODataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to IODataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to IODataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to IODataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to IODataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n\n{'z': array([97.71890412]), 'c': array([0.95861794])}\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.178 seconds)</p> <p> Download Python source code: plot_surrogate.py</p> <p> Download Jupyter notebook: plot_surrogate.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/scripts/examples/plot_uncertain_space/","title":"Uncertain space","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/scripts/examples/plot_uncertain_space/#uncertain-space","title":"Uncertain space","text":"<p>GEMSEO does not offer an uncertain space but a <code>ParameterSpace</code>, grouping both deterministic and uncertain variables. This is a subclass of <code>DesignSpace</code> with a method <code>add_random_variable</code>.</p> <p>If you want to create an uncertain space, create a <code>ParameterSpace</code> and only use its <code>add_random_variable</code> method.</p>"},{"location":"generated/scripts/examples/plot_uncertain_space/#create-an-uncertain-space","title":"Create an uncertain space","text":"<p>Firstly, we create an empty <code>ParameterSpace</code> from the high-level function <code>create_parameter_space</code>:</p> <pre><code>from gemseo import create_parameter_space\n\nuncertain_space = create_parameter_space()\n</code></pre> <p>and add a first uncertain variable \\(u\\), following the standard Gaussian distribution</p> <pre><code>uncertain_space.add_random_variable(\"u\", \"OTNormalDistribution\")\n</code></pre> <p>Note</p> <p>OT stands for OpenTURNS, the UQ library used for sampling.</p> <p>We can also add a second uncertain variable \\(v\\) following the Gaussian distribution with mean 2 and standard deviation 0.5:</p> <pre><code>uncertain_space.add_random_variable(\"v\", \"OTNormalDistribution\", mu=2, sigma=0.5)\n</code></pre> <p>as well as a third uncertain variable \\(w\\) following a triangular distribution:</p> <pre><code>uncertain_space.add_random_variable(\n    \"z\", \"OTTriangularDistribution\", minimum=-1.0, mode=0.5, maximum=1.0\n)\n</code></pre> <p>We can print this <code>ParameterSpace</code>:</p> <pre><code>uncertain_space\n</code></pre> Parameter space: Name Lower bound Value Upper bound Type Distribution u -inf 0 inf float Normal(mu=0.0, sigma=1.0) v -inf 2 inf float Normal(mu=2, sigma=0.5) z -1 0.1666666666666667 1 float Triangular(lower=-1.0, mode=0.5, upper=1.0) <p>.. note::    The initial current value corresponds to the mean of the random variables.</p>"},{"location":"generated/scripts/examples/plot_uncertain_space/#create-a-class-of-uncertain-space","title":"Create a class of uncertain space","text":"<p>If we want to use this uncertain space more than once, it can be more convenient and Pythonic to use the object-oriented paradigm and subclass <code>ParameterSpace</code>:</p> <pre><code>from gemseo.algos.parameter_space import ParameterSpace\n\n\nclass MyUncertainSpace(ParameterSpace):\n    def __init__(self):\n        super().__init__()\n        self.add_random_variable(\"u\", \"OTNormalDistribution\")\n        self.add_random_variable(\"v\", \"OTNormalDistribution\", mu=2, sigma=0.5)\n        self.add_random_variable(\n            \"z\", \"OTTriangularDistribution\", minimum=-1.0, mode=0.5, maximum=1.0\n        )\n</code></pre> <p>Then, we only have to instantiate <code>MyUncertainSpace</code>:</p> <pre><code>uncertain_space = MyUncertainSpace()\nuncertain_space\n</code></pre> My uncertain space: Name Lower bound Value Upper bound Type Distribution u -inf 0 inf float Normal(mu=0.0, sigma=1.0) v -inf 2 inf float Normal(mu=2, sigma=0.5) z -1 0.1666666666666667 1 float Triangular(lower=-1.0, mode=0.5, upper=1.0) <p>Total running time of the script: ( 0 minutes  0.008 seconds)</p> <p> Download Python source code: plot_uncertain_space.py</p> <p> Download Jupyter notebook: plot_uncertain_space.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/scripts/examples/plot_uncertainty_propagation/","title":"Uncertainty propagation","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/scripts/examples/plot_uncertainty_propagation/#uncertainty-propagation","title":"Uncertainty propagation","text":"<p>In this example, we will propagate uncertainties through a discipline \\(f:u,v\\mapsto u+v\\)</p> <pre><code>from gemseo import create_discipline\nfrom gemseo import create_parameter_space\nfrom gemseo.uncertainty import create_statistics\nfrom gemseo_mlearning.api import sample_discipline\nfrom matplotlib import pyplot as plt\n</code></pre> <p>Firstly, we define a uncertain space with two normal random variables \\(u\\) and \\(v\\) with mean -1 and +1 and unit standard deviation.</p> <pre><code>uncertain_space = create_parameter_space()\nuncertain_space.add_random_variable(\"u\", \"OTNormalDistribution\", mu=-1.0)\nuncertain_space.add_random_variable(\"v\", \"OTNormalDistribution\", mu=1.0)\n</code></pre> <p>Then, we define the discipline from analytic formula:</p> <pre><code>discipline = create_discipline(\"AnalyticDiscipline\", expressions={\"w\": \"u+v\"})\n</code></pre> <p>Thirdly, we sample the discipline with a Monte Carlo algorithm:</p> <pre><code>dataset = sample_discipline(discipline, uncertain_space, [\"w\"], \"OT_MONTE_CARLO\", 1000)\n</code></pre> <p>Out:</p> <pre><code>/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to IODataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n</code></pre> <p>Lastly, we create an <code>EmpiricalStatistics</code> object to estimate statistics, such as mean and variance:</p> <pre><code>statistics = create_statistics(dataset)\nmean = statistics.compute_mean()\nvariance = statistics.compute_variance()\nnames = [\"u\", \"v\", \"w\"]\nfor name in names:\n    print(name, mean[name][0], variance[name][0])\n</code></pre> <p>Out:</p> <pre><code>/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to IODataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\nu -0.947776842011246 0.9405180678918997\nv 0.9589697721518806 1.0263090423482364\nw 0.011192930140634615 1.9698802472293142\n</code></pre> <p>Note</p> <p>The mean and standard deviation of the output are almost equal to 0 and 2, which is the expected behavior of the sum of two independent Gaussian random variables.</p> <p>We can also plot the histogram of the three random variables:</p> <pre><code>fig, axes = plt.subplots(1, 3)\nfor ax, name in zip(axes, names):\n    ax.hist(dataset.get_view(variable_names=name))\n    ax.set_title(name)\nplt.show()\n</code></pre> <p></p> <p>Out:</p> <pre><code>/home/mickael/ModIA_5A/Metamodelisation/lh2pac/.venv/lib/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to IODataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n/home/mickael/ModIA_5A/Metamodelisation/lh2pac/docs/scripts/examples/plot_uncertainty_propagation.py:57: UserWarning: FigureCanvasAgg is non-interactive, and thus cannot be shown\n  plt.show()\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.605 seconds)</p> <p> Download Python source code: plot_uncertainty_propagation.py</p> <p> Download Jupyter notebook: plot_uncertainty_propagation.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/scripts/examples/plot_unit_conversion/","title":"Unit conversion","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/scripts/examples/plot_unit_conversion/#unit-conversion","title":"Unit conversion","text":"<p>The data presented in the use case description are often expressed with usual units but the simulator requires standard units. This example illustrates how to convert a data from a unit to another.</p> <p>First, we load the <code>unit</code> module.</p> <pre><code>from lh2pac.marilib.utils import unit\n</code></pre> <p>Then, we consider a time value expressed in minutes:</p> <pre><code>time_in_minutes = 1\n</code></pre> <p>Lastly, we convert it into seconds:</p> <pre><code>time_in_seconds = unit.s_min(time_in_minutes)\ntime_in_seconds\n</code></pre> <p>Out:</p> <pre><code>60.0\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.007 seconds)</p> <p> Download Python source code: plot_unit_conversion.py</p> <p> Download Jupyter notebook: plot_unit_conversion.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/scripts/project/","title":"Scripts","text":""},{"location":"generated/scripts/project/#project","title":"Project","text":"<p> Download all examples in Python source code: project_python.zip</p> <p> Download all examples in Jupyter notebooks: project_jupyter.zip</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"presentation/dates/","title":"Important dates","text":""},{"location":"presentation/dates/#courses","title":"Courses","text":"Day Date Time Tuesday 28/05/2024 14h - 15h45 Tuesday 28/05/2024 16h15 - 18h Friday 31/05/2024 14h - 15h45 Friday 31/05/2024 16h15 - 18h Monday 03/06/2024 14h - 15h45 Monday 03/06/2024 16h15 - 18h Thursday 03/06/2024 14h - 15h45 Thursday 03/06/2024 16h15 - 18h"},{"location":"presentation/dates/#evaluation","title":"Evaluation","text":"<p>Send the report at <code>matthias.delozzo@irt-saintexupery.com</code> by Tuesday, June 18 at the latest.</p>"},{"location":"presentation/deliverables/","title":"Deliverables","text":""},{"location":"presentation/deliverables/#code","title":"Code","text":"<p>A series of Python scripts containing:</p> <ul> <li>Python code,</li> <li>documentation.</li> </ul> <p>These scripts must be placed in the directory docs/scripts/project.</p> <p>Moreover, they must be properly formatted in order to be correctly compiled when using <code>mkdocs build</code> and <code>mkdocs serve</code> (or <code>mkdocs.exe build</code> and <code>mkdocs.exe serve</code> under windows):</p> <ul> <li>the header docstring will be converted into an HTML block,</li> <li>the Python comments starting with <code>#%%</code> will be converted into HTML blocks,</li> <li>the Python code will be executed,</li> <li>the text resulting from the method <code>print</code>   and the figure resulting from the Matplotlib <code>show</code> method   will benefit from a special rendering.</li> </ul> <p>Note</p> <p>You do not need to compile the project every time you change the Python script. You can use this Python script like any other Python script and compile the project only after the script writing is finished. When the project is compiled, only the scripts that have evolved are recompiled.</p> <p>Here is an example of a well-formatted and documented Python code:</p> <pre><code>   r\"\"\"\n   # Sum function\n\n   In this example,\n   we implement a function summing the elements of a vector $x\\in\\mathbb{R}^d$:\n\n   $$f(x)=\\sum_{i=1}^d x_i$$\n   \"\"\"\n   from numpy import array\n\n   #%%\n   # Firstly,\n   # we define the function:\n   def f(x):\n       return x.sum()\n\n   #%%\n   # Then,\n   # we evaluate this function from the input vector $x=[1,2]$:\n   y = f(array([1.,2.]))\n\n   #%%\n   # Lastly,\n   # we print the output value:\n   print(y)\n\n   # Contrarily to the previous ones,\n   # this comment will not be converted into an HTML block\n   # because it does not start with #%%.\n   # It will appear as a Python comment.\n</code></pre>"},{"location":"presentation/deliverables/#report","title":"Report","text":"<p>A markdown-based HTML report containing:</p> <ul> <li>an introduction,</li> <li>a section for each problem, ending with a synthesis.</li> <li>a general conclusion.</li> </ul> <p>The syntheses and the general conclusion summarize the main facts for someone who does not want to read the details.</p> <p>Furthermore, all the results provided must be interpreted.</p> <p>The markdown files must be placed in the directory lh2pac/docs/report and referenced in the nav/Report section of the mkdocs.yml file.</p>"},{"location":"presentation/use_case/","title":"Use case: an hydrogen powered turbofan","text":"<p>Note</p> <p>This study case is kindly provided by Thierry Druot, Pre-Project Research Engineer at Airbus, seconded to ENAC. The authors of this practice are very grateful to him. Thanks, Thierry!</p> <p>Hydrogen is a candidate to replace kerosene for future airplanes because it does not emit carbon dioxide when burning, as described in the  The Airbus' ZEROe project:</p> <p>Airbus\u2019 ambition is to bring to market the world\u2019s first hydrogen-powered commercial aircraft by 2035.  To get there,  our ZEROe project is exploring a variety of configurations and technologies,  as well as preparing the ecosystem that will produce and supply the hydrogen.</p> <p>The aim of this study is to evaluate the impact of the use of liquid hydrogen in place of kerosene on the design and performances of a turbofan airplane.</p> <p></p>"},{"location":"presentation/use_case/#the-type-of-airplane-targeted","title":"The type of airplane targeted","text":"<p>The type of airplane in the focus of this study corresponds to an A320.</p> <p>We suppose that we want to redesign an airplane with the same set of requirements than the classical kerosene A320 but powered with liquid hydrogen.</p> <p></p>"},{"location":"presentation/use_case/#the-problems-with-liquid-hydrogen","title":"The problems with liquid hydrogen","text":"<p>Liquid hydrogen (LH2) has three main drawbacks in comparison to kerosene as soon as airborne storage is needed :</p> <ol> <li>The very low temperature of LH2 (~20Kelvin, -253\u00b0C) requires very specific fuel system    to take it from the tank and feed the engine at ambient temperature.</li> <li>The volume of the tank is about 4 time bigger than with kerosene    for an equivalent amount of internal energy.</li> <li>The weight of tank is important due the necessary high level of insulation.</li> </ol> <p>Point 1 is out of the scope of this study, but we will treat points 2 and 3 that are linked to the level of maturity of liquid hydrogen storing technology.</p>"},{"location":"presentation/use_case/#the-technological-evolutions","title":"The technological evolutions","text":"<p>The technological level of LH2 tanking system is classically characterized by two indices :</p> <ul> <li>The gravimetric index \\(\\frac{\\text{LH2}_\\text{mass}}{\\text{LH2}_\\text{mass}+\\text{Tank}_\\text{mass}}\\)   quantifies the efficiency of the tank to store LH2 in terms of mass.</li> <li>The volumetric index \\(\\frac{\\text{LH2}_\\text{volume}}{\\text{LH2}_\\text{volume}+\\text{Tank}_\\text{volume}}\\)   quantifies the efficiency of the tank to store LH2 in terms of volume.</li> </ul> <p>The technology is expected to evolve in the coming years, following values are commonly accepted :</p> State of the art 2021 Status 2030 Gravimetric index 0.1 0.3 Volumetric index 0.606 0.845 <p>The simplest way to store a huge volume of LH2 in the aircraft is probably to put the tank in the rear fuselage. This implies to share the available length inside the fuselage between passengers and LH2 tank. Anyway, acceptable performances cannot be achieved without lengthening the fuselage of the kerosene airplane.</p> <p></p> <p>For several reasons, fuselage length cannot be stretched beyond a certain limit. In this study, we will use a maximum value for the ratio (fuselage_length)/(fuselage_diameter) to limit the length of the fuselage. This maximum value will be taken from the A340-600 which is considered has an extreme regarding this ratio.</p>"},{"location":"presentation/use_case/#achieve-the-performances-of-the-a320","title":"Achieve the performances of the A320","text":"<p>The classical kerosene A320 has the following general characteristics and performances:</p> <ul> <li>Nominal seat capacity = 150 pax (passengers)</li> <li>Nominal range = 3000 NM (1 Nautical Mile = 1852 m)</li> <li>Cruise speed = Mach 0.78</li> <li>Maximum Take Off Weight (MTOW) = 77000 kg</li> <li> <p>Maximum Landing Weight (MLW) = 65000 kg</p> </li> <li> <p>Engine maximum thrust = 120 kN (103 Newtons)</p> </li> <li>Engine Bypass Ratio (BPR) = 9 (ratio of cold flow over hot flow for a turbofan)</li> <li>Wing area = 122 m\u00b2</li> <li> <p>Wing aspect ratio = 9  (wing_span\u00b2 / wing_area)</p> </li> <li> <p>Fuselage aspect ratio = 11.0  (fuselage_length / fuselage_height, maximum is 13.4)</p> </li> <li>Maximum Take Off Field Length (TOFL) sea level, temperature ISA+15, MTOW = 2200 m</li> <li>Maximum Approach speed sea level, temperature ISA, MLW = 137 kt (1 knots = 1.852 km/h)</li> <li>Minimum Vertical speed Top Of Climb (TOC), 97% MTOW, cruise speed, ISA, Max Climb Rating (MCL) = 300 ft/min (1 m/s = 197 ft/min)</li> <li>Minimum Vertical speed Top Of Climb (TOC), 97% MTOW, cruise speed, ISA, Max Cruise Rating (MCR) = 0 ft/min (1 m/s = 197 ft/min)</li> <li>One engine inoperative minimum climb path, 97% MTOW, ISA, Maxi Continuous Rating (MCN) = 1.1%</li> <li>Maximum Time To Climb to cruise altitude, Maxi Climb Rating (MCL) = 25 min</li> </ul> <p></p> <p>Preliminary studies have shown that a range of 3000 NM could not be achieved with 150 passengers on board with hydrogen as fuel. Number of passengers or range (or both) must be reduced. After having discussed with Marketing team, engineers have chosen to keep the passenger capacity and reduce the range to 1800 NM.</p> <p>It is assumed that about ten years will be necessary to develop and certify such a full liquid hydrogen powered aircraft so 2030 technological level will be assumed. It is supposed that the use of hydrogen have no significant impact on the engine characteristics and performances.</p>"},{"location":"presentation/use_case/#find-the-hydrogen-powered-a320-like-aircraft","title":"Find the hydrogen powered A320-like aircraft","text":"<p>The problem is now to find the \u201cbest\u201d hydrogen powered airplane design that satisfies the same operational constraints as the kerosene A320 (except for the range). The existing know how in terms of airplane design has shown that the Maximum Take-Off Weight (MTOW) of the airplane is a good criterion to optimize a design.</p>"},{"location":"presentation/use_case/#the-design-problem","title":"The design problem","text":"<p>The design problem can be summarized as follows :</p> <p>Find the values of the design parameters  that minimize the criterion MTOW whilst satisfying operational constraints.</p> <p>The design parameters are :</p> <ul> <li>the engine maximum thrust  (100 kN \u2264 thrust \u2264 150 kN, default: 125 kN),</li> <li>the engine bypass ratio  (BPR)  (5 \u2264 BPR \u2264 12, default: 8.5),</li> <li>the wing area  (120 m\u00b2 \u2264 area \u2264 200 m\u00b2, default: 160 m\u00b2),</li> <li>the wing aspect ratio  (7 \u2264 ar \u2264 12, default: 9.5).</li> </ul> <p>The operational constraints are :</p> <ul> <li>the take off field length (TOFL \u2264 2200 m),</li> <li>the approach speed (VAPP \u2264 137 kt),</li> <li>the vertical speed MCL rating  (300 ft/min \u2264 VZ_MCL),</li> <li>the vertical MCR rating  (0 ft/min \u2264 VZ_MCR),</li> <li>the one engine inoperative climb path  (1.1% \u2264 OEI_PATH),</li> <li>the time To climb to cruise altitude  (TTC \u2264 25 min),</li> <li>the fuselage aspect Ratio  (FAR \u2264 13.4).</li> </ul> <p>In addition to this, several technological parameters need to be taken into account:</p> <ol> <li>the tank gravimetric index = 0.3,    with uncertainty: Triangular(0.25, 0.3, 0.305),</li> <li>the tank volumetric index = 0.845,    with uncertainty: Triangular(0.8, 0.845, 085),</li> <li>the aerodynamic efficiency factor = 1.,    with uncertainty: Triangular(0.99, 1., 1.03),</li> <li>the propulsion efficiency factor = 1.,    with uncertainty: Triangular(0.99, 1., 1.03),</li> <li>the structure efficiency factor = 1.,    with uncertainty: Triangular(0.99, 1., 1.03),</li> </ol> <p>where Triangular(\\(a\\), \\(b\\), \\(c\\)) represents the triangular distribution with lower limit \\(a\\), mode \\(d\\) and upper limit \\(c\\):</p> <p></p> <p>These probability distributions are not symmetrical as it is always easier to make something less efficient than expected...</p> <p>Note</p> <p>The involved factors are defined so that a low value is better than a high one.</p> <p>The points 3, 4 and 5 are related to the three main technical areas involved in aircraft design, namely aerodynamics, propulsion and structure. These factors are representing the unknown included in any creative activity.</p>"},{"location":"presentation/use_case/#the-numerical-simulator","title":"The numerical simulator","text":"<p>To solve this design problem, a Python function is provided to compute the criterion MTOW and the operational data from the design and technological parameters.</p>"},{"location":"presentation/use_case/#the-python-function","title":"The Python function","text":"<p>This function packages a dedicated Python script which is an application of MARILib (Multidisciplinary Airplane Research Integrated Library) developed at ENAC to support Airplane Conceptual Design Teaching and some research activities <sup>1</sup>.</p> <p>The signature of the Python function is:</p> <pre><code>   data = fct_turbofan_h2(techno, design, mode)\n</code></pre> <p>where <code>data</code>, <code>techno</code>, <code>design</code> and <code>mode</code> are Python dictionaries defined below:</p> <pre><code>   data = {\n       \"mtow\": mtow, # (kg) Maximum Take Off Weight\n       \"fuel\": fuel_block, # (kg) Specific mission fuel\n       \"coc\":  cash_op_cost, # ($/trip) Specific mission Cash Operating Cost\n       \"tofl\": tofl, # (m) Take Off Field Length\n       \"vapp\": app_speed, # (m/s) Approach speed\n       \"vz_mcl\": vz_mcl, # (m/s) Vertical speed in MCL rating\n       \"vz_mcr\": vz_mcr, # (m/s) Vertical speed in MCR rating\n       \"oei_path\": oei_path, # (rad) Air path with one engine inoperative\n       \"ttc\": ttc, # (s) Time To Climb\n       \"far\": far # () Fuselage aspect ratio\n   }\n</code></pre> <p>Note</p> <p><code>\"fuel_block\" and</code>\"cash_operating_cost\"` are outputs that can be used as criterion for the optimization.</p> <pre><code>   techno = {\n       \"drag\": 1.0, # Aerodynamic efficiency factor\n       \"sfc\": 1.0, # Propulsion efficiency factor\n       \"mass\": 1.0, # Structure efficiency factor\n       \"tvi\": 0.845, # Tank volumetric index\n       \"tgi\": 0.3, # Tank gravimetric index\n   }\n\n   design = {\n       \"thrust\": unit.N_kN(121), # (N) Engine maximum thrust\n       \"bpr\": 9, # () Engine Bypass Ratio\n       \"area\": 164, # (m2) Wing area\n       \"aspect_ratio\": 9 # () Wing aspect ratio\n   }\n\n   mode = \"eval\" # Configuration, Can be \"eval\", \"draw\", \"plr\", \"ds\".\n</code></pre> <p>The different values for mode have the following effects :</p> <ul> <li><code>\"eval\"</code>: only data is provided as output</li> <li><code>\"draw\"</code>: a small 3 view drawing of the airplane is displayed</li> <li><code>\"plr\"</code>: a Payload vs Range diagram is displayed</li> <li><code>\"ds\"</code>: a graphical analysis of the design space around the provided point is displayed</li> </ul> <p>You can access the <code>turbofan_h2_function</code> with</p> <pre><code>   from lh2pac.turbofan_h2_function import fct_turbofan_h2, str_h2turbofan\n\n   output_data = fct_turbofan_h2(techno, design, \"eval\")\n   str_h2turbofan(techno, design, output_data)\n</code></pre>"},{"location":"presentation/use_case/#unit-conversion","title":"Unit conversion","text":"<p>Warning</p> <p>The function only knows STANDARD UNITS which means that all data provided to the function MUST be expressed in standard units and that all data retrieved by the function are expressed in standard units.</p> <p>Used standard units are:</p> Standard unit Symbol meter m square meter m2 kilogram kg second s meter per second m/s nots kt Newton N Dollar $ <p>Usual units are:</p> Usual unit Symbol minute min feet ft feet per minute ft/min knot kt <p>One may use specific converters provided by MARILib in the module unit to play between the units.</p> <p>The syntax of the converters is: <code>[target_unit]_[initial_unit](value)</code>.</p> <p>Required converters for the study are:</p> <ul> <li><code>ftpmin_mps()</code>,</li> <li><code>mps_ftpmin()</code>,</li> <li><code>kt_mps()</code>,</li> <li><code>mps_kt()</code>,</li> <li><code>N_kN()</code>,</li> <li><code>kN_N()</code>,</li> <li><code>s_min()</code>,</li> <li><code>min_s()</code>.</li> </ul> <p>The function <code>print_data(data)</code> is provided to display the content of the data dictionary rounded in usual units.</p>"},{"location":"presentation/use_case/#start-with-gemseo","title":"Start with GEMSEO","text":"<p>The first stage of this project will be to discover the GEMSEO examples available in the <code>utils</code> section and the <code>H2TurboFan</code> class which is a so-called discipline wrapping the function <code>fct_turbofan_h2</code>.</p> <p>discipline is a key concept in GEMSEO.</p> <p>Note that a discipline considers input and output data of the form <code>{name: value, ...}</code> where <code>name</code> is the name of a variable and <code>value</code> is its value expressed as a 1D NumPy array.</p> <p>This <code>H2TurboFan</code> class and the other GEMSEO-based helpers  are in the package <code>lh2pac.gemseo</code> of the <code>src</code> directory`:</p> <ul> <li>the module <code>lh2pac.gemseo.discipline</code> includes the <code>H2TurboFan</code> discipline,</li> <li>the module <code>lh2pac.gemseo.utils</code> includes <code>draw_aircraft</code> and <code>get_aircraft_data</code>,   two functions to get information about an aircraft or visualize it..</li> </ul> <ol> <li> <p>Thierry Druot, Mathieu Belleville, Pascal Roches, Fran\u00e7ois Gallard, Nicolas Peteilh, et al. A Multidisciplinary Airplane Research Integrated Library With Applications To Partial Turboelectric Propulsion. AIAA Aviation 2019 Forum, Jun 2019, Dallas, United States. \u27e8hal-02160977\u27e9 \u21a9</p> </li> </ol>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>lh2pac<ul> <li>example<ul> <li>aircraft<ul> <li>arrangement_tree</li> <li>turbofan<ul> <li>turbofan_classic_medium_range</li> <li>turbofan_h2_function</li> <li>turbofan_h2_medium_range</li> </ul> </li> </ul> </li> </ul> </li> <li>gemseo<ul> <li>discipline</li> <li>utils</li> </ul> </li> <li>marilib<ul> <li>aircraft<ul> <li>aircraft_root</li> <li>airframe<ul> <li>airframe_root</li> <li>component</li> <li>model</li> <li>propulsion</li> <li>system</li> </ul> </li> <li>design<ul> <li>process</li> </ul> </li> <li>environment</li> <li>handling_quality</li> <li>mission</li> <li>model_config</li> <li>model_config_small_plane</li> <li>performance</li> <li>requirement</li> <li>step_mission</li> <li>tool<ul> <li>configuration</li> <li>dictionary</li> <li>drawing</li> </ul> </li> </ul> </li> <li>airship<ul> <li>airship</li> <li>airship_old</li> <li>physical_data</li> <li>trajectory</li> </ul> </li> <li>utils<ul> <li>earth</li> <li>math</li> <li>read_write</li> <li>unit</li> </ul> </li> </ul> </li> <li>turbofan_h2_function</li> </ul> </li> </ul>"},{"location":"reference/lh2pac/","title":"API documentation","text":""},{"location":"reference/lh2pac/#lh2pac","title":"lh2pac","text":""},{"location":"reference/lh2pac/turbofan_h2_function/","title":"Turbofan h2 function","text":""},{"location":"reference/lh2pac/turbofan_h2_function/#lh2pac.turbofan_h2_function","title":"turbofan_h2_function","text":"<p>Created on Thu Jan 20 20:20:20 2020</p> <p>@author: Conceptual Airplane Design &amp; Operations (CADO team)          Nicolas PETEILH, Pascal ROCHES, Nicolas MONROLIN, Thierry DRUOT          Aircraft &amp; Systems, Air Transport Departement, ENAC</p>"},{"location":"reference/lh2pac/turbofan_h2_function/#lh2pac.turbofan_h2_function-classes","title":"Classes","text":""},{"location":"reference/lh2pac/example/","title":"Example","text":""},{"location":"reference/lh2pac/example/#lh2pac.example","title":"example","text":""},{"location":"reference/lh2pac/example/aircraft/","title":"Aircraft","text":""},{"location":"reference/lh2pac/example/aircraft/#lh2pac.example.aircraft","title":"aircraft","text":""},{"location":"reference/lh2pac/example/aircraft/arrangement_tree/","title":"Arrangement tree","text":""},{"location":"reference/lh2pac/example/aircraft/arrangement_tree/#lh2pac.example.aircraft.arrangement_tree","title":"arrangement_tree","text":""},{"location":"reference/lh2pac/example/aircraft/arrangement_tree/#lh2pac.example.aircraft.arrangement_tree-attributes","title":"Attributes","text":""},{"location":"reference/lh2pac/example/aircraft/arrangement_tree/#lh2pac.example.aircraft.arrangement_tree.INCOMPATIBILITY_DICT","title":"INCOMPATIBILITY_DICT  <code>module-attribute</code>","text":"<pre><code>INCOMPATIBILITY_DICT = {\n    \"body_type\": None,\n    \"wing_type\": {\n        \"blended\": {\"body_type\": [\"fuselage\"]},\n        \"classic\": {\"body_type\": [\"blended\"]},\n    },\n    \"wing_attachement\": None,\n    \"stab_architecture\": None,\n    \"tank_architecture\": {\n        \"piggy_back\": {\n            \"stab_architecture\": [\"classic\", \"t_tail\"]\n        }\n    },\n    \"number_of_engine\": {\n        \"quadri\": {\"tank_architecture\": [\"pods\"]},\n        \"hexa\": {\"tank_architecture\": [\"pods\"]},\n    },\n    \"nacelle_attachment\": {\n        \"rear\": {\n            \"stab_architecture\": [\"classic\", \"h_tail\"],\n            \"number_of_engine\": [\"quadri\", \"hexa\"],\n        },\n        \"pods\": {\n            \"tank_architecture\": [\"wing_box\", \"piggy_back\"],\n            \"number_of_engine\": [\"quadri\", \"hexa\"],\n        },\n    },\n    \"power_architecture\": None,\n    \"power_source\": {\n        \"fuel_cell\": {\n            \"power_architecture\": [\n                \"tf\",\n                \"tp\",\n                \"extf\",\n                \"pte\",\n            ]\n        },\n        \"battery\": {\n            \"power_architecture\": [\n                \"tf\",\n                \"tp\",\n                \"extf\",\n                \"pte\",\n            ]\n        },\n        \"fuel\": {\n            \"power_architecture\": [\"ef\", \"ep\", \"exef\"]\n        },\n    },\n    \"fuel_type\": {\n        \"battery\": {\n            \"power_architecture\": [\"tf\", \"tp\", \"extf\"],\n            \"power_source\": [\"fuel\", \"fuel_cell\"],\n        },\n        \"kerosene\": {\n            \"power_architecture\": [\"ef\", \"ep\", \"exef\"],\n            \"power_source\": [\"fuel_cell\", \"battery\"],\n        },\n        \"methane\": {\n            \"power_architecture\": [\"ef\", \"ep\", \"exef\"],\n            \"power_source\": [\"fuel_cell\", \"battery\"],\n        },\n        \"liquid_h2\": {\"power_source\": [\"battery\"]},\n        \"compressed_h2\": {\"power_source\": [\"battery\"]},\n    },\n}\n</code></pre>"},{"location":"reference/lh2pac/example/aircraft/arrangement_tree/#lh2pac.example.aircraft.arrangement_tree.INCOMPATIBILITY_DICT--convert-the-downward-incompatibility-dict-to-the-upward-incompatibility-dict","title":"Convert the DOWNWARD incompatibility dict to the upward incompatibility dict","text":"<p>if name == \"main\":     new_dict = dict.fromkeys(INCOMPATIBILITY_DICT)     for k in INCOMPATIBILITY_DICT.keys():         if INCOMPATIBILITY_DICT[k] == None:             continue</p> <pre><code>    for setting_key,setting_dict in INCOMPATIBILITY_DICT[k].items():\n        for ikey,incompatible_settings in setting_dict.items():\n            if new_dict[ikey] == None:\n                new_dict[ikey] = {} # init subdict\n            for s in incompatible_settings:\n                try: new_dict[ikey][s]\n                except KeyError: new_dict[ikey][s] = {} # init subsubdict\n                try: new_dict[ikey][s][k]\n                except KeyError: new_dict[ikey][s][k] = []  # init list\n                new_dict[ikey][s][k].append(setting_key)\n\nfrom lh2pac.marilib.utils.read_write import MarilibIO\nio = MarilibIO()\nio.to_json_file(new_dict,'temp')\n</code></pre>"},{"location":"reference/lh2pac/example/aircraft/arrangement_tree/#lh2pac.example.aircraft.arrangement_tree-classes","title":"Classes","text":""},{"location":"reference/lh2pac/example/aircraft/arrangement_tree/#lh2pac.example.aircraft.arrangement_tree.ArrangementTree","title":"ArrangementTree","text":"<pre><code>ArrangementTree(**kwargs)\n</code></pre> <p>               Bases: <code>Node</code></p> <p>A custom anytree.Node object to describe all feasible arrangements. For example:</p> <p>tree = ArrangementTree(tank_architecture =\"piggy_back\", number_of_engine=\"quadri\",power_source=\"fuel_cell\") print(tree.leaves)</p> <p>will display all feasible arrangement, for the specified <code>number_of_engine</code> and <code>power_source</code> settings.</p> <p>Keep only the branches of the tree passing through the selected node(s) :param **kwargs: the Arrangement settings that are set to a desired value. Example::         tree = ArrangementTree(wing_type='classic') :return: the root node of the tree (anytree.Node)</p> Source code in <code>src/lh2pac/example/aircraft/arrangement_tree.py</code> <pre><code>def __init__(self,**kwargs):\n    \"\"\" Keep only the branches of the tree passing through the selected node(s)\n    :param **kwargs: the Arrangement settings that are set to a desired value. Example::\n            tree = ArrangementTree(wing_type='classic')\n    :return: the root node of the tree (anytree.Node)\n    \"\"\"\n    super().__init__(\"Arrangement\")  # intialize root node\n\n    # build a dict of 'fixed settings' and check their validity.\n    fixed_nodes = dict.fromkeys(ARRANGEMENT_DICT.keys())    # default init\n    for key,val in kwargs.items():\n        if key not in ARRANGEMENT_DICT.keys():\n            msg = \"Arrangement has no entry named %s\" % key\n            raise KeyError(msg)\n        else:\n            if val not in ARRANGEMENT_DICT[key]:\n                raise ValueError(\"Invalid value %s for entry %s\" %(val,key))\n            else:\n                fixed_nodes[key] = val\n\n    # Construct the tree, step by step (depth level by depth level)\n    for key,settings in ARRANGEMENT_DICT.items():  # iterate over all arrangement options\n        if fixed_nodes[key] is not None:\n            for leaf in self.leaves:  # iterate over the \"leaves\" of the tree\n                if self.is_feasible(self.path_of_node(leaf)+[fixed_nodes[key]]):\n                    leaf.children = [Node(fixed_nodes[key])]\n                else:\n                    try: # try to delete the branch\n                        # find the fork at the origin of the branch:\n                        while len(leaf.parent.children) &lt; 2:  # raises AttributeError if leaf.parent is None -&gt; root node\n                            leaf = leaf.parent\n                        leaf.parent = None  # detach the branch from the tree\n                    except AttributeError:  # the previous while loop reached the root node -&gt; there is no feasible branch in the tree\n                        print(\"The setting '%s' is not compatible with the other settings\" %fixed_nodes[key])\n                        self.root.children =[] # reset the tree\n                        break\n\n        else:\n            for leaf in self.leaves:\n                leaf.children = [Node(s) for s in settings if len(s) &gt; 0 and self.is_feasible(self.path_of_node(leaf)+[s])]\n</code></pre>"},{"location":"reference/lh2pac/example/aircraft/arrangement_tree/#lh2pac.example.aircraft.arrangement_tree.ArrangementTree-functions","title":"Functions","text":""},{"location":"reference/lh2pac/example/aircraft/arrangement_tree/#lh2pac.example.aircraft.arrangement_tree.ArrangementTree.dict_from_path","title":"dict_from_path","text":"<pre><code>dict_from_path(path)\n</code></pre> <p>Convert a path to an arrangement dict, using the entries given by <code>ARRANGEMENT_DICT</code></p> Source code in <code>src/lh2pac/example/aircraft/arrangement_tree.py</code> <pre><code>def dict_from_path(self,path):\n    \"\"\"Convert a path to an arrangement dict, using the entries given by `ARRANGEMENT_DICT`\"\"\"\n    dic = dict.fromkeys(ARRANGEMENT_DICT.keys())\n    for key,value in zip(dic.keys(), path):\n        dic[key] = value\n    return dic\n</code></pre>"},{"location":"reference/lh2pac/example/aircraft/arrangement_tree/#lh2pac.example.aircraft.arrangement_tree.ArrangementTree.is_feasible","title":"is_feasible","text":"<pre><code>is_feasible(path)\n</code></pre> <p>Check that the last element of the path is compatible with all other elements in the path. :return: <code>True</code> if feasible, <code>False</code> if incompatible settings are found in the path</p> Source code in <code>src/lh2pac/example/aircraft/arrangement_tree.py</code> <pre><code>def is_feasible(self,path):\n    \"\"\"Check that the last element of the path is compatible with all other elements in the path.\n    :return: `True` if feasible, `False` if incompatible settings are found in the path\n    \"\"\"\n    current_setting_value = path[-1]\n    current_setting_key = list(INCOMPATIBILITY_DICT.keys())[len(path)-1]\n\n    if INCOMPATIBILITY_DICT[current_setting_key] == None:  # there is no icompatibility for this setting\n        return True\n    else:\n        try: # try to store the dict incompatibilities of the current_setting_value.\n            incompatibilities = INCOMPATIBILITY_DICT[current_setting_key][current_setting_value] #\n        except KeyError:  # the current_setting_value has no incompatibility\n            incompatibilities = None\n            return True\n\n        pathdict = self.dict_from_path(path)\n        for key,incomp_list in incompatibilities.items():  # test for incompatibilitites in the current path\n            if pathdict[key] in incomp_list:\n                return False\n        return True\n\n    raise ValueError(\"Unexpected behavior, should return True are False but found None.\")\n</code></pre>"},{"location":"reference/lh2pac/example/aircraft/arrangement_tree/#lh2pac.example.aircraft.arrangement_tree.ArrangementTree.path_of_node","title":"path_of_node","text":"<pre><code>path_of_node(node)\n</code></pre> <p>convert the builtin node.path (list of node objects) to a list of node names (list of strings)</p> Source code in <code>src/lh2pac/example/aircraft/arrangement_tree.py</code> <pre><code>def path_of_node(self,node):\n    \"\"\"convert the builtin node.path (list of node objects) to a list of node names (list of strings)\"\"\"\n    return [str(n.name) for n in node.path[1:]]\n</code></pre>"},{"location":"reference/lh2pac/example/aircraft/arrangement_tree/#lh2pac.example.aircraft.arrangement_tree.ArrangementTree.write_txt","title":"write_txt","text":"<pre><code>write_txt(filename, root_node)\n</code></pre> <p>Save the tree to text file :param root_node: :return:</p> Source code in <code>src/lh2pac/example/aircraft/arrangement_tree.py</code> <pre><code>def write_txt(self,filename,root_node):\n    \"\"\"Save the tree to text file\n    :param root_node:\n    :return:\n    \"\"\"\n    with open(filname,\"w\") as f:\n        content = \"\"\n        for pre,_, node in RenderTree(root_node,style = AsciiStyle):\n            content += \"%s%s\\n\" %(pre, node.name)\n        f.write(content)\n</code></pre>"},{"location":"reference/lh2pac/example/aircraft/arrangement_tree/#lh2pac.example.aircraft.arrangement_tree-functions","title":"Functions","text":""},{"location":"reference/lh2pac/example/aircraft/arrangement_tree/#lh2pac.example.aircraft.arrangement_tree.path_to_line","title":"path_to_line","text":"<pre><code>path_to_line(path, n_x, n_y)\n</code></pre> <p>Convert the path (list of string like [\"my\",\"path\",\"to\",\"leaf\"]) to the list of x,y coordinates of the cells center in the tabular.</p> Source code in <code>src/lh2pac/example/aircraft/arrangement_tree.py</code> <pre><code>def path_to_line(path,n_x,n_y):\n    \"\"\"Convert the path (list of string like [\"my\",\"path\",\"to\",\"leaf\"]) to the list of x,y coordinates of the\n     cells center in the tabular.\"\"\"\n    points = []\n    for j,setting in enumerate(path):  # iterate over all nodes of this tree branch\n        for i in range(1,n_y+1):  # iterate over all lines of the table\n            if tab[i,j].get_text().get_text()==setting:\n                points.append((j,i))\n                if tab[i,j].get_facecolor() != (0,0,1,0.5):\n                    tab[i,j].set_facecolor((0,1,0,0.5))\n                    tab[i, j].set_text_props(color=(0, 0, 0, 1))\n            elif tab[i,j].get_facecolor() != (0,0,1,0.5) and tab[i,j].get_facecolor() != (0,1,0,0.5): # if not blue or green\n                tab[i,j].set_text_props(color=(0,0,0,0.2))\n\n    x,y = zip(*points)\n    x = (0.5 + np.array(x)) / n_x\n    y = 1 - (np.array(y) + 0.5) / (n_y + 1)\n    return x,y\n</code></pre>"},{"location":"reference/lh2pac/example/aircraft/turbofan/","title":"Turbofan","text":""},{"location":"reference/lh2pac/example/aircraft/turbofan/#lh2pac.example.aircraft.turbofan","title":"turbofan","text":""},{"location":"reference/lh2pac/example/aircraft/turbofan/turbofan_classic_medium_range/","title":"Turbofan classic medium range","text":""},{"location":"reference/lh2pac/example/aircraft/turbofan/turbofan_classic_medium_range/#lh2pac.example.aircraft.turbofan.turbofan_classic_medium_range","title":"turbofan_classic_medium_range","text":"<p>Created on Thu Jan 20 20:20:20 2020</p> <p>@author: Conceptual Airplane Design &amp; Operations (CADO team)          Nicolas PETEILH, Pascal ROCHES, Nicolas MONROLIN, Thierry DRUOT          Aircraft &amp; Systems, Air Transport Departement, ENAC</p>"},{"location":"reference/lh2pac/example/aircraft/turbofan/turbofan_classic_medium_range/#lh2pac.example.aircraft.turbofan.turbofan_classic_medium_range-classes","title":"Classes","text":""},{"location":"reference/lh2pac/example/aircraft/turbofan/turbofan_h2_function/","title":"Turbofan h2 function","text":""},{"location":"reference/lh2pac/example/aircraft/turbofan/turbofan_h2_function/#lh2pac.example.aircraft.turbofan.turbofan_h2_function","title":"turbofan_h2_function","text":"<p>Created on Thu Jan 20 20:20:20 2020</p> <p>@author: Conceptual Airplane Design &amp; Operations (CADO team)          Nicolas PETEILH, Pascal ROCHES, Nicolas MONROLIN, Thierry DRUOT          Aircraft &amp; Systems, Air Transport Departement, ENAC</p>"},{"location":"reference/lh2pac/example/aircraft/turbofan/turbofan_h2_function/#lh2pac.example.aircraft.turbofan.turbofan_h2_function-classes","title":"Classes","text":""},{"location":"reference/lh2pac/example/aircraft/turbofan/turbofan_h2_medium_range/","title":"Turbofan h2 medium range","text":""},{"location":"reference/lh2pac/example/aircraft/turbofan/turbofan_h2_medium_range/#lh2pac.example.aircraft.turbofan.turbofan_h2_medium_range","title":"turbofan_h2_medium_range","text":"<p>Created on Thu Jan 20 20:20:20 2020</p> <p>@author: Conceptual Airplane Design &amp; Operations (CADO team)          Nicolas PETEILH, Pascal ROCHES, Nicolas MONROLIN, Thierry DRUOT          Aircraft &amp; Systems, Air Transport Departement, ENAC</p>"},{"location":"reference/lh2pac/example/aircraft/turbofan/turbofan_h2_medium_range/#lh2pac.example.aircraft.turbofan.turbofan_h2_medium_range-classes","title":"Classes","text":""},{"location":"reference/lh2pac/gemseo/","title":"Gemseo","text":""},{"location":"reference/lh2pac/gemseo/#lh2pac.gemseo","title":"gemseo","text":""},{"location":"reference/lh2pac/gemseo/discipline/","title":"Discipline","text":""},{"location":"reference/lh2pac/gemseo/discipline/#lh2pac.gemseo.discipline","title":"discipline","text":""},{"location":"reference/lh2pac/gemseo/discipline/#lh2pac.gemseo.discipline--the-h2turbofan-discipline","title":"The H2TurboFan discipline.","text":""},{"location":"reference/lh2pac/gemseo/discipline/#lh2pac.gemseo.discipline-classes","title":"Classes","text":""},{"location":"reference/lh2pac/gemseo/discipline/#lh2pac.gemseo.discipline.H2TurboFan","title":"H2TurboFan","text":"<pre><code>H2TurboFan()\n</code></pre> <p>               Bases: <code>MDODiscipline</code></p> <p>Wrapper of the MARILib-based function <code>fct_turbofan_h2</code>.</p> <p>This discipline evaluates the function <code>fct_turbofan_h2</code> from values of <code>TECHNOLOGICAL_VARIABLES</code> and <code>DESIGN_VARIABLES</code> passed to the method <code>execute</code> as a dictionary of NumPy arrays.</p> <p>The discipline uses <code>DEFAULT_DESIGN_VALUES</code> for unspecified <code>DESIGN_VARIABLES</code> and <code>DEFAULT_TECHNOLOGICAL_VALUES</code> for unspecified <code>TECHNOLOGICAL_VARIABLES</code>.</p> <p>Initialize self.  See help(type(self)) for accurate signature.</p> Source code in <code>src/lh2pac/gemseo/discipline.py</code> <pre><code>def __init__(self) -&gt; None:\n    super(H2TurboFan, self).__init__()\n\n    # Define the input and output variables.\n    self.input_grammar.update_from_names(\n        self.DESIGN_VARIABLES + self.TECHNOLOGICAL_VARIABLES\n    )\n    self.output_grammar.update_from_names(self.OUTPUT_VARIABLES)\n\n    # Define the default inputs.\n    self.default_inputs.update(self.DEFAULT_DESIGN_VALUES)\n    self.default_inputs.update(self.DEFAULT_TECHNOLOGICAL_VALUES)\n</code></pre>"},{"location":"reference/lh2pac/gemseo/utils/","title":"Utils","text":""},{"location":"reference/lh2pac/gemseo/utils/#lh2pac.gemseo.utils","title":"utils","text":""},{"location":"reference/lh2pac/gemseo/utils/#lh2pac.gemseo.utils-classes","title":"Classes","text":""},{"location":"reference/lh2pac/marilib/","title":"Marilib","text":""},{"location":"reference/lh2pac/marilib/#lh2pac.marilib","title":"marilib","text":""},{"location":"reference/lh2pac/marilib/aircraft/","title":"Aircraft","text":""},{"location":"reference/lh2pac/marilib/aircraft/#lh2pac.marilib.aircraft","title":"aircraft","text":"<p>The aircraft package is the main package of MARILib.</p>"},{"location":"reference/lh2pac/marilib/aircraft/#lh2pac.marilib.aircraft--usage","title":"Usage","text":"<p>To initialize an airplane you need to import the package :mod:<code>marilib.aircraft</code> and give it a name::</p> <pre><code>import marilib.aircraft\n\nmyplane = Aircraft(\"my Plane\")\n</code></pre> <p>The statement <code>import marilib.aircraft</code> will load :class:<code>aircraft_root.Aircraft</code>, :class:<code>aircraft_root.Arrangement</code> and :class:<code>requirement.Requirement</code>. At this stage your airplane is empty. You have to define the top level requirements and the general arrangement of the airplane as follow ::</p> <pre><code>arrangement = Arrangement()  # default settings here\nrequirement = Requirement()  # default settings again\n</code></pre> <p>You can also define your own settings. For example, the Top Level Aircraft Requirement can be specified as follow ::</p> <pre><code>requirement =  Requirement(n_pax_ref = 150.,\n                           design_range = unit.m_NM(3000.),  # convert Nautical Miles to meters\n                           cruise_mach = 0.78,\n                           cruise_altp = unit.m_ft(35000.))  # convert feets to meters\n</code></pre> <p>.. note:: MARILib works with the International System of units. But you can convert to many other units tanks to the module    :mod:<code>marilib.utils.unit</code>. Add the following statement at the beginning of your script ::</p> <pre><code>    from lh2pac.marilib.utils import unit\n</code></pre> <p>To intialise your aircraft you need to run :func:<code>aircraft_root.Aircraft.factory</code>::</p> <pre><code>myplane.factory(agmt, reqs)  # WARNING : arrangement must not be changed after this line\n</code></pre> <p>This will initialize all secondary requirements and build the airframe from a set of physical components. You can still change the requirements, however at this stage the arrangement is fixed and can not be changed anymore.</p>"},{"location":"reference/lh2pac/marilib/aircraft/#lh2pac.marilib.aircraft--structure","title":"Structure","text":"<p>The airplane in MARILib is thought as an object that can flow through different design routines.</p> <p>.. figure:: ../uml/aircraft.png     :width: 100%     :align: center     :alt: UML aircraft package</p> <pre><code>Simplified Class diagram of the aircraft package\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/#lh2pac.marilib.aircraft--design-drivers","title":"Design drivers","text":"<p>The design is driven by user inputs :</p> <ul> <li>The requirements defined by :class:<code>requirement.Requirement</code>.</li> <li>The arrangement defined by :class:<code>aircraft_root.Arrangement</code></li> </ul>"},{"location":"reference/lh2pac/marilib/aircraft/#lh2pac.marilib.aircraft--design-parameters","title":"Design parameters","text":"<p>Most airplane design parameteers are stored in the airframe. The airframe is a list of physical components (wing, thrusters fuselage ...) available in :mod:<code>marilib.aircraft.airframe.component</code> and in :mod:<code>marilib.aircraft.airframe.propulsion</code>. Each component has:</p> <ul> <li>a positon and a geometry (fuselage lentgh, wing size, thruster diameter ...)</li> <li>aerodynamic length, surface and form factors if necessary.</li> <li>a mass and a center of gravity</li> </ul> <p>.. todo:: In Marilib 2.0, the inertia tensor is implemented but not used yet.</p>"},{"location":"reference/lh2pac/marilib/aircraft/#lh2pac.marilib.aircraft--models","title":"Models","text":"<p>In order to run design or optimisation routines (MDA/MDO), the aircraft contains several models:</p> <p>.. todo:: the documentation of this section is not finished.</p>"},{"location":"reference/lh2pac/marilib/aircraft/#lh2pac.marilib.aircraft--customizing-your-aircraft","title":"Customizing your Aircraft","text":"<p>You can build new Aircraft, with new components that are not implemented yet. To do so :</p> <ol> <li> <p>add your new component in :mod:<code>marilib.aircraft.airframe.component</code>. Your component must inherit the abstract     class :class:<code>marilib.aircraft.airframe.component.Component</code>.</p> </li> <li> <p>Implement the following pre-design functions for your component:</p> <ul> <li>:func:<code>airframe.component.Component.eval_geometry</code></li> <li>:func:<code>airframe.component.Component.eval_mass</code></li> </ul> </li> <li> <p>Change the factory of the aircraft (:func:<code>marilib.aircraft.aircraft_root.Aircraft.factory</code>) in order to add your     component to the airframe.</p> </li> <li> <p>Whisper a prayer, and click the run button.</p> </li> </ol>"},{"location":"reference/lh2pac/marilib/aircraft/#lh2pac.marilib.aircraft--submodules-documentation","title":"Submodules documentation","text":""},{"location":"reference/lh2pac/marilib/aircraft/#lh2pac.marilib.aircraft-classes","title":"Classes","text":""},{"location":"reference/lh2pac/marilib/aircraft/#lh2pac.marilib.aircraft-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/aircraft/aircraft_root/","title":"Aircraft root","text":""},{"location":"reference/lh2pac/marilib/aircraft/aircraft_root/#lh2pac.marilib.aircraft.aircraft_root","title":"aircraft_root","text":"<p>Created on Thu Jan 20 20:20:20 2020</p> <p>:author: Conceptual Airplane Design &amp; Operations (CADO team)          Nicolas PETEILH, Pascal ROCHES, Nicolas MONROLIN, Thierry DRUOT          Aircraft &amp; Systems, Air Transport Departement, ENAC</p>"},{"location":"reference/lh2pac/marilib/aircraft/aircraft_root/#lh2pac.marilib.aircraft.aircraft_root-classes","title":"Classes","text":""},{"location":"reference/lh2pac/marilib/aircraft/aircraft_root/#lh2pac.marilib.aircraft.aircraft_root.Aircraft","title":"Aircraft","text":"<pre><code>Aircraft(name)\n</code></pre> <p>               Bases: <code>object</code></p> <p>Logical aircraft description</p> Source code in <code>src/lh2pac/marilib/aircraft/aircraft_root.py</code> <pre><code>def __init__(self, name):\n\n    self.name = name\n    self.arrangement = None\n    self.requirement = None\n\n    self.airframe = Airframe(self)\n\n    self.power_system = None\n    self.aerodynamics = None\n    self.weight_cg = None\n    self.handling_quality = None\n    self.performance = None\n    self.economics = None\n    self.environment = None\n    self.draw = Drawing(self)\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/aircraft_root/#lh2pac.marilib.aircraft.aircraft_root.Aircraft-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/aircraft/aircraft_root/#lh2pac.marilib.aircraft.aircraft_root.Aircraft.factory","title":"factory","text":"<pre><code>factory(arrangement, requirement)\n</code></pre> <p>Build an aircraft according to architectural choices</p> Source code in <code>src/lh2pac/marilib/aircraft/aircraft_root.py</code> <pre><code>    def factory(self, arrangement, requirement):\n        \"\"\"Build an aircraft according to architectural choices\n        \"\"\"\n        self.requirement = requirement\n        self.arrangement = arrangement\n\n        self.requirement.init_all_requirements(arrangement)  # finalize the initialisation of all requirements.\n\n        if (self.arrangement.power_architecture in [\"ef\",\"ep\",\"exef\"]):\n            if(self.arrangement.power_source not in [\"battery\",\"fuel_cell\"]):\n                raise Exception(\"Power architecture electro_fan (ef) requires energy source battery or fuel_cell\")\n\n# ----------------------------------------------------------------------------------------------------------------------\n        self.airframe.cabin = component.Cabin(self)\n\n# ----------------------------------------------------------------------------------------------------------------------\n        if (self.arrangement.body_type==\"fuselage\"):\n            self.airframe.body = component.Fuselage(self)\n        else:\n            raise Exception(\"Type of body is unknown\")\n\n# ----------------------------------------------------------------------------------------------------------------------\n        if (self.arrangement.wing_type==\"classic\"):\n            self.airframe.wing = component.Wing(self)\n        else:\n            raise Exception(\"Type of wing is unknown\")\n\n# ----------------------------------------------------------------------------------------------------------------------\n        self.airframe.cargo = component.Cargo(self)\n\n# ----------------------------------------------------------------------------------------------------------------------\n        if (self.arrangement.stab_architecture==\"classic\"):\n            self.airframe.vertical_stab = component.VtpClassic(self)\n            self.airframe.horizontal_stab = component.HtpClassic(self)\n        elif (self.arrangement.stab_architecture==\"t_tail\"):\n            self.airframe.vertical_stab = component.VtpTtail(self)\n            self.airframe.horizontal_stab = component.HtpTtail(self)\n        elif (self.arrangement.stab_architecture==\"h_tail\"):\n            self.airframe.horizontal_stab = component.HtpHtail(self)\n            self.airframe.vertical_stab = component.VtpHtail(self,\"right\")\n            self.airframe.other_vertical_stab = component.VtpHtail(self,\"left\")\n        else:\n            raise Exception(\"stab_architecture is unknown\")\n\n# ----------------------------------------------------------------------------------------------------------------------\n        if (self.arrangement.tank_architecture==\"wing_box\"):\n            self.airframe.tank = component.TankWingBox(self)\n            self.airframe.tank_analysis_order = [\"tank\"]\n        elif (self.arrangement.tank_architecture==\"floor\"):\n            self.airframe.tank = component.TankFuselageFloor(self)\n            self.airframe.tank_analysis_order = [\"tank\"]\n        elif (self.arrangement.tank_architecture==\"rear\"):\n            self.airframe.tank = component.TankRearFuselage(self)\n            self.airframe.tank_analysis_order = [\"tank\"]\n        elif (self.arrangement.tank_architecture==\"piggy_back\"):\n            self.airframe.tank = component.TankPiggyBack(self)\n            self.airframe.tank_analysis_order = [\"tank\"]\n        elif (self.arrangement.tank_architecture==\"pods\"):\n            self.airframe.tank = component.TankWingPod(self,\"right\")\n            self.airframe.other_tank = component.TankWingPod(self,\"left\")\n            self.airframe.tank_analysis_order = [\"tank\",\"other_tank\"]\n        else:\n            raise Exception(\"Type of tank is unknown\")\n\n# ----------------------------------------------------------------------------------------------------------------------\n        if (self.arrangement.gear_architecture==\"retractable\"):\n            self.airframe.landing_gear = component.RetractableLandingGear(self)\n        elif (self.arrangement.gear_architecture==\"bare_fixed\"):\n            self.airframe.landing_gear = component.BareFixedLandingGear(self)\n        else:\n            raise Exception(\"Type of landing gear is unknown\")\n\n# ----------------------------------------------------------------------------------------------------------------------\n        if (self.arrangement.power_source == \"battery\"):\n            self.airframe.system = system.SystemWithBattery(self)\n        elif (self.arrangement.power_source == \"fuel_cell\"):\n            self.airframe.system = system.SystemWithFuelCell(self)\n        else:\n            if (self.arrangement.power_architecture==\"pte\"):\n                self.airframe.system = system.SystemPartialTurboElectric(self)\n            elif (self.arrangement.power_architecture==\"pte_pod\"):\n                self.airframe.system = system.SystemPartialTurboElectricPods(self)\n            elif (self.arrangement.power_architecture==\"pte_piggy\"):\n                self.airframe.system = system.SystemPartialTurboElectricPiggyBack(self)\n            else:\n                self.airframe.system = system.System(self)\n\n# ----------------------------------------------------------------------------------------------------------------------\n        if (self.arrangement.power_architecture==\"tf0\"):\n            self.power_system = model.Turbofan(self)\n            if (self.arrangement.nacelle_attachment==\"wing\"):\n                if (self.arrangement.number_of_engine==\"twin\"):\n                    self.airframe.nacelle = propulsion.InboardWingMountedTf0Nacelle(self,\"right\")\n                    self.airframe.other_nacelle = propulsion.InboardWingMountedTf0Nacelle(self,\"left\")\n                    self.airframe.engine_analysis_order = [\"nacelle\",\"other_nacelle\"]\n                elif (self.arrangement.number_of_engine==\"quadri\"):\n                    self.airframe.nacelle = propulsion.OutboardWingMountedTf0Nacelle(self,\"right\")\n                    self.airframe.other_nacelle = propulsion.OutboardWingMountedTf0Nacelle(self,\"left\")\n                    self.airframe.internal_nacelle = propulsion.InboardWingMountedTf0Nacelle(self,\"right\")\n                    self.airframe.other_internal_nacelle = propulsion.InboardWingMountedTf0Nacelle(self,\"left\")\n                    self.airframe.engine_analysis_order = [\"nacelle\",\"other_nacelle\",\"internal_nacelle\",\"other_internal_nacelle\"]\n                else:\n                    raise Exception(\"Number of engines not allowed\")\n            elif (self.arrangement.nacelle_attachment==\"rear\"):\n                if (self.arrangement.number_of_engine==\"twin\"):\n                    self.airframe.nacelle = propulsion.RearFuselageMountedTf0Nacelle(self,\"right\")\n                    self.airframe.other_nacelle = propulsion.RearFuselageMountedTf0Nacelle(self,\"left\")\n                    self.airframe.engine_analysis_order = [\"nacelle\",\"other_nacelle\"]\n                else:\n                    raise Exception(\"Number of engines not allowed\")\n            else:\n                raise Exception(\"Type of nacelle attachment is unknown\")\n\n        elif (self.arrangement.power_architecture==\"tf\"):\n            self.power_system = model.Turbofan(self)\n            if (self.arrangement.nacelle_attachment==\"wing\"):\n                if (self.arrangement.number_of_engine==\"twin\"):\n                    self.airframe.nacelle = propulsion.InboardWingMountedTfNacelle(self,\"right\")\n                    self.airframe.other_nacelle = propulsion.InboardWingMountedTfNacelle(self,\"left\")\n                    self.airframe.engine_analysis_order = [\"nacelle\",\"other_nacelle\"]\n                elif (self.arrangement.number_of_engine==\"quadri\"):\n                    self.airframe.nacelle = propulsion.OutboardWingMountedTfNacelle(self,\"right\")\n                    self.airframe.other_nacelle = propulsion.OutboardWingMountedTfNacelle(self,\"left\")\n                    self.airframe.internal_nacelle = propulsion.InboardWingMountedTfNacelle(self,\"right\")\n                    self.airframe.other_internal_nacelle = propulsion.InboardWingMountedTfNacelle(self,\"left\")\n                    self.airframe.engine_analysis_order = [\"nacelle\",\"other_nacelle\",\"internal_nacelle\",\"other_internal_nacelle\"]\n                else:\n                    raise Exception(\"Number of engines not allowed\")\n            elif (self.arrangement.nacelle_attachment==\"rear\"):\n                if (self.arrangement.number_of_engine==\"twin\"):\n                    self.airframe.nacelle = propulsion.RearFuselageMountedTfNacelle(self,\"right\")\n                    self.airframe.other_nacelle = propulsion.RearFuselageMountedTfNacelle(self,\"left\")\n                else:\n                    raise Exception(\"Number of engines not allowed\")\n            elif (self.arrangement.nacelle_attachment==\"pods\"):\n                if (self.arrangement.number_of_engine==\"twin\"):\n                    self.airframe.nacelle = propulsion.PodTailConeMountedTfNacelle(self,\"right\")\n                    self.airframe.other_nacelle = propulsion.PodTailConeMountedTfNacelle(self,\"left\")\n                    self.airframe.engine_analysis_order = [\"nacelle\",\"other_nacelle\"]\n                else:\n                    raise Exception(\"Number of engines not allowed\")\n            elif (self.arrangement.nacelle_attachment==\"body_cones\"):\n                if (self.arrangement.number_of_engine==\"twin\"):\n                    self.airframe.nacelle = propulsion.BodyTailConeMountedTfNacelle(self)\n                    self.airframe.other_nacelle = propulsion.PiggyBackTailConeMountedTfNacelle(self)\n                    self.airframe.engine_analysis_order = [\"nacelle\",\"other_nacelle\"]\n                else:\n                    raise Exception(\"Number of engines not allowed\")\n            else:\n                raise Exception(\"Type of nacelle attachment is unknown\")\n\n        elif (self.arrangement.power_architecture==\"tp\"):\n            self.power_system = model.Turboprop(self)\n            if (self.arrangement.nacelle_attachment==\"wing\"):\n                if (self.arrangement.number_of_engine==\"twin\"):\n                    self.airframe.nacelle = propulsion.InboardWingMountedTpNacelle(self,\"right\")\n                    self.airframe.other_nacelle = propulsion.InboardWingMountedTpNacelle(self,\"left\")\n                    self.airframe.engine_analysis_order = [\"nacelle\",\"other_nacelle\"]\n                elif (self.arrangement.number_of_engine==\"quadri\"):\n                    self.airframe.nacelle = propulsion.OutboardWingMountedTpNacelle(self,\"right\")\n                    self.airframe.other_nacelle = propulsion.OutboardWingMountedTpNacelle(self,\"left\")\n                    self.airframe.internal_nacelle = propulsion.InboardWingMountedTpNacelle(self,\"right\")\n                    self.airframe.other_internal_nacelle = propulsion.InboardWingMountedTpNacelle(self,\"left\")\n                    self.airframe.engine_analysis_order = [\"nacelle\",\"other_nacelle\",\"internal_nacelle\",\"other_internal_nacelle\"]\n                else:\n                    raise Exception(\"Number of engines not allowed\")\n            else:\n                raise Exception(\"Type of nacelle attachment is not allowed\")\n\n        elif (self.arrangement.power_architecture==\"ep\"):\n            self.power_system = model.Electroprop(self)\n            if (self.arrangement.nacelle_attachment==\"wing\"):\n                if (self.arrangement.number_of_engine==\"twin\"):\n                    self.airframe.nacelle = propulsion.InboardWingMountedEpNacelle(self,\"right\")\n                    self.airframe.other_nacelle = propulsion.InboardWingMountedEpNacelle(self,\"left\")\n                    self.airframe.engine_analysis_order = [\"nacelle\",\"other_nacelle\"]\n                elif (self.arrangement.number_of_engine==\"quadri\"):\n                    self.airframe.nacelle = propulsion.OutboardWingMountedEpNacelle(self,\"right\")\n                    self.airframe.other_nacelle = propulsion.OutboardWingMountedEpNacelle(self,\"left\")\n                    self.airframe.internal_nacelle = propulsion.InboardWingMountedEpNacelle(self,\"right\")\n                    self.airframe.other_internal_nacelle = propulsion.InboardWingMountedEpNacelle(self,\"left\")\n                    self.airframe.engine_analysis_order = [\"nacelle\",\"other_nacelle\",\"internal_nacelle\",\"other_internal_nacelle\"]\n                elif (self.arrangement.number_of_engine==\"hexa\"):\n                    self.airframe.nacelle = propulsion.ExternalWingMountedEpNacelle(self,\"right\")\n                    self.airframe.other_nacelle = propulsion.ExternalWingMountedEpNacelle(self,\"left\")\n                    self.airframe.median_nacelle = propulsion.OutboardWingMountedEpNacelle(self,\"right\")\n                    self.airframe.other_median_nacelle = propulsion.OutboardWingMountedEpNacelle(self,\"left\")\n                    self.airframe.internal_nacelle = propulsion.InboardWingMountedEpNacelle(self,\"right\")\n                    self.airframe.other_internal_nacelle = propulsion.InboardWingMountedEpNacelle(self,\"left\")\n                    self.airframe.engine_analysis_order = [\"nacelle\",\"other_nacelle\",\"median_nacelle\",\"other_median_nacelle\",\"internal_nacelle\",\"other_internal_nacelle\"]\n                else:\n                    raise Exception(\"Number of engines not allowed\")\n            else:\n                raise Exception(\"Type of nacelle attachment is not allowed\")\n\n        elif (self.arrangement.power_architecture==\"ef\"):\n            self.power_system = model.Electrofan(self)\n            if (self.arrangement.nacelle_attachment==\"wing\"):\n                if (self.arrangement.number_of_engine==\"twin\"):\n                    self.airframe.nacelle = propulsion.InboardWingMountedEfNacelle(self,\"right\")\n                    self.airframe.other_nacelle = propulsion.InboardWingMountedEfNacelle(self,\"left\")\n                    self.airframe.engine_analysis_order = [\"nacelle\",\"other_nacelle\"]\n                elif (self.arrangement.number_of_engine==\"quadri\"):\n                    self.airframe.nacelle = propulsion.OutboardWingMountedEfNacelle(self,\"right\")\n                    self.airframe.other_nacelle = propulsion.OutboardWingMountedEfNacelle(self,\"left\")\n                    self.airframe.internal_nacelle = propulsion.InboardWingMountedEfNacelle(self,\"right\")\n                    self.airframe.other_internal_nacelle = propulsion.InboardWingMountedEfNacelle(self,\"left\")\n                    self.airframe.engine_analysis_order = [\"nacelle\",\"other_nacelle\",\"internal_nacelle\",\"other_internal_nacelle\"]\n                else:\n                    raise Exception(\"Number of engines not allowed\")\n            elif (self.arrangement.nacelle_attachment==\"rear\"):\n                if (self.arrangement.number_of_engine==\"twin\"):\n                    self.airframe.nacelle = propulsion.RearFuselageMountedEfNacelle(self,\"right\")\n                    self.airframe.other_nacelle = propulsion.RearFuselageMountedEfNacelle(self,\"left\")\n                    self.airframe.engine_analysis_order = [\"nacelle\",\"other_nacelle\"]\n                else:\n                    raise Exception(\"Number of engines not allowed\")\n            else:\n                raise Exception(\"Type of nacelle attachment is unknown\")\n\n        elif (self.arrangement.power_architecture==\"pte\"):\n            self.power_system = model.PartialTurboElectric(self)\n            if (self.arrangement.nacelle_attachment==\"wing\"):\n                if (self.arrangement.number_of_engine==\"twin\"):\n                    self.airframe.nacelle = propulsion.InboardWingMountedTfNacelle(self,\"right\")\n                    self.airframe.other_nacelle = propulsion.InboardWingMountedTfNacelle(self,\"left\")\n                    self.airframe.tail_nacelle = propulsion.BodyTailConeMountedEfNacelle(self)\n                    self.airframe.engine_analysis_order = [\"nacelle\",\"other_nacelle\",\"tail_nacelle\"]\n                elif (self.arrangement.number_of_engine==\"quadri\"):\n                    self.airframe.nacelle = propulsion.OutboardWingMountedTfNacelle(self,\"right\")\n                    self.airframe.other_nacelle = propulsion.OutboardWingMountedTfNacelle(self,\"left\")\n                    self.airframe.internal_nacelle = propulsion.InboardWingMountedTfNacelle(self,\"right\")\n                    self.airframe.other_internal_nacelle = propulsion.InboardWingMountedTfNacelle(self,\"left\")\n                    self.airframe.tail_nacelle = propulsion.BodyTailConeMountedEfNacelle(self)\n                    self.airframe.engine_analysis_order = [\"nacelle\",\"other_nacelle\",\"internal_nacelle\",\"other_internal_nacelle\",\"tail_nacelle\"]\n                else:\n                    raise Exception(\"Number of engines not allowed\")\n            elif (self.arrangement.nacelle_attachment==\"rear\"):\n                if (self.arrangement.number_of_engine==\"twin\"):\n                    self.airframe.nacelle = propulsion.RearFuselageMountedTfNacelle(self,\"right\")\n                    self.airframe.other_nacelle = propulsion.RearFuselageMountedTfNacelle(self,\"left\")\n                    self.airframe.tail_nacelle = propulsion.BodyTailConeMountedEfNacelle(self)\n                    self.airframe.engine_analysis_order = [\"nacelle\",\"other_nacelle\",\"tail_nacelle\"]\n                else:\n                    raise Exception(\"Number of engines not allowed\")\n            else:\n                raise Exception(\"Type of nacelle attachment is unknown\")\n\n        elif (self.arrangement.power_architecture==\"pte_pod\"):\n            self.power_system = model.PartialTurboElectricPods(self)\n            if (self.arrangement.nacelle_attachment==\"wing\"):\n                if (self.arrangement.number_of_engine==\"twin\"):\n                    self.airframe.nacelle = propulsion.InboardWingMountedTfNacelle(self,\"right\")\n                    self.airframe.other_nacelle = propulsion.InboardWingMountedTfNacelle(self,\"left\")\n                    self.airframe.tail_nacelle = propulsion.BodyTailConeMountedEfNacelle(self)\n                    self.airframe.pod_tail_nacelle = propulsion.PodTailConeMountedEfNacelle(self,\"right\")\n                    self.airframe.other_pod_tail_nacelle = propulsion.PodTailConeMountedEfNacelle(self,\"left\")\n                    self.airframe.engine_analysis_order = [\"nacelle\",\"other_nacelle\",\"tail_nacelle\",\"pod_tail_nacelle\",\"other_pod_tail_nacelle\"]\n                elif (self.arrangement.number_of_engine==\"quadri\"):\n                    self.airframe.nacelle = propulsion.OutboardWingMountedTfNacelle(self,\"right\")\n                    self.airframe.other_nacelle = propulsion.OutboardWingMountedTfNacelle(self,\"left\")\n                    self.airframe.internal_nacelle = propulsion.InboardWingMountedTfNacelle(self,\"right\")\n                    self.airframe.other_internal_nacelle = propulsion.InboardWingMountedTfNacelle(self,\"left\")\n                    self.airframe.pod_tail_nacelle = propulsion.PodTailConeMountedEfNacelle(self,\"right\")\n                    self.airframe.other_pod_tail_nacelle = propulsion.PodTailConeMountedEfNacelle(self,\"left\")\n                    self.airframe.engine_analysis_order = [\"nacelle\",\"other_nacelle\",\"internal_nacelle\",\"other_internal_nacelle\",\"pod_tail_nacelle\",\"other_pod_tail_nacelle\"]\n                else:\n                    raise Exception(\"Number of engines not allowed\")\n            elif (self.arrangement.nacelle_attachment==\"rear\"):\n                if (self.arrangement.number_of_engine==\"twin\"):\n                    self.airframe.nacelle = propulsion.RearFuselageMountedTfNacelle(self,\"right\")\n                    self.airframe.other_nacelle = propulsion.RearFuselageMountedTfNacelle(self,\"left\")\n                    self.airframe.pod_tail_nacelle = propulsion.PodTailConeMountedEfNacelle(self,\"right\")\n                    self.airframe.other_pod_tail_nacelle = propulsion.PodTailConeMountedEfNacelle(self,\"left\")\n                    self.airframe.engine_analysis_order = [\"nacelle\",\"other_nacelle\",\"tail_nacelle\",\"pod_tail_nacelle\",\"other_pod_tail_nacelle\"]\n                else:\n                    raise Exception(\"Number of engines not allowed\")\n            else:\n                raise Exception(\"Type of nacelle attachment not allowed\")\n\n        elif (self.arrangement.power_architecture==\"pte_piggy\"):\n            self.power_system = model.PartialTurboElectricPiggyBack(self)\n            if (self.arrangement.nacelle_attachment==\"wing\"):\n                if (self.arrangement.number_of_engine==\"twin\"):\n                    self.airframe.nacelle = propulsion.InboardWingMountedTfNacelle(self,\"right\")\n                    self.airframe.other_nacelle = propulsion.InboardWingMountedTfNacelle(self,\"left\")\n                    self.airframe.tail_nacelle = propulsion.BodyTailConeMountedEfNacelle(self)\n                    self.airframe.other_tail_nacelle = propulsion.PiggyBackTailConeMountedEfNacelle(self)\n                    self.airframe.engine_analysis_order = [\"nacelle\",\"other_nacelle\",\"tail_nacelle\",\"other_tail_nacelle\"]\n                elif (self.arrangement.number_of_engine==\"quadri\"):\n                    self.airframe.nacelle = propulsion.OutboardWingMountedTfNacelle(self,\"right\")\n                    self.airframe.other_nacelle = propulsion.OutboardWingMountedTfNacelle(self,\"left\")\n                    self.airframe.internal_nacelle = propulsion.InboardWingMountedTfNacelle(self,\"right\")\n                    self.airframe.other_internal_nacelle = propulsion.InboardWingMountedTfNacelle(self,\"left\")\n                    self.airframe.tail_nacelle = propulsion.BodyTailConeMountedEfNacelle(self)\n                    self.airframe.other_tail_nacelle = propulsion.PiggyBackTailConeMountedEfNacelle(self)\n                    self.airframe.engine_analysis_order = [\"nacelle\",\"other_nacelle\",\"internal_nacelle\",\"other_internal_nacelle\",\"tail_nacelle\",\"other_tail_nacelle\"]\n                else:\n                    raise Exception(\"Number of engines not allowed\")\n            elif (self.arrangement.nacelle_attachment==\"rear\"):\n                if (self.arrangement.number_of_engine==\"twin\"):\n                    self.airframe.nacelle = propulsion.RearFuselageMountedTfNacelle(self,\"right\")\n                    self.airframe.other_nacelle = propulsion.RearFuselageMountedTfNacelle(self,\"left\")\n                    self.airframe.tail_nacelle = propulsion.BodyTailConeMountedEfNacelle(self)\n                    self.airframe.other_tail_nacelle = propulsion.PiggyBackTailConeMountedEfNacelle(self)\n                    self.airframe.engine_analysis_order = [\"nacelle\",\"other_nacelle\",\"tail_nacelle\",\"other_tail_nacelle\"]\n                else:\n                    raise Exception(\"Number of engines not allowed\")\n            else:\n                raise Exception(\"Type of nacelle attachment not allowed\")\n\n# ----------------------------------------------------------------------------------------------------------------------\n        else:\n            raise Exception(\"Type of power architecture is unknown\")\n\n# ----------------------------------------------------------------------------------------------------------------------\n        self.airframe.mass_analysis_order =   [\"cabin\",\"body\",\"wing\",\"landing_gear\",\"cargo\"] \\\n                                            + self.airframe.engine_analysis_order \\\n                                            + [\"vertical_stab\",\"horizontal_stab\"] \\\n                                            + self.airframe.tank_analysis_order \\\n                                            + [\"system\"]\n\n# ----------------------------------------------------------------------------------------------------------------------\n        self.aerodynamics = model.Aerodynamics(self)\n\n# ----------------------------------------------------------------------------------------------------------------------\n        self.weight_cg = model.WeightCg(self)\n\n# ----------------------------------------------------------------------------------------------------------------------\n        self.handling_quality = HandlingQuality(self)\n\n# ----------------------------------------------------------------------------------------------------------------------\n        self.performance = Performance(self)\n\n# ----------------------------------------------------------------------------------------------------------------------\n        if (self.arrangement.power_source == \"battery\"):\n            self.performance.mission = AllMissionIsoMass(self)\n        else:\n            self.performance.mission = AllMissionVarMass(self)\n\n# ----------------------------------------------------------------------------------------------------------------------\n        self.economics = Economics(self)\n\n# ----------------------------------------------------------------------------------------------------------------------\n        self.environment = Environment(self)\n\n\n        return\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/aircraft_root/#lh2pac.marilib.aircraft.aircraft_root.Arrangement","title":"Arrangement","text":"<pre><code>Arrangement(\n    body_type=\"fuselage\",\n    wing_type=\"classic\",\n    wing_attachment=\"low\",\n    stab_architecture=\"classic\",\n    tank_architecture=\"wing_box\",\n    gear_architecture=\"retractable\",\n    number_of_engine=\"twin\",\n    nacelle_attachment=\"wing\",\n    power_architecture=\"tf\",\n    power_source=\"fuel\",\n    fuel_type=\"kerosene\",\n)\n</code></pre> <p>               Bases: <code>object</code></p> <p>Architectural choices</p> Source code in <code>src/lh2pac/marilib/aircraft/aircraft_root.py</code> <pre><code>def __init__(self,body_type = \"fuselage\",               # \"fuselage\" or \"blended\"\n                  wing_type = \"classic\",                # \"classic\" or \"blended\"\n                  wing_attachment = \"low\",              # \"low\" or \"high\"\n                  stab_architecture = \"classic\",        # \"classic\", \"t_tail\" or \"h_tail\"\n                  tank_architecture = \"wing_box\",       # \"wing_box\", \"piggy_back\" or \"pods\"\n                  gear_architecture = \"retractable\",    # \"retractable\", \"bare_fixed\"\n                  number_of_engine = \"twin\",            # \"twin\" or \"quadri\"\n                  nacelle_attachment = \"wing\",          # \"wing\", \"pod\" or \"rear\"\n                  power_architecture = \"tf\",            # \"tf\", \"tp\", \"ef\", \"pte1\", \"ef1\", \"ep1\",\n                  power_source = \"fuel\",                # \"fuel\", \"battery\", \"fuel_cell\"\n                  fuel_type = \"kerosene\"                # \"kerosene\", \"liquid_h2\", \"Compressed_h2\" or \"battery\"\n             ):\n\n    self.body_type = body_type\n    self.wing_type = wing_type\n    self.wing_attachment = wing_attachment\n    self.stab_architecture = stab_architecture\n    self.tank_architecture = tank_architecture\n    self.gear_architecture = gear_architecture\n    self.number_of_engine = number_of_engine\n    self.nacelle_attachment = nacelle_attachment\n    self.power_architecture = power_architecture\n    self.power_source = power_source\n    self.fuel_type = fuel_type\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/environment/","title":"Environment","text":""},{"location":"reference/lh2pac/marilib/aircraft/environment/#lh2pac.marilib.aircraft.environment","title":"environment","text":"<p>Created on Thu Jan 20 20:20:20 2020</p> <p>@author: Conceptual Airplane Design &amp; Operations (CADO team)          Nicolas PETEILH, Pascal ROCHES, Nicolas MONROLIN, Thierry DRUOT          Aircraft &amp; Systems, Air Transport Departement, ENAC</p>"},{"location":"reference/lh2pac/marilib/aircraft/environment/#lh2pac.marilib.aircraft.environment-classes","title":"Classes","text":""},{"location":"reference/lh2pac/marilib/aircraft/environment/#lh2pac.marilib.aircraft.environment.Economics","title":"Economics","text":"<pre><code>Economics(aircraft)\n</code></pre> Source code in <code>src/lh2pac/marilib/aircraft/environment.py</code> <pre><code>def __init__(self, aircraft):\n    self.aircraft = aircraft\n\n    cost_range = self.aircraft.requirement.cost_range\n\n    self.irp = aircraft.get_init(self,\"irp\")\n    self.period = aircraft.get_init(self,\"period\")\n    self.interest_rate = aircraft.get_init(self,\"interest_rate\")\n    self.labor_cost = aircraft.get_init(self,\"labor_cost\")\n    self.utilization = aircraft.get_init(self,\"utilization\", val=self.yearly_utilization(cost_range))\n\n    self.fuel_price = aircraft.get_init(self,\"fuel_price\")\n    self.energy_price = aircraft.get_init(self,\"energy_price\")\n    self.battery_price = aircraft.get_init(self,\"battery_price\")\n\n    self.engine_price = None\n    self.gear_price = None\n    self.frame_price = None\n\n    self.frame_cost = None\n    self.engine_cost = None\n    self.cockpit_crew_cost = None\n    self.cabin_crew_cost = None\n    self.landing_fees = None\n    self.navigation_fees = None\n    self.catering_cost = None\n    self.pax_handling_cost = None\n    self.ramp_handling_cost = None\n\n    self.std_op_cost = None\n    self.cash_op_cost = None\n    self.direct_op_cost = None\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/environment/#lh2pac.marilib.aircraft.environment.Economics-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/aircraft/environment/#lh2pac.marilib.aircraft.environment.Economics.landing_gear_price","title":"landing_gear_price","text":"<pre><code>landing_gear_price()\n</code></pre> <p>Typical value</p> Source code in <code>src/lh2pac/marilib/aircraft/environment.py</code> <pre><code>def landing_gear_price(self):\n    \"\"\"Typical value\n    \"\"\"\n    landing_gear_mass = self.aircraft.airframe.landing_gear.mass\n    gear_price = 720. * landing_gear_mass\n    return gear_price\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/environment/#lh2pac.marilib.aircraft.environment.Economics.one_airframe_price","title":"one_airframe_price","text":"<pre><code>one_airframe_price()\n</code></pre> <p>Regression on catalog prices corrected with engine prices</p> Source code in <code>src/lh2pac/marilib/aircraft/environment.py</code> <pre><code>def one_airframe_price(self):\n    \"\"\"Regression on catalog prices corrected with engine prices\n    \"\"\"\n    mwe = self.aircraft.weight_cg.mwe\n    airframe_price = 0.7e3*(9e4 + 1.15*mwe - 1.8e9/(2e4 + mwe**0.94))\n    return airframe_price\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/environment/#lh2pac.marilib.aircraft.environment.Economics.one_engine_price","title":"one_engine_price","text":"<pre><code>one_engine_price()\n</code></pre> <p>Regression on catalog prices</p> Source code in <code>src/lh2pac/marilib/aircraft/environment.py</code> <pre><code>def one_engine_price(self):\n    \"\"\"Regression on catalog prices\n    \"\"\"\n    reference_thrust = self.aircraft.power_system.get_reference_thrust()\n    engine_price = ((2.115e-4*reference_thrust + 78.85)*reference_thrust)\n    return engine_price\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/environment/#lh2pac.marilib.aircraft.environment.Economics.operating_cost_analysis","title":"operating_cost_analysis","text":"<pre><code>operating_cost_analysis()\n</code></pre> <p>Computes Cash and Direct Operating Costs per flight (based on AAE 451 Spring 2004)</p> Source code in <code>src/lh2pac/marilib/aircraft/environment.py</code> <pre><code>    def operating_cost_analysis(self):\n        \"\"\"Computes Cash and Direct Operating Costs per flight (based on AAE 451 Spring 2004)\n        \"\"\"\n        n_pax_ref = self.aircraft.airframe.cabin.n_pax_ref\n\n        fuel_type = self.aircraft.arrangement.fuel_type\n        power_architecture = self.aircraft.arrangement.power_architecture\n        nacelle_mass = self.aircraft.airframe.nacelle.mass\n\n        reference_thrust = self.aircraft.power_system.get_reference_thrust()\n        n_engine = self.aircraft.power_system.n_engine\n\n        mtow = self.aircraft.weight_cg.mtow\n        mwe = self.aircraft.weight_cg.mwe\n\n        cost_range = self.aircraft.performance.mission.cost.range\n        time_block = self.aircraft.performance.mission.cost.time_block\n\n        # Cash Operating Cost\n        #-----------------------------------------------------------------------------------------------------------------------------------------------\n        if (self.aircraft.arrangement.power_source == \"battery\"):\n            enrg_block = self.aircraft.performance.mission.cost.enrg_block\n            self.fuel_cost = enrg_block*self.energy_price\n        else:\n            fuel_density = earth.fuel_density(fuel_type)\n            fuel_block = self.aircraft.performance.mission.cost.fuel_block\n            self.fuel_cost = fuel_block*self.fuel_price/fuel_density\n\n        b_h = time_block/3600.\n        t_t = b_h + 0.25\n\n        w_f = (10000. + mwe - nacelle_mass)*1.e-5\n\n        labor_frame = ((1.26+1.774*w_f-0.1071*w_f**2)*t_t + (1.614+0.7227*w_f+0.1204*w_f**2))*self.labor_cost\n        matrl_frame = (12.39+29.8*w_f+0.1806*w_f**2)*t_t + (15.20+97.330*w_f-2.8620*w_f**2)\n        self.frame_cost = labor_frame + matrl_frame\n\n        t_h = 0.05*((reference_thrust)/4.4482198)*1e-4\n\n        labor_engine = n_engine*(0.645*t_t+t_h*(0.566*t_t+0.434))*self.labor_cost\n        matrl_engine = n_engine*(25.*t_t+t_h*(0.62*t_t+0.38))\n\n        if (power_architecture==\"pte\"):\n            rear_engine_cost = self.aircraft.airframe.tail_nacelle.specific_nacelle_cost * self.aircraft.airframe.tail_nacelle.mass\n        else:\n            rear_engine_cost = 0.\n\n        self.engine_cost = labor_engine + matrl_engine + rear_engine_cost\n\n        w_g = mtow*1e-3\n\n        self.cockpit_crew_cost = b_h*2*(440-0.532*w_g)\n        self.cabin_crew_cost = b_h*np.ceil(n_pax_ref/50.)*self.labor_cost\n        self.landing_fees = 8.66*(mtow*1e-3)\n        self.navigation_fees = 57.*(cost_range/185200.)*np.sqrt((mtow/1000.)/50.)\n        self.catering_cost = 3.07 * n_pax_ref\n        self.pax_handling_cost = 2. * n_pax_ref\n        self.ramp_handling_cost = 8.70 * n_pax_ref\n        self.std_op_cost = self.fuel_cost + self.frame_cost + self.engine_cost + self.cockpit_crew_cost + self.landing_fees + self.navigation_fees #+ self.elec_cost\n        self.cash_op_cost = self.std_op_cost + self.cabin_crew_cost + self.catering_cost + self.pax_handling_cost + self.ramp_handling_cost\n\n        # DirectOperating Cost\n        #-----------------------------------------------------------------------------------------------------------------------------------------------\n        self.engine_price = self.one_engine_price()\n        self.gear_price = self.landing_gear_price()\n        self.frame_price = self.one_airframe_price()\n\n#        battery_price = eco.battery_mass_price*cost_mission.req_battery_mass\n\n        self.utilization = self.yearly_utilization(cost_range)\n        self.aircraft_price = self.frame_price + self.engine_price * n_engine + self.gear_price #+ battery_price\n        self.total_investment = self.frame_price * 1.06 + n_engine * self.engine_price * 1.025\n        irp_year = unit.year_s(self.irp)\n        period_year = unit.year_s(self.period)\n        self.interest = (self.total_investment/(self.utilization*period_year)) * (irp_year * 0.04 * (((1. + self.interest_rate)**irp_year)/((1. + self.interest_rate)**irp_year - 1.)) - 1.)\n        self.insurance = 0.0035 * self.aircraft_price/self.utilization\n        self.depreciation = 0.99 * (self.total_investment / (self.utilization * period_year))     # Depreciation\n        self.direct_op_cost = self.cash_op_cost + self.interest + self.depreciation + self.insurance\n\n        return\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/environment/#lh2pac.marilib.aircraft.environment.Economics.yearly_utilization","title":"yearly_utilization","text":"<pre><code>yearly_utilization(mean_range)\n</code></pre> <p>Compute the yearly utilization from the average range</p> <p>:param mean_range: Average range :return:</p> Source code in <code>src/lh2pac/marilib/aircraft/environment.py</code> <pre><code>def yearly_utilization(self, mean_range):\n    \"\"\"Compute the yearly utilization from the average range\n\n    :param mean_range: Average range\n    :return:\n    \"\"\"\n    range = unit.convert_from(\"NM\",\n                  [ 100.,  500., 1000., 1500., 2000., 2500., 3000., 3500., 4000.])\n    utilization = [2300., 2300., 1500., 1200.,  900.,  800.,  700.,  600.,  600.]\n    return lin_interp_1d(mean_range, range, utilization)\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/environment/#lh2pac.marilib.aircraft.environment.Environment","title":"Environment","text":"<pre><code>Environment(aircraft)\n</code></pre> <p>               Bases: <code>Flight</code></p> Source code in <code>src/lh2pac/marilib/aircraft/environment.py</code> <pre><code>def __init__(self, aircraft):\n    super(Environment, self).__init__(aircraft)\n    self.aircraft = aircraft\n\n    fuel_type = self.aircraft.arrangement.fuel_type\n\n    self.CO2_metric = None\n    self.CO2_index = earth.emission_index(fuel_type, \"CO2\")\n    self.H2O_index = earth.emission_index(fuel_type, \"H2O\")\n    self.SO2_index = earth.emission_index(fuel_type, \"SO2\")\n    self.NOx_index = earth.emission_index(fuel_type, \"NOx\")\n    self.CO_index = earth.emission_index(fuel_type, \"CO\")\n    self.HC_index = earth.emission_index(fuel_type, \"HC\")\n    self.sulfuric_acid_index = earth.emission_index(fuel_type, \"sulfuric_acid\")\n    self.nitrous_acid_index = earth.emission_index(fuel_type, \"nitrous_acid\")\n    self.nitric_acid_index = earth.emission_index(fuel_type, \"nitric_acid\")\n    self.soot_index = earth.emission_index(fuel_type, \"soot\")\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/environment/#lh2pac.marilib.aircraft.environment.Environment-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/aircraft/environment/#lh2pac.marilib.aircraft.environment.Environment.acceleration","title":"acceleration","text":"<pre><code>acceleration(\n    nei,\n    altp,\n    disa,\n    speed_mode,\n    speed,\n    mass,\n    rating,\n    throttle,\n    full_output=False,\n)\n</code></pre> <p>Aircraft acceleration on level flight</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def acceleration(self,nei,altp,disa,speed_mode,speed,mass,rating,throttle, full_output=False):\n    \"\"\"Aircraft acceleration on level flight\n    \"\"\"\n    r,gam,Cp,Cv = earth.gas_data()\n\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    mach = self.get_mach(pamb,speed_mode,speed)\n\n    dict = self.aircraft.power_system.thrust(pamb,tamb,mach,rating,throttle=throttle,nei=nei)\n    fn = dict[\"fn\"]\n    ff = dict[\"ff\"]\n\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    if(nei&gt;0):\n        dcx = self.aircraft.power_system.oei_drag(pamb,mach)\n        cx = cx + dcx*nei\n\n    acc = (fn - 0.5*gam*pamb*mach**2*self.aircraft.airframe.wing.area*cx) / mass\n\n    if full_output:\n        return acc,fn,ff,cz,cx,pamb,tamb\n    else:\n        return acc\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/environment/#lh2pac.marilib.aircraft.environment.Environment.air_path","title":"air_path","text":"<pre><code>air_path(\n    nei,\n    altp,\n    disa,\n    speed_mode,\n    speed,\n    mass,\n    rating,\n    kfn,\n    full_output=False,\n)\n</code></pre> <p>Retrieve air path in various conditions</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def air_path(self,nei,altp,disa,speed_mode,speed,mass,rating,kfn, full_output=False):\n    \"\"\"Retrieve air path in various conditions\n    \"\"\"\n    g = earth.gravity()\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    mach = self.get_mach(pamb,speed_mode,speed)\n\n    dict = self.aircraft.power_system.thrust(pamb,tamb,mach,rating,nei=nei)\n    fn = dict[\"fn\"]*kfn\n    ff = dict[\"ff\"]*kfn\n    if kfn!=1. and full_output:\n        print(\"WARNING, air_path method, kfn is different from 1, fuel flow may not be accurate\")\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    if(nei&gt;0):\n        dcx = self.aircraft.power_system.oei_drag(pamb,mach)\n        cx = cx + dcx*nei\n        lod = cz/cx\n\n    acc_factor = earth.climb_mode(speed_mode, mach, dtodz, tstd, disa)\n    slope = ( fn/(mass*g) - 1./lod ) / acc_factor\n    vz = slope * mach * earth.sound_speed(tamb)\n    acc = (acc_factor-1.)*g*slope\n    if full_output:\n        return slope,vz,fn,ff,acc,cz,cx,pamb,tamb\n    else:\n        return slope,vz\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/environment/#lh2pac.marilib.aircraft.environment.Environment.arrival_ground_legs","title":"arrival_ground_legs","text":"<pre><code>arrival_ground_legs(ldw)\n</code></pre> <p>Compute fuel and time allowances for arrival ground phases</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def arrival_ground_legs(self,ldw):\n    \"\"\"Compute fuel and time allowances for arrival ground phases\n    \"\"\"\n    n_engine = self.aircraft.power_system.n_engine\n    reference_thrust = self.aircraft.power_system.get_reference_thrust()\n    fuel_type = self.aircraft.arrangement.fuel_type\n\n    time_landing = 180.\n    time_taxi_in = 420.\n\n    if fuel_type!=\"battery\":\n        engine_bpr = self.aircraft.airframe.nacelle.engine_bpr\n        fuel_mass_factor = earth.fuel_heat(\"kerosene\") / earth.fuel_heat(fuel_type)\n        fuel_landing = fuel_mass_factor*1e-4*(0.5+2.3/engine_bpr)*ldw\n        fuel_taxi_in = fuel_mass_factor*(26. + 1.8e-4*reference_thrust)*n_engine\n        return {\"fuel\":{\"landing\":fuel_landing,\"taxi_in\":fuel_taxi_in},\n                \"time\":{\"landing\":time_landing,\"taxi_in\":time_taxi_in}}\n    else:\n        enrg_landing = (0.25*43.1e6)*0.75e-4*ldw\n        enrg_taxi_in = (0.25*43.1e6)*(26. + 1.8e-4*reference_thrust)*n_engine\n        return {\"enrg\":{\"landing\":enrg_landing,\"taxi_in\":enrg_taxi_in},\n                \"time\":{\"landing\":time_landing,\"taxi_in\":time_taxi_in}}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/environment/#lh2pac.marilib.aircraft.environment.Environment.breguet_range","title":"breguet_range","text":"<pre><code>breguet_range(range, tow, ktow, altp, mach, disa)\n</code></pre> <p>Breguet range equation is dependant from power architecture</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def breguet_range(self,range,tow,ktow,altp,mach,disa):\n    \"\"\"Breguet range equation is dependant from power architecture\n    \"\"\"\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    tas = mach * earth.sound_speed(tamb)\n    time = 1.09*(range/tas)\n\n    dict = self.level_flight(pamb,tamb,mach,tow*ktow)\n    val = self.aircraft.power_system.specific_breguet_range(tow,range,tas,dict)\n    return val,time\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/environment/#lh2pac.marilib.aircraft.environment.Environment.check_ceiling","title":"check_ceiling","text":"<pre><code>check_ceiling(mass, altp_ini, mach, disa)\n</code></pre> <p>Check reachable altitude</p> Source code in <code>src/lh2pac/marilib/aircraft/environment.py</code> <pre><code>def check_ceiling(self,mass,altp_ini,mach,disa):\n    \"\"\"\n    Check reachable altitude\n    \"\"\"\n    vz_req_mcl = self.aircraft.performance.mcl_ceiling.vz_req\n    vz_req_mcr = self.aircraft.performance.mcr_ceiling.vz_req\n\n    isomach = \"mach\"\n    nei = 0\n\n    altp = altp_ini\n    throttle = 1.\n    ceiling = 0\n\n    slope,vz_clb = self.air_path(nei,altp_ini,disa,isomach,mach,mass,\"MCL\",throttle)\n\n    if(vz_clb&lt;vz_req_mcl):\n        altp, rei = self.propulsion_ceiling(altp_ini,nei,vz_req_mcl,disa,isomach,mach,mass,\"MCL\",throttle)\n        if(rei==1):\n            ceiling = 1\n        else:\n            ceiling = -1\n\n    [slope,vz_crz] = self.air_path(nei,altp_ini,disa,isomach,mach,mass,\"MCR\",throttle)\n\n    if(vz_crz&lt;vz_req_mcr):\n        altp, rei = self.propulsion_ceiling(altp_ini,nei,vz_req_mcr,disa,isomach,mach,mass,\"MCR\",throttle)\n\n        if(rei==1):\n            ceiling = 2\n        else:\n            ceiling = -1\n\n    return altp,ceiling\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/environment/#lh2pac.marilib.aircraft.environment.Environment.departure_ground_legs","title":"departure_ground_legs","text":"<pre><code>departure_ground_legs(tow)\n</code></pre> <p>Compute fuel and time allowances for departure ground phases</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def departure_ground_legs(self,tow):\n    \"\"\"Compute fuel and time allowances for departure ground phases\n    \"\"\"\n    n_engine = self.aircraft.power_system.n_engine\n    reference_thrust = self.aircraft.power_system.get_reference_thrust()\n    fuel_type = self.aircraft.arrangement.fuel_type\n\n    time_taxi_out = 540.\n    time_take_off = 220.*tow/(reference_thrust*n_engine)\n\n    if fuel_type!=\"battery\":\n        engine_bpr = self.aircraft.airframe.nacelle.engine_bpr\n        fuel_mass_factor = earth.fuel_heat(\"kerosene\") / earth.fuel_heat(fuel_type)\n        fuel_taxi_out = fuel_mass_factor*(34. + 2.3e-4*reference_thrust)*n_engine\n        fuel_take_off = fuel_mass_factor*1e-4*(2.8+2.3/engine_bpr)*tow\n        return {\"fuel\":{\"taxi_out\":fuel_taxi_out,\"take_off\":fuel_take_off},\n                \"time\":{\"taxi_out\":time_taxi_out,\"take_off\":time_take_off}}\n    else:\n        enrg_taxi_out = (0.25*43.1e6)*(34. + 2.3e-4*reference_thrust)*n_engine\n        enrg_take_off = (0.25*43.1e6)*3.e-4*tow\n        return {\"enrg\":{\"taxi_out\":enrg_taxi_out,\"take_off\":enrg_take_off},\n                \"time\":{\"taxi_out\":time_taxi_out,\"take_off\":time_take_off}}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/environment/#lh2pac.marilib.aircraft.environment.Environment.descent","title":"descent","text":"<pre><code>descent(nei, altp, disa, speed_mode, speed, vz, mass)\n</code></pre> <p>Retrieve air path and flight characteristics in various conditions</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def descent(self,nei,altp,disa,speed_mode,speed,vz,mass):\n    \"\"\"Retrieve air path and flight characteristics in various conditions\n    \"\"\"\n    g = earth.gravity()\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    mach = self.get_mach(pamb,speed_mode,speed)\n\n    slope = vz / (mach * earth.sound_speed(tamb))\n    acc_factor = earth.climb_mode(speed_mode, mach, dtodz, tstd, disa)\n\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    fn = (slope * acc_factor + 1./lod) * (mass*g)\n    dict = self.aircraft.power_system.sc(self,pamb,tamb,mach,\"FID\", fn, nei)\n    ff = dict[\"sfc\"]*fn\n    thtl = dict[\"thtl\"]\n\n    return slope,thtl,fn,ff,cz,cx,pamb,tamb\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/environment/#lh2pac.marilib.aircraft.environment.Environment.eval_sar","title":"eval_sar","text":"<pre><code>eval_sar(altp, mass, mach, disa)\n</code></pre> <p>Evaluate Specific Air Range</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def eval_sar(self,altp,mass,mach,disa):\n    \"\"\"Evaluate Specific Air Range\n    \"\"\"\n    g = earth.gravity()\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    tas = mach * earth.sound_speed(tamb)\n\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    nei = 0\n    thrust = mass*g / lod\n    dict = self.aircraft.power_system.sc(pamb,tamb,mach,\"MCR\",thrust,nei)\n    dict[\"fn\"] = thrust\n    dict[\"cz\"] = cz\n    dict[\"cx\"] = cx\n    dict[\"lod\"] = lod\n    dict[\"sar\"] = self.aircraft.power_system.specific_air_range(mass,tas,dict)\n    return dict\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/environment/#lh2pac.marilib.aircraft.environment.Environment.fuel_efficiency_metric","title":"fuel_efficiency_metric","text":"<pre><code>fuel_efficiency_metric()\n</code></pre> <p>Fuel efficiency metric (CO2 metric) valid for kerosene aircraft only</p> Source code in <code>src/lh2pac/marilib/aircraft/environment.py</code> <pre><code>def fuel_efficiency_metric(self):\n    \"\"\"Fuel efficiency metric (CO2 metric) valid for kerosene aircraft only\n    \"\"\"\n    if (self.aircraft.arrangement.fuel_type==\"kerosene\"):\n        mtow = self.aircraft.weight_cg.mtow\n        rgf = self.aircraft.airframe.cabin.projected_area      # Reference Geometric Factor (Pressurized floor area)\n        disa = self.aircraft.requirement.cruise_disa\n        mach = self.aircraft.requirement.cruise_mach    # take cruise mach instead of Maxi Range because SFC is constant\n\n        high_weight = 0.92*mtow\n        low_weight = 0.45*mtow + 0.63*mtow**0.924\n        medium_weight = 0.5*(high_weight+low_weight)\n\n        # WARNING : Maximum SAR altitude or speed may be lowered by propulsion ceilings\n        #-----------------------------------------------------------------------------------------------------------\n        dict = self.eval_max_sar(high_weight,mach,disa)\n        altp_sar_max_hw = dict[\"altp\"]\n        altp_sar_max_hw,hw_ceiling = self.check_ceiling(high_weight,altp_sar_max_hw,mach,disa)\n        if(hw_ceiling&lt;0.):\n            lower_mach = mach - 0.03\n            dict = self.eval_max_sar(high_weight,lower_mach,disa)\n            altp_sar_max_hw = dict[\"altp\"]\n            altp_sar_max_hw,hw_ceiling = self.check_ceiling(high_weight,altp_sar_max_hw,lower_mach,disa)\n            dict = self.eval_sar(altp_sar_max_hw,high_weight,lower_mach,disa)\n            sar_max_hw = dict[\"sar\"]\n        else:\n            dict = self.eval_sar(altp_sar_max_hw,high_weight,mach,disa)\n            sar_max_hw = dict[\"sar\"]\n\n        dict = self.eval_max_sar(medium_weight,mach,disa)\n        altp_sar_max_mw = dict[\"altp\"]\n        altp_sar_max_mw,mw_ceiling = self.check_ceiling(medium_weight,altp_sar_max_mw,mach,disa)\n        if(mw_ceiling&lt;0.):\n            lower_mach = mach - 0.03\n            dict = self.eval_max_sar(medium_weight,lower_mach,disa)\n            altp_sar_max_mw = dict[\"altp\"]\n            altp_sar_max_mw,mw_ceiling = self.check_ceiling(medium_weight,altp_sar_max_mw,lower_mach,disa)\n            dict = self.eval_sar(altp_sar_max_mw,medium_weight,lower_mach,disa)\n            sar_max_mw = dict[\"sar\"]\n        else:\n            dict = self.eval_sar(altp_sar_max_mw,medium_weight,mach,disa)\n            sar_max_mw = dict[\"sar\"]\n\n        dict = self.eval_max_sar(low_weight,mach,disa)\n        altp_sar_max_lw = dict[\"altp\"]\n        altp_sar_max_lw,lw_ceiling = self.check_ceiling(low_weight,altp_sar_max_lw,mach,disa)\n        if(lw_ceiling&lt;0.):\n            lower_mach = mach - 0.03\n            dict = self.eval_max_sar(low_weight,lower_mach,disa)\n            altp_sar_max_lw = dict[\"altp\"]\n            altp_sar_max_lw,lw_ceiling = self.check_ceiling(low_weight,altp_sar_max_lw,lower_mach,disa)\n            dict = self.eval_sar(altp_sar_max_lw,low_weight,lower_mach,disa)\n            sar_max_lw = dict[\"sar\"]\n        else:\n            dict = self.eval_sar(altp_sar_max_lw,low_weight,mach,disa)\n            sar_max_lw = dict[\"sar\"]\n\n        self.CO2_metric = (1./rgf**0.24)*(1./sar_max_hw + 1./sar_max_mw + 1./sar_max_lw)/3.        # kg/m/m2\n    else:\n        self.CO2_metric = np.nan\n    return\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/environment/#lh2pac.marilib.aircraft.environment.Environment.get_mach","title":"get_mach","text":"<pre><code>get_mach(pamb, speed_mode, speed)\n</code></pre> <p>Retrieve Mach from CAS or mach depending on speed_mode</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def get_mach(self,pamb,speed_mode,speed):\n    \"\"\"Retrieve Mach from CAS or mach depending on speed_mode\n    \"\"\"\n    mach = {\"cas\" : earth.mach_from_vcas(pamb, speed),  # Input is CAS\n            \"mach\" : speed  # Input is mach\n            }.get(speed_mode, \"Erreur: select speed_mode equal to cas or mach\")\n    return mach\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/environment/#lh2pac.marilib.aircraft.environment.Environment.get_speed","title":"get_speed","text":"<pre><code>get_speed(pamb, speed_mode, mach)\n</code></pre> <p>retrieve CAS or Mach from mach depending on speed_mode</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def get_speed(self,pamb,speed_mode,mach):\n    \"\"\"retrieve CAS or Mach from mach depending on speed_mode\n    \"\"\"\n    speed = {\"cas\" : earth.vcas_from_mach(pamb, mach),  # CAS required\n             \"mach\" : mach  # mach required\n             }.get(speed_mode, \"Erreur: select speed_mode equal to cas or mach\")\n    return speed\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/environment/#lh2pac.marilib.aircraft.environment.Environment.get_vcas","title":"get_vcas","text":"<pre><code>get_vcas(pamb, speed_mode, speed)\n</code></pre> <p>Retrieve CAS from Mach or CAS depending on speed_mode</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def get_vcas(self,pamb,speed_mode,speed):\n    \"\"\"Retrieve CAS from Mach or CAS depending on speed_mode\n    \"\"\"\n    cas = {\"mach\" : earth.vcas_from_mach(pamb, speed),  # Input is CAS\n            \"cas\" : speed  # Input is mach\n            }.get(speed_mode, \"Erreur: select speed_mode equal to cas or mach\")\n    return cas\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/environment/#lh2pac.marilib.aircraft.environment.Environment.holding","title":"holding","text":"<pre><code>holding(time, mass, altp, mach, disa)\n</code></pre> <p>Holding equation is dependant from power architecture</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def holding(self,time,mass,altp,mach,disa):\n    \"\"\"Holding equation is dependant from power architecture\n    \"\"\"\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    tas = mach * earth.sound_speed(tamb)\n    dict = self.level_flight(pamb,tamb,mach,mass)\n    return self.aircraft.power_system.specific_holding(mass,time,tas,dict)\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/environment/#lh2pac.marilib.aircraft.environment.Environment.level_flight","title":"level_flight","text":"<pre><code>level_flight(pamb, tamb, mach, mass)\n</code></pre> <p>Level flight equilibrium</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def level_flight(self,pamb,tamb,mach,mass):\n    \"\"\"Level flight equilibrium\n    \"\"\"\n    g = earth.gravity()\n    r,gam,Cp,Cv = earth.gas_data()\n    tas = mach * earth.sound_speed(tamb)\n\n    cz = (2.*mass*g)/(gam*pamb*mach**2*self.aircraft.airframe.wing.area)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    thrust = (gam/2.)*pamb*mach**2*self.aircraft.airframe.wing.area*cx\n    dict = self.aircraft.power_system.sc(pamb,tamb,mach,\"MCR\",thrust)\n    dict[\"fn\"] = thrust\n    dict[\"cx\"] = cx\n    dict[\"cz\"] = cz\n    dict[\"lod\"] = lod\n    dict[\"sar\"] = self.aircraft.power_system.specific_air_range(mass,tas,dict)\n    return dict\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/environment/#lh2pac.marilib.aircraft.environment.Environment.lift_from_speed","title":"lift_from_speed","text":"<pre><code>lift_from_speed(pamb, tamb, mach, mass)\n</code></pre> <p>Retrieve cz from mach using simplified lift equation</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def lift_from_speed(self,pamb,tamb,mach,mass):\n    \"\"\"Retrieve cz from mach using simplified lift equation\n    \"\"\"\n    g = earth.gravity()\n    r,gam,Cp,Cv = earth.gas_data()\n    cz = (2.*mass*g)/(gam*pamb*mach**2*self.aircraft.airframe.wing.area)\n    return cz\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/environment/#lh2pac.marilib.aircraft.environment.Environment.max_air_path","title":"max_air_path","text":"<pre><code>max_air_path(\n    nei,\n    altp,\n    disa,\n    speed_mode,\n    mass,\n    rating,\n    kfn,\n    full_output=False,\n)\n</code></pre> <p>Optimize the speed of the aircraft to maximize the air path</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def max_air_path(self,nei,altp,disa,speed_mode,mass,rating,kfn, full_output=False):\n    \"\"\"Optimize the speed of the aircraft to maximize the air path\n    \"\"\"\n    def fct(cz):\n        pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n        mach = self.speed_from_lift(pamb,tamb,cz,mass)\n        speed = self.get_speed(pamb,speed_mode,mach)\n        slope,vz = self.air_path(nei,altp,disa,speed_mode,speed,mass,rating,kfn)\n        if isformax: return slope\n        else: return slope,vz,mach\n\n    cz_ini = 0.5\n    dcz = 0.05\n\n    isformax = True\n    cz,slope,rc = maximize_1d(cz_ini,dcz,[fct])\n    isformax = False\n\n    slope,vz,mach = fct(cz)\n    return slope,vz,mach,cz\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/environment/#lh2pac.marilib.aircraft.environment.Environment.propulsion_ceiling","title":"propulsion_ceiling","text":"<pre><code>propulsion_ceiling(\n    altp_ini,\n    nei,\n    vzreq,\n    disa,\n    speed_mode,\n    speed,\n    mass,\n    rating,\n    throttle,\n)\n</code></pre> <p>Optimize the speed of the aircraft to maximize the air path</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def propulsion_ceiling(self,altp_ini,nei,vzreq,disa,speed_mode,speed,mass,rating,throttle):\n    \"\"\"Optimize the speed of the aircraft to maximize the air path\n    \"\"\"\n    def fct_prop_ceiling(altp,nei,vzreq,disa,speed_mode,speed,mass,rating):\n        slope,vz = self.air_path(nei,altp,disa,speed_mode,speed,mass,rating,throttle)\n        delta_vz = vz - vzreq\n        return delta_vz\n\n    fct_arg = (nei,vzreq,disa,speed_mode,speed,mass,rating)\n\n    output_dict = fsolve(fct_prop_ceiling, x0 = altp_ini, args=fct_arg, full_output = True)\n\n    altp = output_dict[0][0]\n    rei = output_dict[2]\n    if(rei!=1): altp = np.NaN\n\n    return altp, rei\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/environment/#lh2pac.marilib.aircraft.environment.Environment.speed_from_lift","title":"speed_from_lift","text":"<pre><code>speed_from_lift(pamb, tamb, cz, mass)\n</code></pre> <p>Retrieve mach from cz using simplified lift equation</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def speed_from_lift(self,pamb,tamb,cz,mass):\n    \"\"\"Retrieve mach from cz using simplified lift equation\n    \"\"\"\n    g = earth.gravity()\n    r,gam,Cp,Cv = earth.gas_data()\n    mach = np.sqrt((mass*g)/(0.5*gam*pamb*self.aircraft.airframe.wing.area*cz))\n    return mach\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/environment/#lh2pac.marilib.aircraft.environment-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/aircraft/handling_quality/","title":"Handling quality","text":""},{"location":"reference/lh2pac/marilib/aircraft/handling_quality/#lh2pac.marilib.aircraft.handling_quality","title":"handling_quality","text":"<p>Created on Thu Jan 20 20:20:20 2020</p> <p>@author: Conceptual Airplane Design &amp; Operations (CADO team)          Nicolas PETEILH, Pascal ROCHES, Nicolas MONROLIN, Thierry DRUOT          Aircraft &amp; Systems, Air Transport Departement, ENAC</p>"},{"location":"reference/lh2pac/marilib/aircraft/handling_quality/#lh2pac.marilib.aircraft.handling_quality-classes","title":"Classes","text":""},{"location":"reference/lh2pac/marilib/aircraft/handling_quality/#lh2pac.marilib.aircraft.handling_quality.HandlingQuality","title":"HandlingQuality","text":"<pre><code>HandlingQuality(aircraft)\n</code></pre> <p>               Bases: <code>Flight</code></p> <p>Master class for all aircraft handling qualities</p> Source code in <code>src/lh2pac/marilib/aircraft/handling_quality.py</code> <pre><code>def __init__(self, aircraft):\n    self.aircraft = aircraft\n\n    self.static_stab_margin = aircraft.get_init(self,\"static_stab_margin\")\n\n    self.forward_cg_mass = None\n    self.forward_cg_req = None\n    self.forward_cg_stall = None\n\n    self.backward_cg_mass = None\n    self.backward_cg_req = None\n    self.backward_cg_stab = None\n\n    self.backward_cg_oei_trim = None\n    self.backward_cg_oei_mass = None\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/handling_quality/#lh2pac.marilib.aircraft.handling_quality.HandlingQuality-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/aircraft/handling_quality/#lh2pac.marilib.aircraft.handling_quality.HandlingQuality.acceleration","title":"acceleration","text":"<pre><code>acceleration(\n    nei,\n    altp,\n    disa,\n    speed_mode,\n    speed,\n    mass,\n    rating,\n    throttle,\n    full_output=False,\n)\n</code></pre> <p>Aircraft acceleration on level flight</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def acceleration(self,nei,altp,disa,speed_mode,speed,mass,rating,throttle, full_output=False):\n    \"\"\"Aircraft acceleration on level flight\n    \"\"\"\n    r,gam,Cp,Cv = earth.gas_data()\n\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    mach = self.get_mach(pamb,speed_mode,speed)\n\n    dict = self.aircraft.power_system.thrust(pamb,tamb,mach,rating,throttle=throttle,nei=nei)\n    fn = dict[\"fn\"]\n    ff = dict[\"ff\"]\n\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    if(nei&gt;0):\n        dcx = self.aircraft.power_system.oei_drag(pamb,mach)\n        cx = cx + dcx*nei\n\n    acc = (fn - 0.5*gam*pamb*mach**2*self.aircraft.airframe.wing.area*cx) / mass\n\n    if full_output:\n        return acc,fn,ff,cz,cx,pamb,tamb\n    else:\n        return acc\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/handling_quality/#lh2pac.marilib.aircraft.handling_quality.HandlingQuality.air_path","title":"air_path","text":"<pre><code>air_path(\n    nei,\n    altp,\n    disa,\n    speed_mode,\n    speed,\n    mass,\n    rating,\n    kfn,\n    full_output=False,\n)\n</code></pre> <p>Retrieve air path in various conditions</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def air_path(self,nei,altp,disa,speed_mode,speed,mass,rating,kfn, full_output=False):\n    \"\"\"Retrieve air path in various conditions\n    \"\"\"\n    g = earth.gravity()\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    mach = self.get_mach(pamb,speed_mode,speed)\n\n    dict = self.aircraft.power_system.thrust(pamb,tamb,mach,rating,nei=nei)\n    fn = dict[\"fn\"]*kfn\n    ff = dict[\"ff\"]*kfn\n    if kfn!=1. and full_output:\n        print(\"WARNING, air_path method, kfn is different from 1, fuel flow may not be accurate\")\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    if(nei&gt;0):\n        dcx = self.aircraft.power_system.oei_drag(pamb,mach)\n        cx = cx + dcx*nei\n        lod = cz/cx\n\n    acc_factor = earth.climb_mode(speed_mode, mach, dtodz, tstd, disa)\n    slope = ( fn/(mass*g) - 1./lod ) / acc_factor\n    vz = slope * mach * earth.sound_speed(tamb)\n    acc = (acc_factor-1.)*g*slope\n    if full_output:\n        return slope,vz,fn,ff,acc,cz,cx,pamb,tamb\n    else:\n        return slope,vz\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/handling_quality/#lh2pac.marilib.aircraft.handling_quality.HandlingQuality.analysis","title":"analysis","text":"<pre><code>analysis()\n</code></pre> <p>Evaluate CG bounds according to HQ constraints</p> Source code in <code>src/lh2pac/marilib/aircraft/handling_quality.py</code> <pre><code>def analysis(self):\n    \"\"\"Evaluate CG bounds according to HQ constraints\n    \"\"\"\n    # Required forward CG position\n    #------------------------------------------------------------------------------------------------------\n    self.forward_cg_mass = (  self.aircraft.weight_cg.owe\n                            + self.aircraft.airframe.cabin.pax_max_fwd_mass\n                            + self.aircraft.airframe.cargo.freight_max_fwd_mass\n                            + self.aircraft.airframe.tank.fuel_max_fwd_mass)\n    self.forward_cg_req = (  self.aircraft.weight_cg.owe_cg * self.aircraft.weight_cg.owe\n                           + self.aircraft.airframe.cabin.pax_max_fwd_cg * self.aircraft.airframe.cabin.pax_max_fwd_mass\n                           + self.aircraft.airframe.cargo.freight_max_fwd_cg * self.aircraft.airframe.cargo.freight_max_fwd_mass\n                           + self.aircraft.airframe.tank.fuel_max_fwd_cg * self.aircraft.airframe.tank.fuel_max_fwd_mass ) \\\n                         /self.forward_cg_mass\n\n    # Required backward CG position\n    #------------------------------------------------------------------------------------------------------\n    self.backward_cg_mass = (  self.aircraft.weight_cg.owe\n                             + self.aircraft.airframe.cabin.pax_max_bwd_mass\n                             + self.aircraft.airframe.cargo.freight_max_bwd_mass\n                             + self.aircraft.airframe.tank.fuel_max_bwd_mass)\n    self.backward_cg_req = (  self.aircraft.weight_cg.owe_cg * self.aircraft.weight_cg.owe\n                            + self.aircraft.airframe.cabin.pax_max_bwd_cg * self.aircraft.airframe.cabin.pax_max_bwd_mass\n                            + self.aircraft.airframe.cargo.freight_max_bwd_cg * self.aircraft.airframe.cargo.freight_max_bwd_mass\n                            + self.aircraft.airframe.tank.fuel_max_bwd_cg * self.aircraft.airframe.tank.fuel_max_bwd_mass ) \\\n                          /self.backward_cg_mass\n\n    # Forward limit : trim landing\n    #------------------------------------------------------------------------------------------------------\n    altp = unit.m_ft(0.)\n    disa = 0.\n    nei = 0\n    speed_mode = \"mach\"\n    hld_conf = self.aircraft.aerodynamics.hld_conf_ld\n    mass = self.forward_cg_mass\n\n    forward_cg_stall, speed, fn, aoa, ih, c_z, cx_trimmed = self.max_fwd_cg_stall(altp,disa,nei,hld_conf,speed_mode,mass)\n\n    self.forward_cg_stall = forward_cg_stall    # Forward cg limit\n\n    # Backward limit : static stability\n    #------------------------------------------------------------------------------------------------------\n    altp = unit.m_ft(0.)\n    disa = 0.\n    speed = 0.25\n    speed_mode = \"mach\"\n    hld_conf = self.aircraft.aerodynamics.hld_conf_clean\n\n    self.backward_cg_stab = self.max_bwd_cg_stab(altp,disa,hld_conf,speed_mode,speed)\n\n    # Backward limit : engine failure control\n    #------------------------------------------------------------------------------------------------------\n    altp = unit.m_ft(0.)\n    disa = 15.\n\n    backward_cg_oei_trim, backward_cg_oei_mass = self.max_bwd_cg_oei(altp, disa)\n\n    self.backward_cg_oei_trim = backward_cg_oei_trim\n    self.backward_cg_oei_mass = backward_cg_oei_mass\n\n    return\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/handling_quality/#lh2pac.marilib.aircraft.handling_quality.HandlingQuality.arrival_ground_legs","title":"arrival_ground_legs","text":"<pre><code>arrival_ground_legs(ldw)\n</code></pre> <p>Compute fuel and time allowances for arrival ground phases</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def arrival_ground_legs(self,ldw):\n    \"\"\"Compute fuel and time allowances for arrival ground phases\n    \"\"\"\n    n_engine = self.aircraft.power_system.n_engine\n    reference_thrust = self.aircraft.power_system.get_reference_thrust()\n    fuel_type = self.aircraft.arrangement.fuel_type\n\n    time_landing = 180.\n    time_taxi_in = 420.\n\n    if fuel_type!=\"battery\":\n        engine_bpr = self.aircraft.airframe.nacelle.engine_bpr\n        fuel_mass_factor = earth.fuel_heat(\"kerosene\") / earth.fuel_heat(fuel_type)\n        fuel_landing = fuel_mass_factor*1e-4*(0.5+2.3/engine_bpr)*ldw\n        fuel_taxi_in = fuel_mass_factor*(26. + 1.8e-4*reference_thrust)*n_engine\n        return {\"fuel\":{\"landing\":fuel_landing,\"taxi_in\":fuel_taxi_in},\n                \"time\":{\"landing\":time_landing,\"taxi_in\":time_taxi_in}}\n    else:\n        enrg_landing = (0.25*43.1e6)*0.75e-4*ldw\n        enrg_taxi_in = (0.25*43.1e6)*(26. + 1.8e-4*reference_thrust)*n_engine\n        return {\"enrg\":{\"landing\":enrg_landing,\"taxi_in\":enrg_taxi_in},\n                \"time\":{\"landing\":time_landing,\"taxi_in\":time_taxi_in}}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/handling_quality/#lh2pac.marilib.aircraft.handling_quality.HandlingQuality.breguet_range","title":"breguet_range","text":"<pre><code>breguet_range(range, tow, ktow, altp, mach, disa)\n</code></pre> <p>Breguet range equation is dependant from power architecture</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def breguet_range(self,range,tow,ktow,altp,mach,disa):\n    \"\"\"Breguet range equation is dependant from power architecture\n    \"\"\"\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    tas = mach * earth.sound_speed(tamb)\n    time = 1.09*(range/tas)\n\n    dict = self.level_flight(pamb,tamb,mach,tow*ktow)\n    val = self.aircraft.power_system.specific_breguet_range(tow,range,tas,dict)\n    return val,time\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/handling_quality/#lh2pac.marilib.aircraft.handling_quality.HandlingQuality.departure_ground_legs","title":"departure_ground_legs","text":"<pre><code>departure_ground_legs(tow)\n</code></pre> <p>Compute fuel and time allowances for departure ground phases</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def departure_ground_legs(self,tow):\n    \"\"\"Compute fuel and time allowances for departure ground phases\n    \"\"\"\n    n_engine = self.aircraft.power_system.n_engine\n    reference_thrust = self.aircraft.power_system.get_reference_thrust()\n    fuel_type = self.aircraft.arrangement.fuel_type\n\n    time_taxi_out = 540.\n    time_take_off = 220.*tow/(reference_thrust*n_engine)\n\n    if fuel_type!=\"battery\":\n        engine_bpr = self.aircraft.airframe.nacelle.engine_bpr\n        fuel_mass_factor = earth.fuel_heat(\"kerosene\") / earth.fuel_heat(fuel_type)\n        fuel_taxi_out = fuel_mass_factor*(34. + 2.3e-4*reference_thrust)*n_engine\n        fuel_take_off = fuel_mass_factor*1e-4*(2.8+2.3/engine_bpr)*tow\n        return {\"fuel\":{\"taxi_out\":fuel_taxi_out,\"take_off\":fuel_take_off},\n                \"time\":{\"taxi_out\":time_taxi_out,\"take_off\":time_take_off}}\n    else:\n        enrg_taxi_out = (0.25*43.1e6)*(34. + 2.3e-4*reference_thrust)*n_engine\n        enrg_take_off = (0.25*43.1e6)*3.e-4*tow\n        return {\"enrg\":{\"taxi_out\":enrg_taxi_out,\"take_off\":enrg_take_off},\n                \"time\":{\"taxi_out\":time_taxi_out,\"take_off\":time_take_off}}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/handling_quality/#lh2pac.marilib.aircraft.handling_quality.HandlingQuality.descent","title":"descent","text":"<pre><code>descent(nei, altp, disa, speed_mode, speed, vz, mass)\n</code></pre> <p>Retrieve air path and flight characteristics in various conditions</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def descent(self,nei,altp,disa,speed_mode,speed,vz,mass):\n    \"\"\"Retrieve air path and flight characteristics in various conditions\n    \"\"\"\n    g = earth.gravity()\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    mach = self.get_mach(pamb,speed_mode,speed)\n\n    slope = vz / (mach * earth.sound_speed(tamb))\n    acc_factor = earth.climb_mode(speed_mode, mach, dtodz, tstd, disa)\n\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    fn = (slope * acc_factor + 1./lod) * (mass*g)\n    dict = self.aircraft.power_system.sc(self,pamb,tamb,mach,\"FID\", fn, nei)\n    ff = dict[\"sfc\"]*fn\n    thtl = dict[\"thtl\"]\n\n    return slope,thtl,fn,ff,cz,cx,pamb,tamb\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/handling_quality/#lh2pac.marilib.aircraft.handling_quality.HandlingQuality.eval_sar","title":"eval_sar","text":"<pre><code>eval_sar(altp, mass, mach, disa)\n</code></pre> <p>Evaluate Specific Air Range</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def eval_sar(self,altp,mass,mach,disa):\n    \"\"\"Evaluate Specific Air Range\n    \"\"\"\n    g = earth.gravity()\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    tas = mach * earth.sound_speed(tamb)\n\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    nei = 0\n    thrust = mass*g / lod\n    dict = self.aircraft.power_system.sc(pamb,tamb,mach,\"MCR\",thrust,nei)\n    dict[\"fn\"] = thrust\n    dict[\"cz\"] = cz\n    dict[\"cx\"] = cx\n    dict[\"lod\"] = lod\n    dict[\"sar\"] = self.aircraft.power_system.specific_air_range(mass,tas,dict)\n    return dict\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/handling_quality/#lh2pac.marilib.aircraft.handling_quality.HandlingQuality.get_mach","title":"get_mach","text":"<pre><code>get_mach(pamb, speed_mode, speed)\n</code></pre> <p>Retrieve Mach from CAS or mach depending on speed_mode</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def get_mach(self,pamb,speed_mode,speed):\n    \"\"\"Retrieve Mach from CAS or mach depending on speed_mode\n    \"\"\"\n    mach = {\"cas\" : earth.mach_from_vcas(pamb, speed),  # Input is CAS\n            \"mach\" : speed  # Input is mach\n            }.get(speed_mode, \"Erreur: select speed_mode equal to cas or mach\")\n    return mach\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/handling_quality/#lh2pac.marilib.aircraft.handling_quality.HandlingQuality.get_speed","title":"get_speed","text":"<pre><code>get_speed(pamb, speed_mode, mach)\n</code></pre> <p>retrieve CAS or Mach from mach depending on speed_mode</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def get_speed(self,pamb,speed_mode,mach):\n    \"\"\"retrieve CAS or Mach from mach depending on speed_mode\n    \"\"\"\n    speed = {\"cas\" : earth.vcas_from_mach(pamb, mach),  # CAS required\n             \"mach\" : mach  # mach required\n             }.get(speed_mode, \"Erreur: select speed_mode equal to cas or mach\")\n    return speed\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/handling_quality/#lh2pac.marilib.aircraft.handling_quality.HandlingQuality.get_vcas","title":"get_vcas","text":"<pre><code>get_vcas(pamb, speed_mode, speed)\n</code></pre> <p>Retrieve CAS from Mach or CAS depending on speed_mode</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def get_vcas(self,pamb,speed_mode,speed):\n    \"\"\"Retrieve CAS from Mach or CAS depending on speed_mode\n    \"\"\"\n    cas = {\"mach\" : earth.vcas_from_mach(pamb, speed),  # Input is CAS\n            \"cas\" : speed  # Input is mach\n            }.get(speed_mode, \"Erreur: select speed_mode equal to cas or mach\")\n    return cas\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/handling_quality/#lh2pac.marilib.aircraft.handling_quality.HandlingQuality.holding","title":"holding","text":"<pre><code>holding(time, mass, altp, mach, disa)\n</code></pre> <p>Holding equation is dependant from power architecture</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def holding(self,time,mass,altp,mach,disa):\n    \"\"\"Holding equation is dependant from power architecture\n    \"\"\"\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    tas = mach * earth.sound_speed(tamb)\n    dict = self.level_flight(pamb,tamb,mach,mass)\n    return self.aircraft.power_system.specific_holding(mass,time,tas,dict)\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/handling_quality/#lh2pac.marilib.aircraft.handling_quality.HandlingQuality.level_flight","title":"level_flight","text":"<pre><code>level_flight(pamb, tamb, mach, mass)\n</code></pre> <p>Level flight equilibrium</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def level_flight(self,pamb,tamb,mach,mass):\n    \"\"\"Level flight equilibrium\n    \"\"\"\n    g = earth.gravity()\n    r,gam,Cp,Cv = earth.gas_data()\n    tas = mach * earth.sound_speed(tamb)\n\n    cz = (2.*mass*g)/(gam*pamb*mach**2*self.aircraft.airframe.wing.area)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    thrust = (gam/2.)*pamb*mach**2*self.aircraft.airframe.wing.area*cx\n    dict = self.aircraft.power_system.sc(pamb,tamb,mach,\"MCR\",thrust)\n    dict[\"fn\"] = thrust\n    dict[\"cx\"] = cx\n    dict[\"cz\"] = cz\n    dict[\"lod\"] = lod\n    dict[\"sar\"] = self.aircraft.power_system.specific_air_range(mass,tas,dict)\n    return dict\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/handling_quality/#lh2pac.marilib.aircraft.handling_quality.HandlingQuality.lift_from_speed","title":"lift_from_speed","text":"<pre><code>lift_from_speed(pamb, tamb, mach, mass)\n</code></pre> <p>Retrieve cz from mach using simplified lift equation</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def lift_from_speed(self,pamb,tamb,mach,mass):\n    \"\"\"Retrieve cz from mach using simplified lift equation\n    \"\"\"\n    g = earth.gravity()\n    r,gam,Cp,Cv = earth.gas_data()\n    cz = (2.*mass*g)/(gam*pamb*mach**2*self.aircraft.airframe.wing.area)\n    return cz\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/handling_quality/#lh2pac.marilib.aircraft.handling_quality.HandlingQuality.max_air_path","title":"max_air_path","text":"<pre><code>max_air_path(\n    nei,\n    altp,\n    disa,\n    speed_mode,\n    mass,\n    rating,\n    kfn,\n    full_output=False,\n)\n</code></pre> <p>Optimize the speed of the aircraft to maximize the air path</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def max_air_path(self,nei,altp,disa,speed_mode,mass,rating,kfn, full_output=False):\n    \"\"\"Optimize the speed of the aircraft to maximize the air path\n    \"\"\"\n    def fct(cz):\n        pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n        mach = self.speed_from_lift(pamb,tamb,cz,mass)\n        speed = self.get_speed(pamb,speed_mode,mach)\n        slope,vz = self.air_path(nei,altp,disa,speed_mode,speed,mass,rating,kfn)\n        if isformax: return slope\n        else: return slope,vz,mach\n\n    cz_ini = 0.5\n    dcz = 0.05\n\n    isformax = True\n    cz,slope,rc = maximize_1d(cz_ini,dcz,[fct])\n    isformax = False\n\n    slope,vz,mach = fct(cz)\n    return slope,vz,mach,cz\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/handling_quality/#lh2pac.marilib.aircraft.handling_quality.HandlingQuality.max_bwd_cg_oei","title":"max_bwd_cg_oei","text":"<pre><code>max_bwd_cg_oei(altp, disa)\n</code></pre> <p>Computes maximum backward CG position to meet engine failure case constraint WARNING : Influence of CG position is ignored</p> Source code in <code>src/lh2pac/marilib/aircraft/handling_quality.py</code> <pre><code>def max_bwd_cg_oei(self, altp, disa):\n    \"\"\"Computes maximum backward CG position to meet engine failure case constraint\n    WARNING : Influence of CG position is ignored\n    \"\"\"\n    wing_mac = self.aircraft.airframe.wing.mac\n    owe = self.aircraft.weight_cg.owe\n    cyb_vtp, xlc_vtp, aoa_max_vtp, ki_vtp = self.aircraft.airframe.vertical_stab.eval_aero_data()\n\n    payload_miss = 0.5*self.aircraft.airframe.cabin.nominal_payload      # Light payload\n    range_miss = self.aircraft.requirement.design_range/15.              # Short mission\n    altp_miss = self.aircraft.requirement.cruise_altp                    # Nominal altitude\n    mach_miss = self.aircraft.requirement.cruise_mach                    # Nominal speed\n    disa_miss = self.aircraft.requirement.cruise_disa                    # Nominal temperature\n\n    self.aircraft.performance.mission.toy.eval(owe,altp_miss,mach_miss,disa_miss, range=range_miss, payload=payload_miss)\n    tow = self.aircraft.performance.mission.toy.tow\n\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp,disa)\n    stall_margin = self.aircraft.requirement.take_off.kvs1g\n    czmax_to = self.aircraft.aerodynamics.czmax_conf_to\n    mach_s1g = self.speed_from_lift(pamb,tamb,czmax_to,tow) # Stall speed in Mach number\n    mach_35ft = stall_margin*mach_s1g                       # V2 speed\n    mach_mca = mach_35ft/1.1                                # Approximation of required VMCA\n\n    throttle = 1.\n    nei = 1\n\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp,disa)\n    dict = self.aircraft.power_system.thrust(pamb, tamb, mach_mca, \"MTO\", throttle, nei)\n    fn = dict[\"fn1\"]    # Main engines only\n    dcx_oei = self.aircraft.power_system.oei_drag(pamb,mach_mca)\n    cn_prop = self.thrust_yaw_moment(fn,pamb,mach_mca,dcx_oei,nei)\n    backward_cg_oei = xlc_vtp - (cn_prop*wing_mac)/(cyb_vtp*aoa_max_vtp)\n\n    return backward_cg_oei, tow\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/handling_quality/#lh2pac.marilib.aircraft.handling_quality.HandlingQuality.max_bwd_cg_stab","title":"max_bwd_cg_stab","text":"<pre><code>max_bwd_cg_stab(altp, disa, hld_conf, speed_mode, speed)\n</code></pre> <p>Computes max backward CG position according to static stability (neutral point position)</p> Source code in <code>src/lh2pac/marilib/aircraft/handling_quality.py</code> <pre><code>def max_bwd_cg_stab(self, altp, disa, hld_conf, speed_mode, speed):\n    \"\"\"Computes max backward CG position according to static stability (neutral point position)\n    \"\"\"\n    wing_mac = self.aircraft.airframe.wing.mac\n    stability_margin = self.static_stab_margin\n\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp,disa)\n    mach = self.get_mach(pamb,speed_mode,speed)\n\n    cza_wo_htp, xlc_wo_htp, ki_wing = self.aircraft.airframe.wing.eval_aero_data(mach,hld_conf)\n    cza_htp, xlc_htp, aoa_max_htp, ki_htp = self.aircraft.airframe.horizontal_stab.eval_aero_data()\n\n    cg_max_bwd_stab =  (xlc_wo_htp*cza_wo_htp + xlc_htp*cza_htp*(1.-ki_wing*cza_wo_htp)) \\\n                     / (cza_wo_htp + cza_htp*(1.-ki_wing*cza_wo_htp)) \\\n                     - stability_margin*wing_mac\n\n    return cg_max_bwd_stab\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/handling_quality/#lh2pac.marilib.aircraft.handling_quality.HandlingQuality.max_fwd_cg_stall","title":"max_fwd_cg_stall","text":"<pre><code>max_fwd_cg_stall(\n    altp, disa, nei, hld_conf, speed_mode, mass\n)\n</code></pre> <p>Computes max forward trimmable CG position at stall speed</p> Source code in <code>src/lh2pac/marilib/aircraft/handling_quality.py</code> <pre><code>def max_fwd_cg_stall(self,altp,disa,nei,hld_conf,speed_mode,mass):\n    \"\"\"Computes max forward trimmable CG position at stall speed\n    \"\"\"\n    htp_area = self.aircraft.airframe.horizontal_stab.area\n    wing_area = self.aircraft.airframe.wing.area\n    wing_setting = self.aircraft.airframe.wing.setting\n\n    r,gam,Cp,Cv = earth.gas_data()\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp,disa)\n\n    cz_max_wing,cz0 = self.aircraft.airframe.wing.high_lift(hld_conf)     # Wing maximum lift coefficient without margin\n    cza_htp, xlc_htp, aoa_max_htp, ki_htp = self.aircraft.airframe.horizontal_stab.eval_aero_data()\n    cz_max_htp = cza_htp*aoa_max_htp    # Assuming max down lift on HTP\n    c_z = cz_max_wing - cz_max_htp      # Max forward Cg assumed, HTP has down lift\n    mach = self.speed_from_lift(pamb, tamb, c_z, mass)\n    cza_wo_htp, xlc_wo_htp, ki_wing = self.aircraft.airframe.wing.eval_aero_data(mach,hld_conf)\n\n    if(nei&gt;0):\n        dcx_oei = self.aircraft.power_system.oei_drag(pamb,mach)\n    else:\n        dcx_oei = 0.\n\n    dw_angle = self.aircraft.airframe.wing.downwash_angle(ki_wing,cz_max_wing)          # Downwash angle due to the wing\n    cx_basic,lod_trash = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz_max_wing)    # By definition of the drag_ function\n\n    cxi_htp = (ki_htp*cz_max_htp**2)*(htp_area/wing_area)   # Induced drag generated by HTP\n    cx_inter = cz_max_htp*dw_angle                          # Interaction drag (due to downwash)\n    cx_trimmed = cx_basic + cxi_htp + cx_inter + dcx_oei\n    fn = 0.5*gam*pamb*mach**2*wing_area*cx_trimmed\n\n    cm_prop = self.thrust_pitch_moment(fn,pamb,mach,dcx_oei,nei)\n\n    cg_max_fwd_stall = (cm_prop + xlc_wo_htp*cz_max_wing - xlc_htp*cz_max_htp)/(cz_max_wing - cz_max_htp)\n    aoa_wing = (cz_max_wing-cz0) / cza_wo_htp   # Wing angle of attack\n    aoa = aoa_wing - wing_setting               # Reference angle of attack (fuselage axis versus air speed)\n    ih = - aoa + dw_angle - aoa_max_htp         # HTP trim setting\n\n    speed = self.get_speed(pamb,speed_mode,mach)\n\n    return cg_max_fwd_stall, speed, fn, aoa, ih, c_z, cx_trimmed\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/handling_quality/#lh2pac.marilib.aircraft.handling_quality.HandlingQuality.optimization","title":"optimization","text":"<pre><code>optimization()\n</code></pre> <p>Perform hq based empennage sizing and longitudinal wing positioning</p> Source code in <code>src/lh2pac/marilib/aircraft/handling_quality.py</code> <pre><code>def optimization(self):\n    \"\"\"Perform hq based empennage sizing and longitudinal wing positioning\n    \"\"\"\n    def fct(x_in):\n        self.aircraft.airframe.wing.x_root = x_in[0]\n        self.aircraft.airframe.horizontal_stab.area = x_in[1]\n        self.aircraft.airframe.vertical_stab.area = x_in[2]\n\n        self.aircraft.airframe.geometry_analysis(hq_optim=True) # Recompute geometry\n        self.aircraft.weight_cg.mass_pre_design()               # Recompute weights and CGs\n        self.aircraft.aerodynamics.aerodynamic_analysis()       # Recompute aerodynamic characteristics\n        self.aircraft.handling_quality.analysis()               # Recompute CG matching\n\n        y_out = [self.forward_cg_stall - self.forward_cg_req[0],\n                 self.backward_cg_stab - self.backward_cg_req[0],\n                 self.backward_cg_oei_trim - self.backward_cg_req[0]]\n        return y_out\n    #-----------------------------------------------------------------------------------------------------------\n    x_ini = [self.aircraft.airframe.wing.x_root,\n             self.aircraft.airframe.horizontal_stab.area,\n             self.aircraft.airframe.vertical_stab.area]\n\n    output_dict = fsolve(fct, x0=x_ini, args=(), full_output=True)\n\n    if (output_dict[2]!=1):\n        print(output_dict[3])\n        raise Exception(\"Convergence problem in HQ optimization\")\n\n    self.aircraft.airframe.wing.x_root = output_dict[0][0]\n    self.aircraft.airframe.horizontal_stab.area = output_dict[0][1]\n    self.aircraft.airframe.vertical_stab.area = output_dict[0][2]\n\n    self.aircraft.airframe.geometry_analysis(hq_optim=True) # Recompute geometry\n    self.aircraft.weight_cg.mass_pre_design()               # Recompute weights and CGs\n    self.aircraft.aerodynamics.aerodynamic_analysis()       # Recompute aerodynamic characteristics\n    self.aircraft.handling_quality.analysis()               # Recompute CG matching\n\n    return\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/handling_quality/#lh2pac.marilib.aircraft.handling_quality.HandlingQuality.propulsion_ceiling","title":"propulsion_ceiling","text":"<pre><code>propulsion_ceiling(\n    altp_ini,\n    nei,\n    vzreq,\n    disa,\n    speed_mode,\n    speed,\n    mass,\n    rating,\n    throttle,\n)\n</code></pre> <p>Optimize the speed of the aircraft to maximize the air path</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def propulsion_ceiling(self,altp_ini,nei,vzreq,disa,speed_mode,speed,mass,rating,throttle):\n    \"\"\"Optimize the speed of the aircraft to maximize the air path\n    \"\"\"\n    def fct_prop_ceiling(altp,nei,vzreq,disa,speed_mode,speed,mass,rating):\n        slope,vz = self.air_path(nei,altp,disa,speed_mode,speed,mass,rating,throttle)\n        delta_vz = vz - vzreq\n        return delta_vz\n\n    fct_arg = (nei,vzreq,disa,speed_mode,speed,mass,rating)\n\n    output_dict = fsolve(fct_prop_ceiling, x0 = altp_ini, args=fct_arg, full_output = True)\n\n    altp = output_dict[0][0]\n    rei = output_dict[2]\n    if(rei!=1): altp = np.NaN\n\n    return altp, rei\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/handling_quality/#lh2pac.marilib.aircraft.handling_quality.HandlingQuality.speed_from_lift","title":"speed_from_lift","text":"<pre><code>speed_from_lift(pamb, tamb, cz, mass)\n</code></pre> <p>Retrieve mach from cz using simplified lift equation</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def speed_from_lift(self,pamb,tamb,cz,mass):\n    \"\"\"Retrieve mach from cz using simplified lift equation\n    \"\"\"\n    g = earth.gravity()\n    r,gam,Cp,Cv = earth.gas_data()\n    mach = np.sqrt((mass*g)/(0.5*gam*pamb*self.aircraft.airframe.wing.area*cz))\n    return mach\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/handling_quality/#lh2pac.marilib.aircraft.handling_quality.HandlingQuality.thrust_pitch_moment","title":"thrust_pitch_moment","text":"<pre><code>thrust_pitch_moment(fn, pamb, mach, dcx_oei, nei)\n</code></pre> <p>Computes the pitch moment due to most outboard engine failure WARNING : Assumed right engine inoperative</p> Source code in <code>src/lh2pac/marilib/aircraft/handling_quality.py</code> <pre><code>def thrust_pitch_moment(self,fn,pamb,mach,dcx_oei,nei):\n    \"\"\"Computes the pitch moment due to most outboard engine failure\n    WARNING : Assumed right engine inoperative\n    \"\"\"\n    r,gam,Cp,Cv = earth.gas_data()\n\n    n_engine = self.aircraft.power_system.n_engine\n    wing_area = self.aircraft.airframe.wing.area\n    wing_mac = self.aircraft.airframe.wing.mac\n\n    qs = 0.5*gam*pamb*mach**2*wing_area\n    ufn = fn / (n_engine - nei)         # Unitary thrust of main engines\n\n    # Compute cm_prop as if all engines were running\n    cm_prop = 0.\n    for comp in self.aircraft.airframe:\n        if comp.__class__.__name__ in self.aircraft.airframe.engine_analysis_order:\n            cm_prop += (self.aircraft.weight_cg.owe_cg[2] - comp.frame_origin[2]) * ufn / (qs*wing_mac)\n\n    # Replace thrust by oei drag for failed engines\n    if nei==0:\n        pass\n    elif nei==1:\n        cm_prop += (self.aircraft.weight_cg.owe_cg[2] - self.aircraft.airframe.nacelle.frame_origin[2]) * (-ufn/qs - dcx_oei) / wing_mac\n    elif nei==2:\n        cm_prop += (self.aircraft.weight_cg.owe_cg[2] - self.aircraft.airframe.nacelle.frame_origin[2]) * (-ufn/qs - dcx_oei) / wing_mac\n        if n_engine==4:\n            cm_prop += (self.aircraft.weight_cg.owe_cg[2] - self.aircraft.airframe.internal_nacelle.frame_origin[2]) * (-ufn/qs - dcx_oei) / wing_mac\n        elif n_engine==6:\n            cm_prop += (self.aircraft.weight_cg.owe_cg[2] - self.aircraft.airframe.median_nacelle.frame_origin[2]) * (-ufn/qs - dcx_oei) / wing_mac\n    elif nei==3:\n        cm_prop += (self.aircraft.weight_cg.owe_cg[2] - self.aircraft.airframe.nacelle.frame_origin[2]) * (-ufn/qs - dcx_oei) / wing_mac\n        cm_prop += (self.aircraft.weight_cg.owe_cg[2] - self.aircraft.airframe.median_nacelle.frame_origin[2]) * (-ufn/qs - dcx_oei) / wing_mac\n        cm_prop += (self.aircraft.weight_cg.owe_cg[2] - self.aircraft.airframe.internal_nacelle.frame_origin[2]) * (-ufn/qs - dcx_oei) / wing_mac\n\n    return cm_prop\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/handling_quality/#lh2pac.marilib.aircraft.handling_quality.HandlingQuality.thrust_yaw_moment","title":"thrust_yaw_moment","text":"<pre><code>thrust_yaw_moment(fn, pamb, mach, dcx_oei, nei)\n</code></pre> <p>Computes the yaw moment due to most outboard engine failure WARNING : Assumed right engine inoperative</p> Source code in <code>src/lh2pac/marilib/aircraft/handling_quality.py</code> <pre><code>def thrust_yaw_moment(self,fn,pamb,mach,dcx_oei,nei):\n    \"\"\"Computes the yaw moment due to most outboard engine failure\n    WARNING : Assumed right engine inoperative\n    \"\"\"\n    r,gam,Cp,Cv = earth.gas_data()\n\n    n_engine = self.aircraft.power_system.n_engine\n    wing_area = self.aircraft.airframe.wing.area\n    wing_mac = self.aircraft.airframe.wing.mac\n\n    qs = 0.5*gam*pamb*mach**2*wing_area\n    ufn = fn / (n_engine - nei)         # Unitary thrust of main engines\n\n    # cn_prop as if all engines were running\n    cn_prop = 0.\n\n    # Replace thrust by oei drag for failed engines\n    if nei==0:\n        pass\n    elif nei==1:\n        cn_prop += self.aircraft.airframe.nacelle.frame_origin[1] * (ufn/qs + dcx_oei) / wing_mac\n    elif nei==2:\n        cn_prop += self.aircraft.airframe.nacelle.frame_origin[1] * (ufn/qs + dcx_oei) / wing_mac\n        if n_engine==4:\n            cn_prop += self.aircraft.airframe.internal_nacelle.frame_origin[1] * (ufn/qs + dcx_oei) / wing_mac\n        elif n_engine==6:\n            cn_prop += self.aircraft.airframe.median_nacelle.frame_origin[1] * (ufn/qs + dcx_oei) / wing_mac\n    elif nei==3:\n        cn_prop += self.aircraft.airframe.nacelle.frame_origin[1] * (ufn/qs + dcx_oei) / wing_mac\n        cn_prop += self.aircraft.airframe.median_nacelle.frame_origin[1] * (ufn/qs + dcx_oei) / wing_mac\n        cn_prop += self.aircraft.airframe.internalnacelle.frame_origin[1] * (ufn/qs + dcx_oei) / wing_mac\n\n    return cn_prop\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/","title":"Mission","text":""},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission","title":"mission","text":"<p>Created on Thu Jan 20 20:20:20 2020</p> <p>@author: Conceptual Airplane Design &amp; Operations (CADO team)          Nicolas PETEILH, Pascal ROCHES, Nicolas MONROLIN, Thierry DRUOT          Aircraft &amp; Systems, Air Transport Departement, ENAC          Aircraft &amp; Systems, Air Transport Departement, ENAC</p>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission-classes","title":"Classes","text":""},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.AllMissionIsoMass","title":"AllMissionIsoMass","text":"<pre><code>AllMissionIsoMass(aircraft)\n</code></pre> <p>               Bases: <code>AllMissions</code></p> <p>Definition of all mission types for battery powered airplanes</p> Source code in <code>src/lh2pac/marilib/aircraft/mission.py</code> <pre><code>def __init__(self, aircraft):\n    super(AllMissionIsoMass, self).__init__(aircraft)\n\n    self.max_payload = MissionIsoMassGeneric(aircraft)\n    self.nominal = MissionIsoMassGeneric(aircraft)\n    self.max_fuel = MissionIsoMassGeneric(aircraft)\n    self.zero_payload = MissionIsoMassGeneric(aircraft)\n    self.cost = MissionIsoMassGeneric(aircraft)\n    self.toy = MissionIsoMassGeneric(aircraft)\n\n    self.crz_esar = None\n    self.crz_cz = None\n    self.crz_lod = None\n    self.crz_thrust = None\n    self.crz_power = None\n    self.crz_throttle = None\n    self.crz_sec = None\n\n    self.max_esar_altp = None\n    self.max_esar = None\n    self.max_esar_cz = None\n    self.max_esar_lod = None\n    self.max_esar_thrust = None\n    self.max_esar_power = None\n    self.max_esar_throttle = None\n    self.max_esar_sec = None\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.AllMissionIsoMass-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.AllMissionIsoMass.acceleration","title":"acceleration","text":"<pre><code>acceleration(\n    nei,\n    altp,\n    disa,\n    speed_mode,\n    speed,\n    mass,\n    rating,\n    throttle,\n    full_output=False,\n)\n</code></pre> <p>Aircraft acceleration on level flight</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def acceleration(self,nei,altp,disa,speed_mode,speed,mass,rating,throttle, full_output=False):\n    \"\"\"Aircraft acceleration on level flight\n    \"\"\"\n    r,gam,Cp,Cv = earth.gas_data()\n\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    mach = self.get_mach(pamb,speed_mode,speed)\n\n    dict = self.aircraft.power_system.thrust(pamb,tamb,mach,rating,throttle=throttle,nei=nei)\n    fn = dict[\"fn\"]\n    ff = dict[\"ff\"]\n\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    if(nei&gt;0):\n        dcx = self.aircraft.power_system.oei_drag(pamb,mach)\n        cx = cx + dcx*nei\n\n    acc = (fn - 0.5*gam*pamb*mach**2*self.aircraft.airframe.wing.area*cx) / mass\n\n    if full_output:\n        return acc,fn,ff,cz,cx,pamb,tamb\n    else:\n        return acc\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.AllMissionIsoMass.air_path","title":"air_path","text":"<pre><code>air_path(\n    nei,\n    altp,\n    disa,\n    speed_mode,\n    speed,\n    mass,\n    rating,\n    kfn,\n    full_output=False,\n)\n</code></pre> <p>Retrieve air path in various conditions</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def air_path(self,nei,altp,disa,speed_mode,speed,mass,rating,kfn, full_output=False):\n    \"\"\"Retrieve air path in various conditions\n    \"\"\"\n    g = earth.gravity()\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    mach = self.get_mach(pamb,speed_mode,speed)\n\n    dict = self.aircraft.power_system.thrust(pamb,tamb,mach,rating,nei=nei)\n    fn = dict[\"fn\"]*kfn\n    ff = dict[\"ff\"]*kfn\n    if kfn!=1. and full_output:\n        print(\"WARNING, air_path method, kfn is different from 1, fuel flow may not be accurate\")\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    if(nei&gt;0):\n        dcx = self.aircraft.power_system.oei_drag(pamb,mach)\n        cx = cx + dcx*nei\n        lod = cz/cx\n\n    acc_factor = earth.climb_mode(speed_mode, mach, dtodz, tstd, disa)\n    slope = ( fn/(mass*g) - 1./lod ) / acc_factor\n    vz = slope * mach * earth.sound_speed(tamb)\n    acc = (acc_factor-1.)*g*slope\n    if full_output:\n        return slope,vz,fn,ff,acc,cz,cx,pamb,tamb\n    else:\n        return slope,vz\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.AllMissionIsoMass.arrival_ground_legs","title":"arrival_ground_legs","text":"<pre><code>arrival_ground_legs(ldw)\n</code></pre> <p>Compute fuel and time allowances for arrival ground phases</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def arrival_ground_legs(self,ldw):\n    \"\"\"Compute fuel and time allowances for arrival ground phases\n    \"\"\"\n    n_engine = self.aircraft.power_system.n_engine\n    reference_thrust = self.aircraft.power_system.get_reference_thrust()\n    fuel_type = self.aircraft.arrangement.fuel_type\n\n    time_landing = 180.\n    time_taxi_in = 420.\n\n    if fuel_type!=\"battery\":\n        engine_bpr = self.aircraft.airframe.nacelle.engine_bpr\n        fuel_mass_factor = earth.fuel_heat(\"kerosene\") / earth.fuel_heat(fuel_type)\n        fuel_landing = fuel_mass_factor*1e-4*(0.5+2.3/engine_bpr)*ldw\n        fuel_taxi_in = fuel_mass_factor*(26. + 1.8e-4*reference_thrust)*n_engine\n        return {\"fuel\":{\"landing\":fuel_landing,\"taxi_in\":fuel_taxi_in},\n                \"time\":{\"landing\":time_landing,\"taxi_in\":time_taxi_in}}\n    else:\n        enrg_landing = (0.25*43.1e6)*0.75e-4*ldw\n        enrg_taxi_in = (0.25*43.1e6)*(26. + 1.8e-4*reference_thrust)*n_engine\n        return {\"enrg\":{\"landing\":enrg_landing,\"taxi_in\":enrg_taxi_in},\n                \"time\":{\"landing\":time_landing,\"taxi_in\":time_taxi_in}}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.AllMissionIsoMass.breguet_range","title":"breguet_range","text":"<pre><code>breguet_range(range, tow, ktow, altp, mach, disa)\n</code></pre> <p>Breguet range equation is dependant from power architecture</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def breguet_range(self,range,tow,ktow,altp,mach,disa):\n    \"\"\"Breguet range equation is dependant from power architecture\n    \"\"\"\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    tas = mach * earth.sound_speed(tamb)\n    time = 1.09*(range/tas)\n\n    dict = self.level_flight(pamb,tamb,mach,tow*ktow)\n    val = self.aircraft.power_system.specific_breguet_range(tow,range,tas,dict)\n    return val,time\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.AllMissionIsoMass.departure_ground_legs","title":"departure_ground_legs","text":"<pre><code>departure_ground_legs(tow)\n</code></pre> <p>Compute fuel and time allowances for departure ground phases</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def departure_ground_legs(self,tow):\n    \"\"\"Compute fuel and time allowances for departure ground phases\n    \"\"\"\n    n_engine = self.aircraft.power_system.n_engine\n    reference_thrust = self.aircraft.power_system.get_reference_thrust()\n    fuel_type = self.aircraft.arrangement.fuel_type\n\n    time_taxi_out = 540.\n    time_take_off = 220.*tow/(reference_thrust*n_engine)\n\n    if fuel_type!=\"battery\":\n        engine_bpr = self.aircraft.airframe.nacelle.engine_bpr\n        fuel_mass_factor = earth.fuel_heat(\"kerosene\") / earth.fuel_heat(fuel_type)\n        fuel_taxi_out = fuel_mass_factor*(34. + 2.3e-4*reference_thrust)*n_engine\n        fuel_take_off = fuel_mass_factor*1e-4*(2.8+2.3/engine_bpr)*tow\n        return {\"fuel\":{\"taxi_out\":fuel_taxi_out,\"take_off\":fuel_take_off},\n                \"time\":{\"taxi_out\":time_taxi_out,\"take_off\":time_take_off}}\n    else:\n        enrg_taxi_out = (0.25*43.1e6)*(34. + 2.3e-4*reference_thrust)*n_engine\n        enrg_take_off = (0.25*43.1e6)*3.e-4*tow\n        return {\"enrg\":{\"taxi_out\":enrg_taxi_out,\"take_off\":enrg_take_off},\n                \"time\":{\"taxi_out\":time_taxi_out,\"take_off\":time_take_off}}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.AllMissionIsoMass.descent","title":"descent","text":"<pre><code>descent(nei, altp, disa, speed_mode, speed, vz, mass)\n</code></pre> <p>Retrieve air path and flight characteristics in various conditions</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def descent(self,nei,altp,disa,speed_mode,speed,vz,mass):\n    \"\"\"Retrieve air path and flight characteristics in various conditions\n    \"\"\"\n    g = earth.gravity()\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    mach = self.get_mach(pamb,speed_mode,speed)\n\n    slope = vz / (mach * earth.sound_speed(tamb))\n    acc_factor = earth.climb_mode(speed_mode, mach, dtodz, tstd, disa)\n\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    fn = (slope * acc_factor + 1./lod) * (mass*g)\n    dict = self.aircraft.power_system.sc(self,pamb,tamb,mach,\"FID\", fn, nei)\n    ff = dict[\"sfc\"]*fn\n    thtl = dict[\"thtl\"]\n\n    return slope,thtl,fn,ff,cz,cx,pamb,tamb\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.AllMissionIsoMass.eval_cruise_point","title":"eval_cruise_point","text":"<pre><code>eval_cruise_point()\n</code></pre> <p>Evaluate cruise point characteristics</p> Source code in <code>src/lh2pac/marilib/aircraft/mission.py</code> <pre><code>def eval_cruise_point(self):\n    \"\"\"Evaluate cruise point characteristics\n    \"\"\"\n    self.disa = self.aircraft.requirement.cruise_disa\n    self.altp = self.aircraft.requirement.cruise_altp\n    self.mach = self.aircraft.requirement.cruise_mach\n    self.mass = self.aircraft.weight_cg.mtow\n\n    pamb,tamb,tstd,dtodz = earth.atmosphere(self.altp, self.disa)\n\n    lf_dict = self.level_flight(pamb,tamb,self.mach,self.mass)\n    sm_dict = self.eval_max_sar(self.mass,self.mach,self.disa)\n\n    self.crz_esar = lf_dict[\"sar\"]\n    self.crz_cz = lf_dict[\"cz\"]\n    self.crz_lod = lf_dict[\"lod\"]\n    self.crz_thrust = lf_dict[\"fn\"]\n    self.crz_throttle = lf_dict[\"thtl\"]\n    self.crz_power = lf_dict[\"sec\"]*lf_dict[\"fn\"]\n    self.crz_sec = lf_dict[\"sec\"]\n\n    self.max_esar_altp = sm_dict[\"altp\"]\n    self.max_esar = sm_dict[\"sar\"]\n    self.max_esar_cz = sm_dict[\"cz\"]\n    self.max_esar_lod = sm_dict[\"lod\"]\n    self.max_esar_thrust = sm_dict[\"fn\"]\n    self.max_esar_throttle = sm_dict[\"thtl\"]\n    self.max_esar_power = sm_dict[\"sec\"]*sm_dict[\"fn\"]\n    self.max_esar_sec = sm_dict[\"sec\"]\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.AllMissionIsoMass.eval_sar","title":"eval_sar","text":"<pre><code>eval_sar(altp, mass, mach, disa)\n</code></pre> <p>Evaluate Specific Air Range</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def eval_sar(self,altp,mass,mach,disa):\n    \"\"\"Evaluate Specific Air Range\n    \"\"\"\n    g = earth.gravity()\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    tas = mach * earth.sound_speed(tamb)\n\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    nei = 0\n    thrust = mass*g / lod\n    dict = self.aircraft.power_system.sc(pamb,tamb,mach,\"MCR\",thrust,nei)\n    dict[\"fn\"] = thrust\n    dict[\"cz\"] = cz\n    dict[\"cx\"] = cx\n    dict[\"lod\"] = lod\n    dict[\"sar\"] = self.aircraft.power_system.specific_air_range(mass,tas,dict)\n    return dict\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.AllMissionIsoMass.get_mach","title":"get_mach","text":"<pre><code>get_mach(pamb, speed_mode, speed)\n</code></pre> <p>Retrieve Mach from CAS or mach depending on speed_mode</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def get_mach(self,pamb,speed_mode,speed):\n    \"\"\"Retrieve Mach from CAS or mach depending on speed_mode\n    \"\"\"\n    mach = {\"cas\" : earth.mach_from_vcas(pamb, speed),  # Input is CAS\n            \"mach\" : speed  # Input is mach\n            }.get(speed_mode, \"Erreur: select speed_mode equal to cas or mach\")\n    return mach\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.AllMissionIsoMass.get_speed","title":"get_speed","text":"<pre><code>get_speed(pamb, speed_mode, mach)\n</code></pre> <p>retrieve CAS or Mach from mach depending on speed_mode</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def get_speed(self,pamb,speed_mode,mach):\n    \"\"\"retrieve CAS or Mach from mach depending on speed_mode\n    \"\"\"\n    speed = {\"cas\" : earth.vcas_from_mach(pamb, mach),  # CAS required\n             \"mach\" : mach  # mach required\n             }.get(speed_mode, \"Erreur: select speed_mode equal to cas or mach\")\n    return speed\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.AllMissionIsoMass.get_vcas","title":"get_vcas","text":"<pre><code>get_vcas(pamb, speed_mode, speed)\n</code></pre> <p>Retrieve CAS from Mach or CAS depending on speed_mode</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def get_vcas(self,pamb,speed_mode,speed):\n    \"\"\"Retrieve CAS from Mach or CAS depending on speed_mode\n    \"\"\"\n    cas = {\"mach\" : earth.vcas_from_mach(pamb, speed),  # Input is CAS\n            \"cas\" : speed  # Input is mach\n            }.get(speed_mode, \"Erreur: select speed_mode equal to cas or mach\")\n    return cas\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.AllMissionIsoMass.holding","title":"holding","text":"<pre><code>holding(time, mass, altp, mach, disa)\n</code></pre> <p>Holding equation is dependant from power architecture</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def holding(self,time,mass,altp,mach,disa):\n    \"\"\"Holding equation is dependant from power architecture\n    \"\"\"\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    tas = mach * earth.sound_speed(tamb)\n    dict = self.level_flight(pamb,tamb,mach,mass)\n    return self.aircraft.power_system.specific_holding(mass,time,tas,dict)\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.AllMissionIsoMass.level_flight","title":"level_flight","text":"<pre><code>level_flight(pamb, tamb, mach, mass)\n</code></pre> <p>Level flight equilibrium</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def level_flight(self,pamb,tamb,mach,mass):\n    \"\"\"Level flight equilibrium\n    \"\"\"\n    g = earth.gravity()\n    r,gam,Cp,Cv = earth.gas_data()\n    tas = mach * earth.sound_speed(tamb)\n\n    cz = (2.*mass*g)/(gam*pamb*mach**2*self.aircraft.airframe.wing.area)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    thrust = (gam/2.)*pamb*mach**2*self.aircraft.airframe.wing.area*cx\n    dict = self.aircraft.power_system.sc(pamb,tamb,mach,\"MCR\",thrust)\n    dict[\"fn\"] = thrust\n    dict[\"cx\"] = cx\n    dict[\"cz\"] = cz\n    dict[\"lod\"] = lod\n    dict[\"sar\"] = self.aircraft.power_system.specific_air_range(mass,tas,dict)\n    return dict\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.AllMissionIsoMass.lift_from_speed","title":"lift_from_speed","text":"<pre><code>lift_from_speed(pamb, tamb, mach, mass)\n</code></pre> <p>Retrieve cz from mach using simplified lift equation</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def lift_from_speed(self,pamb,tamb,mach,mass):\n    \"\"\"Retrieve cz from mach using simplified lift equation\n    \"\"\"\n    g = earth.gravity()\n    r,gam,Cp,Cv = earth.gas_data()\n    cz = (2.*mass*g)/(gam*pamb*mach**2*self.aircraft.airframe.wing.area)\n    return cz\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.AllMissionIsoMass.mass_mission_adaptation","title":"mass_mission_adaptation","text":"<pre><code>mass_mission_adaptation()\n</code></pre> <p>Solves coupling between MTOW and OWE</p> Source code in <code>src/lh2pac/marilib/aircraft/mission.py</code> <pre><code>def mass_mission_adaptation(self):\n    \"\"\"Solves coupling between MTOW and OWE\n    \"\"\"\n    range = self.aircraft.requirement.design_range\n    altp = self.aircraft.requirement.cruise_altp\n    mach = self.aircraft.requirement.cruise_mach\n    disa = self.aircraft.requirement.cruise_disa\n\n    payload = self.aircraft.airframe.cabin.nominal_payload\n\n    def fct(mtow):\n        self.aircraft.weight_cg.mtow = mtow[0]\n        self.aircraft.weight_cg.mass_pre_design()\n        owe = self.aircraft.weight_cg.owe\n        self.nominal.eval(owe,altp,mach,disa, range=range, tow=mtow)\n        battery_mass = self.nominal.battery_mass\n        return mtow - (owe + payload + battery_mass)\n\n    mtow_ini = [self.aircraft.weight_cg.mtow]\n    output_dict = fsolve(fct, x0=mtow_ini, args=(), full_output=True)\n    if (output_dict[2]!=1): raise Exception(\"Convergence problem\")\n\n    self.aircraft.weight_cg.mtow = output_dict[0][0]\n    self.aircraft.weight_cg.mass_pre_design()\n    self.aircraft.performance.mission.payload_range()\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.AllMissionIsoMass.max_air_path","title":"max_air_path","text":"<pre><code>max_air_path(\n    nei,\n    altp,\n    disa,\n    speed_mode,\n    mass,\n    rating,\n    kfn,\n    full_output=False,\n)\n</code></pre> <p>Optimize the speed of the aircraft to maximize the air path</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def max_air_path(self,nei,altp,disa,speed_mode,mass,rating,kfn, full_output=False):\n    \"\"\"Optimize the speed of the aircraft to maximize the air path\n    \"\"\"\n    def fct(cz):\n        pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n        mach = self.speed_from_lift(pamb,tamb,cz,mass)\n        speed = self.get_speed(pamb,speed_mode,mach)\n        slope,vz = self.air_path(nei,altp,disa,speed_mode,speed,mass,rating,kfn)\n        if isformax: return slope\n        else: return slope,vz,mach\n\n    cz_ini = 0.5\n    dcz = 0.05\n\n    isformax = True\n    cz,slope,rc = maximize_1d(cz_ini,dcz,[fct])\n    isformax = False\n\n    slope,vz,mach = fct(cz)\n    return slope,vz,mach,cz\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.AllMissionIsoMass.propulsion_ceiling","title":"propulsion_ceiling","text":"<pre><code>propulsion_ceiling(\n    altp_ini,\n    nei,\n    vzreq,\n    disa,\n    speed_mode,\n    speed,\n    mass,\n    rating,\n    throttle,\n)\n</code></pre> <p>Optimize the speed of the aircraft to maximize the air path</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def propulsion_ceiling(self,altp_ini,nei,vzreq,disa,speed_mode,speed,mass,rating,throttle):\n    \"\"\"Optimize the speed of the aircraft to maximize the air path\n    \"\"\"\n    def fct_prop_ceiling(altp,nei,vzreq,disa,speed_mode,speed,mass,rating):\n        slope,vz = self.air_path(nei,altp,disa,speed_mode,speed,mass,rating,throttle)\n        delta_vz = vz - vzreq\n        return delta_vz\n\n    fct_arg = (nei,vzreq,disa,speed_mode,speed,mass,rating)\n\n    output_dict = fsolve(fct_prop_ceiling, x0 = altp_ini, args=fct_arg, full_output = True)\n\n    altp = output_dict[0][0]\n    rei = output_dict[2]\n    if(rei!=1): altp = np.NaN\n\n    return altp, rei\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.AllMissionIsoMass.speed_from_lift","title":"speed_from_lift","text":"<pre><code>speed_from_lift(pamb, tamb, cz, mass)\n</code></pre> <p>Retrieve mach from cz using simplified lift equation</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def speed_from_lift(self,pamb,tamb,cz,mass):\n    \"\"\"Retrieve mach from cz using simplified lift equation\n    \"\"\"\n    g = earth.gravity()\n    r,gam,Cp,Cv = earth.gas_data()\n    mach = np.sqrt((mass*g)/(0.5*gam*pamb*self.aircraft.airframe.wing.area*cz))\n    return mach\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.AllMissionVarMass","title":"AllMissionVarMass","text":"<pre><code>AllMissionVarMass(aircraft)\n</code></pre> <p>               Bases: <code>AllMissions</code></p> <p>Definition of all mission types for fuel powered airplanes</p> Source code in <code>src/lh2pac/marilib/aircraft/mission.py</code> <pre><code>def __init__(self, aircraft):\n    super(AllMissionVarMass, self).__init__(aircraft)\n\n    self.max_payload = MissionVarMassGeneric(aircraft)\n    self.nominal = MissionVarMassGeneric(aircraft)\n    self.max_fuel = MissionVarMassGeneric(aircraft)\n    self.zero_payload = MissionVarMassGeneric(aircraft)\n    self.cost = MissionVarMassGeneric(aircraft)\n    self.toy = MissionVarMassGeneric(aircraft)\n\n    self.ktow = aircraft.get_init(self,\"ktow\")\n\n    self.crz_tas = None\n    self.crz_sar = None\n    self.crz_cz = None\n    self.crz_wing_aoa = None\n    self.crz_fuselage_aoa = None\n    self.crz_lod = None\n    self.crz_thrust = None\n    self.crz_throttle = None\n    self.crz_propulsive_power = None\n    if self.aircraft.power_system.sfc_type==\"thrust\":\n        self.crz_tsfc = None\n    elif self.aircraft.power_system.sfc_type==\"power\":\n        self.crz_psfc = None\n\n    self.max_sar_altp = None\n    self.max_sar = None\n    self.max_sar_cz = None\n    self.max_sar_lod = None\n    self.max_sar_thrust = None\n    self.max_sar_throttle = None\n    if self.aircraft.power_system.sfc_type==\"thrust\":\n        self.max_sar_tsfc = None\n    elif self.aircraft.power_system.sfc_type==\"power\":\n        self.max_sar_psfc = None\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.AllMissionVarMass-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.AllMissionVarMass.acceleration","title":"acceleration","text":"<pre><code>acceleration(\n    nei,\n    altp,\n    disa,\n    speed_mode,\n    speed,\n    mass,\n    rating,\n    throttle,\n    full_output=False,\n)\n</code></pre> <p>Aircraft acceleration on level flight</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def acceleration(self,nei,altp,disa,speed_mode,speed,mass,rating,throttle, full_output=False):\n    \"\"\"Aircraft acceleration on level flight\n    \"\"\"\n    r,gam,Cp,Cv = earth.gas_data()\n\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    mach = self.get_mach(pamb,speed_mode,speed)\n\n    dict = self.aircraft.power_system.thrust(pamb,tamb,mach,rating,throttle=throttle,nei=nei)\n    fn = dict[\"fn\"]\n    ff = dict[\"ff\"]\n\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    if(nei&gt;0):\n        dcx = self.aircraft.power_system.oei_drag(pamb,mach)\n        cx = cx + dcx*nei\n\n    acc = (fn - 0.5*gam*pamb*mach**2*self.aircraft.airframe.wing.area*cx) / mass\n\n    if full_output:\n        return acc,fn,ff,cz,cx,pamb,tamb\n    else:\n        return acc\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.AllMissionVarMass.air_path","title":"air_path","text":"<pre><code>air_path(\n    nei,\n    altp,\n    disa,\n    speed_mode,\n    speed,\n    mass,\n    rating,\n    kfn,\n    full_output=False,\n)\n</code></pre> <p>Retrieve air path in various conditions</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def air_path(self,nei,altp,disa,speed_mode,speed,mass,rating,kfn, full_output=False):\n    \"\"\"Retrieve air path in various conditions\n    \"\"\"\n    g = earth.gravity()\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    mach = self.get_mach(pamb,speed_mode,speed)\n\n    dict = self.aircraft.power_system.thrust(pamb,tamb,mach,rating,nei=nei)\n    fn = dict[\"fn\"]*kfn\n    ff = dict[\"ff\"]*kfn\n    if kfn!=1. and full_output:\n        print(\"WARNING, air_path method, kfn is different from 1, fuel flow may not be accurate\")\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    if(nei&gt;0):\n        dcx = self.aircraft.power_system.oei_drag(pamb,mach)\n        cx = cx + dcx*nei\n        lod = cz/cx\n\n    acc_factor = earth.climb_mode(speed_mode, mach, dtodz, tstd, disa)\n    slope = ( fn/(mass*g) - 1./lod ) / acc_factor\n    vz = slope * mach * earth.sound_speed(tamb)\n    acc = (acc_factor-1.)*g*slope\n    if full_output:\n        return slope,vz,fn,ff,acc,cz,cx,pamb,tamb\n    else:\n        return slope,vz\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.AllMissionVarMass.arrival_ground_legs","title":"arrival_ground_legs","text":"<pre><code>arrival_ground_legs(ldw)\n</code></pre> <p>Compute fuel and time allowances for arrival ground phases</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def arrival_ground_legs(self,ldw):\n    \"\"\"Compute fuel and time allowances for arrival ground phases\n    \"\"\"\n    n_engine = self.aircraft.power_system.n_engine\n    reference_thrust = self.aircraft.power_system.get_reference_thrust()\n    fuel_type = self.aircraft.arrangement.fuel_type\n\n    time_landing = 180.\n    time_taxi_in = 420.\n\n    if fuel_type!=\"battery\":\n        engine_bpr = self.aircraft.airframe.nacelle.engine_bpr\n        fuel_mass_factor = earth.fuel_heat(\"kerosene\") / earth.fuel_heat(fuel_type)\n        fuel_landing = fuel_mass_factor*1e-4*(0.5+2.3/engine_bpr)*ldw\n        fuel_taxi_in = fuel_mass_factor*(26. + 1.8e-4*reference_thrust)*n_engine\n        return {\"fuel\":{\"landing\":fuel_landing,\"taxi_in\":fuel_taxi_in},\n                \"time\":{\"landing\":time_landing,\"taxi_in\":time_taxi_in}}\n    else:\n        enrg_landing = (0.25*43.1e6)*0.75e-4*ldw\n        enrg_taxi_in = (0.25*43.1e6)*(26. + 1.8e-4*reference_thrust)*n_engine\n        return {\"enrg\":{\"landing\":enrg_landing,\"taxi_in\":enrg_taxi_in},\n                \"time\":{\"landing\":time_landing,\"taxi_in\":time_taxi_in}}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.AllMissionVarMass.breguet_range","title":"breguet_range","text":"<pre><code>breguet_range(range, tow, ktow, altp, mach, disa)\n</code></pre> <p>Breguet range equation is dependant from power architecture</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def breguet_range(self,range,tow,ktow,altp,mach,disa):\n    \"\"\"Breguet range equation is dependant from power architecture\n    \"\"\"\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    tas = mach * earth.sound_speed(tamb)\n    time = 1.09*(range/tas)\n\n    dict = self.level_flight(pamb,tamb,mach,tow*ktow)\n    val = self.aircraft.power_system.specific_breguet_range(tow,range,tas,dict)\n    return val,time\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.AllMissionVarMass.departure_ground_legs","title":"departure_ground_legs","text":"<pre><code>departure_ground_legs(tow)\n</code></pre> <p>Compute fuel and time allowances for departure ground phases</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def departure_ground_legs(self,tow):\n    \"\"\"Compute fuel and time allowances for departure ground phases\n    \"\"\"\n    n_engine = self.aircraft.power_system.n_engine\n    reference_thrust = self.aircraft.power_system.get_reference_thrust()\n    fuel_type = self.aircraft.arrangement.fuel_type\n\n    time_taxi_out = 540.\n    time_take_off = 220.*tow/(reference_thrust*n_engine)\n\n    if fuel_type!=\"battery\":\n        engine_bpr = self.aircraft.airframe.nacelle.engine_bpr\n        fuel_mass_factor = earth.fuel_heat(\"kerosene\") / earth.fuel_heat(fuel_type)\n        fuel_taxi_out = fuel_mass_factor*(34. + 2.3e-4*reference_thrust)*n_engine\n        fuel_take_off = fuel_mass_factor*1e-4*(2.8+2.3/engine_bpr)*tow\n        return {\"fuel\":{\"taxi_out\":fuel_taxi_out,\"take_off\":fuel_take_off},\n                \"time\":{\"taxi_out\":time_taxi_out,\"take_off\":time_take_off}}\n    else:\n        enrg_taxi_out = (0.25*43.1e6)*(34. + 2.3e-4*reference_thrust)*n_engine\n        enrg_take_off = (0.25*43.1e6)*3.e-4*tow\n        return {\"enrg\":{\"taxi_out\":enrg_taxi_out,\"take_off\":enrg_take_off},\n                \"time\":{\"taxi_out\":time_taxi_out,\"take_off\":time_take_off}}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.AllMissionVarMass.descent","title":"descent","text":"<pre><code>descent(nei, altp, disa, speed_mode, speed, vz, mass)\n</code></pre> <p>Retrieve air path and flight characteristics in various conditions</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def descent(self,nei,altp,disa,speed_mode,speed,vz,mass):\n    \"\"\"Retrieve air path and flight characteristics in various conditions\n    \"\"\"\n    g = earth.gravity()\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    mach = self.get_mach(pamb,speed_mode,speed)\n\n    slope = vz / (mach * earth.sound_speed(tamb))\n    acc_factor = earth.climb_mode(speed_mode, mach, dtodz, tstd, disa)\n\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    fn = (slope * acc_factor + 1./lod) * (mass*g)\n    dict = self.aircraft.power_system.sc(self,pamb,tamb,mach,\"FID\", fn, nei)\n    ff = dict[\"sfc\"]*fn\n    thtl = dict[\"thtl\"]\n\n    return slope,thtl,fn,ff,cz,cx,pamb,tamb\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.AllMissionVarMass.eval_cruise_point","title":"eval_cruise_point","text":"<pre><code>eval_cruise_point()\n</code></pre> <p>Evaluate cruise point characteristics</p> Source code in <code>src/lh2pac/marilib/aircraft/mission.py</code> <pre><code>def eval_cruise_point(self):\n    \"\"\"Evaluate cruise point characteristics\n    \"\"\"\n    self.disa = self.aircraft.requirement.cruise_disa\n    self.altp = self.aircraft.requirement.cruise_altp\n    self.mach = self.aircraft.requirement.cruise_mach\n    self.mass = self.ktow*self.aircraft.weight_cg.mtow\n\n    crz_pamb,crz_tamb,tstd,dtodz = earth.atmosphere(self.altp, self.disa)\n\n    lf_dict = self.level_flight(crz_pamb,crz_tamb,self.mach,self.mass)\n\n    self.crz_tas = self.mach*earth.sound_speed(crz_tamb)\n    self.crz_sar = lf_dict[\"sar\"]\n    self.crz_cz = lf_dict[\"cz\"]\n    self.crz_lod = lf_dict[\"lod\"]\n    self.crz_thrust = lf_dict[\"fn\"]\n    self.crz_propulsive_power = lf_dict[\"fn\"]*self.crz_tas\n    self.crz_throttle = lf_dict[\"thtl\"]\n    if self.aircraft.power_system.sfc_type==\"thrust\":\n        self.crz_tsfc = lf_dict[\"sfc\"]\n    elif self.aircraft.power_system.sfc_type==\"power\":\n        self.crz_psfc = lf_dict[\"sfc\"]\n    if \"sec\" in lf_dict.keys():\n        self.crz_sec = lf_dict[\"sec\"]\n\n    crz_wing_aoa, crz_fuselage_aoa = self.aircraft.aerodynamics.aoa(self.mach,self.crz_cz)\n    self.crz_wing_aoa = crz_wing_aoa\n    self.crz_fuselage_aoa = crz_fuselage_aoa\n\n    sm_dict = self.eval_max_sar(self.mass,self.mach,self.disa)\n\n    pamb,tamb,tstd,dtodz = earth.atmosphere(sm_dict[\"altp\"], self.disa)\n\n    self.max_sar_altp = sm_dict[\"altp\"]\n    self.max_sar_tas = self.mach*earth.sound_speed(tamb)\n    self.max_sar = sm_dict[\"sar\"]\n    self.max_sar_cz = sm_dict[\"cz\"]\n    self.max_sar_lod = sm_dict[\"lod\"]\n    self.max_sar_thrust = sm_dict[\"fn\"]\n    self.max_sar_throttle = sm_dict[\"thtl\"]\n    if self.aircraft.power_system.sfc_type==\"thrust\":\n        self.max_sar_tsfc = sm_dict[\"sfc\"]\n    elif self.aircraft.power_system.sfc_type==\"power\":\n        self.max_sar_psfc = sm_dict[\"sfc\"]\n    if \"sec\" in lf_dict.keys():\n        self.crz_sec = lf_dict[\"sec\"]\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.AllMissionVarMass.eval_sar","title":"eval_sar","text":"<pre><code>eval_sar(altp, mass, mach, disa)\n</code></pre> <p>Evaluate Specific Air Range</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def eval_sar(self,altp,mass,mach,disa):\n    \"\"\"Evaluate Specific Air Range\n    \"\"\"\n    g = earth.gravity()\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    tas = mach * earth.sound_speed(tamb)\n\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    nei = 0\n    thrust = mass*g / lod\n    dict = self.aircraft.power_system.sc(pamb,tamb,mach,\"MCR\",thrust,nei)\n    dict[\"fn\"] = thrust\n    dict[\"cz\"] = cz\n    dict[\"cx\"] = cx\n    dict[\"lod\"] = lod\n    dict[\"sar\"] = self.aircraft.power_system.specific_air_range(mass,tas,dict)\n    return dict\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.AllMissionVarMass.get_mach","title":"get_mach","text":"<pre><code>get_mach(pamb, speed_mode, speed)\n</code></pre> <p>Retrieve Mach from CAS or mach depending on speed_mode</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def get_mach(self,pamb,speed_mode,speed):\n    \"\"\"Retrieve Mach from CAS or mach depending on speed_mode\n    \"\"\"\n    mach = {\"cas\" : earth.mach_from_vcas(pamb, speed),  # Input is CAS\n            \"mach\" : speed  # Input is mach\n            }.get(speed_mode, \"Erreur: select speed_mode equal to cas or mach\")\n    return mach\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.AllMissionVarMass.get_speed","title":"get_speed","text":"<pre><code>get_speed(pamb, speed_mode, mach)\n</code></pre> <p>retrieve CAS or Mach from mach depending on speed_mode</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def get_speed(self,pamb,speed_mode,mach):\n    \"\"\"retrieve CAS or Mach from mach depending on speed_mode\n    \"\"\"\n    speed = {\"cas\" : earth.vcas_from_mach(pamb, mach),  # CAS required\n             \"mach\" : mach  # mach required\n             }.get(speed_mode, \"Erreur: select speed_mode equal to cas or mach\")\n    return speed\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.AllMissionVarMass.get_vcas","title":"get_vcas","text":"<pre><code>get_vcas(pamb, speed_mode, speed)\n</code></pre> <p>Retrieve CAS from Mach or CAS depending on speed_mode</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def get_vcas(self,pamb,speed_mode,speed):\n    \"\"\"Retrieve CAS from Mach or CAS depending on speed_mode\n    \"\"\"\n    cas = {\"mach\" : earth.vcas_from_mach(pamb, speed),  # Input is CAS\n            \"cas\" : speed  # Input is mach\n            }.get(speed_mode, \"Erreur: select speed_mode equal to cas or mach\")\n    return cas\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.AllMissionVarMass.holding","title":"holding","text":"<pre><code>holding(time, mass, altp, mach, disa)\n</code></pre> <p>Holding equation is dependant from power architecture</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def holding(self,time,mass,altp,mach,disa):\n    \"\"\"Holding equation is dependant from power architecture\n    \"\"\"\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    tas = mach * earth.sound_speed(tamb)\n    dict = self.level_flight(pamb,tamb,mach,mass)\n    return self.aircraft.power_system.specific_holding(mass,time,tas,dict)\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.AllMissionVarMass.level_flight","title":"level_flight","text":"<pre><code>level_flight(pamb, tamb, mach, mass)\n</code></pre> <p>Level flight equilibrium</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def level_flight(self,pamb,tamb,mach,mass):\n    \"\"\"Level flight equilibrium\n    \"\"\"\n    g = earth.gravity()\n    r,gam,Cp,Cv = earth.gas_data()\n    tas = mach * earth.sound_speed(tamb)\n\n    cz = (2.*mass*g)/(gam*pamb*mach**2*self.aircraft.airframe.wing.area)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    thrust = (gam/2.)*pamb*mach**2*self.aircraft.airframe.wing.area*cx\n    dict = self.aircraft.power_system.sc(pamb,tamb,mach,\"MCR\",thrust)\n    dict[\"fn\"] = thrust\n    dict[\"cx\"] = cx\n    dict[\"cz\"] = cz\n    dict[\"lod\"] = lod\n    dict[\"sar\"] = self.aircraft.power_system.specific_air_range(mass,tas,dict)\n    return dict\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.AllMissionVarMass.lift_from_speed","title":"lift_from_speed","text":"<pre><code>lift_from_speed(pamb, tamb, mach, mass)\n</code></pre> <p>Retrieve cz from mach using simplified lift equation</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def lift_from_speed(self,pamb,tamb,mach,mass):\n    \"\"\"Retrieve cz from mach using simplified lift equation\n    \"\"\"\n    g = earth.gravity()\n    r,gam,Cp,Cv = earth.gas_data()\n    cz = (2.*mass*g)/(gam*pamb*mach**2*self.aircraft.airframe.wing.area)\n    return cz\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.AllMissionVarMass.mass_mission_adaptation","title":"mass_mission_adaptation","text":"<pre><code>mass_mission_adaptation()\n</code></pre> <p>Solves coupling between MTOW and OWE</p> Source code in <code>src/lh2pac/marilib/aircraft/mission.py</code> <pre><code>def mass_mission_adaptation(self):\n    \"\"\"Solves coupling between MTOW and OWE\n    \"\"\"\n    range = self.aircraft.requirement.design_range\n    altp = self.aircraft.requirement.cruise_altp\n    mach = self.aircraft.requirement.cruise_mach\n    disa = self.aircraft.requirement.cruise_disa\n\n    payload = self.aircraft.airframe.cabin.nominal_payload\n\n    def fct(mtow):\n        self.aircraft.weight_cg.mtow = mtow[0]\n\n        self.aircraft.weight_cg.mass_pre_design()\n\n        owe = self.aircraft.weight_cg.owe\n        self.nominal.eval(owe,altp,mach,disa, range=range, tow=self.aircraft.weight_cg.mtow)\n        fuel_total = self.nominal.fuel_total\n\n        return self.aircraft.weight_cg.mtow - (owe + payload + fuel_total)\n\n    mtow_ini = [self.aircraft.weight_cg.mtow]\n    output_dict = fsolve(fct, x0=mtow_ini, args=(), full_output=True)\n    if (output_dict[2]!=1): raise Exception(\"Convergence problem\")\n\n    self.aircraft.weight_cg.mtow = output_dict[0][0]\n    self.aircraft.weight_cg.mass_pre_design()\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.AllMissionVarMass.max_air_path","title":"max_air_path","text":"<pre><code>max_air_path(\n    nei,\n    altp,\n    disa,\n    speed_mode,\n    mass,\n    rating,\n    kfn,\n    full_output=False,\n)\n</code></pre> <p>Optimize the speed of the aircraft to maximize the air path</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def max_air_path(self,nei,altp,disa,speed_mode,mass,rating,kfn, full_output=False):\n    \"\"\"Optimize the speed of the aircraft to maximize the air path\n    \"\"\"\n    def fct(cz):\n        pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n        mach = self.speed_from_lift(pamb,tamb,cz,mass)\n        speed = self.get_speed(pamb,speed_mode,mach)\n        slope,vz = self.air_path(nei,altp,disa,speed_mode,speed,mass,rating,kfn)\n        if isformax: return slope\n        else: return slope,vz,mach\n\n    cz_ini = 0.5\n    dcz = 0.05\n\n    isformax = True\n    cz,slope,rc = maximize_1d(cz_ini,dcz,[fct])\n    isformax = False\n\n    slope,vz,mach = fct(cz)\n    return slope,vz,mach,cz\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.AllMissionVarMass.propulsion_ceiling","title":"propulsion_ceiling","text":"<pre><code>propulsion_ceiling(\n    altp_ini,\n    nei,\n    vzreq,\n    disa,\n    speed_mode,\n    speed,\n    mass,\n    rating,\n    throttle,\n)\n</code></pre> <p>Optimize the speed of the aircraft to maximize the air path</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def propulsion_ceiling(self,altp_ini,nei,vzreq,disa,speed_mode,speed,mass,rating,throttle):\n    \"\"\"Optimize the speed of the aircraft to maximize the air path\n    \"\"\"\n    def fct_prop_ceiling(altp,nei,vzreq,disa,speed_mode,speed,mass,rating):\n        slope,vz = self.air_path(nei,altp,disa,speed_mode,speed,mass,rating,throttle)\n        delta_vz = vz - vzreq\n        return delta_vz\n\n    fct_arg = (nei,vzreq,disa,speed_mode,speed,mass,rating)\n\n    output_dict = fsolve(fct_prop_ceiling, x0 = altp_ini, args=fct_arg, full_output = True)\n\n    altp = output_dict[0][0]\n    rei = output_dict[2]\n    if(rei!=1): altp = np.NaN\n\n    return altp, rei\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.AllMissionVarMass.speed_from_lift","title":"speed_from_lift","text":"<pre><code>speed_from_lift(pamb, tamb, cz, mass)\n</code></pre> <p>Retrieve mach from cz using simplified lift equation</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def speed_from_lift(self,pamb,tamb,cz,mass):\n    \"\"\"Retrieve mach from cz using simplified lift equation\n    \"\"\"\n    g = earth.gravity()\n    r,gam,Cp,Cv = earth.gas_data()\n    mach = np.sqrt((mass*g)/(0.5*gam*pamb*self.aircraft.airframe.wing.area*cz))\n    return mach\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.AllMissions","title":"AllMissions","text":"<pre><code>AllMissions(aircraft)\n</code></pre> <p>               Bases: <code>Flight</code></p> <p>Definition of all mission types for fuel powered airplanes</p> Source code in <code>src/lh2pac/marilib/aircraft/mission.py</code> <pre><code>def __init__(self, aircraft):\n    super(AllMissions, self).__init__(aircraft)\n\n    self.max_payload = None\n    self.nominal = None\n    self.max_fuel = None\n    self.zero_payload = None\n    self.cost = None\n    self.toy = None\n\n    self.disa = None\n    self.altp = None\n    self.mach = None\n    self.mass = None\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.AllMissions-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.AllMissions.acceleration","title":"acceleration","text":"<pre><code>acceleration(\n    nei,\n    altp,\n    disa,\n    speed_mode,\n    speed,\n    mass,\n    rating,\n    throttle,\n    full_output=False,\n)\n</code></pre> <p>Aircraft acceleration on level flight</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def acceleration(self,nei,altp,disa,speed_mode,speed,mass,rating,throttle, full_output=False):\n    \"\"\"Aircraft acceleration on level flight\n    \"\"\"\n    r,gam,Cp,Cv = earth.gas_data()\n\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    mach = self.get_mach(pamb,speed_mode,speed)\n\n    dict = self.aircraft.power_system.thrust(pamb,tamb,mach,rating,throttle=throttle,nei=nei)\n    fn = dict[\"fn\"]\n    ff = dict[\"ff\"]\n\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    if(nei&gt;0):\n        dcx = self.aircraft.power_system.oei_drag(pamb,mach)\n        cx = cx + dcx*nei\n\n    acc = (fn - 0.5*gam*pamb*mach**2*self.aircraft.airframe.wing.area*cx) / mass\n\n    if full_output:\n        return acc,fn,ff,cz,cx,pamb,tamb\n    else:\n        return acc\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.AllMissions.air_path","title":"air_path","text":"<pre><code>air_path(\n    nei,\n    altp,\n    disa,\n    speed_mode,\n    speed,\n    mass,\n    rating,\n    kfn,\n    full_output=False,\n)\n</code></pre> <p>Retrieve air path in various conditions</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def air_path(self,nei,altp,disa,speed_mode,speed,mass,rating,kfn, full_output=False):\n    \"\"\"Retrieve air path in various conditions\n    \"\"\"\n    g = earth.gravity()\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    mach = self.get_mach(pamb,speed_mode,speed)\n\n    dict = self.aircraft.power_system.thrust(pamb,tamb,mach,rating,nei=nei)\n    fn = dict[\"fn\"]*kfn\n    ff = dict[\"ff\"]*kfn\n    if kfn!=1. and full_output:\n        print(\"WARNING, air_path method, kfn is different from 1, fuel flow may not be accurate\")\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    if(nei&gt;0):\n        dcx = self.aircraft.power_system.oei_drag(pamb,mach)\n        cx = cx + dcx*nei\n        lod = cz/cx\n\n    acc_factor = earth.climb_mode(speed_mode, mach, dtodz, tstd, disa)\n    slope = ( fn/(mass*g) - 1./lod ) / acc_factor\n    vz = slope * mach * earth.sound_speed(tamb)\n    acc = (acc_factor-1.)*g*slope\n    if full_output:\n        return slope,vz,fn,ff,acc,cz,cx,pamb,tamb\n    else:\n        return slope,vz\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.AllMissions.arrival_ground_legs","title":"arrival_ground_legs","text":"<pre><code>arrival_ground_legs(ldw)\n</code></pre> <p>Compute fuel and time allowances for arrival ground phases</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def arrival_ground_legs(self,ldw):\n    \"\"\"Compute fuel and time allowances for arrival ground phases\n    \"\"\"\n    n_engine = self.aircraft.power_system.n_engine\n    reference_thrust = self.aircraft.power_system.get_reference_thrust()\n    fuel_type = self.aircraft.arrangement.fuel_type\n\n    time_landing = 180.\n    time_taxi_in = 420.\n\n    if fuel_type!=\"battery\":\n        engine_bpr = self.aircraft.airframe.nacelle.engine_bpr\n        fuel_mass_factor = earth.fuel_heat(\"kerosene\") / earth.fuel_heat(fuel_type)\n        fuel_landing = fuel_mass_factor*1e-4*(0.5+2.3/engine_bpr)*ldw\n        fuel_taxi_in = fuel_mass_factor*(26. + 1.8e-4*reference_thrust)*n_engine\n        return {\"fuel\":{\"landing\":fuel_landing,\"taxi_in\":fuel_taxi_in},\n                \"time\":{\"landing\":time_landing,\"taxi_in\":time_taxi_in}}\n    else:\n        enrg_landing = (0.25*43.1e6)*0.75e-4*ldw\n        enrg_taxi_in = (0.25*43.1e6)*(26. + 1.8e-4*reference_thrust)*n_engine\n        return {\"enrg\":{\"landing\":enrg_landing,\"taxi_in\":enrg_taxi_in},\n                \"time\":{\"landing\":time_landing,\"taxi_in\":time_taxi_in}}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.AllMissions.breguet_range","title":"breguet_range","text":"<pre><code>breguet_range(range, tow, ktow, altp, mach, disa)\n</code></pre> <p>Breguet range equation is dependant from power architecture</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def breguet_range(self,range,tow,ktow,altp,mach,disa):\n    \"\"\"Breguet range equation is dependant from power architecture\n    \"\"\"\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    tas = mach * earth.sound_speed(tamb)\n    time = 1.09*(range/tas)\n\n    dict = self.level_flight(pamb,tamb,mach,tow*ktow)\n    val = self.aircraft.power_system.specific_breguet_range(tow,range,tas,dict)\n    return val,time\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.AllMissions.departure_ground_legs","title":"departure_ground_legs","text":"<pre><code>departure_ground_legs(tow)\n</code></pre> <p>Compute fuel and time allowances for departure ground phases</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def departure_ground_legs(self,tow):\n    \"\"\"Compute fuel and time allowances for departure ground phases\n    \"\"\"\n    n_engine = self.aircraft.power_system.n_engine\n    reference_thrust = self.aircraft.power_system.get_reference_thrust()\n    fuel_type = self.aircraft.arrangement.fuel_type\n\n    time_taxi_out = 540.\n    time_take_off = 220.*tow/(reference_thrust*n_engine)\n\n    if fuel_type!=\"battery\":\n        engine_bpr = self.aircraft.airframe.nacelle.engine_bpr\n        fuel_mass_factor = earth.fuel_heat(\"kerosene\") / earth.fuel_heat(fuel_type)\n        fuel_taxi_out = fuel_mass_factor*(34. + 2.3e-4*reference_thrust)*n_engine\n        fuel_take_off = fuel_mass_factor*1e-4*(2.8+2.3/engine_bpr)*tow\n        return {\"fuel\":{\"taxi_out\":fuel_taxi_out,\"take_off\":fuel_take_off},\n                \"time\":{\"taxi_out\":time_taxi_out,\"take_off\":time_take_off}}\n    else:\n        enrg_taxi_out = (0.25*43.1e6)*(34. + 2.3e-4*reference_thrust)*n_engine\n        enrg_take_off = (0.25*43.1e6)*3.e-4*tow\n        return {\"enrg\":{\"taxi_out\":enrg_taxi_out,\"take_off\":enrg_take_off},\n                \"time\":{\"taxi_out\":time_taxi_out,\"take_off\":time_take_off}}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.AllMissions.descent","title":"descent","text":"<pre><code>descent(nei, altp, disa, speed_mode, speed, vz, mass)\n</code></pre> <p>Retrieve air path and flight characteristics in various conditions</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def descent(self,nei,altp,disa,speed_mode,speed,vz,mass):\n    \"\"\"Retrieve air path and flight characteristics in various conditions\n    \"\"\"\n    g = earth.gravity()\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    mach = self.get_mach(pamb,speed_mode,speed)\n\n    slope = vz / (mach * earth.sound_speed(tamb))\n    acc_factor = earth.climb_mode(speed_mode, mach, dtodz, tstd, disa)\n\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    fn = (slope * acc_factor + 1./lod) * (mass*g)\n    dict = self.aircraft.power_system.sc(self,pamb,tamb,mach,\"FID\", fn, nei)\n    ff = dict[\"sfc\"]*fn\n    thtl = dict[\"thtl\"]\n\n    return slope,thtl,fn,ff,cz,cx,pamb,tamb\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.AllMissions.eval_sar","title":"eval_sar","text":"<pre><code>eval_sar(altp, mass, mach, disa)\n</code></pre> <p>Evaluate Specific Air Range</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def eval_sar(self,altp,mass,mach,disa):\n    \"\"\"Evaluate Specific Air Range\n    \"\"\"\n    g = earth.gravity()\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    tas = mach * earth.sound_speed(tamb)\n\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    nei = 0\n    thrust = mass*g / lod\n    dict = self.aircraft.power_system.sc(pamb,tamb,mach,\"MCR\",thrust,nei)\n    dict[\"fn\"] = thrust\n    dict[\"cz\"] = cz\n    dict[\"cx\"] = cx\n    dict[\"lod\"] = lod\n    dict[\"sar\"] = self.aircraft.power_system.specific_air_range(mass,tas,dict)\n    return dict\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.AllMissions.get_mach","title":"get_mach","text":"<pre><code>get_mach(pamb, speed_mode, speed)\n</code></pre> <p>Retrieve Mach from CAS or mach depending on speed_mode</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def get_mach(self,pamb,speed_mode,speed):\n    \"\"\"Retrieve Mach from CAS or mach depending on speed_mode\n    \"\"\"\n    mach = {\"cas\" : earth.mach_from_vcas(pamb, speed),  # Input is CAS\n            \"mach\" : speed  # Input is mach\n            }.get(speed_mode, \"Erreur: select speed_mode equal to cas or mach\")\n    return mach\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.AllMissions.get_speed","title":"get_speed","text":"<pre><code>get_speed(pamb, speed_mode, mach)\n</code></pre> <p>retrieve CAS or Mach from mach depending on speed_mode</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def get_speed(self,pamb,speed_mode,mach):\n    \"\"\"retrieve CAS or Mach from mach depending on speed_mode\n    \"\"\"\n    speed = {\"cas\" : earth.vcas_from_mach(pamb, mach),  # CAS required\n             \"mach\" : mach  # mach required\n             }.get(speed_mode, \"Erreur: select speed_mode equal to cas or mach\")\n    return speed\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.AllMissions.get_vcas","title":"get_vcas","text":"<pre><code>get_vcas(pamb, speed_mode, speed)\n</code></pre> <p>Retrieve CAS from Mach or CAS depending on speed_mode</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def get_vcas(self,pamb,speed_mode,speed):\n    \"\"\"Retrieve CAS from Mach or CAS depending on speed_mode\n    \"\"\"\n    cas = {\"mach\" : earth.vcas_from_mach(pamb, speed),  # Input is CAS\n            \"cas\" : speed  # Input is mach\n            }.get(speed_mode, \"Erreur: select speed_mode equal to cas or mach\")\n    return cas\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.AllMissions.holding","title":"holding","text":"<pre><code>holding(time, mass, altp, mach, disa)\n</code></pre> <p>Holding equation is dependant from power architecture</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def holding(self,time,mass,altp,mach,disa):\n    \"\"\"Holding equation is dependant from power architecture\n    \"\"\"\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    tas = mach * earth.sound_speed(tamb)\n    dict = self.level_flight(pamb,tamb,mach,mass)\n    return self.aircraft.power_system.specific_holding(mass,time,tas,dict)\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.AllMissions.level_flight","title":"level_flight","text":"<pre><code>level_flight(pamb, tamb, mach, mass)\n</code></pre> <p>Level flight equilibrium</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def level_flight(self,pamb,tamb,mach,mass):\n    \"\"\"Level flight equilibrium\n    \"\"\"\n    g = earth.gravity()\n    r,gam,Cp,Cv = earth.gas_data()\n    tas = mach * earth.sound_speed(tamb)\n\n    cz = (2.*mass*g)/(gam*pamb*mach**2*self.aircraft.airframe.wing.area)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    thrust = (gam/2.)*pamb*mach**2*self.aircraft.airframe.wing.area*cx\n    dict = self.aircraft.power_system.sc(pamb,tamb,mach,\"MCR\",thrust)\n    dict[\"fn\"] = thrust\n    dict[\"cx\"] = cx\n    dict[\"cz\"] = cz\n    dict[\"lod\"] = lod\n    dict[\"sar\"] = self.aircraft.power_system.specific_air_range(mass,tas,dict)\n    return dict\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.AllMissions.lift_from_speed","title":"lift_from_speed","text":"<pre><code>lift_from_speed(pamb, tamb, mach, mass)\n</code></pre> <p>Retrieve cz from mach using simplified lift equation</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def lift_from_speed(self,pamb,tamb,mach,mass):\n    \"\"\"Retrieve cz from mach using simplified lift equation\n    \"\"\"\n    g = earth.gravity()\n    r,gam,Cp,Cv = earth.gas_data()\n    cz = (2.*mass*g)/(gam*pamb*mach**2*self.aircraft.airframe.wing.area)\n    return cz\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.AllMissions.max_air_path","title":"max_air_path","text":"<pre><code>max_air_path(\n    nei,\n    altp,\n    disa,\n    speed_mode,\n    mass,\n    rating,\n    kfn,\n    full_output=False,\n)\n</code></pre> <p>Optimize the speed of the aircraft to maximize the air path</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def max_air_path(self,nei,altp,disa,speed_mode,mass,rating,kfn, full_output=False):\n    \"\"\"Optimize the speed of the aircraft to maximize the air path\n    \"\"\"\n    def fct(cz):\n        pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n        mach = self.speed_from_lift(pamb,tamb,cz,mass)\n        speed = self.get_speed(pamb,speed_mode,mach)\n        slope,vz = self.air_path(nei,altp,disa,speed_mode,speed,mass,rating,kfn)\n        if isformax: return slope\n        else: return slope,vz,mach\n\n    cz_ini = 0.5\n    dcz = 0.05\n\n    isformax = True\n    cz,slope,rc = maximize_1d(cz_ini,dcz,[fct])\n    isformax = False\n\n    slope,vz,mach = fct(cz)\n    return slope,vz,mach,cz\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.AllMissions.propulsion_ceiling","title":"propulsion_ceiling","text":"<pre><code>propulsion_ceiling(\n    altp_ini,\n    nei,\n    vzreq,\n    disa,\n    speed_mode,\n    speed,\n    mass,\n    rating,\n    throttle,\n)\n</code></pre> <p>Optimize the speed of the aircraft to maximize the air path</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def propulsion_ceiling(self,altp_ini,nei,vzreq,disa,speed_mode,speed,mass,rating,throttle):\n    \"\"\"Optimize the speed of the aircraft to maximize the air path\n    \"\"\"\n    def fct_prop_ceiling(altp,nei,vzreq,disa,speed_mode,speed,mass,rating):\n        slope,vz = self.air_path(nei,altp,disa,speed_mode,speed,mass,rating,throttle)\n        delta_vz = vz - vzreq\n        return delta_vz\n\n    fct_arg = (nei,vzreq,disa,speed_mode,speed,mass,rating)\n\n    output_dict = fsolve(fct_prop_ceiling, x0 = altp_ini, args=fct_arg, full_output = True)\n\n    altp = output_dict[0][0]\n    rei = output_dict[2]\n    if(rei!=1): altp = np.NaN\n\n    return altp, rei\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.AllMissions.speed_from_lift","title":"speed_from_lift","text":"<pre><code>speed_from_lift(pamb, tamb, cz, mass)\n</code></pre> <p>Retrieve mach from cz using simplified lift equation</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def speed_from_lift(self,pamb,tamb,cz,mass):\n    \"\"\"Retrieve mach from cz using simplified lift equation\n    \"\"\"\n    g = earth.gravity()\n    r,gam,Cp,Cv = earth.gas_data()\n    mach = np.sqrt((mass*g)/(0.5*gam*pamb*self.aircraft.airframe.wing.area*cz))\n    return mach\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.MissionDef","title":"MissionDef","text":"<pre><code>MissionDef(aircraft)\n</code></pre> <p>               Bases: <code>Flight</code></p> <p>Defines a mission evaluation for a fuel based propulsion system (kerozen, H2 ...etc)</p> <p>.. warning::     This class is not used. By default MARILib uses :class:<code>MissionGeneric</code>.</p> Source code in <code>src/lh2pac/marilib/aircraft/mission.py</code> <pre><code>def __init__(self,aircraft):\n    # Inputs\n\n    self.disa = None  # Mean cruise temperature shift\n    self.altp = None  # Mean cruise altitude\n    self.mach = None  # Cruise mach number\n    self.range = None  # Mission distance\n    self.owe = None # default Operating Weight Empty\n    # Outputs\n    self.tow = None  # Take Off Weight\n    self.payload = None  # Mission payload\n    self.time_block = None  # Mission block duration\n    self.fuel_block = None  # Mission block fuel consumption\n    self.fuel_reserve = None  # Mission reserve fuel\n    self.fuel_total = None  # Mission total fuel\n\n    self.holding_time = unit.s_min(30)  # Holding duration\n    self.reserve_fuel_ratio = self.__reserve_fuel_ratio()  # Ratio of mission fuel to account into reserve\n    self.diversion_range = self.diversion_range()  # Diversion leg\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.MissionDef-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.MissionDef.acceleration","title":"acceleration","text":"<pre><code>acceleration(\n    nei,\n    altp,\n    disa,\n    speed_mode,\n    speed,\n    mass,\n    rating,\n    throttle,\n    full_output=False,\n)\n</code></pre> <p>Aircraft acceleration on level flight</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def acceleration(self,nei,altp,disa,speed_mode,speed,mass,rating,throttle, full_output=False):\n    \"\"\"Aircraft acceleration on level flight\n    \"\"\"\n    r,gam,Cp,Cv = earth.gas_data()\n\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    mach = self.get_mach(pamb,speed_mode,speed)\n\n    dict = self.aircraft.power_system.thrust(pamb,tamb,mach,rating,throttle=throttle,nei=nei)\n    fn = dict[\"fn\"]\n    ff = dict[\"ff\"]\n\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    if(nei&gt;0):\n        dcx = self.aircraft.power_system.oei_drag(pamb,mach)\n        cx = cx + dcx*nei\n\n    acc = (fn - 0.5*gam*pamb*mach**2*self.aircraft.airframe.wing.area*cx) / mass\n\n    if full_output:\n        return acc,fn,ff,cz,cx,pamb,tamb\n    else:\n        return acc\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.MissionDef.air_path","title":"air_path","text":"<pre><code>air_path(\n    nei,\n    altp,\n    disa,\n    speed_mode,\n    speed,\n    mass,\n    rating,\n    kfn,\n    full_output=False,\n)\n</code></pre> <p>Retrieve air path in various conditions</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def air_path(self,nei,altp,disa,speed_mode,speed,mass,rating,kfn, full_output=False):\n    \"\"\"Retrieve air path in various conditions\n    \"\"\"\n    g = earth.gravity()\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    mach = self.get_mach(pamb,speed_mode,speed)\n\n    dict = self.aircraft.power_system.thrust(pamb,tamb,mach,rating,nei=nei)\n    fn = dict[\"fn\"]*kfn\n    ff = dict[\"ff\"]*kfn\n    if kfn!=1. and full_output:\n        print(\"WARNING, air_path method, kfn is different from 1, fuel flow may not be accurate\")\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    if(nei&gt;0):\n        dcx = self.aircraft.power_system.oei_drag(pamb,mach)\n        cx = cx + dcx*nei\n        lod = cz/cx\n\n    acc_factor = earth.climb_mode(speed_mode, mach, dtodz, tstd, disa)\n    slope = ( fn/(mass*g) - 1./lod ) / acc_factor\n    vz = slope * mach * earth.sound_speed(tamb)\n    acc = (acc_factor-1.)*g*slope\n    if full_output:\n        return slope,vz,fn,ff,acc,cz,cx,pamb,tamb\n    else:\n        return slope,vz\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.MissionDef.arrival_ground_legs","title":"arrival_ground_legs","text":"<pre><code>arrival_ground_legs(ldw)\n</code></pre> <p>Compute fuel and time allowances for arrival ground phases</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def arrival_ground_legs(self,ldw):\n    \"\"\"Compute fuel and time allowances for arrival ground phases\n    \"\"\"\n    n_engine = self.aircraft.power_system.n_engine\n    reference_thrust = self.aircraft.power_system.get_reference_thrust()\n    fuel_type = self.aircraft.arrangement.fuel_type\n\n    time_landing = 180.\n    time_taxi_in = 420.\n\n    if fuel_type!=\"battery\":\n        engine_bpr = self.aircraft.airframe.nacelle.engine_bpr\n        fuel_mass_factor = earth.fuel_heat(\"kerosene\") / earth.fuel_heat(fuel_type)\n        fuel_landing = fuel_mass_factor*1e-4*(0.5+2.3/engine_bpr)*ldw\n        fuel_taxi_in = fuel_mass_factor*(26. + 1.8e-4*reference_thrust)*n_engine\n        return {\"fuel\":{\"landing\":fuel_landing,\"taxi_in\":fuel_taxi_in},\n                \"time\":{\"landing\":time_landing,\"taxi_in\":time_taxi_in}}\n    else:\n        enrg_landing = (0.25*43.1e6)*0.75e-4*ldw\n        enrg_taxi_in = (0.25*43.1e6)*(26. + 1.8e-4*reference_thrust)*n_engine\n        return {\"enrg\":{\"landing\":enrg_landing,\"taxi_in\":enrg_taxi_in},\n                \"time\":{\"landing\":time_landing,\"taxi_in\":time_taxi_in}}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.MissionDef.breguet_range","title":"breguet_range","text":"<pre><code>breguet_range(range, tow, ktow, altp, mach, disa)\n</code></pre> <p>Breguet range equation is dependant from power architecture</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def breguet_range(self,range,tow,ktow,altp,mach,disa):\n    \"\"\"Breguet range equation is dependant from power architecture\n    \"\"\"\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    tas = mach * earth.sound_speed(tamb)\n    time = 1.09*(range/tas)\n\n    dict = self.level_flight(pamb,tamb,mach,tow*ktow)\n    val = self.aircraft.power_system.specific_breguet_range(tow,range,tas,dict)\n    return val,time\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.MissionDef.departure_ground_legs","title":"departure_ground_legs","text":"<pre><code>departure_ground_legs(tow)\n</code></pre> <p>Compute fuel and time allowances for departure ground phases</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def departure_ground_legs(self,tow):\n    \"\"\"Compute fuel and time allowances for departure ground phases\n    \"\"\"\n    n_engine = self.aircraft.power_system.n_engine\n    reference_thrust = self.aircraft.power_system.get_reference_thrust()\n    fuel_type = self.aircraft.arrangement.fuel_type\n\n    time_taxi_out = 540.\n    time_take_off = 220.*tow/(reference_thrust*n_engine)\n\n    if fuel_type!=\"battery\":\n        engine_bpr = self.aircraft.airframe.nacelle.engine_bpr\n        fuel_mass_factor = earth.fuel_heat(\"kerosene\") / earth.fuel_heat(fuel_type)\n        fuel_taxi_out = fuel_mass_factor*(34. + 2.3e-4*reference_thrust)*n_engine\n        fuel_take_off = fuel_mass_factor*1e-4*(2.8+2.3/engine_bpr)*tow\n        return {\"fuel\":{\"taxi_out\":fuel_taxi_out,\"take_off\":fuel_take_off},\n                \"time\":{\"taxi_out\":time_taxi_out,\"take_off\":time_take_off}}\n    else:\n        enrg_taxi_out = (0.25*43.1e6)*(34. + 2.3e-4*reference_thrust)*n_engine\n        enrg_take_off = (0.25*43.1e6)*3.e-4*tow\n        return {\"enrg\":{\"taxi_out\":enrg_taxi_out,\"take_off\":enrg_take_off},\n                \"time\":{\"taxi_out\":time_taxi_out,\"take_off\":time_take_off}}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.MissionDef.descent","title":"descent","text":"<pre><code>descent(nei, altp, disa, speed_mode, speed, vz, mass)\n</code></pre> <p>Retrieve air path and flight characteristics in various conditions</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def descent(self,nei,altp,disa,speed_mode,speed,vz,mass):\n    \"\"\"Retrieve air path and flight characteristics in various conditions\n    \"\"\"\n    g = earth.gravity()\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    mach = self.get_mach(pamb,speed_mode,speed)\n\n    slope = vz / (mach * earth.sound_speed(tamb))\n    acc_factor = earth.climb_mode(speed_mode, mach, dtodz, tstd, disa)\n\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    fn = (slope * acc_factor + 1./lod) * (mass*g)\n    dict = self.aircraft.power_system.sc(self,pamb,tamb,mach,\"FID\", fn, nei)\n    ff = dict[\"sfc\"]*fn\n    thtl = dict[\"thtl\"]\n\n    return slope,thtl,fn,ff,cz,cx,pamb,tamb\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.MissionDef.eval","title":"eval","text":"<pre><code>eval(inputs={'range': None, 'tow': None}, **kwargs)\n</code></pre> <p>Solve mission equations for given inputs. During a mission at given cruise mach, altitude, temperature shift (disa) and Operating Weight Empty (owe) the four following parameters are linked together:</p> <ul> <li>tow : Take-Off Weight</li> <li>payload : weight of Payload</li> <li>range : mission range</li> <li>fuel_total : weight of fuel taking into account safety margins</li> </ul> <p>by two equations :</p> <p>1) fuel_total = <code>eval_Breguet(range,tow, altp, mach, disa)</code> 2) tow - payload - fuel_total - owe = 0</p> <p>By fixing two of the previous variables, we deduce the two remaining unknowns.</p> <p>:param inputs: a dictionary of two fixed parameters. Default is <code>{'range','tow'}</code> :param kwargs: optional named parameters for meth:<code>set_parameters</code> :return: a dictionary of the two remaining unknown parameter. By default <code>{'range', 'fuel_total'}</code>.</p> <p>Throws error if <code>fsolve</code> does not converge.</p> Source code in <code>src/lh2pac/marilib/aircraft/mission.py</code> <pre><code>def eval(self, inputs={'range':None,'tow':None}, **kwargs):\n    \"\"\"Solve mission equations for given inputs.\n    During a mission at given cruise mach, altitude, temperature shift (disa) and Operating Weight Empty (owe)\n    the four following parameters are linked together:\n\n    - tow : Take-Off Weight\n    - payload : weight of Payload\n    - range : mission range\n    - fuel_total : weight of fuel taking into account safety margins\n\n    by two equations :\n\n    1) fuel_total = `eval_Breguet(range,tow, altp, mach, disa)`\n    2) tow - payload - fuel_total - owe = 0\n\n    By fixing two of the previous variables, we deduce the two remaining unknowns.\n\n    :param inputs: a dictionary of two fixed parameters. Default is `{'range','tow'}`\n    :param kwargs: optional named parameters for :py:meth:`set_parameters`\n    :return: a dictionary of the two remaining unknown parameter. By default `{'range', 'fuel_total'}`.\n\n    Throws error if `fsolve` does not converge.\n    \"\"\"\n\n    if len(kwargs)&gt;0:\n        self.set_parameters(**kwargs)\n\n    # Build the unknown dict\n    all_variables = ['range','tow','payload','fuel_total']\n    unknowns = []\n    for name in sorted(all_variables):\n        if name not in inputs.keys():\n            unknowns.append(name) # add a new unknown\n        else:\n            self.__dict__[name] = inputs[name] # set the input value in the mission attribute\n\n    x0 = self.__init_unknowns(unknowns)\n    x = fsolve(self.__mission_equations_to_solve, x0, args=({'inputs': inputs.keys(), 'unknowns': unknowns}))\n\n    output = {}\n    for k,solution in enumerate(x): # store the solutions\n        self.__dict__[unknowns[k]] = solution # set the value in the mission attribute\n        output[unknowns[k]] = solution\n\n    return output\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.MissionDef.eval_breguet","title":"eval_breguet","text":"<pre><code>eval_breguet(range, tow, altp, mach, disa)\n</code></pre> <p>Mission computation using breguet equation, fixed L/D and fixed sfc</p> Source code in <code>src/lh2pac/marilib/aircraft/mission.py</code> <pre><code>def eval_breguet(self, range, tow, altp, mach, disa):\n    \"\"\"\n    Mission computation using breguet equation, fixed L/D and fixed sfc\n    \"\"\"\n    g = earth.gravity()\n\n    n_engine = self.aircraft.airframe.nacelle.n_engine\n    reference_thrust = self.aircraft.airframe.nacelle.reference_thrust\n    engine_bpr = self.aircraft.airframe.nacelle.engine_bpr\n    ktow = self.aircraft.performance.mission.ktow\n\n    # Departure ground phases\n    # -----------------------------------------------------------------------------------------------------------\n    fuel_taxi_out = (34. + 2.3e-4 * reference_thrust) * n_engine\n    time_taxi_out = 540.\n\n    fuel_take_off = 1e-4 * (2.8 + 2.3 / engine_bpr) * tow\n    time_take_off = 220. * tow / (reference_thrust * n_engine)\n\n    # Mission leg\n    # -----------------------------------------------------------------------------------------------------------\n    fuel_mission,time_mission = self.breguet_range(range,tow,ktow,altp,mach,disa)\n\n    mass = tow - (fuel_taxi_out + fuel_take_off + fuel_mission)  # mass is not landing weight\n\n    # Arrival ground phases\n    # -----------------------------------------------------------------------------------------------------------\n    fuel_landing = 1e-4 * (0.5 + 2.3 / engine_bpr) * mass\n    time_landing = 180.\n\n    fuel_taxi_in = (26. + 1.8e-4 * reference_thrust) * n_engine\n    time_taxi_in = 420.\n\n    # Block fuel and time\n    # -----------------------------------------------------------------------------------------------------------\n    self.fuel_block = fuel_taxi_out + fuel_take_off + fuel_mission + fuel_landing + fuel_taxi_in\n    self.time_block = time_taxi_out + time_take_off + time_mission + time_landing + time_taxi_in\n\n    # Diversion fuel\n    # -----------------------------------------------------------------------------------------------------------\n    fuel_diversion,t = self.breguet_range(self.diversion_range,mass,0.99,altp,mach,disa)\n\n    # Holding fuel\n    # -----------------------------------------------------------------------------------------------------------\n    altp_holding = unit.m_ft(1500.)\n    mach_holding = 0.65 * mach\n    fuel_holding = self.holding(self.holding_time,mass,altp_holding,mach_holding,disa)\n\n    # Total\n    # -----------------------------------------------------------------------------------------------------------\n    self.fuel_reserve = fuel_mission * self.reserve_fuel_ratio + fuel_diversion + fuel_holding\n    self.fuel_total = self.fuel_block + self.fuel_reserve\n\n    # -----------------------------------------------------------------------------------------------------------\n    return\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.MissionDef.eval_payload","title":"eval_payload","text":"<pre><code>eval_payload(owe)\n</code></pre> <p>Computing resulting payload</p> Source code in <code>src/lh2pac/marilib/aircraft/mission.py</code> <pre><code>def eval_payload(self, owe):\n    \"\"\"\n    Computing resulting payload\n    \"\"\"\n    self.payload = self.tow - self.fuel_total - owe\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.MissionDef.eval_sar","title":"eval_sar","text":"<pre><code>eval_sar(altp, mass, mach, disa)\n</code></pre> <p>Evaluate Specific Air Range</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def eval_sar(self,altp,mass,mach,disa):\n    \"\"\"Evaluate Specific Air Range\n    \"\"\"\n    g = earth.gravity()\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    tas = mach * earth.sound_speed(tamb)\n\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    nei = 0\n    thrust = mass*g / lod\n    dict = self.aircraft.power_system.sc(pamb,tamb,mach,\"MCR\",thrust,nei)\n    dict[\"fn\"] = thrust\n    dict[\"cz\"] = cz\n    dict[\"cx\"] = cx\n    dict[\"lod\"] = lod\n    dict[\"sar\"] = self.aircraft.power_system.specific_air_range(mass,tas,dict)\n    return dict\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.MissionDef.get_mach","title":"get_mach","text":"<pre><code>get_mach(pamb, speed_mode, speed)\n</code></pre> <p>Retrieve Mach from CAS or mach depending on speed_mode</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def get_mach(self,pamb,speed_mode,speed):\n    \"\"\"Retrieve Mach from CAS or mach depending on speed_mode\n    \"\"\"\n    mach = {\"cas\" : earth.mach_from_vcas(pamb, speed),  # Input is CAS\n            \"mach\" : speed  # Input is mach\n            }.get(speed_mode, \"Erreur: select speed_mode equal to cas or mach\")\n    return mach\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.MissionDef.get_speed","title":"get_speed","text":"<pre><code>get_speed(pamb, speed_mode, mach)\n</code></pre> <p>retrieve CAS or Mach from mach depending on speed_mode</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def get_speed(self,pamb,speed_mode,mach):\n    \"\"\"retrieve CAS or Mach from mach depending on speed_mode\n    \"\"\"\n    speed = {\"cas\" : earth.vcas_from_mach(pamb, mach),  # CAS required\n             \"mach\" : mach  # mach required\n             }.get(speed_mode, \"Erreur: select speed_mode equal to cas or mach\")\n    return speed\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.MissionDef.get_vcas","title":"get_vcas","text":"<pre><code>get_vcas(pamb, speed_mode, speed)\n</code></pre> <p>Retrieve CAS from Mach or CAS depending on speed_mode</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def get_vcas(self,pamb,speed_mode,speed):\n    \"\"\"Retrieve CAS from Mach or CAS depending on speed_mode\n    \"\"\"\n    cas = {\"mach\" : earth.vcas_from_mach(pamb, speed),  # Input is CAS\n            \"cas\" : speed  # Input is mach\n            }.get(speed_mode, \"Erreur: select speed_mode equal to cas or mach\")\n    return cas\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.MissionDef.holding","title":"holding","text":"<pre><code>holding(time, mass, altp, mach, disa)\n</code></pre> <p>Holding equation is dependant from power architecture</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def holding(self,time,mass,altp,mach,disa):\n    \"\"\"Holding equation is dependant from power architecture\n    \"\"\"\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    tas = mach * earth.sound_speed(tamb)\n    dict = self.level_flight(pamb,tamb,mach,mass)\n    return self.aircraft.power_system.specific_holding(mass,time,tas,dict)\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.MissionDef.init_unknowns","title":"init_unknowns","text":"<pre><code>init_unknowns(unknowns)\n</code></pre> <p>Initialize the value of the unknowns before calling fsolve :param unknowns: a list of two variable names in ['range', 'tow', 'payload', 'fuel_total'] :return: two init values</p> Source code in <code>src/lh2pac/marilib/aircraft/mission.py</code> <pre><code>def init_unknowns(self,unknowns):\n    \"\"\"Initialize the value of the unknowns before calling fsolve\n    :param unknowns: a list of two variable names in ['range', 'tow', 'payload', 'fuel_total']\n    :return: two init values\n    \"\"\"\n    x0 = [None,None]\n    for k,unknown in enumerate(sorted(unknowns)):\n        if (unknown == \"fuel_total\"):\n            x0[k] = 0.25 * self.owe\n        elif (unknown == \"payload\"):\n            x0[k] = 0.25 * self.owe\n        elif (unknown == \"range\"):\n            x0[k] = self.aircraft.requirement.design_range\n        elif (unknown == \"tow\"):\n            x0[k] = self.aircraft.weight_cg.mtow\n    return x0\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.MissionDef.level_flight","title":"level_flight","text":"<pre><code>level_flight(pamb, tamb, mach, mass)\n</code></pre> <p>Level flight equilibrium</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def level_flight(self,pamb,tamb,mach,mass):\n    \"\"\"Level flight equilibrium\n    \"\"\"\n    g = earth.gravity()\n    r,gam,Cp,Cv = earth.gas_data()\n    tas = mach * earth.sound_speed(tamb)\n\n    cz = (2.*mass*g)/(gam*pamb*mach**2*self.aircraft.airframe.wing.area)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    thrust = (gam/2.)*pamb*mach**2*self.aircraft.airframe.wing.area*cx\n    dict = self.aircraft.power_system.sc(pamb,tamb,mach,\"MCR\",thrust)\n    dict[\"fn\"] = thrust\n    dict[\"cx\"] = cx\n    dict[\"cz\"] = cz\n    dict[\"lod\"] = lod\n    dict[\"sar\"] = self.aircraft.power_system.specific_air_range(mass,tas,dict)\n    return dict\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.MissionDef.lift_from_speed","title":"lift_from_speed","text":"<pre><code>lift_from_speed(pamb, tamb, mach, mass)\n</code></pre> <p>Retrieve cz from mach using simplified lift equation</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def lift_from_speed(self,pamb,tamb,mach,mass):\n    \"\"\"Retrieve cz from mach using simplified lift equation\n    \"\"\"\n    g = earth.gravity()\n    r,gam,Cp,Cv = earth.gas_data()\n    cz = (2.*mass*g)/(gam*pamb*mach**2*self.aircraft.airframe.wing.area)\n    return cz\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.MissionDef.max_air_path","title":"max_air_path","text":"<pre><code>max_air_path(\n    nei,\n    altp,\n    disa,\n    speed_mode,\n    mass,\n    rating,\n    kfn,\n    full_output=False,\n)\n</code></pre> <p>Optimize the speed of the aircraft to maximize the air path</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def max_air_path(self,nei,altp,disa,speed_mode,mass,rating,kfn, full_output=False):\n    \"\"\"Optimize the speed of the aircraft to maximize the air path\n    \"\"\"\n    def fct(cz):\n        pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n        mach = self.speed_from_lift(pamb,tamb,cz,mass)\n        speed = self.get_speed(pamb,speed_mode,mach)\n        slope,vz = self.air_path(nei,altp,disa,speed_mode,speed,mass,rating,kfn)\n        if isformax: return slope\n        else: return slope,vz,mach\n\n    cz_ini = 0.5\n    dcz = 0.05\n\n    isformax = True\n    cz,slope,rc = maximize_1d(cz_ini,dcz,[fct])\n    isformax = False\n\n    slope,vz,mach = fct(cz)\n    return slope,vz,mach,cz\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.MissionDef.mission_equations_to_solve","title":"mission_equations_to_solve","text":"<pre><code>mission_equations_to_solve(unknowns, *args)\n</code></pre> <p>The set of two equations to solve to determine the two unknowns:</p> <pre><code>1) `fuel_total - eval_Breguet(range,tow, altp, mach, disa) = 0`\n2) `tow - payload - fuel_total - owe = 0`\n</code></pre> <p>:param unknowns: a list of two guess values for the unknowns :param args: a tuple containing a dict of inputs and unknowns names in ['range', 'tow', 'payload', 'fuel_total'] :return: the values of the two equations</p> Source code in <code>src/lh2pac/marilib/aircraft/mission.py</code> <pre><code>def mission_equations_to_solve(self, unknowns, *args):\n    \"\"\"The set of two equations to solve to determine the two unknowns:\n\n        1) `fuel_total - eval_Breguet(range,tow, altp, mach, disa) = 0`\n        2) `tow - payload - fuel_total - owe = 0`\n\n    :param unknowns: a list of two guess values for the unknowns\n    :param args: a tuple containing a dict of inputs and unknowns names in ['range', 'tow', 'payload', 'fuel_total']\n    :return: the values of the two equations\n\n    \"\"\"\n    inputs = args[0]['inputs']\n    unknowns_name = args[0]['unknowns']\n\n    xx = {'range':None, 'tow':None, 'payload':None, 'fuel_total':None}\n\n    k = 0\n    for name in sorted(xx.keys()): # iterate over the list\n        if name in inputs:\n            xx[name] = self.__dict__[name]  # read the value  of the attribute\n        elif name in unknowns_name:\n            xx[name] = unknowns[k]  # read the value in the unknown list : the order matters -&gt; sorted()\n            k += 1\n\n    self.eval_breguet(xx['range'], xx['tow'], self.altp, self.mach, self.disa)\n    eq1 = xx['fuel_total'] - self.fuel_total\n    eq2 = xx['tow'] - xx['fuel_total'] - self.owe - xx['payload']\n\n    return eq1,eq2\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.MissionDef.propulsion_ceiling","title":"propulsion_ceiling","text":"<pre><code>propulsion_ceiling(\n    altp_ini,\n    nei,\n    vzreq,\n    disa,\n    speed_mode,\n    speed,\n    mass,\n    rating,\n    throttle,\n)\n</code></pre> <p>Optimize the speed of the aircraft to maximize the air path</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def propulsion_ceiling(self,altp_ini,nei,vzreq,disa,speed_mode,speed,mass,rating,throttle):\n    \"\"\"Optimize the speed of the aircraft to maximize the air path\n    \"\"\"\n    def fct_prop_ceiling(altp,nei,vzreq,disa,speed_mode,speed,mass,rating):\n        slope,vz = self.air_path(nei,altp,disa,speed_mode,speed,mass,rating,throttle)\n        delta_vz = vz - vzreq\n        return delta_vz\n\n    fct_arg = (nei,vzreq,disa,speed_mode,speed,mass,rating)\n\n    output_dict = fsolve(fct_prop_ceiling, x0 = altp_ini, args=fct_arg, full_output = True)\n\n    altp = output_dict[0][0]\n    rei = output_dict[2]\n    if(rei!=1): altp = np.NaN\n\n    return altp, rei\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.MissionDef.set_parameters","title":"set_parameters","text":"<pre><code>set_parameters(mach=None, altp=None, disa=None, owe=None)\n</code></pre> Set the flight condition of the mission <p>1) if one or more value is specified : set the corresponding mission attributes 2) if no value is specified : reset mission parameters to default aircraft requirements</p> <p>:param mach: cruise Mach number :param altp: cruise altitude :param disa: mean temperature shift :param owe: Operating Weight empty</p> Source code in <code>src/lh2pac/marilib/aircraft/mission.py</code> <pre><code>def set_parameters(self, mach=None, altp=None, disa=None, owe=None):\n    \"\"\"Set the flight condition of the mission:\n        1) if one or more value is specified : set the corresponding mission attributes\n        2) if no value is specified : reset mission parameters to default aircraft requirements\n\n    :param mach: cruise Mach number\n    :param altp: cruise altitude\n    :param disa: mean temperature shift\n    :param owe: Operating Weight empty\n    \"\"\"\n    if mach==None and altp==None and disa==None and owe==None: # 1: reset to default\n        self.mach = self.aircraft.requirement.cruise_mach\n        self.altp = self.aircraft.requirement.cruise_altp\n        self.disa = self.aircraft.requirement.cruise_disa\n        self.owe = self.aircraft.weight_cg.owe\n\n    else:\n        if mach != None:\n            self.mach = mach\n        if disa != None:\n            self.disa = disa\n        if owe != None:\n            self.owe = owe\n        if altp != None:\n            self.altp = altp\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.MissionDef.speed_from_lift","title":"speed_from_lift","text":"<pre><code>speed_from_lift(pamb, tamb, cz, mass)\n</code></pre> <p>Retrieve mach from cz using simplified lift equation</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def speed_from_lift(self,pamb,tamb,cz,mass):\n    \"\"\"Retrieve mach from cz using simplified lift equation\n    \"\"\"\n    g = earth.gravity()\n    r,gam,Cp,Cv = earth.gas_data()\n    mach = np.sqrt((mass*g)/(0.5*gam*pamb*self.aircraft.airframe.wing.area*cz))\n    return mach\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.MissionIsoMassGeneric","title":"MissionIsoMassGeneric","text":"<pre><code>MissionIsoMassGeneric(aircraft)\n</code></pre> <p>               Bases: <code>Flight</code></p> <p>Define common features for all mission types.</p> Source code in <code>src/lh2pac/marilib/aircraft/mission.py</code> <pre><code>def __init__(self, aircraft):\n    super(MissionIsoMassGeneric, self).__init__(aircraft)\n\n    self.disa = None    # Mean cruise temperature shift\n    self.altp = None    # Mean cruise altitude\n    self.mach = None    # Cruise mach number\n    self.range = None   # Mission distance\n    self.tow = None     # Take Off Weight\n    self.payload = None         # Mission payload\n    self.time_block = None      # Mission block duration\n    self.enrg_block = None      # Mission block energy consumption\n    self.enrg_reserve = None    # Mission reserve energy\n    self.enrg_total = None      # Mission total energy\n    self.battery_mass = None    # Mission battery mass\n\n    self.holding_time = aircraft.get_init(self,\"holding_time\")\n    self.reserve_enrg_ratio = aircraft.get_init(self,\"reserve_enrg_ratio\", val=self.reserve_enrg_ratio())    # Ratio of mission fuel to account into reserve\n    self.diversion_range = aircraft.get_init(self,\"diversion_range\", val=self.diversion_range())             # Diversion leg\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.MissionIsoMassGeneric-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.MissionIsoMassGeneric.acceleration","title":"acceleration","text":"<pre><code>acceleration(\n    nei,\n    altp,\n    disa,\n    speed_mode,\n    speed,\n    mass,\n    rating,\n    throttle,\n    full_output=False,\n)\n</code></pre> <p>Aircraft acceleration on level flight</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def acceleration(self,nei,altp,disa,speed_mode,speed,mass,rating,throttle, full_output=False):\n    \"\"\"Aircraft acceleration on level flight\n    \"\"\"\n    r,gam,Cp,Cv = earth.gas_data()\n\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    mach = self.get_mach(pamb,speed_mode,speed)\n\n    dict = self.aircraft.power_system.thrust(pamb,tamb,mach,rating,throttle=throttle,nei=nei)\n    fn = dict[\"fn\"]\n    ff = dict[\"ff\"]\n\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    if(nei&gt;0):\n        dcx = self.aircraft.power_system.oei_drag(pamb,mach)\n        cx = cx + dcx*nei\n\n    acc = (fn - 0.5*gam*pamb*mach**2*self.aircraft.airframe.wing.area*cx) / mass\n\n    if full_output:\n        return acc,fn,ff,cz,cx,pamb,tamb\n    else:\n        return acc\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.MissionIsoMassGeneric.air_path","title":"air_path","text":"<pre><code>air_path(\n    nei,\n    altp,\n    disa,\n    speed_mode,\n    speed,\n    mass,\n    rating,\n    kfn,\n    full_output=False,\n)\n</code></pre> <p>Retrieve air path in various conditions</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def air_path(self,nei,altp,disa,speed_mode,speed,mass,rating,kfn, full_output=False):\n    \"\"\"Retrieve air path in various conditions\n    \"\"\"\n    g = earth.gravity()\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    mach = self.get_mach(pamb,speed_mode,speed)\n\n    dict = self.aircraft.power_system.thrust(pamb,tamb,mach,rating,nei=nei)\n    fn = dict[\"fn\"]*kfn\n    ff = dict[\"ff\"]*kfn\n    if kfn!=1. and full_output:\n        print(\"WARNING, air_path method, kfn is different from 1, fuel flow may not be accurate\")\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    if(nei&gt;0):\n        dcx = self.aircraft.power_system.oei_drag(pamb,mach)\n        cx = cx + dcx*nei\n        lod = cz/cx\n\n    acc_factor = earth.climb_mode(speed_mode, mach, dtodz, tstd, disa)\n    slope = ( fn/(mass*g) - 1./lod ) / acc_factor\n    vz = slope * mach * earth.sound_speed(tamb)\n    acc = (acc_factor-1.)*g*slope\n    if full_output:\n        return slope,vz,fn,ff,acc,cz,cx,pamb,tamb\n    else:\n        return slope,vz\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.MissionIsoMassGeneric.arrival_ground_legs","title":"arrival_ground_legs","text":"<pre><code>arrival_ground_legs(ldw)\n</code></pre> <p>Compute fuel and time allowances for arrival ground phases</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def arrival_ground_legs(self,ldw):\n    \"\"\"Compute fuel and time allowances for arrival ground phases\n    \"\"\"\n    n_engine = self.aircraft.power_system.n_engine\n    reference_thrust = self.aircraft.power_system.get_reference_thrust()\n    fuel_type = self.aircraft.arrangement.fuel_type\n\n    time_landing = 180.\n    time_taxi_in = 420.\n\n    if fuel_type!=\"battery\":\n        engine_bpr = self.aircraft.airframe.nacelle.engine_bpr\n        fuel_mass_factor = earth.fuel_heat(\"kerosene\") / earth.fuel_heat(fuel_type)\n        fuel_landing = fuel_mass_factor*1e-4*(0.5+2.3/engine_bpr)*ldw\n        fuel_taxi_in = fuel_mass_factor*(26. + 1.8e-4*reference_thrust)*n_engine\n        return {\"fuel\":{\"landing\":fuel_landing,\"taxi_in\":fuel_taxi_in},\n                \"time\":{\"landing\":time_landing,\"taxi_in\":time_taxi_in}}\n    else:\n        enrg_landing = (0.25*43.1e6)*0.75e-4*ldw\n        enrg_taxi_in = (0.25*43.1e6)*(26. + 1.8e-4*reference_thrust)*n_engine\n        return {\"enrg\":{\"landing\":enrg_landing,\"taxi_in\":enrg_taxi_in},\n                \"time\":{\"landing\":time_landing,\"taxi_in\":time_taxi_in}}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.MissionIsoMassGeneric.breguet_range","title":"breguet_range","text":"<pre><code>breguet_range(range, tow, ktow, altp, mach, disa)\n</code></pre> <p>Breguet range equation is dependant from power architecture</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def breguet_range(self,range,tow,ktow,altp,mach,disa):\n    \"\"\"Breguet range equation is dependant from power architecture\n    \"\"\"\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    tas = mach * earth.sound_speed(tamb)\n    time = 1.09*(range/tas)\n\n    dict = self.level_flight(pamb,tamb,mach,tow*ktow)\n    val = self.aircraft.power_system.specific_breguet_range(tow,range,tas,dict)\n    return val,time\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.MissionIsoMassGeneric.departure_ground_legs","title":"departure_ground_legs","text":"<pre><code>departure_ground_legs(tow)\n</code></pre> <p>Compute fuel and time allowances for departure ground phases</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def departure_ground_legs(self,tow):\n    \"\"\"Compute fuel and time allowances for departure ground phases\n    \"\"\"\n    n_engine = self.aircraft.power_system.n_engine\n    reference_thrust = self.aircraft.power_system.get_reference_thrust()\n    fuel_type = self.aircraft.arrangement.fuel_type\n\n    time_taxi_out = 540.\n    time_take_off = 220.*tow/(reference_thrust*n_engine)\n\n    if fuel_type!=\"battery\":\n        engine_bpr = self.aircraft.airframe.nacelle.engine_bpr\n        fuel_mass_factor = earth.fuel_heat(\"kerosene\") / earth.fuel_heat(fuel_type)\n        fuel_taxi_out = fuel_mass_factor*(34. + 2.3e-4*reference_thrust)*n_engine\n        fuel_take_off = fuel_mass_factor*1e-4*(2.8+2.3/engine_bpr)*tow\n        return {\"fuel\":{\"taxi_out\":fuel_taxi_out,\"take_off\":fuel_take_off},\n                \"time\":{\"taxi_out\":time_taxi_out,\"take_off\":time_take_off}}\n    else:\n        enrg_taxi_out = (0.25*43.1e6)*(34. + 2.3e-4*reference_thrust)*n_engine\n        enrg_take_off = (0.25*43.1e6)*3.e-4*tow\n        return {\"enrg\":{\"taxi_out\":enrg_taxi_out,\"take_off\":enrg_take_off},\n                \"time\":{\"taxi_out\":time_taxi_out,\"take_off\":time_take_off}}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.MissionIsoMassGeneric.descent","title":"descent","text":"<pre><code>descent(nei, altp, disa, speed_mode, speed, vz, mass)\n</code></pre> <p>Retrieve air path and flight characteristics in various conditions</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def descent(self,nei,altp,disa,speed_mode,speed,vz,mass):\n    \"\"\"Retrieve air path and flight characteristics in various conditions\n    \"\"\"\n    g = earth.gravity()\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    mach = self.get_mach(pamb,speed_mode,speed)\n\n    slope = vz / (mach * earth.sound_speed(tamb))\n    acc_factor = earth.climb_mode(speed_mode, mach, dtodz, tstd, disa)\n\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    fn = (slope * acc_factor + 1./lod) * (mass*g)\n    dict = self.aircraft.power_system.sc(self,pamb,tamb,mach,\"FID\", fn, nei)\n    ff = dict[\"sfc\"]*fn\n    thtl = dict[\"thtl\"]\n\n    return slope,thtl,fn,ff,cz,cx,pamb,tamb\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.MissionIsoMassGeneric.eval","title":"eval","text":"<pre><code>eval(owe, altp, mach, disa, **kwargs)\n</code></pre> <p>Generic mission solver kwargs must contain affectations to the parameters that are fixed among the following list : range, tow, payload, fuel_total</p> Source code in <code>src/lh2pac/marilib/aircraft/mission.py</code> <pre><code>def eval(self,owe,altp,mach,disa,**kwargs):\n    \"\"\"Generic mission solver\n    kwargs must contain affectations to the parameters that are fixed\n    among the following list : range, tow, payload, fuel_total\n    \"\"\"\n    self.disa = disa    # Mean cruise temperature shift\n    self.altp = altp    # Mean cruise altitude\n    self.mach = mach    # Cruise mach number\n\n    range = [0.]\n    tow = [0.]\n    payload = [0.]\n    fuel_total = [0.]\n\n    for key,val in kwargs.items():      # load parameter values, this quantities will not be modified\n        exec(key+\"[0] = val\")\n\n    if not list(set([\"range\",\"tow\"])-set(kwargs.keys())):   # Test if input corresponds to eval_breguet input (range, tow)\n        self.range = range[0]  # Mission distance\n        self.tow = tow[0]      # Take Off Weight\n        self.eval_breguet(range[0],tow[0],altp,mach,disa)\n        self.eval_payload(owe)\n        return\n\n    vars = list(set([\"range\",\"tow\",\"payload\",\"fuel_total\"])-set(kwargs.keys())) # extract variable names\n\n    def fct(x_in):\n        for k,key in enumerate(vars):      # load variable values\n            exec(key+\"[0] = x_in[k]\")\n        self.eval_breguet(range[0],tow[0],altp,mach,disa)         # eval Breguet equation, fuel_total is updated in the object\n        return  [self.battery_mass - fuel_total[0],\n                 tow[0] - (owe+payload[0]+self.battery_mass)]  # constraints residuals are sent back\n\n    x_ini = np.zeros(2)\n    for k,key in enumerate(vars):              # load init values from object\n        if (key==\"fuel_total\"): x_ini[k] = self.aircraft.airframe.cabin.nominal_payload\n        elif (key==\"payload\"): x_ini[k] = self.aircraft.airframe.cabin.nominal_payload\n        elif (key==\"range\"): x_ini[k] = self.aircraft.requirement.design_range\n        elif (key==\"tow\"): x_ini[k] = self.aircraft.weight_cg.mtow\n    output_dict = fsolve(fct, x0=x_ini, args=(), full_output=True)\n    if (output_dict[2]!=1): raise Exception(\"Convergence problem\")\n\n    for k,key in enumerate(vars):              # get solution\n        exec(key+\"[0] = output_dict[0][k]\")\n    self.eval_breguet(range[0],tow[0],altp,mach,disa)\n    self.range = range[0]\n    self.tow = tow[0]\n    self.payload = payload[0]\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.MissionIsoMassGeneric.eval_breguet","title":"eval_breguet","text":"<pre><code>eval_breguet(range, tow, altp, mach, disa)\n</code></pre> <p>Mission computation using bregue\u00e7t equation, fixed L/D and fixed sfc</p> Source code in <code>src/lh2pac/marilib/aircraft/mission.py</code> <pre><code>def eval_breguet(self,range,tow,altp,mach,disa):\n    \"\"\"\n    Mission computation using bregue\u00e7t equation, fixed L/D and fixed sfc\n    \"\"\"\n    g = earth.gravity()\n    n_engine = self.aircraft.power_system.n_engine\n    reference_thrust = self.aircraft.power_system.get_reference_thrust()\n\n    # Departure ground legs\n    #-----------------------------------------------------------------------------------------------------------\n    dict = self.departure_ground_legs(tow)\n\n    enrg_taxi_out = dict[\"enrg\"][\"taxi_out\"]\n    time_taxi_out = dict[\"time\"][\"taxi_out\"]\n\n    enrg_take_off = dict[\"enrg\"][\"take_off\"]\n    time_take_off = dict[\"time\"][\"take_off\"]\n\n    # Mission leg\n    #-----------------------------------------------------------------------------------------------------------\n    enrg_mission,time_mission = self.breguet_range(range,tow,1.,altp,mach,disa)\n\n    # Arrival ground legs\n    #-----------------------------------------------------------------------------------------------------------\n    dict = self.arrival_ground_legs(tow)\n\n    enrg_landing = dict[\"enrg\"][\"landing\"]\n    time_landing = dict[\"time\"][\"landing\"]\n\n    enrg_taxi_in = dict[\"enrg\"][\"taxi_in\"]\n    time_taxi_in = dict[\"time\"][\"taxi_in\"]\n\n    # Block fuel and time\n    #-----------------------------------------------------------------------------------------------------------\n    self.enrg_block = enrg_taxi_out + enrg_take_off + enrg_mission + enrg_landing + enrg_taxi_in\n    self.time_block = time_taxi_out + time_take_off + time_mission + time_landing + time_taxi_in\n\n    # Diversion fuel\n    #-----------------------------------------------------------------------------------------------------------\n    enrg_diversion,t = self.breguet_range(self.diversion_range,tow,1.,altp,mach,disa)\n\n    # Holding fuel\n    #-----------------------------------------------------------------------------------------------------------\n    altp_holding = unit.m_ft(1500.)\n    mach_holding = 0.65 * mach\n    enrg_holding = self.holding(self.holding_time,tow,altp_holding,mach_holding,disa)\n\n    # Total\n    #-----------------------------------------------------------------------------------------------------------\n    self.enrg_reserve = enrg_mission*self.reserve_enrg_ratio + enrg_diversion + enrg_holding\n    self.enrg_total = self.enrg_block + self.enrg_reserve\n    self.battery_mass = self.enrg_total / self.aircraft.airframe.system.battery_energy_density\n\n    #-----------------------------------------------------------------------------------------------------------\n    return\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.MissionIsoMassGeneric.eval_payload","title":"eval_payload","text":"<pre><code>eval_payload(owe)\n</code></pre> <p>Computing resulting payload</p> Source code in <code>src/lh2pac/marilib/aircraft/mission.py</code> <pre><code>def eval_payload(self,owe):\n    \"\"\"Computing resulting payload\n    \"\"\"\n    self.payload = self.tow - self.battery_mass - owe\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.MissionIsoMassGeneric.eval_sar","title":"eval_sar","text":"<pre><code>eval_sar(altp, mass, mach, disa)\n</code></pre> <p>Evaluate Specific Air Range</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def eval_sar(self,altp,mass,mach,disa):\n    \"\"\"Evaluate Specific Air Range\n    \"\"\"\n    g = earth.gravity()\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    tas = mach * earth.sound_speed(tamb)\n\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    nei = 0\n    thrust = mass*g / lod\n    dict = self.aircraft.power_system.sc(pamb,tamb,mach,\"MCR\",thrust,nei)\n    dict[\"fn\"] = thrust\n    dict[\"cz\"] = cz\n    dict[\"cx\"] = cx\n    dict[\"lod\"] = lod\n    dict[\"sar\"] = self.aircraft.power_system.specific_air_range(mass,tas,dict)\n    return dict\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.MissionIsoMassGeneric.get_mach","title":"get_mach","text":"<pre><code>get_mach(pamb, speed_mode, speed)\n</code></pre> <p>Retrieve Mach from CAS or mach depending on speed_mode</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def get_mach(self,pamb,speed_mode,speed):\n    \"\"\"Retrieve Mach from CAS or mach depending on speed_mode\n    \"\"\"\n    mach = {\"cas\" : earth.mach_from_vcas(pamb, speed),  # Input is CAS\n            \"mach\" : speed  # Input is mach\n            }.get(speed_mode, \"Erreur: select speed_mode equal to cas or mach\")\n    return mach\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.MissionIsoMassGeneric.get_speed","title":"get_speed","text":"<pre><code>get_speed(pamb, speed_mode, mach)\n</code></pre> <p>retrieve CAS or Mach from mach depending on speed_mode</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def get_speed(self,pamb,speed_mode,mach):\n    \"\"\"retrieve CAS or Mach from mach depending on speed_mode\n    \"\"\"\n    speed = {\"cas\" : earth.vcas_from_mach(pamb, mach),  # CAS required\n             \"mach\" : mach  # mach required\n             }.get(speed_mode, \"Erreur: select speed_mode equal to cas or mach\")\n    return speed\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.MissionIsoMassGeneric.get_vcas","title":"get_vcas","text":"<pre><code>get_vcas(pamb, speed_mode, speed)\n</code></pre> <p>Retrieve CAS from Mach or CAS depending on speed_mode</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def get_vcas(self,pamb,speed_mode,speed):\n    \"\"\"Retrieve CAS from Mach or CAS depending on speed_mode\n    \"\"\"\n    cas = {\"mach\" : earth.vcas_from_mach(pamb, speed),  # Input is CAS\n            \"cas\" : speed  # Input is mach\n            }.get(speed_mode, \"Erreur: select speed_mode equal to cas or mach\")\n    return cas\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.MissionIsoMassGeneric.holding","title":"holding","text":"<pre><code>holding(time, mass, altp, mach, disa)\n</code></pre> <p>Holding equation is dependant from power architecture</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def holding(self,time,mass,altp,mach,disa):\n    \"\"\"Holding equation is dependant from power architecture\n    \"\"\"\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    tas = mach * earth.sound_speed(tamb)\n    dict = self.level_flight(pamb,tamb,mach,mass)\n    return self.aircraft.power_system.specific_holding(mass,time,tas,dict)\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.MissionIsoMassGeneric.level_flight","title":"level_flight","text":"<pre><code>level_flight(pamb, tamb, mach, mass)\n</code></pre> <p>Level flight equilibrium</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def level_flight(self,pamb,tamb,mach,mass):\n    \"\"\"Level flight equilibrium\n    \"\"\"\n    g = earth.gravity()\n    r,gam,Cp,Cv = earth.gas_data()\n    tas = mach * earth.sound_speed(tamb)\n\n    cz = (2.*mass*g)/(gam*pamb*mach**2*self.aircraft.airframe.wing.area)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    thrust = (gam/2.)*pamb*mach**2*self.aircraft.airframe.wing.area*cx\n    dict = self.aircraft.power_system.sc(pamb,tamb,mach,\"MCR\",thrust)\n    dict[\"fn\"] = thrust\n    dict[\"cx\"] = cx\n    dict[\"cz\"] = cz\n    dict[\"lod\"] = lod\n    dict[\"sar\"] = self.aircraft.power_system.specific_air_range(mass,tas,dict)\n    return dict\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.MissionIsoMassGeneric.lift_from_speed","title":"lift_from_speed","text":"<pre><code>lift_from_speed(pamb, tamb, mach, mass)\n</code></pre> <p>Retrieve cz from mach using simplified lift equation</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def lift_from_speed(self,pamb,tamb,mach,mass):\n    \"\"\"Retrieve cz from mach using simplified lift equation\n    \"\"\"\n    g = earth.gravity()\n    r,gam,Cp,Cv = earth.gas_data()\n    cz = (2.*mass*g)/(gam*pamb*mach**2*self.aircraft.airframe.wing.area)\n    return cz\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.MissionIsoMassGeneric.max_air_path","title":"max_air_path","text":"<pre><code>max_air_path(\n    nei,\n    altp,\n    disa,\n    speed_mode,\n    mass,\n    rating,\n    kfn,\n    full_output=False,\n)\n</code></pre> <p>Optimize the speed of the aircraft to maximize the air path</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def max_air_path(self,nei,altp,disa,speed_mode,mass,rating,kfn, full_output=False):\n    \"\"\"Optimize the speed of the aircraft to maximize the air path\n    \"\"\"\n    def fct(cz):\n        pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n        mach = self.speed_from_lift(pamb,tamb,cz,mass)\n        speed = self.get_speed(pamb,speed_mode,mach)\n        slope,vz = self.air_path(nei,altp,disa,speed_mode,speed,mass,rating,kfn)\n        if isformax: return slope\n        else: return slope,vz,mach\n\n    cz_ini = 0.5\n    dcz = 0.05\n\n    isformax = True\n    cz,slope,rc = maximize_1d(cz_ini,dcz,[fct])\n    isformax = False\n\n    slope,vz,mach = fct(cz)\n    return slope,vz,mach,cz\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.MissionIsoMassGeneric.propulsion_ceiling","title":"propulsion_ceiling","text":"<pre><code>propulsion_ceiling(\n    altp_ini,\n    nei,\n    vzreq,\n    disa,\n    speed_mode,\n    speed,\n    mass,\n    rating,\n    throttle,\n)\n</code></pre> <p>Optimize the speed of the aircraft to maximize the air path</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def propulsion_ceiling(self,altp_ini,nei,vzreq,disa,speed_mode,speed,mass,rating,throttle):\n    \"\"\"Optimize the speed of the aircraft to maximize the air path\n    \"\"\"\n    def fct_prop_ceiling(altp,nei,vzreq,disa,speed_mode,speed,mass,rating):\n        slope,vz = self.air_path(nei,altp,disa,speed_mode,speed,mass,rating,throttle)\n        delta_vz = vz - vzreq\n        return delta_vz\n\n    fct_arg = (nei,vzreq,disa,speed_mode,speed,mass,rating)\n\n    output_dict = fsolve(fct_prop_ceiling, x0 = altp_ini, args=fct_arg, full_output = True)\n\n    altp = output_dict[0][0]\n    rei = output_dict[2]\n    if(rei!=1): altp = np.NaN\n\n    return altp, rei\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.MissionIsoMassGeneric.speed_from_lift","title":"speed_from_lift","text":"<pre><code>speed_from_lift(pamb, tamb, cz, mass)\n</code></pre> <p>Retrieve mach from cz using simplified lift equation</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def speed_from_lift(self,pamb,tamb,cz,mass):\n    \"\"\"Retrieve mach from cz using simplified lift equation\n    \"\"\"\n    g = earth.gravity()\n    r,gam,Cp,Cv = earth.gas_data()\n    mach = np.sqrt((mass*g)/(0.5*gam*pamb*self.aircraft.airframe.wing.area*cz))\n    return mach\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.MissionVarMassGeneric","title":"MissionVarMassGeneric","text":"<pre><code>MissionVarMassGeneric(aircraft)\n</code></pre> <p>               Bases: <code>Flight</code></p> <p>Define common features for all mission types.</p> Source code in <code>src/lh2pac/marilib/aircraft/mission.py</code> <pre><code>def __init__(self, aircraft):\n    super(MissionVarMassGeneric, self).__init__(aircraft)\n\n    self.disa = None    # Mean cruise temperature shift\n    self.altp = None    # Mean cruise altitude\n    self.mach = None    # Cruise mach number\n    self.range = None   # Mission distance\n    self.tow = None     # Take Off Weight\n    self.payload = None         # Mission payload\n    self.time_block = None      # Mission block duration\n    self.fuel_block = None      # Mission block fuel consumption\n    self.fuel_reserve = None    # Mission reserve fuel\n    self.fuel_total = None      # Mission total fuel\n\n    self.holding_time = aircraft.get_init(self,\"holding_time\")\n    self.reserve_fuel_ratio = aircraft.get_init(self,\"reserve_fuel_ratio\", val=self.reserve_fuel_ratio())    # Ratio of mission fuel to account into reserve\n    self.diversion_range = aircraft.get_init(self,\"diversion_range\", val=self.diversion_range())             # Diversion leg\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.MissionVarMassGeneric-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.MissionVarMassGeneric.acceleration","title":"acceleration","text":"<pre><code>acceleration(\n    nei,\n    altp,\n    disa,\n    speed_mode,\n    speed,\n    mass,\n    rating,\n    throttle,\n    full_output=False,\n)\n</code></pre> <p>Aircraft acceleration on level flight</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def acceleration(self,nei,altp,disa,speed_mode,speed,mass,rating,throttle, full_output=False):\n    \"\"\"Aircraft acceleration on level flight\n    \"\"\"\n    r,gam,Cp,Cv = earth.gas_data()\n\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    mach = self.get_mach(pamb,speed_mode,speed)\n\n    dict = self.aircraft.power_system.thrust(pamb,tamb,mach,rating,throttle=throttle,nei=nei)\n    fn = dict[\"fn\"]\n    ff = dict[\"ff\"]\n\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    if(nei&gt;0):\n        dcx = self.aircraft.power_system.oei_drag(pamb,mach)\n        cx = cx + dcx*nei\n\n    acc = (fn - 0.5*gam*pamb*mach**2*self.aircraft.airframe.wing.area*cx) / mass\n\n    if full_output:\n        return acc,fn,ff,cz,cx,pamb,tamb\n    else:\n        return acc\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.MissionVarMassGeneric.air_path","title":"air_path","text":"<pre><code>air_path(\n    nei,\n    altp,\n    disa,\n    speed_mode,\n    speed,\n    mass,\n    rating,\n    kfn,\n    full_output=False,\n)\n</code></pre> <p>Retrieve air path in various conditions</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def air_path(self,nei,altp,disa,speed_mode,speed,mass,rating,kfn, full_output=False):\n    \"\"\"Retrieve air path in various conditions\n    \"\"\"\n    g = earth.gravity()\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    mach = self.get_mach(pamb,speed_mode,speed)\n\n    dict = self.aircraft.power_system.thrust(pamb,tamb,mach,rating,nei=nei)\n    fn = dict[\"fn\"]*kfn\n    ff = dict[\"ff\"]*kfn\n    if kfn!=1. and full_output:\n        print(\"WARNING, air_path method, kfn is different from 1, fuel flow may not be accurate\")\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    if(nei&gt;0):\n        dcx = self.aircraft.power_system.oei_drag(pamb,mach)\n        cx = cx + dcx*nei\n        lod = cz/cx\n\n    acc_factor = earth.climb_mode(speed_mode, mach, dtodz, tstd, disa)\n    slope = ( fn/(mass*g) - 1./lod ) / acc_factor\n    vz = slope * mach * earth.sound_speed(tamb)\n    acc = (acc_factor-1.)*g*slope\n    if full_output:\n        return slope,vz,fn,ff,acc,cz,cx,pamb,tamb\n    else:\n        return slope,vz\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.MissionVarMassGeneric.arrival_ground_legs","title":"arrival_ground_legs","text":"<pre><code>arrival_ground_legs(ldw)\n</code></pre> <p>Compute fuel and time allowances for arrival ground phases</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def arrival_ground_legs(self,ldw):\n    \"\"\"Compute fuel and time allowances for arrival ground phases\n    \"\"\"\n    n_engine = self.aircraft.power_system.n_engine\n    reference_thrust = self.aircraft.power_system.get_reference_thrust()\n    fuel_type = self.aircraft.arrangement.fuel_type\n\n    time_landing = 180.\n    time_taxi_in = 420.\n\n    if fuel_type!=\"battery\":\n        engine_bpr = self.aircraft.airframe.nacelle.engine_bpr\n        fuel_mass_factor = earth.fuel_heat(\"kerosene\") / earth.fuel_heat(fuel_type)\n        fuel_landing = fuel_mass_factor*1e-4*(0.5+2.3/engine_bpr)*ldw\n        fuel_taxi_in = fuel_mass_factor*(26. + 1.8e-4*reference_thrust)*n_engine\n        return {\"fuel\":{\"landing\":fuel_landing,\"taxi_in\":fuel_taxi_in},\n                \"time\":{\"landing\":time_landing,\"taxi_in\":time_taxi_in}}\n    else:\n        enrg_landing = (0.25*43.1e6)*0.75e-4*ldw\n        enrg_taxi_in = (0.25*43.1e6)*(26. + 1.8e-4*reference_thrust)*n_engine\n        return {\"enrg\":{\"landing\":enrg_landing,\"taxi_in\":enrg_taxi_in},\n                \"time\":{\"landing\":time_landing,\"taxi_in\":time_taxi_in}}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.MissionVarMassGeneric.breguet_range","title":"breguet_range","text":"<pre><code>breguet_range(range, tow, ktow, altp, mach, disa)\n</code></pre> <p>Breguet range equation is dependant from power architecture</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def breguet_range(self,range,tow,ktow,altp,mach,disa):\n    \"\"\"Breguet range equation is dependant from power architecture\n    \"\"\"\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    tas = mach * earth.sound_speed(tamb)\n    time = 1.09*(range/tas)\n\n    dict = self.level_flight(pamb,tamb,mach,tow*ktow)\n    val = self.aircraft.power_system.specific_breguet_range(tow,range,tas,dict)\n    return val,time\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.MissionVarMassGeneric.departure_ground_legs","title":"departure_ground_legs","text":"<pre><code>departure_ground_legs(tow)\n</code></pre> <p>Compute fuel and time allowances for departure ground phases</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def departure_ground_legs(self,tow):\n    \"\"\"Compute fuel and time allowances for departure ground phases\n    \"\"\"\n    n_engine = self.aircraft.power_system.n_engine\n    reference_thrust = self.aircraft.power_system.get_reference_thrust()\n    fuel_type = self.aircraft.arrangement.fuel_type\n\n    time_taxi_out = 540.\n    time_take_off = 220.*tow/(reference_thrust*n_engine)\n\n    if fuel_type!=\"battery\":\n        engine_bpr = self.aircraft.airframe.nacelle.engine_bpr\n        fuel_mass_factor = earth.fuel_heat(\"kerosene\") / earth.fuel_heat(fuel_type)\n        fuel_taxi_out = fuel_mass_factor*(34. + 2.3e-4*reference_thrust)*n_engine\n        fuel_take_off = fuel_mass_factor*1e-4*(2.8+2.3/engine_bpr)*tow\n        return {\"fuel\":{\"taxi_out\":fuel_taxi_out,\"take_off\":fuel_take_off},\n                \"time\":{\"taxi_out\":time_taxi_out,\"take_off\":time_take_off}}\n    else:\n        enrg_taxi_out = (0.25*43.1e6)*(34. + 2.3e-4*reference_thrust)*n_engine\n        enrg_take_off = (0.25*43.1e6)*3.e-4*tow\n        return {\"enrg\":{\"taxi_out\":enrg_taxi_out,\"take_off\":enrg_take_off},\n                \"time\":{\"taxi_out\":time_taxi_out,\"take_off\":time_take_off}}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.MissionVarMassGeneric.descent","title":"descent","text":"<pre><code>descent(nei, altp, disa, speed_mode, speed, vz, mass)\n</code></pre> <p>Retrieve air path and flight characteristics in various conditions</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def descent(self,nei,altp,disa,speed_mode,speed,vz,mass):\n    \"\"\"Retrieve air path and flight characteristics in various conditions\n    \"\"\"\n    g = earth.gravity()\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    mach = self.get_mach(pamb,speed_mode,speed)\n\n    slope = vz / (mach * earth.sound_speed(tamb))\n    acc_factor = earth.climb_mode(speed_mode, mach, dtodz, tstd, disa)\n\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    fn = (slope * acc_factor + 1./lod) * (mass*g)\n    dict = self.aircraft.power_system.sc(self,pamb,tamb,mach,\"FID\", fn, nei)\n    ff = dict[\"sfc\"]*fn\n    thtl = dict[\"thtl\"]\n\n    return slope,thtl,fn,ff,cz,cx,pamb,tamb\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.MissionVarMassGeneric.eval","title":"eval","text":"<pre><code>eval(owe, altp, mach, disa, **kwargs)\n</code></pre> <p>Generic mission solver kwargs must contain affectations to the parameters that are fixed among the following list : range, tow, payload, fuel_total</p> Source code in <code>src/lh2pac/marilib/aircraft/mission.py</code> <pre><code>def eval(self,owe,altp,mach,disa,**kwargs):\n    \"\"\"Generic mission solver\n    kwargs must contain affectations to the parameters that are fixed\n    among the following list : range, tow, payload, fuel_total\n    \"\"\"\n    self.disa = disa    # Mean cruise temperature shift\n    self.altp = altp    # Mean cruise altitude\n    self.mach = mach    # Cruise mach number\n\n    range = [0.]\n    tow = [0.]\n    payload = [0.]\n    fuel_total = [0.]\n\n    for key,val in kwargs.items():      # load parameter values, this quantities will not be modified\n        exec(key+\"[0] = val\")\n\n    if not list(set([\"range\",\"tow\"])-set(kwargs.keys())):   # Test if input corresponds to eval_breguet input (range, tow)\n        self.range = range[0]  # Mission distance\n        self.tow = tow[0]      # Take Off Weight\n        self.eval_breguet(range[0],tow[0],altp,mach,disa)\n        self.eval_payload(owe)\n        return\n\n    vars = list(set([\"range\",\"tow\",\"payload\",\"fuel_total\"])-set(kwargs.keys())) # extract variable names\n\n    def fct(x_in):\n        for k,key in enumerate(vars):      # load variable values\n            exec(key+\"[0] = x_in[k]\")\n        self.eval_breguet(range[0],tow[0],altp,mach,disa)         # eval Breguet equation, fuel_total is updated in the object\n        return  [self.fuel_total - fuel_total[0],\n                 tow[0] - (owe+payload[0]+self.fuel_total)]  # constraints residuals are sent back\n\n    x_ini = np.zeros(2)\n    for k,key in enumerate(vars):              # load init values from object\n        if (key==\"fuel_total\"): x_ini[k] = self.aircraft.airframe.cabin.nominal_payload\n        elif (key==\"payload\"): x_ini[k] = self.aircraft.airframe.cabin.nominal_payload\n        elif (key==\"range\"): x_ini[k] = self.aircraft.requirement.design_range\n        elif (key==\"tow\"): x_ini[k] = self.aircraft.weight_cg.mtow\n    output_dict = fsolve(fct, x0=x_ini, args=(), full_output=True)\n    if (output_dict[2]!=1): raise Exception(\"Convergence problem\")\n\n    for k,key in enumerate(vars):              # get solution\n        exec(key+\"[0] = output_dict[0][k]\")\n    self.eval_breguet(range[0],tow[0],altp,mach,disa)\n    self.range = range[0]\n    self.tow = tow[0]\n    self.payload = payload[0]\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.MissionVarMassGeneric.eval_breguet","title":"eval_breguet","text":"<pre><code>eval_breguet(range, tow, altp, mach, disa)\n</code></pre> <p>Mission computation using bregue\u00e7t equation, fixed L/D and fixed sfc</p> Source code in <code>src/lh2pac/marilib/aircraft/mission.py</code> <pre><code>def eval_breguet(self,range,tow,altp,mach,disa):\n    \"\"\"\n    Mission computation using bregue\u00e7t equation, fixed L/D and fixed sfc\n    \"\"\"\n    g = earth.gravity()\n\n    n_engine = self.aircraft.power_system.n_engine\n    reference_thrust = self.aircraft.power_system.get_reference_thrust()\n    engine_bpr = self.aircraft.airframe.nacelle.engine_bpr\n    fuel_type = self.aircraft.arrangement.fuel_type\n    ktow = self.aircraft.performance.mission.ktow\n\n    fuel_mass_factor = earth.fuel_heat(\"kerosene\") / earth.fuel_heat(fuel_type)\n\n    # Departure ground legs\n    #-----------------------------------------------------------------------------------------------------------\n    dict = self.departure_ground_legs(tow)\n\n    fuel_taxi_out = dict[\"fuel\"][\"taxi_out\"]\n    time_taxi_out = dict[\"time\"][\"taxi_out\"]\n\n    fuel_take_off = dict[\"fuel\"][\"take_off\"]\n    time_take_off = dict[\"time\"][\"take_off\"]\n\n    # Mission leg\n    #-----------------------------------------------------------------------------------------------------------\n    fuel_mission,time_mission = self.breguet_range(range,tow,ktow,altp,mach,disa)\n\n    mass = tow - (fuel_taxi_out + fuel_take_off + fuel_mission)     # mass is not landing weight\n\n    # Arrival ground legs\n    #-----------------------------------------------------------------------------------------------------------\n    dict = self.arrival_ground_legs(mass)\n\n    fuel_landing = dict[\"fuel\"][\"landing\"]\n    time_landing = dict[\"time\"][\"landing\"]\n\n    fuel_taxi_in = dict[\"fuel\"][\"taxi_in\"]\n    time_taxi_in = dict[\"time\"][\"taxi_in\"]\n\n    # Block fuel and time\n    #-----------------------------------------------------------------------------------------------------------\n    self.fuel_block = fuel_taxi_out + fuel_take_off + fuel_mission + fuel_landing + fuel_taxi_in\n    self.time_block = time_taxi_out + time_take_off + time_mission + time_landing + time_taxi_in\n\n    # Diversion fuel\n    #-----------------------------------------------------------------------------------------------------------\n    fuel_diversion,t = self.breguet_range(self.diversion_range,mass,0.99,altp,mach,disa)\n\n    # Holding fuel\n    #-----------------------------------------------------------------------------------------------------------\n    altp_holding = unit.m_ft(1500.)\n    mach_holding = 0.65 * mach\n    fuel_holding = self.holding(self.holding_time,mass,altp_holding,mach_holding,disa)\n\n    # Total\n    #-----------------------------------------------------------------------------------------------------------\n    self.fuel_reserve = fuel_mission*self.reserve_fuel_ratio + fuel_diversion + fuel_holding\n    self.fuel_total = self.fuel_block + self.fuel_reserve\n\n    #-----------------------------------------------------------------------------------------------------------\n    return\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.MissionVarMassGeneric.eval_payload","title":"eval_payload","text":"<pre><code>eval_payload(owe)\n</code></pre> <p>Computing resulting payload</p> Source code in <code>src/lh2pac/marilib/aircraft/mission.py</code> <pre><code>def eval_payload(self,owe):\n    \"\"\"Computing resulting payload\n    \"\"\"\n    self.payload = self.tow - self.fuel_total - owe\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.MissionVarMassGeneric.eval_sar","title":"eval_sar","text":"<pre><code>eval_sar(altp, mass, mach, disa)\n</code></pre> <p>Evaluate Specific Air Range</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def eval_sar(self,altp,mass,mach,disa):\n    \"\"\"Evaluate Specific Air Range\n    \"\"\"\n    g = earth.gravity()\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    tas = mach * earth.sound_speed(tamb)\n\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    nei = 0\n    thrust = mass*g / lod\n    dict = self.aircraft.power_system.sc(pamb,tamb,mach,\"MCR\",thrust,nei)\n    dict[\"fn\"] = thrust\n    dict[\"cz\"] = cz\n    dict[\"cx\"] = cx\n    dict[\"lod\"] = lod\n    dict[\"sar\"] = self.aircraft.power_system.specific_air_range(mass,tas,dict)\n    return dict\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.MissionVarMassGeneric.get_mach","title":"get_mach","text":"<pre><code>get_mach(pamb, speed_mode, speed)\n</code></pre> <p>Retrieve Mach from CAS or mach depending on speed_mode</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def get_mach(self,pamb,speed_mode,speed):\n    \"\"\"Retrieve Mach from CAS or mach depending on speed_mode\n    \"\"\"\n    mach = {\"cas\" : earth.mach_from_vcas(pamb, speed),  # Input is CAS\n            \"mach\" : speed  # Input is mach\n            }.get(speed_mode, \"Erreur: select speed_mode equal to cas or mach\")\n    return mach\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.MissionVarMassGeneric.get_speed","title":"get_speed","text":"<pre><code>get_speed(pamb, speed_mode, mach)\n</code></pre> <p>retrieve CAS or Mach from mach depending on speed_mode</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def get_speed(self,pamb,speed_mode,mach):\n    \"\"\"retrieve CAS or Mach from mach depending on speed_mode\n    \"\"\"\n    speed = {\"cas\" : earth.vcas_from_mach(pamb, mach),  # CAS required\n             \"mach\" : mach  # mach required\n             }.get(speed_mode, \"Erreur: select speed_mode equal to cas or mach\")\n    return speed\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.MissionVarMassGeneric.get_vcas","title":"get_vcas","text":"<pre><code>get_vcas(pamb, speed_mode, speed)\n</code></pre> <p>Retrieve CAS from Mach or CAS depending on speed_mode</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def get_vcas(self,pamb,speed_mode,speed):\n    \"\"\"Retrieve CAS from Mach or CAS depending on speed_mode\n    \"\"\"\n    cas = {\"mach\" : earth.vcas_from_mach(pamb, speed),  # Input is CAS\n            \"cas\" : speed  # Input is mach\n            }.get(speed_mode, \"Erreur: select speed_mode equal to cas or mach\")\n    return cas\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.MissionVarMassGeneric.holding","title":"holding","text":"<pre><code>holding(time, mass, altp, mach, disa)\n</code></pre> <p>Holding equation is dependant from power architecture</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def holding(self,time,mass,altp,mach,disa):\n    \"\"\"Holding equation is dependant from power architecture\n    \"\"\"\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    tas = mach * earth.sound_speed(tamb)\n    dict = self.level_flight(pamb,tamb,mach,mass)\n    return self.aircraft.power_system.specific_holding(mass,time,tas,dict)\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.MissionVarMassGeneric.level_flight","title":"level_flight","text":"<pre><code>level_flight(pamb, tamb, mach, mass)\n</code></pre> <p>Level flight equilibrium</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def level_flight(self,pamb,tamb,mach,mass):\n    \"\"\"Level flight equilibrium\n    \"\"\"\n    g = earth.gravity()\n    r,gam,Cp,Cv = earth.gas_data()\n    tas = mach * earth.sound_speed(tamb)\n\n    cz = (2.*mass*g)/(gam*pamb*mach**2*self.aircraft.airframe.wing.area)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    thrust = (gam/2.)*pamb*mach**2*self.aircraft.airframe.wing.area*cx\n    dict = self.aircraft.power_system.sc(pamb,tamb,mach,\"MCR\",thrust)\n    dict[\"fn\"] = thrust\n    dict[\"cx\"] = cx\n    dict[\"cz\"] = cz\n    dict[\"lod\"] = lod\n    dict[\"sar\"] = self.aircraft.power_system.specific_air_range(mass,tas,dict)\n    return dict\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.MissionVarMassGeneric.lift_from_speed","title":"lift_from_speed","text":"<pre><code>lift_from_speed(pamb, tamb, mach, mass)\n</code></pre> <p>Retrieve cz from mach using simplified lift equation</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def lift_from_speed(self,pamb,tamb,mach,mass):\n    \"\"\"Retrieve cz from mach using simplified lift equation\n    \"\"\"\n    g = earth.gravity()\n    r,gam,Cp,Cv = earth.gas_data()\n    cz = (2.*mass*g)/(gam*pamb*mach**2*self.aircraft.airframe.wing.area)\n    return cz\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.MissionVarMassGeneric.max_air_path","title":"max_air_path","text":"<pre><code>max_air_path(\n    nei,\n    altp,\n    disa,\n    speed_mode,\n    mass,\n    rating,\n    kfn,\n    full_output=False,\n)\n</code></pre> <p>Optimize the speed of the aircraft to maximize the air path</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def max_air_path(self,nei,altp,disa,speed_mode,mass,rating,kfn, full_output=False):\n    \"\"\"Optimize the speed of the aircraft to maximize the air path\n    \"\"\"\n    def fct(cz):\n        pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n        mach = self.speed_from_lift(pamb,tamb,cz,mass)\n        speed = self.get_speed(pamb,speed_mode,mach)\n        slope,vz = self.air_path(nei,altp,disa,speed_mode,speed,mass,rating,kfn)\n        if isformax: return slope\n        else: return slope,vz,mach\n\n    cz_ini = 0.5\n    dcz = 0.05\n\n    isformax = True\n    cz,slope,rc = maximize_1d(cz_ini,dcz,[fct])\n    isformax = False\n\n    slope,vz,mach = fct(cz)\n    return slope,vz,mach,cz\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.MissionVarMassGeneric.propulsion_ceiling","title":"propulsion_ceiling","text":"<pre><code>propulsion_ceiling(\n    altp_ini,\n    nei,\n    vzreq,\n    disa,\n    speed_mode,\n    speed,\n    mass,\n    rating,\n    throttle,\n)\n</code></pre> <p>Optimize the speed of the aircraft to maximize the air path</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def propulsion_ceiling(self,altp_ini,nei,vzreq,disa,speed_mode,speed,mass,rating,throttle):\n    \"\"\"Optimize the speed of the aircraft to maximize the air path\n    \"\"\"\n    def fct_prop_ceiling(altp,nei,vzreq,disa,speed_mode,speed,mass,rating):\n        slope,vz = self.air_path(nei,altp,disa,speed_mode,speed,mass,rating,throttle)\n        delta_vz = vz - vzreq\n        return delta_vz\n\n    fct_arg = (nei,vzreq,disa,speed_mode,speed,mass,rating)\n\n    output_dict = fsolve(fct_prop_ceiling, x0 = altp_ini, args=fct_arg, full_output = True)\n\n    altp = output_dict[0][0]\n    rei = output_dict[2]\n    if(rei!=1): altp = np.NaN\n\n    return altp, rei\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/mission/#lh2pac.marilib.aircraft.mission.MissionVarMassGeneric.speed_from_lift","title":"speed_from_lift","text":"<pre><code>speed_from_lift(pamb, tamb, cz, mass)\n</code></pre> <p>Retrieve mach from cz using simplified lift equation</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def speed_from_lift(self,pamb,tamb,cz,mass):\n    \"\"\"Retrieve mach from cz using simplified lift equation\n    \"\"\"\n    g = earth.gravity()\n    r,gam,Cp,Cv = earth.gas_data()\n    mach = np.sqrt((mass*g)/(0.5*gam*pamb*self.aircraft.airframe.wing.area*cz))\n    return mach\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/model_config/","title":"Model config","text":""},{"location":"reference/lh2pac/marilib/aircraft/model_config/#lh2pac.marilib.aircraft.model_config","title":"model_config","text":"<p>Created on Thu Jan 20 20:20:20 2020</p> <p>@author: Conceptual Airplane Design &amp; Operations (CADO team)          Nicolas PETEILH, Pascal ROCHES, Nicolas MONROLIN, Thierry DRUOT          Aircraft &amp; Systems, Air Transport Departement, ENAC</p>"},{"location":"reference/lh2pac/marilib/aircraft/model_config_small_plane/","title":"Model config small plane","text":""},{"location":"reference/lh2pac/marilib/aircraft/model_config_small_plane/#lh2pac.marilib.aircraft.model_config_small_plane","title":"model_config_small_plane","text":"<p>Created on Thu Jan 20 20:20:20 2020</p> <p>@author: Conceptual Airplane Design &amp; Operations (CADO team)          Nicolas PETEILH, Pascal ROCHES, Nicolas MONROLIN, Thierry DRUOT          Aircraft &amp; Systems, Air Transport Departement, ENAC</p>"},{"location":"reference/lh2pac/marilib/aircraft/performance/","title":"Performance","text":""},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance","title":"performance","text":"<p>Created on Thu Jan 20 20:20:20 2020</p> <p>@author: Conceptual Airplane Design &amp; Operations (CADO team)          Nicolas PETEILH, Pascal ROCHES, Nicolas MONROLIN, Thierry DRUOT          Aircraft &amp; Systems, Air Transport Departement, ENAC</p>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance-classes","title":"Classes","text":""},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.Approach","title":"Approach","text":"<pre><code>Approach(aircraft)\n</code></pre> <p>               Bases: <code>Flight</code></p> <p>Approach speed</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def __init__(self, aircraft):\n    super(Approach, self).__init__(aircraft)\n\n    self.disa = None\n    self.altp = None\n    self.kmlw = None\n    self.kvs1g = None\n    self.app_speed_req = None\n    self.app_speed_eff = None\n    self.hld_conf = self.aircraft.aerodynamics.hld_conf_ld\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.Approach-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.Approach.acceleration","title":"acceleration","text":"<pre><code>acceleration(\n    nei,\n    altp,\n    disa,\n    speed_mode,\n    speed,\n    mass,\n    rating,\n    throttle,\n    full_output=False,\n)\n</code></pre> <p>Aircraft acceleration on level flight</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def acceleration(self,nei,altp,disa,speed_mode,speed,mass,rating,throttle, full_output=False):\n    \"\"\"Aircraft acceleration on level flight\n    \"\"\"\n    r,gam,Cp,Cv = earth.gas_data()\n\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    mach = self.get_mach(pamb,speed_mode,speed)\n\n    dict = self.aircraft.power_system.thrust(pamb,tamb,mach,rating,throttle=throttle,nei=nei)\n    fn = dict[\"fn\"]\n    ff = dict[\"ff\"]\n\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    if(nei&gt;0):\n        dcx = self.aircraft.power_system.oei_drag(pamb,mach)\n        cx = cx + dcx*nei\n\n    acc = (fn - 0.5*gam*pamb*mach**2*self.aircraft.airframe.wing.area*cx) / mass\n\n    if full_output:\n        return acc,fn,ff,cz,cx,pamb,tamb\n    else:\n        return acc\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.Approach.air_path","title":"air_path","text":"<pre><code>air_path(\n    nei,\n    altp,\n    disa,\n    speed_mode,\n    speed,\n    mass,\n    rating,\n    kfn,\n    full_output=False,\n)\n</code></pre> <p>Retrieve air path in various conditions</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def air_path(self,nei,altp,disa,speed_mode,speed,mass,rating,kfn, full_output=False):\n    \"\"\"Retrieve air path in various conditions\n    \"\"\"\n    g = earth.gravity()\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    mach = self.get_mach(pamb,speed_mode,speed)\n\n    dict = self.aircraft.power_system.thrust(pamb,tamb,mach,rating,nei=nei)\n    fn = dict[\"fn\"]*kfn\n    ff = dict[\"ff\"]*kfn\n    if kfn!=1. and full_output:\n        print(\"WARNING, air_path method, kfn is different from 1, fuel flow may not be accurate\")\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    if(nei&gt;0):\n        dcx = self.aircraft.power_system.oei_drag(pamb,mach)\n        cx = cx + dcx*nei\n        lod = cz/cx\n\n    acc_factor = earth.climb_mode(speed_mode, mach, dtodz, tstd, disa)\n    slope = ( fn/(mass*g) - 1./lod ) / acc_factor\n    vz = slope * mach * earth.sound_speed(tamb)\n    acc = (acc_factor-1.)*g*slope\n    if full_output:\n        return slope,vz,fn,ff,acc,cz,cx,pamb,tamb\n    else:\n        return slope,vz\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.Approach.arrival_ground_legs","title":"arrival_ground_legs","text":"<pre><code>arrival_ground_legs(ldw)\n</code></pre> <p>Compute fuel and time allowances for arrival ground phases</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def arrival_ground_legs(self,ldw):\n    \"\"\"Compute fuel and time allowances for arrival ground phases\n    \"\"\"\n    n_engine = self.aircraft.power_system.n_engine\n    reference_thrust = self.aircraft.power_system.get_reference_thrust()\n    fuel_type = self.aircraft.arrangement.fuel_type\n\n    time_landing = 180.\n    time_taxi_in = 420.\n\n    if fuel_type!=\"battery\":\n        engine_bpr = self.aircraft.airframe.nacelle.engine_bpr\n        fuel_mass_factor = earth.fuel_heat(\"kerosene\") / earth.fuel_heat(fuel_type)\n        fuel_landing = fuel_mass_factor*1e-4*(0.5+2.3/engine_bpr)*ldw\n        fuel_taxi_in = fuel_mass_factor*(26. + 1.8e-4*reference_thrust)*n_engine\n        return {\"fuel\":{\"landing\":fuel_landing,\"taxi_in\":fuel_taxi_in},\n                \"time\":{\"landing\":time_landing,\"taxi_in\":time_taxi_in}}\n    else:\n        enrg_landing = (0.25*43.1e6)*0.75e-4*ldw\n        enrg_taxi_in = (0.25*43.1e6)*(26. + 1.8e-4*reference_thrust)*n_engine\n        return {\"enrg\":{\"landing\":enrg_landing,\"taxi_in\":enrg_taxi_in},\n                \"time\":{\"landing\":time_landing,\"taxi_in\":time_taxi_in}}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.Approach.breguet_range","title":"breguet_range","text":"<pre><code>breguet_range(range, tow, ktow, altp, mach, disa)\n</code></pre> <p>Breguet range equation is dependant from power architecture</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def breguet_range(self,range,tow,ktow,altp,mach,disa):\n    \"\"\"Breguet range equation is dependant from power architecture\n    \"\"\"\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    tas = mach * earth.sound_speed(tamb)\n    time = 1.09*(range/tas)\n\n    dict = self.level_flight(pamb,tamb,mach,tow*ktow)\n    val = self.aircraft.power_system.specific_breguet_range(tow,range,tas,dict)\n    return val,time\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.Approach.departure_ground_legs","title":"departure_ground_legs","text":"<pre><code>departure_ground_legs(tow)\n</code></pre> <p>Compute fuel and time allowances for departure ground phases</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def departure_ground_legs(self,tow):\n    \"\"\"Compute fuel and time allowances for departure ground phases\n    \"\"\"\n    n_engine = self.aircraft.power_system.n_engine\n    reference_thrust = self.aircraft.power_system.get_reference_thrust()\n    fuel_type = self.aircraft.arrangement.fuel_type\n\n    time_taxi_out = 540.\n    time_take_off = 220.*tow/(reference_thrust*n_engine)\n\n    if fuel_type!=\"battery\":\n        engine_bpr = self.aircraft.airframe.nacelle.engine_bpr\n        fuel_mass_factor = earth.fuel_heat(\"kerosene\") / earth.fuel_heat(fuel_type)\n        fuel_taxi_out = fuel_mass_factor*(34. + 2.3e-4*reference_thrust)*n_engine\n        fuel_take_off = fuel_mass_factor*1e-4*(2.8+2.3/engine_bpr)*tow\n        return {\"fuel\":{\"taxi_out\":fuel_taxi_out,\"take_off\":fuel_take_off},\n                \"time\":{\"taxi_out\":time_taxi_out,\"take_off\":time_take_off}}\n    else:\n        enrg_taxi_out = (0.25*43.1e6)*(34. + 2.3e-4*reference_thrust)*n_engine\n        enrg_take_off = (0.25*43.1e6)*3.e-4*tow\n        return {\"enrg\":{\"taxi_out\":enrg_taxi_out,\"take_off\":enrg_take_off},\n                \"time\":{\"taxi_out\":time_taxi_out,\"take_off\":time_take_off}}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.Approach.descent","title":"descent","text":"<pre><code>descent(nei, altp, disa, speed_mode, speed, vz, mass)\n</code></pre> <p>Retrieve air path and flight characteristics in various conditions</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def descent(self,nei,altp,disa,speed_mode,speed,vz,mass):\n    \"\"\"Retrieve air path and flight characteristics in various conditions\n    \"\"\"\n    g = earth.gravity()\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    mach = self.get_mach(pamb,speed_mode,speed)\n\n    slope = vz / (mach * earth.sound_speed(tamb))\n    acc_factor = earth.climb_mode(speed_mode, mach, dtodz, tstd, disa)\n\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    fn = (slope * acc_factor + 1./lod) * (mass*g)\n    dict = self.aircraft.power_system.sc(self,pamb,tamb,mach,\"FID\", fn, nei)\n    ff = dict[\"sfc\"]*fn\n    thtl = dict[\"thtl\"]\n\n    return slope,thtl,fn,ff,cz,cx,pamb,tamb\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.Approach.eval","title":"eval","text":"<pre><code>eval(disa, altp, mass, hld_conf, kvs1g)\n</code></pre> <p>Minimum approach speed (VLS)</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def eval(self,disa,altp,mass,hld_conf,kvs1g):\n    \"\"\"Minimum approach speed (VLS)\n    \"\"\"\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n\n    czmax,cz0 = self.aircraft.airframe.wing.high_lift(hld_conf)\n    cz = czmax / kvs1g**2\n\n    mach = self.speed_from_lift(pamb,tamb,cz,mass)\n    vapp = self.get_speed(pamb,\"cas\",mach)\n\n    w_aoa,_ = self.aircraft.aerodynamics.aoa(mach,cz)\n\n    return {\"vapp\":vapp, \"aoa_wing\":w_aoa}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.Approach.eval_sar","title":"eval_sar","text":"<pre><code>eval_sar(altp, mass, mach, disa)\n</code></pre> <p>Evaluate Specific Air Range</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def eval_sar(self,altp,mass,mach,disa):\n    \"\"\"Evaluate Specific Air Range\n    \"\"\"\n    g = earth.gravity()\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    tas = mach * earth.sound_speed(tamb)\n\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    nei = 0\n    thrust = mass*g / lod\n    dict = self.aircraft.power_system.sc(pamb,tamb,mach,\"MCR\",thrust,nei)\n    dict[\"fn\"] = thrust\n    dict[\"cz\"] = cz\n    dict[\"cx\"] = cx\n    dict[\"lod\"] = lod\n    dict[\"sar\"] = self.aircraft.power_system.specific_air_range(mass,tas,dict)\n    return dict\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.Approach.get_mach","title":"get_mach","text":"<pre><code>get_mach(pamb, speed_mode, speed)\n</code></pre> <p>Retrieve Mach from CAS or mach depending on speed_mode</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def get_mach(self,pamb,speed_mode,speed):\n    \"\"\"Retrieve Mach from CAS or mach depending on speed_mode\n    \"\"\"\n    mach = {\"cas\" : earth.mach_from_vcas(pamb, speed),  # Input is CAS\n            \"mach\" : speed  # Input is mach\n            }.get(speed_mode, \"Erreur: select speed_mode equal to cas or mach\")\n    return mach\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.Approach.get_speed","title":"get_speed","text":"<pre><code>get_speed(pamb, speed_mode, mach)\n</code></pre> <p>retrieve CAS or Mach from mach depending on speed_mode</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def get_speed(self,pamb,speed_mode,mach):\n    \"\"\"retrieve CAS or Mach from mach depending on speed_mode\n    \"\"\"\n    speed = {\"cas\" : earth.vcas_from_mach(pamb, mach),  # CAS required\n             \"mach\" : mach  # mach required\n             }.get(speed_mode, \"Erreur: select speed_mode equal to cas or mach\")\n    return speed\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.Approach.get_vcas","title":"get_vcas","text":"<pre><code>get_vcas(pamb, speed_mode, speed)\n</code></pre> <p>Retrieve CAS from Mach or CAS depending on speed_mode</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def get_vcas(self,pamb,speed_mode,speed):\n    \"\"\"Retrieve CAS from Mach or CAS depending on speed_mode\n    \"\"\"\n    cas = {\"mach\" : earth.vcas_from_mach(pamb, speed),  # Input is CAS\n            \"cas\" : speed  # Input is mach\n            }.get(speed_mode, \"Erreur: select speed_mode equal to cas or mach\")\n    return cas\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.Approach.holding","title":"holding","text":"<pre><code>holding(time, mass, altp, mach, disa)\n</code></pre> <p>Holding equation is dependant from power architecture</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def holding(self,time,mass,altp,mach,disa):\n    \"\"\"Holding equation is dependant from power architecture\n    \"\"\"\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    tas = mach * earth.sound_speed(tamb)\n    dict = self.level_flight(pamb,tamb,mach,mass)\n    return self.aircraft.power_system.specific_holding(mass,time,tas,dict)\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.Approach.level_flight","title":"level_flight","text":"<pre><code>level_flight(pamb, tamb, mach, mass)\n</code></pre> <p>Level flight equilibrium</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def level_flight(self,pamb,tamb,mach,mass):\n    \"\"\"Level flight equilibrium\n    \"\"\"\n    g = earth.gravity()\n    r,gam,Cp,Cv = earth.gas_data()\n    tas = mach * earth.sound_speed(tamb)\n\n    cz = (2.*mass*g)/(gam*pamb*mach**2*self.aircraft.airframe.wing.area)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    thrust = (gam/2.)*pamb*mach**2*self.aircraft.airframe.wing.area*cx\n    dict = self.aircraft.power_system.sc(pamb,tamb,mach,\"MCR\",thrust)\n    dict[\"fn\"] = thrust\n    dict[\"cx\"] = cx\n    dict[\"cz\"] = cz\n    dict[\"lod\"] = lod\n    dict[\"sar\"] = self.aircraft.power_system.specific_air_range(mass,tas,dict)\n    return dict\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.Approach.lift_from_speed","title":"lift_from_speed","text":"<pre><code>lift_from_speed(pamb, tamb, mach, mass)\n</code></pre> <p>Retrieve cz from mach using simplified lift equation</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def lift_from_speed(self,pamb,tamb,mach,mass):\n    \"\"\"Retrieve cz from mach using simplified lift equation\n    \"\"\"\n    g = earth.gravity()\n    r,gam,Cp,Cv = earth.gas_data()\n    cz = (2.*mass*g)/(gam*pamb*mach**2*self.aircraft.airframe.wing.area)\n    return cz\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.Approach.max_air_path","title":"max_air_path","text":"<pre><code>max_air_path(\n    nei,\n    altp,\n    disa,\n    speed_mode,\n    mass,\n    rating,\n    kfn,\n    full_output=False,\n)\n</code></pre> <p>Optimize the speed of the aircraft to maximize the air path</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def max_air_path(self,nei,altp,disa,speed_mode,mass,rating,kfn, full_output=False):\n    \"\"\"Optimize the speed of the aircraft to maximize the air path\n    \"\"\"\n    def fct(cz):\n        pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n        mach = self.speed_from_lift(pamb,tamb,cz,mass)\n        speed = self.get_speed(pamb,speed_mode,mach)\n        slope,vz = self.air_path(nei,altp,disa,speed_mode,speed,mass,rating,kfn)\n        if isformax: return slope\n        else: return slope,vz,mach\n\n    cz_ini = 0.5\n    dcz = 0.05\n\n    isformax = True\n    cz,slope,rc = maximize_1d(cz_ini,dcz,[fct])\n    isformax = False\n\n    slope,vz,mach = fct(cz)\n    return slope,vz,mach,cz\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.Approach.propulsion_ceiling","title":"propulsion_ceiling","text":"<pre><code>propulsion_ceiling(\n    altp_ini,\n    nei,\n    vzreq,\n    disa,\n    speed_mode,\n    speed,\n    mass,\n    rating,\n    throttle,\n)\n</code></pre> <p>Optimize the speed of the aircraft to maximize the air path</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def propulsion_ceiling(self,altp_ini,nei,vzreq,disa,speed_mode,speed,mass,rating,throttle):\n    \"\"\"Optimize the speed of the aircraft to maximize the air path\n    \"\"\"\n    def fct_prop_ceiling(altp,nei,vzreq,disa,speed_mode,speed,mass,rating):\n        slope,vz = self.air_path(nei,altp,disa,speed_mode,speed,mass,rating,throttle)\n        delta_vz = vz - vzreq\n        return delta_vz\n\n    fct_arg = (nei,vzreq,disa,speed_mode,speed,mass,rating)\n\n    output_dict = fsolve(fct_prop_ceiling, x0 = altp_ini, args=fct_arg, full_output = True)\n\n    altp = output_dict[0][0]\n    rei = output_dict[2]\n    if(rei!=1): altp = np.NaN\n\n    return altp, rei\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.Approach.speed_from_lift","title":"speed_from_lift","text":"<pre><code>speed_from_lift(pamb, tamb, cz, mass)\n</code></pre> <p>Retrieve mach from cz using simplified lift equation</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def speed_from_lift(self,pamb,tamb,cz,mass):\n    \"\"\"Retrieve mach from cz using simplified lift equation\n    \"\"\"\n    g = earth.gravity()\n    r,gam,Cp,Cv = earth.gas_data()\n    mach = np.sqrt((mass*g)/(0.5*gam*pamb*self.aircraft.airframe.wing.area*cz))\n    return mach\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.Flight","title":"Flight","text":"<pre><code>Flight(aircraft)\n</code></pre> <p>               Bases: <code>object</code></p> <p>Usefull methods for all simulation</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def __init__(self, aircraft):\n    self.aircraft = aircraft\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.Flight-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.Flight.acceleration","title":"acceleration","text":"<pre><code>acceleration(\n    nei,\n    altp,\n    disa,\n    speed_mode,\n    speed,\n    mass,\n    rating,\n    throttle,\n    full_output=False,\n)\n</code></pre> <p>Aircraft acceleration on level flight</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def acceleration(self,nei,altp,disa,speed_mode,speed,mass,rating,throttle, full_output=False):\n    \"\"\"Aircraft acceleration on level flight\n    \"\"\"\n    r,gam,Cp,Cv = earth.gas_data()\n\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    mach = self.get_mach(pamb,speed_mode,speed)\n\n    dict = self.aircraft.power_system.thrust(pamb,tamb,mach,rating,throttle=throttle,nei=nei)\n    fn = dict[\"fn\"]\n    ff = dict[\"ff\"]\n\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    if(nei&gt;0):\n        dcx = self.aircraft.power_system.oei_drag(pamb,mach)\n        cx = cx + dcx*nei\n\n    acc = (fn - 0.5*gam*pamb*mach**2*self.aircraft.airframe.wing.area*cx) / mass\n\n    if full_output:\n        return acc,fn,ff,cz,cx,pamb,tamb\n    else:\n        return acc\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.Flight.air_path","title":"air_path","text":"<pre><code>air_path(\n    nei,\n    altp,\n    disa,\n    speed_mode,\n    speed,\n    mass,\n    rating,\n    kfn,\n    full_output=False,\n)\n</code></pre> <p>Retrieve air path in various conditions</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def air_path(self,nei,altp,disa,speed_mode,speed,mass,rating,kfn, full_output=False):\n    \"\"\"Retrieve air path in various conditions\n    \"\"\"\n    g = earth.gravity()\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    mach = self.get_mach(pamb,speed_mode,speed)\n\n    dict = self.aircraft.power_system.thrust(pamb,tamb,mach,rating,nei=nei)\n    fn = dict[\"fn\"]*kfn\n    ff = dict[\"ff\"]*kfn\n    if kfn!=1. and full_output:\n        print(\"WARNING, air_path method, kfn is different from 1, fuel flow may not be accurate\")\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    if(nei&gt;0):\n        dcx = self.aircraft.power_system.oei_drag(pamb,mach)\n        cx = cx + dcx*nei\n        lod = cz/cx\n\n    acc_factor = earth.climb_mode(speed_mode, mach, dtodz, tstd, disa)\n    slope = ( fn/(mass*g) - 1./lod ) / acc_factor\n    vz = slope * mach * earth.sound_speed(tamb)\n    acc = (acc_factor-1.)*g*slope\n    if full_output:\n        return slope,vz,fn,ff,acc,cz,cx,pamb,tamb\n    else:\n        return slope,vz\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.Flight.arrival_ground_legs","title":"arrival_ground_legs","text":"<pre><code>arrival_ground_legs(ldw)\n</code></pre> <p>Compute fuel and time allowances for arrival ground phases</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def arrival_ground_legs(self,ldw):\n    \"\"\"Compute fuel and time allowances for arrival ground phases\n    \"\"\"\n    n_engine = self.aircraft.power_system.n_engine\n    reference_thrust = self.aircraft.power_system.get_reference_thrust()\n    fuel_type = self.aircraft.arrangement.fuel_type\n\n    time_landing = 180.\n    time_taxi_in = 420.\n\n    if fuel_type!=\"battery\":\n        engine_bpr = self.aircraft.airframe.nacelle.engine_bpr\n        fuel_mass_factor = earth.fuel_heat(\"kerosene\") / earth.fuel_heat(fuel_type)\n        fuel_landing = fuel_mass_factor*1e-4*(0.5+2.3/engine_bpr)*ldw\n        fuel_taxi_in = fuel_mass_factor*(26. + 1.8e-4*reference_thrust)*n_engine\n        return {\"fuel\":{\"landing\":fuel_landing,\"taxi_in\":fuel_taxi_in},\n                \"time\":{\"landing\":time_landing,\"taxi_in\":time_taxi_in}}\n    else:\n        enrg_landing = (0.25*43.1e6)*0.75e-4*ldw\n        enrg_taxi_in = (0.25*43.1e6)*(26. + 1.8e-4*reference_thrust)*n_engine\n        return {\"enrg\":{\"landing\":enrg_landing,\"taxi_in\":enrg_taxi_in},\n                \"time\":{\"landing\":time_landing,\"taxi_in\":time_taxi_in}}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.Flight.breguet_range","title":"breguet_range","text":"<pre><code>breguet_range(range, tow, ktow, altp, mach, disa)\n</code></pre> <p>Breguet range equation is dependant from power architecture</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def breguet_range(self,range,tow,ktow,altp,mach,disa):\n    \"\"\"Breguet range equation is dependant from power architecture\n    \"\"\"\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    tas = mach * earth.sound_speed(tamb)\n    time = 1.09*(range/tas)\n\n    dict = self.level_flight(pamb,tamb,mach,tow*ktow)\n    val = self.aircraft.power_system.specific_breguet_range(tow,range,tas,dict)\n    return val,time\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.Flight.departure_ground_legs","title":"departure_ground_legs","text":"<pre><code>departure_ground_legs(tow)\n</code></pre> <p>Compute fuel and time allowances for departure ground phases</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def departure_ground_legs(self,tow):\n    \"\"\"Compute fuel and time allowances for departure ground phases\n    \"\"\"\n    n_engine = self.aircraft.power_system.n_engine\n    reference_thrust = self.aircraft.power_system.get_reference_thrust()\n    fuel_type = self.aircraft.arrangement.fuel_type\n\n    time_taxi_out = 540.\n    time_take_off = 220.*tow/(reference_thrust*n_engine)\n\n    if fuel_type!=\"battery\":\n        engine_bpr = self.aircraft.airframe.nacelle.engine_bpr\n        fuel_mass_factor = earth.fuel_heat(\"kerosene\") / earth.fuel_heat(fuel_type)\n        fuel_taxi_out = fuel_mass_factor*(34. + 2.3e-4*reference_thrust)*n_engine\n        fuel_take_off = fuel_mass_factor*1e-4*(2.8+2.3/engine_bpr)*tow\n        return {\"fuel\":{\"taxi_out\":fuel_taxi_out,\"take_off\":fuel_take_off},\n                \"time\":{\"taxi_out\":time_taxi_out,\"take_off\":time_take_off}}\n    else:\n        enrg_taxi_out = (0.25*43.1e6)*(34. + 2.3e-4*reference_thrust)*n_engine\n        enrg_take_off = (0.25*43.1e6)*3.e-4*tow\n        return {\"enrg\":{\"taxi_out\":enrg_taxi_out,\"take_off\":enrg_take_off},\n                \"time\":{\"taxi_out\":time_taxi_out,\"take_off\":time_take_off}}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.Flight.descent","title":"descent","text":"<pre><code>descent(nei, altp, disa, speed_mode, speed, vz, mass)\n</code></pre> <p>Retrieve air path and flight characteristics in various conditions</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def descent(self,nei,altp,disa,speed_mode,speed,vz,mass):\n    \"\"\"Retrieve air path and flight characteristics in various conditions\n    \"\"\"\n    g = earth.gravity()\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    mach = self.get_mach(pamb,speed_mode,speed)\n\n    slope = vz / (mach * earth.sound_speed(tamb))\n    acc_factor = earth.climb_mode(speed_mode, mach, dtodz, tstd, disa)\n\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    fn = (slope * acc_factor + 1./lod) * (mass*g)\n    dict = self.aircraft.power_system.sc(self,pamb,tamb,mach,\"FID\", fn, nei)\n    ff = dict[\"sfc\"]*fn\n    thtl = dict[\"thtl\"]\n\n    return slope,thtl,fn,ff,cz,cx,pamb,tamb\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.Flight.eval_sar","title":"eval_sar","text":"<pre><code>eval_sar(altp, mass, mach, disa)\n</code></pre> <p>Evaluate Specific Air Range</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def eval_sar(self,altp,mass,mach,disa):\n    \"\"\"Evaluate Specific Air Range\n    \"\"\"\n    g = earth.gravity()\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    tas = mach * earth.sound_speed(tamb)\n\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    nei = 0\n    thrust = mass*g / lod\n    dict = self.aircraft.power_system.sc(pamb,tamb,mach,\"MCR\",thrust,nei)\n    dict[\"fn\"] = thrust\n    dict[\"cz\"] = cz\n    dict[\"cx\"] = cx\n    dict[\"lod\"] = lod\n    dict[\"sar\"] = self.aircraft.power_system.specific_air_range(mass,tas,dict)\n    return dict\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.Flight.get_mach","title":"get_mach","text":"<pre><code>get_mach(pamb, speed_mode, speed)\n</code></pre> <p>Retrieve Mach from CAS or mach depending on speed_mode</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def get_mach(self,pamb,speed_mode,speed):\n    \"\"\"Retrieve Mach from CAS or mach depending on speed_mode\n    \"\"\"\n    mach = {\"cas\" : earth.mach_from_vcas(pamb, speed),  # Input is CAS\n            \"mach\" : speed  # Input is mach\n            }.get(speed_mode, \"Erreur: select speed_mode equal to cas or mach\")\n    return mach\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.Flight.get_speed","title":"get_speed","text":"<pre><code>get_speed(pamb, speed_mode, mach)\n</code></pre> <p>retrieve CAS or Mach from mach depending on speed_mode</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def get_speed(self,pamb,speed_mode,mach):\n    \"\"\"retrieve CAS or Mach from mach depending on speed_mode\n    \"\"\"\n    speed = {\"cas\" : earth.vcas_from_mach(pamb, mach),  # CAS required\n             \"mach\" : mach  # mach required\n             }.get(speed_mode, \"Erreur: select speed_mode equal to cas or mach\")\n    return speed\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.Flight.get_vcas","title":"get_vcas","text":"<pre><code>get_vcas(pamb, speed_mode, speed)\n</code></pre> <p>Retrieve CAS from Mach or CAS depending on speed_mode</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def get_vcas(self,pamb,speed_mode,speed):\n    \"\"\"Retrieve CAS from Mach or CAS depending on speed_mode\n    \"\"\"\n    cas = {\"mach\" : earth.vcas_from_mach(pamb, speed),  # Input is CAS\n            \"cas\" : speed  # Input is mach\n            }.get(speed_mode, \"Erreur: select speed_mode equal to cas or mach\")\n    return cas\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.Flight.holding","title":"holding","text":"<pre><code>holding(time, mass, altp, mach, disa)\n</code></pre> <p>Holding equation is dependant from power architecture</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def holding(self,time,mass,altp,mach,disa):\n    \"\"\"Holding equation is dependant from power architecture\n    \"\"\"\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    tas = mach * earth.sound_speed(tamb)\n    dict = self.level_flight(pamb,tamb,mach,mass)\n    return self.aircraft.power_system.specific_holding(mass,time,tas,dict)\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.Flight.level_flight","title":"level_flight","text":"<pre><code>level_flight(pamb, tamb, mach, mass)\n</code></pre> <p>Level flight equilibrium</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def level_flight(self,pamb,tamb,mach,mass):\n    \"\"\"Level flight equilibrium\n    \"\"\"\n    g = earth.gravity()\n    r,gam,Cp,Cv = earth.gas_data()\n    tas = mach * earth.sound_speed(tamb)\n\n    cz = (2.*mass*g)/(gam*pamb*mach**2*self.aircraft.airframe.wing.area)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    thrust = (gam/2.)*pamb*mach**2*self.aircraft.airframe.wing.area*cx\n    dict = self.aircraft.power_system.sc(pamb,tamb,mach,\"MCR\",thrust)\n    dict[\"fn\"] = thrust\n    dict[\"cx\"] = cx\n    dict[\"cz\"] = cz\n    dict[\"lod\"] = lod\n    dict[\"sar\"] = self.aircraft.power_system.specific_air_range(mass,tas,dict)\n    return dict\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.Flight.lift_from_speed","title":"lift_from_speed","text":"<pre><code>lift_from_speed(pamb, tamb, mach, mass)\n</code></pre> <p>Retrieve cz from mach using simplified lift equation</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def lift_from_speed(self,pamb,tamb,mach,mass):\n    \"\"\"Retrieve cz from mach using simplified lift equation\n    \"\"\"\n    g = earth.gravity()\n    r,gam,Cp,Cv = earth.gas_data()\n    cz = (2.*mass*g)/(gam*pamb*mach**2*self.aircraft.airframe.wing.area)\n    return cz\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.Flight.max_air_path","title":"max_air_path","text":"<pre><code>max_air_path(\n    nei,\n    altp,\n    disa,\n    speed_mode,\n    mass,\n    rating,\n    kfn,\n    full_output=False,\n)\n</code></pre> <p>Optimize the speed of the aircraft to maximize the air path</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def max_air_path(self,nei,altp,disa,speed_mode,mass,rating,kfn, full_output=False):\n    \"\"\"Optimize the speed of the aircraft to maximize the air path\n    \"\"\"\n    def fct(cz):\n        pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n        mach = self.speed_from_lift(pamb,tamb,cz,mass)\n        speed = self.get_speed(pamb,speed_mode,mach)\n        slope,vz = self.air_path(nei,altp,disa,speed_mode,speed,mass,rating,kfn)\n        if isformax: return slope\n        else: return slope,vz,mach\n\n    cz_ini = 0.5\n    dcz = 0.05\n\n    isformax = True\n    cz,slope,rc = maximize_1d(cz_ini,dcz,[fct])\n    isformax = False\n\n    slope,vz,mach = fct(cz)\n    return slope,vz,mach,cz\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.Flight.propulsion_ceiling","title":"propulsion_ceiling","text":"<pre><code>propulsion_ceiling(\n    altp_ini,\n    nei,\n    vzreq,\n    disa,\n    speed_mode,\n    speed,\n    mass,\n    rating,\n    throttle,\n)\n</code></pre> <p>Optimize the speed of the aircraft to maximize the air path</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def propulsion_ceiling(self,altp_ini,nei,vzreq,disa,speed_mode,speed,mass,rating,throttle):\n    \"\"\"Optimize the speed of the aircraft to maximize the air path\n    \"\"\"\n    def fct_prop_ceiling(altp,nei,vzreq,disa,speed_mode,speed,mass,rating):\n        slope,vz = self.air_path(nei,altp,disa,speed_mode,speed,mass,rating,throttle)\n        delta_vz = vz - vzreq\n        return delta_vz\n\n    fct_arg = (nei,vzreq,disa,speed_mode,speed,mass,rating)\n\n    output_dict = fsolve(fct_prop_ceiling, x0 = altp_ini, args=fct_arg, full_output = True)\n\n    altp = output_dict[0][0]\n    rei = output_dict[2]\n    if(rei!=1): altp = np.NaN\n\n    return altp, rei\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.Flight.speed_from_lift","title":"speed_from_lift","text":"<pre><code>speed_from_lift(pamb, tamb, cz, mass)\n</code></pre> <p>Retrieve mach from cz using simplified lift equation</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def speed_from_lift(self,pamb,tamb,cz,mass):\n    \"\"\"Retrieve mach from cz using simplified lift equation\n    \"\"\"\n    g = earth.gravity()\n    r,gam,Cp,Cv = earth.gas_data()\n    mach = np.sqrt((mass*g)/(0.5*gam*pamb*self.aircraft.airframe.wing.area*cz))\n    return mach\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.MclCeiling","title":"MclCeiling","text":"<pre><code>MclCeiling(aircraft)\n</code></pre> <p>               Bases: <code>Flight</code></p> <p>Propulsion ceiling in MCL rating</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def __init__(self, aircraft):\n    super(MclCeiling, self).__init__(aircraft)\n\n    self.disa = None\n    self.altp = None\n    self.mach = None\n    self.kmtow = None\n    self.rating = None\n    self.speed_mode = None\n    self.vz_req = None\n    self.vz_eff = None\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.MclCeiling-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.MclCeiling.acceleration","title":"acceleration","text":"<pre><code>acceleration(\n    nei,\n    altp,\n    disa,\n    speed_mode,\n    speed,\n    mass,\n    rating,\n    throttle,\n    full_output=False,\n)\n</code></pre> <p>Aircraft acceleration on level flight</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def acceleration(self,nei,altp,disa,speed_mode,speed,mass,rating,throttle, full_output=False):\n    \"\"\"Aircraft acceleration on level flight\n    \"\"\"\n    r,gam,Cp,Cv = earth.gas_data()\n\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    mach = self.get_mach(pamb,speed_mode,speed)\n\n    dict = self.aircraft.power_system.thrust(pamb,tamb,mach,rating,throttle=throttle,nei=nei)\n    fn = dict[\"fn\"]\n    ff = dict[\"ff\"]\n\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    if(nei&gt;0):\n        dcx = self.aircraft.power_system.oei_drag(pamb,mach)\n        cx = cx + dcx*nei\n\n    acc = (fn - 0.5*gam*pamb*mach**2*self.aircraft.airframe.wing.area*cx) / mass\n\n    if full_output:\n        return acc,fn,ff,cz,cx,pamb,tamb\n    else:\n        return acc\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.MclCeiling.air_path","title":"air_path","text":"<pre><code>air_path(\n    nei,\n    altp,\n    disa,\n    speed_mode,\n    speed,\n    mass,\n    rating,\n    kfn,\n    full_output=False,\n)\n</code></pre> <p>Retrieve air path in various conditions</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def air_path(self,nei,altp,disa,speed_mode,speed,mass,rating,kfn, full_output=False):\n    \"\"\"Retrieve air path in various conditions\n    \"\"\"\n    g = earth.gravity()\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    mach = self.get_mach(pamb,speed_mode,speed)\n\n    dict = self.aircraft.power_system.thrust(pamb,tamb,mach,rating,nei=nei)\n    fn = dict[\"fn\"]*kfn\n    ff = dict[\"ff\"]*kfn\n    if kfn!=1. and full_output:\n        print(\"WARNING, air_path method, kfn is different from 1, fuel flow may not be accurate\")\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    if(nei&gt;0):\n        dcx = self.aircraft.power_system.oei_drag(pamb,mach)\n        cx = cx + dcx*nei\n        lod = cz/cx\n\n    acc_factor = earth.climb_mode(speed_mode, mach, dtodz, tstd, disa)\n    slope = ( fn/(mass*g) - 1./lod ) / acc_factor\n    vz = slope * mach * earth.sound_speed(tamb)\n    acc = (acc_factor-1.)*g*slope\n    if full_output:\n        return slope,vz,fn,ff,acc,cz,cx,pamb,tamb\n    else:\n        return slope,vz\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.MclCeiling.arrival_ground_legs","title":"arrival_ground_legs","text":"<pre><code>arrival_ground_legs(ldw)\n</code></pre> <p>Compute fuel and time allowances for arrival ground phases</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def arrival_ground_legs(self,ldw):\n    \"\"\"Compute fuel and time allowances for arrival ground phases\n    \"\"\"\n    n_engine = self.aircraft.power_system.n_engine\n    reference_thrust = self.aircraft.power_system.get_reference_thrust()\n    fuel_type = self.aircraft.arrangement.fuel_type\n\n    time_landing = 180.\n    time_taxi_in = 420.\n\n    if fuel_type!=\"battery\":\n        engine_bpr = self.aircraft.airframe.nacelle.engine_bpr\n        fuel_mass_factor = earth.fuel_heat(\"kerosene\") / earth.fuel_heat(fuel_type)\n        fuel_landing = fuel_mass_factor*1e-4*(0.5+2.3/engine_bpr)*ldw\n        fuel_taxi_in = fuel_mass_factor*(26. + 1.8e-4*reference_thrust)*n_engine\n        return {\"fuel\":{\"landing\":fuel_landing,\"taxi_in\":fuel_taxi_in},\n                \"time\":{\"landing\":time_landing,\"taxi_in\":time_taxi_in}}\n    else:\n        enrg_landing = (0.25*43.1e6)*0.75e-4*ldw\n        enrg_taxi_in = (0.25*43.1e6)*(26. + 1.8e-4*reference_thrust)*n_engine\n        return {\"enrg\":{\"landing\":enrg_landing,\"taxi_in\":enrg_taxi_in},\n                \"time\":{\"landing\":time_landing,\"taxi_in\":time_taxi_in}}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.MclCeiling.breguet_range","title":"breguet_range","text":"<pre><code>breguet_range(range, tow, ktow, altp, mach, disa)\n</code></pre> <p>Breguet range equation is dependant from power architecture</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def breguet_range(self,range,tow,ktow,altp,mach,disa):\n    \"\"\"Breguet range equation is dependant from power architecture\n    \"\"\"\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    tas = mach * earth.sound_speed(tamb)\n    time = 1.09*(range/tas)\n\n    dict = self.level_flight(pamb,tamb,mach,tow*ktow)\n    val = self.aircraft.power_system.specific_breguet_range(tow,range,tas,dict)\n    return val,time\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.MclCeiling.departure_ground_legs","title":"departure_ground_legs","text":"<pre><code>departure_ground_legs(tow)\n</code></pre> <p>Compute fuel and time allowances for departure ground phases</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def departure_ground_legs(self,tow):\n    \"\"\"Compute fuel and time allowances for departure ground phases\n    \"\"\"\n    n_engine = self.aircraft.power_system.n_engine\n    reference_thrust = self.aircraft.power_system.get_reference_thrust()\n    fuel_type = self.aircraft.arrangement.fuel_type\n\n    time_taxi_out = 540.\n    time_take_off = 220.*tow/(reference_thrust*n_engine)\n\n    if fuel_type!=\"battery\":\n        engine_bpr = self.aircraft.airframe.nacelle.engine_bpr\n        fuel_mass_factor = earth.fuel_heat(\"kerosene\") / earth.fuel_heat(fuel_type)\n        fuel_taxi_out = fuel_mass_factor*(34. + 2.3e-4*reference_thrust)*n_engine\n        fuel_take_off = fuel_mass_factor*1e-4*(2.8+2.3/engine_bpr)*tow\n        return {\"fuel\":{\"taxi_out\":fuel_taxi_out,\"take_off\":fuel_take_off},\n                \"time\":{\"taxi_out\":time_taxi_out,\"take_off\":time_take_off}}\n    else:\n        enrg_taxi_out = (0.25*43.1e6)*(34. + 2.3e-4*reference_thrust)*n_engine\n        enrg_take_off = (0.25*43.1e6)*3.e-4*tow\n        return {\"enrg\":{\"taxi_out\":enrg_taxi_out,\"take_off\":enrg_take_off},\n                \"time\":{\"taxi_out\":time_taxi_out,\"take_off\":time_take_off}}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.MclCeiling.descent","title":"descent","text":"<pre><code>descent(nei, altp, disa, speed_mode, speed, vz, mass)\n</code></pre> <p>Retrieve air path and flight characteristics in various conditions</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def descent(self,nei,altp,disa,speed_mode,speed,vz,mass):\n    \"\"\"Retrieve air path and flight characteristics in various conditions\n    \"\"\"\n    g = earth.gravity()\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    mach = self.get_mach(pamb,speed_mode,speed)\n\n    slope = vz / (mach * earth.sound_speed(tamb))\n    acc_factor = earth.climb_mode(speed_mode, mach, dtodz, tstd, disa)\n\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    fn = (slope * acc_factor + 1./lod) * (mass*g)\n    dict = self.aircraft.power_system.sc(self,pamb,tamb,mach,\"FID\", fn, nei)\n    ff = dict[\"sfc\"]*fn\n    thtl = dict[\"thtl\"]\n\n    return slope,thtl,fn,ff,cz,cx,pamb,tamb\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.MclCeiling.eval","title":"eval","text":"<pre><code>eval(disa, altp, mach, mass, rating, kfn, speed_mode)\n</code></pre> <p>Residual climb speed in MCL rating</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def eval(self,disa,altp,mach,mass,rating,kfn,speed_mode):\n    \"\"\"Residual climb speed in MCL rating\n    \"\"\"\n    nei = 0\n    pamb,tamb,tstd,dtodz = earth.atmosphere(self.altp, self.disa)\n    speed = self.get_speed(pamb,self.speed_mode,self.mach)\n    slope,vz,fn,ff,acc,cz,cx,pamb,tamb = self.air_path(nei,altp,disa,speed_mode,speed,mass,rating,kfn, full_output=True)\n    w_aoa,_ = self.aircraft.aerodynamics.aoa(self.mach,cz)\n    return {\"vz\":vz, \"slope\":slope, \"aoa_wing\":w_aoa}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.MclCeiling.eval_sar","title":"eval_sar","text":"<pre><code>eval_sar(altp, mass, mach, disa)\n</code></pre> <p>Evaluate Specific Air Range</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def eval_sar(self,altp,mass,mach,disa):\n    \"\"\"Evaluate Specific Air Range\n    \"\"\"\n    g = earth.gravity()\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    tas = mach * earth.sound_speed(tamb)\n\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    nei = 0\n    thrust = mass*g / lod\n    dict = self.aircraft.power_system.sc(pamb,tamb,mach,\"MCR\",thrust,nei)\n    dict[\"fn\"] = thrust\n    dict[\"cz\"] = cz\n    dict[\"cx\"] = cx\n    dict[\"lod\"] = lod\n    dict[\"sar\"] = self.aircraft.power_system.specific_air_range(mass,tas,dict)\n    return dict\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.MclCeiling.get_mach","title":"get_mach","text":"<pre><code>get_mach(pamb, speed_mode, speed)\n</code></pre> <p>Retrieve Mach from CAS or mach depending on speed_mode</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def get_mach(self,pamb,speed_mode,speed):\n    \"\"\"Retrieve Mach from CAS or mach depending on speed_mode\n    \"\"\"\n    mach = {\"cas\" : earth.mach_from_vcas(pamb, speed),  # Input is CAS\n            \"mach\" : speed  # Input is mach\n            }.get(speed_mode, \"Erreur: select speed_mode equal to cas or mach\")\n    return mach\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.MclCeiling.get_speed","title":"get_speed","text":"<pre><code>get_speed(pamb, speed_mode, mach)\n</code></pre> <p>retrieve CAS or Mach from mach depending on speed_mode</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def get_speed(self,pamb,speed_mode,mach):\n    \"\"\"retrieve CAS or Mach from mach depending on speed_mode\n    \"\"\"\n    speed = {\"cas\" : earth.vcas_from_mach(pamb, mach),  # CAS required\n             \"mach\" : mach  # mach required\n             }.get(speed_mode, \"Erreur: select speed_mode equal to cas or mach\")\n    return speed\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.MclCeiling.get_vcas","title":"get_vcas","text":"<pre><code>get_vcas(pamb, speed_mode, speed)\n</code></pre> <p>Retrieve CAS from Mach or CAS depending on speed_mode</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def get_vcas(self,pamb,speed_mode,speed):\n    \"\"\"Retrieve CAS from Mach or CAS depending on speed_mode\n    \"\"\"\n    cas = {\"mach\" : earth.vcas_from_mach(pamb, speed),  # Input is CAS\n            \"cas\" : speed  # Input is mach\n            }.get(speed_mode, \"Erreur: select speed_mode equal to cas or mach\")\n    return cas\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.MclCeiling.holding","title":"holding","text":"<pre><code>holding(time, mass, altp, mach, disa)\n</code></pre> <p>Holding equation is dependant from power architecture</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def holding(self,time,mass,altp,mach,disa):\n    \"\"\"Holding equation is dependant from power architecture\n    \"\"\"\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    tas = mach * earth.sound_speed(tamb)\n    dict = self.level_flight(pamb,tamb,mach,mass)\n    return self.aircraft.power_system.specific_holding(mass,time,tas,dict)\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.MclCeiling.level_flight","title":"level_flight","text":"<pre><code>level_flight(pamb, tamb, mach, mass)\n</code></pre> <p>Level flight equilibrium</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def level_flight(self,pamb,tamb,mach,mass):\n    \"\"\"Level flight equilibrium\n    \"\"\"\n    g = earth.gravity()\n    r,gam,Cp,Cv = earth.gas_data()\n    tas = mach * earth.sound_speed(tamb)\n\n    cz = (2.*mass*g)/(gam*pamb*mach**2*self.aircraft.airframe.wing.area)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    thrust = (gam/2.)*pamb*mach**2*self.aircraft.airframe.wing.area*cx\n    dict = self.aircraft.power_system.sc(pamb,tamb,mach,\"MCR\",thrust)\n    dict[\"fn\"] = thrust\n    dict[\"cx\"] = cx\n    dict[\"cz\"] = cz\n    dict[\"lod\"] = lod\n    dict[\"sar\"] = self.aircraft.power_system.specific_air_range(mass,tas,dict)\n    return dict\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.MclCeiling.lift_from_speed","title":"lift_from_speed","text":"<pre><code>lift_from_speed(pamb, tamb, mach, mass)\n</code></pre> <p>Retrieve cz from mach using simplified lift equation</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def lift_from_speed(self,pamb,tamb,mach,mass):\n    \"\"\"Retrieve cz from mach using simplified lift equation\n    \"\"\"\n    g = earth.gravity()\n    r,gam,Cp,Cv = earth.gas_data()\n    cz = (2.*mass*g)/(gam*pamb*mach**2*self.aircraft.airframe.wing.area)\n    return cz\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.MclCeiling.max_air_path","title":"max_air_path","text":"<pre><code>max_air_path(\n    nei,\n    altp,\n    disa,\n    speed_mode,\n    mass,\n    rating,\n    kfn,\n    full_output=False,\n)\n</code></pre> <p>Optimize the speed of the aircraft to maximize the air path</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def max_air_path(self,nei,altp,disa,speed_mode,mass,rating,kfn, full_output=False):\n    \"\"\"Optimize the speed of the aircraft to maximize the air path\n    \"\"\"\n    def fct(cz):\n        pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n        mach = self.speed_from_lift(pamb,tamb,cz,mass)\n        speed = self.get_speed(pamb,speed_mode,mach)\n        slope,vz = self.air_path(nei,altp,disa,speed_mode,speed,mass,rating,kfn)\n        if isformax: return slope\n        else: return slope,vz,mach\n\n    cz_ini = 0.5\n    dcz = 0.05\n\n    isformax = True\n    cz,slope,rc = maximize_1d(cz_ini,dcz,[fct])\n    isformax = False\n\n    slope,vz,mach = fct(cz)\n    return slope,vz,mach,cz\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.MclCeiling.propulsion_ceiling","title":"propulsion_ceiling","text":"<pre><code>propulsion_ceiling(\n    altp_ini,\n    nei,\n    vzreq,\n    disa,\n    speed_mode,\n    speed,\n    mass,\n    rating,\n    throttle,\n)\n</code></pre> <p>Optimize the speed of the aircraft to maximize the air path</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def propulsion_ceiling(self,altp_ini,nei,vzreq,disa,speed_mode,speed,mass,rating,throttle):\n    \"\"\"Optimize the speed of the aircraft to maximize the air path\n    \"\"\"\n    def fct_prop_ceiling(altp,nei,vzreq,disa,speed_mode,speed,mass,rating):\n        slope,vz = self.air_path(nei,altp,disa,speed_mode,speed,mass,rating,throttle)\n        delta_vz = vz - vzreq\n        return delta_vz\n\n    fct_arg = (nei,vzreq,disa,speed_mode,speed,mass,rating)\n\n    output_dict = fsolve(fct_prop_ceiling, x0 = altp_ini, args=fct_arg, full_output = True)\n\n    altp = output_dict[0][0]\n    rei = output_dict[2]\n    if(rei!=1): altp = np.NaN\n\n    return altp, rei\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.MclCeiling.speed_from_lift","title":"speed_from_lift","text":"<pre><code>speed_from_lift(pamb, tamb, cz, mass)\n</code></pre> <p>Retrieve mach from cz using simplified lift equation</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def speed_from_lift(self,pamb,tamb,cz,mass):\n    \"\"\"Retrieve mach from cz using simplified lift equation\n    \"\"\"\n    g = earth.gravity()\n    r,gam,Cp,Cv = earth.gas_data()\n    mach = np.sqrt((mass*g)/(0.5*gam*pamb*self.aircraft.airframe.wing.area*cz))\n    return mach\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.McrCeiling","title":"McrCeiling","text":"<pre><code>McrCeiling(aircraft)\n</code></pre> <p>               Bases: <code>Flight</code></p> <p>Propulsion ceiling in MCR rating</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def __init__(self, aircraft):\n    super(McrCeiling, self).__init__(aircraft)\n\n    self.disa = None\n    self.altp = None\n    self.mach = None\n    self.kmtow = None\n    self.rating = None\n    self.speed_mode = None\n    self.vz_req = None\n    self.vz_eff = None\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.McrCeiling-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.McrCeiling.acceleration","title":"acceleration","text":"<pre><code>acceleration(\n    nei,\n    altp,\n    disa,\n    speed_mode,\n    speed,\n    mass,\n    rating,\n    throttle,\n    full_output=False,\n)\n</code></pre> <p>Aircraft acceleration on level flight</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def acceleration(self,nei,altp,disa,speed_mode,speed,mass,rating,throttle, full_output=False):\n    \"\"\"Aircraft acceleration on level flight\n    \"\"\"\n    r,gam,Cp,Cv = earth.gas_data()\n\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    mach = self.get_mach(pamb,speed_mode,speed)\n\n    dict = self.aircraft.power_system.thrust(pamb,tamb,mach,rating,throttle=throttle,nei=nei)\n    fn = dict[\"fn\"]\n    ff = dict[\"ff\"]\n\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    if(nei&gt;0):\n        dcx = self.aircraft.power_system.oei_drag(pamb,mach)\n        cx = cx + dcx*nei\n\n    acc = (fn - 0.5*gam*pamb*mach**2*self.aircraft.airframe.wing.area*cx) / mass\n\n    if full_output:\n        return acc,fn,ff,cz,cx,pamb,tamb\n    else:\n        return acc\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.McrCeiling.air_path","title":"air_path","text":"<pre><code>air_path(\n    nei,\n    altp,\n    disa,\n    speed_mode,\n    speed,\n    mass,\n    rating,\n    kfn,\n    full_output=False,\n)\n</code></pre> <p>Retrieve air path in various conditions</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def air_path(self,nei,altp,disa,speed_mode,speed,mass,rating,kfn, full_output=False):\n    \"\"\"Retrieve air path in various conditions\n    \"\"\"\n    g = earth.gravity()\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    mach = self.get_mach(pamb,speed_mode,speed)\n\n    dict = self.aircraft.power_system.thrust(pamb,tamb,mach,rating,nei=nei)\n    fn = dict[\"fn\"]*kfn\n    ff = dict[\"ff\"]*kfn\n    if kfn!=1. and full_output:\n        print(\"WARNING, air_path method, kfn is different from 1, fuel flow may not be accurate\")\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    if(nei&gt;0):\n        dcx = self.aircraft.power_system.oei_drag(pamb,mach)\n        cx = cx + dcx*nei\n        lod = cz/cx\n\n    acc_factor = earth.climb_mode(speed_mode, mach, dtodz, tstd, disa)\n    slope = ( fn/(mass*g) - 1./lod ) / acc_factor\n    vz = slope * mach * earth.sound_speed(tamb)\n    acc = (acc_factor-1.)*g*slope\n    if full_output:\n        return slope,vz,fn,ff,acc,cz,cx,pamb,tamb\n    else:\n        return slope,vz\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.McrCeiling.arrival_ground_legs","title":"arrival_ground_legs","text":"<pre><code>arrival_ground_legs(ldw)\n</code></pre> <p>Compute fuel and time allowances for arrival ground phases</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def arrival_ground_legs(self,ldw):\n    \"\"\"Compute fuel and time allowances for arrival ground phases\n    \"\"\"\n    n_engine = self.aircraft.power_system.n_engine\n    reference_thrust = self.aircraft.power_system.get_reference_thrust()\n    fuel_type = self.aircraft.arrangement.fuel_type\n\n    time_landing = 180.\n    time_taxi_in = 420.\n\n    if fuel_type!=\"battery\":\n        engine_bpr = self.aircraft.airframe.nacelle.engine_bpr\n        fuel_mass_factor = earth.fuel_heat(\"kerosene\") / earth.fuel_heat(fuel_type)\n        fuel_landing = fuel_mass_factor*1e-4*(0.5+2.3/engine_bpr)*ldw\n        fuel_taxi_in = fuel_mass_factor*(26. + 1.8e-4*reference_thrust)*n_engine\n        return {\"fuel\":{\"landing\":fuel_landing,\"taxi_in\":fuel_taxi_in},\n                \"time\":{\"landing\":time_landing,\"taxi_in\":time_taxi_in}}\n    else:\n        enrg_landing = (0.25*43.1e6)*0.75e-4*ldw\n        enrg_taxi_in = (0.25*43.1e6)*(26. + 1.8e-4*reference_thrust)*n_engine\n        return {\"enrg\":{\"landing\":enrg_landing,\"taxi_in\":enrg_taxi_in},\n                \"time\":{\"landing\":time_landing,\"taxi_in\":time_taxi_in}}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.McrCeiling.breguet_range","title":"breguet_range","text":"<pre><code>breguet_range(range, tow, ktow, altp, mach, disa)\n</code></pre> <p>Breguet range equation is dependant from power architecture</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def breguet_range(self,range,tow,ktow,altp,mach,disa):\n    \"\"\"Breguet range equation is dependant from power architecture\n    \"\"\"\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    tas = mach * earth.sound_speed(tamb)\n    time = 1.09*(range/tas)\n\n    dict = self.level_flight(pamb,tamb,mach,tow*ktow)\n    val = self.aircraft.power_system.specific_breguet_range(tow,range,tas,dict)\n    return val,time\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.McrCeiling.departure_ground_legs","title":"departure_ground_legs","text":"<pre><code>departure_ground_legs(tow)\n</code></pre> <p>Compute fuel and time allowances for departure ground phases</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def departure_ground_legs(self,tow):\n    \"\"\"Compute fuel and time allowances for departure ground phases\n    \"\"\"\n    n_engine = self.aircraft.power_system.n_engine\n    reference_thrust = self.aircraft.power_system.get_reference_thrust()\n    fuel_type = self.aircraft.arrangement.fuel_type\n\n    time_taxi_out = 540.\n    time_take_off = 220.*tow/(reference_thrust*n_engine)\n\n    if fuel_type!=\"battery\":\n        engine_bpr = self.aircraft.airframe.nacelle.engine_bpr\n        fuel_mass_factor = earth.fuel_heat(\"kerosene\") / earth.fuel_heat(fuel_type)\n        fuel_taxi_out = fuel_mass_factor*(34. + 2.3e-4*reference_thrust)*n_engine\n        fuel_take_off = fuel_mass_factor*1e-4*(2.8+2.3/engine_bpr)*tow\n        return {\"fuel\":{\"taxi_out\":fuel_taxi_out,\"take_off\":fuel_take_off},\n                \"time\":{\"taxi_out\":time_taxi_out,\"take_off\":time_take_off}}\n    else:\n        enrg_taxi_out = (0.25*43.1e6)*(34. + 2.3e-4*reference_thrust)*n_engine\n        enrg_take_off = (0.25*43.1e6)*3.e-4*tow\n        return {\"enrg\":{\"taxi_out\":enrg_taxi_out,\"take_off\":enrg_take_off},\n                \"time\":{\"taxi_out\":time_taxi_out,\"take_off\":time_take_off}}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.McrCeiling.descent","title":"descent","text":"<pre><code>descent(nei, altp, disa, speed_mode, speed, vz, mass)\n</code></pre> <p>Retrieve air path and flight characteristics in various conditions</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def descent(self,nei,altp,disa,speed_mode,speed,vz,mass):\n    \"\"\"Retrieve air path and flight characteristics in various conditions\n    \"\"\"\n    g = earth.gravity()\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    mach = self.get_mach(pamb,speed_mode,speed)\n\n    slope = vz / (mach * earth.sound_speed(tamb))\n    acc_factor = earth.climb_mode(speed_mode, mach, dtodz, tstd, disa)\n\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    fn = (slope * acc_factor + 1./lod) * (mass*g)\n    dict = self.aircraft.power_system.sc(self,pamb,tamb,mach,\"FID\", fn, nei)\n    ff = dict[\"sfc\"]*fn\n    thtl = dict[\"thtl\"]\n\n    return slope,thtl,fn,ff,cz,cx,pamb,tamb\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.McrCeiling.eval","title":"eval","text":"<pre><code>eval(disa, altp, mach, mass, rating, kfn, speed_mode)\n</code></pre> <p>Residual climb speed in MCR rating</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def eval(self,disa,altp,mach,mass,rating,kfn,speed_mode):\n    \"\"\"Residual climb speed in MCR rating\n    \"\"\"\n    nei = 0\n    pamb,tamb,tstd,dtodz = earth.atmosphere(self.altp, self.disa)\n    speed = self.get_speed(pamb,self.speed_mode,self.mach)\n    slope,vz,fn,ff,acc,cz,cx,pamb,tamb = self.air_path(nei,altp,disa,speed_mode,speed,mass,rating,kfn, full_output=True)\n    w_aoa,_ = self.aircraft.aerodynamics.aoa(self.mach,cz)\n    return {\"vz\":vz, \"slope\":slope, \"aoa_wing\":w_aoa}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.McrCeiling.eval_sar","title":"eval_sar","text":"<pre><code>eval_sar(altp, mass, mach, disa)\n</code></pre> <p>Evaluate Specific Air Range</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def eval_sar(self,altp,mass,mach,disa):\n    \"\"\"Evaluate Specific Air Range\n    \"\"\"\n    g = earth.gravity()\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    tas = mach * earth.sound_speed(tamb)\n\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    nei = 0\n    thrust = mass*g / lod\n    dict = self.aircraft.power_system.sc(pamb,tamb,mach,\"MCR\",thrust,nei)\n    dict[\"fn\"] = thrust\n    dict[\"cz\"] = cz\n    dict[\"cx\"] = cx\n    dict[\"lod\"] = lod\n    dict[\"sar\"] = self.aircraft.power_system.specific_air_range(mass,tas,dict)\n    return dict\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.McrCeiling.get_mach","title":"get_mach","text":"<pre><code>get_mach(pamb, speed_mode, speed)\n</code></pre> <p>Retrieve Mach from CAS or mach depending on speed_mode</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def get_mach(self,pamb,speed_mode,speed):\n    \"\"\"Retrieve Mach from CAS or mach depending on speed_mode\n    \"\"\"\n    mach = {\"cas\" : earth.mach_from_vcas(pamb, speed),  # Input is CAS\n            \"mach\" : speed  # Input is mach\n            }.get(speed_mode, \"Erreur: select speed_mode equal to cas or mach\")\n    return mach\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.McrCeiling.get_speed","title":"get_speed","text":"<pre><code>get_speed(pamb, speed_mode, mach)\n</code></pre> <p>retrieve CAS or Mach from mach depending on speed_mode</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def get_speed(self,pamb,speed_mode,mach):\n    \"\"\"retrieve CAS or Mach from mach depending on speed_mode\n    \"\"\"\n    speed = {\"cas\" : earth.vcas_from_mach(pamb, mach),  # CAS required\n             \"mach\" : mach  # mach required\n             }.get(speed_mode, \"Erreur: select speed_mode equal to cas or mach\")\n    return speed\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.McrCeiling.get_vcas","title":"get_vcas","text":"<pre><code>get_vcas(pamb, speed_mode, speed)\n</code></pre> <p>Retrieve CAS from Mach or CAS depending on speed_mode</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def get_vcas(self,pamb,speed_mode,speed):\n    \"\"\"Retrieve CAS from Mach or CAS depending on speed_mode\n    \"\"\"\n    cas = {\"mach\" : earth.vcas_from_mach(pamb, speed),  # Input is CAS\n            \"cas\" : speed  # Input is mach\n            }.get(speed_mode, \"Erreur: select speed_mode equal to cas or mach\")\n    return cas\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.McrCeiling.holding","title":"holding","text":"<pre><code>holding(time, mass, altp, mach, disa)\n</code></pre> <p>Holding equation is dependant from power architecture</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def holding(self,time,mass,altp,mach,disa):\n    \"\"\"Holding equation is dependant from power architecture\n    \"\"\"\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    tas = mach * earth.sound_speed(tamb)\n    dict = self.level_flight(pamb,tamb,mach,mass)\n    return self.aircraft.power_system.specific_holding(mass,time,tas,dict)\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.McrCeiling.level_flight","title":"level_flight","text":"<pre><code>level_flight(pamb, tamb, mach, mass)\n</code></pre> <p>Level flight equilibrium</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def level_flight(self,pamb,tamb,mach,mass):\n    \"\"\"Level flight equilibrium\n    \"\"\"\n    g = earth.gravity()\n    r,gam,Cp,Cv = earth.gas_data()\n    tas = mach * earth.sound_speed(tamb)\n\n    cz = (2.*mass*g)/(gam*pamb*mach**2*self.aircraft.airframe.wing.area)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    thrust = (gam/2.)*pamb*mach**2*self.aircraft.airframe.wing.area*cx\n    dict = self.aircraft.power_system.sc(pamb,tamb,mach,\"MCR\",thrust)\n    dict[\"fn\"] = thrust\n    dict[\"cx\"] = cx\n    dict[\"cz\"] = cz\n    dict[\"lod\"] = lod\n    dict[\"sar\"] = self.aircraft.power_system.specific_air_range(mass,tas,dict)\n    return dict\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.McrCeiling.lift_from_speed","title":"lift_from_speed","text":"<pre><code>lift_from_speed(pamb, tamb, mach, mass)\n</code></pre> <p>Retrieve cz from mach using simplified lift equation</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def lift_from_speed(self,pamb,tamb,mach,mass):\n    \"\"\"Retrieve cz from mach using simplified lift equation\n    \"\"\"\n    g = earth.gravity()\n    r,gam,Cp,Cv = earth.gas_data()\n    cz = (2.*mass*g)/(gam*pamb*mach**2*self.aircraft.airframe.wing.area)\n    return cz\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.McrCeiling.max_air_path","title":"max_air_path","text":"<pre><code>max_air_path(\n    nei,\n    altp,\n    disa,\n    speed_mode,\n    mass,\n    rating,\n    kfn,\n    full_output=False,\n)\n</code></pre> <p>Optimize the speed of the aircraft to maximize the air path</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def max_air_path(self,nei,altp,disa,speed_mode,mass,rating,kfn, full_output=False):\n    \"\"\"Optimize the speed of the aircraft to maximize the air path\n    \"\"\"\n    def fct(cz):\n        pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n        mach = self.speed_from_lift(pamb,tamb,cz,mass)\n        speed = self.get_speed(pamb,speed_mode,mach)\n        slope,vz = self.air_path(nei,altp,disa,speed_mode,speed,mass,rating,kfn)\n        if isformax: return slope\n        else: return slope,vz,mach\n\n    cz_ini = 0.5\n    dcz = 0.05\n\n    isformax = True\n    cz,slope,rc = maximize_1d(cz_ini,dcz,[fct])\n    isformax = False\n\n    slope,vz,mach = fct(cz)\n    return slope,vz,mach,cz\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.McrCeiling.propulsion_ceiling","title":"propulsion_ceiling","text":"<pre><code>propulsion_ceiling(\n    altp_ini,\n    nei,\n    vzreq,\n    disa,\n    speed_mode,\n    speed,\n    mass,\n    rating,\n    throttle,\n)\n</code></pre> <p>Optimize the speed of the aircraft to maximize the air path</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def propulsion_ceiling(self,altp_ini,nei,vzreq,disa,speed_mode,speed,mass,rating,throttle):\n    \"\"\"Optimize the speed of the aircraft to maximize the air path\n    \"\"\"\n    def fct_prop_ceiling(altp,nei,vzreq,disa,speed_mode,speed,mass,rating):\n        slope,vz = self.air_path(nei,altp,disa,speed_mode,speed,mass,rating,throttle)\n        delta_vz = vz - vzreq\n        return delta_vz\n\n    fct_arg = (nei,vzreq,disa,speed_mode,speed,mass,rating)\n\n    output_dict = fsolve(fct_prop_ceiling, x0 = altp_ini, args=fct_arg, full_output = True)\n\n    altp = output_dict[0][0]\n    rei = output_dict[2]\n    if(rei!=1): altp = np.NaN\n\n    return altp, rei\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.McrCeiling.speed_from_lift","title":"speed_from_lift","text":"<pre><code>speed_from_lift(pamb, tamb, cz, mass)\n</code></pre> <p>Retrieve mach from cz using simplified lift equation</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def speed_from_lift(self,pamb,tamb,cz,mass):\n    \"\"\"Retrieve mach from cz using simplified lift equation\n    \"\"\"\n    g = earth.gravity()\n    r,gam,Cp,Cv = earth.gas_data()\n    mach = np.sqrt((mass*g)/(0.5*gam*pamb*self.aircraft.airframe.wing.area*cz))\n    return mach\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.OeiCeiling","title":"OeiCeiling","text":"<pre><code>OeiCeiling(aircraft)\n</code></pre> <p>               Bases: <code>Flight</code></p> <p>Definition of all mission types</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def __init__(self, aircraft):\n    super(OeiCeiling, self).__init__(aircraft)\n\n    self.disa = None\n    self.altp = None\n    self.kmtow = None\n    self.rating = None\n    self.speed_mode = None\n    self.path_req = None\n    self.path_eff = None\n    self.mach_opt = None\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.OeiCeiling-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.OeiCeiling.acceleration","title":"acceleration","text":"<pre><code>acceleration(\n    nei,\n    altp,\n    disa,\n    speed_mode,\n    speed,\n    mass,\n    rating,\n    throttle,\n    full_output=False,\n)\n</code></pre> <p>Aircraft acceleration on level flight</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def acceleration(self,nei,altp,disa,speed_mode,speed,mass,rating,throttle, full_output=False):\n    \"\"\"Aircraft acceleration on level flight\n    \"\"\"\n    r,gam,Cp,Cv = earth.gas_data()\n\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    mach = self.get_mach(pamb,speed_mode,speed)\n\n    dict = self.aircraft.power_system.thrust(pamb,tamb,mach,rating,throttle=throttle,nei=nei)\n    fn = dict[\"fn\"]\n    ff = dict[\"ff\"]\n\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    if(nei&gt;0):\n        dcx = self.aircraft.power_system.oei_drag(pamb,mach)\n        cx = cx + dcx*nei\n\n    acc = (fn - 0.5*gam*pamb*mach**2*self.aircraft.airframe.wing.area*cx) / mass\n\n    if full_output:\n        return acc,fn,ff,cz,cx,pamb,tamb\n    else:\n        return acc\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.OeiCeiling.air_path","title":"air_path","text":"<pre><code>air_path(\n    nei,\n    altp,\n    disa,\n    speed_mode,\n    speed,\n    mass,\n    rating,\n    kfn,\n    full_output=False,\n)\n</code></pre> <p>Retrieve air path in various conditions</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def air_path(self,nei,altp,disa,speed_mode,speed,mass,rating,kfn, full_output=False):\n    \"\"\"Retrieve air path in various conditions\n    \"\"\"\n    g = earth.gravity()\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    mach = self.get_mach(pamb,speed_mode,speed)\n\n    dict = self.aircraft.power_system.thrust(pamb,tamb,mach,rating,nei=nei)\n    fn = dict[\"fn\"]*kfn\n    ff = dict[\"ff\"]*kfn\n    if kfn!=1. and full_output:\n        print(\"WARNING, air_path method, kfn is different from 1, fuel flow may not be accurate\")\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    if(nei&gt;0):\n        dcx = self.aircraft.power_system.oei_drag(pamb,mach)\n        cx = cx + dcx*nei\n        lod = cz/cx\n\n    acc_factor = earth.climb_mode(speed_mode, mach, dtodz, tstd, disa)\n    slope = ( fn/(mass*g) - 1./lod ) / acc_factor\n    vz = slope * mach * earth.sound_speed(tamb)\n    acc = (acc_factor-1.)*g*slope\n    if full_output:\n        return slope,vz,fn,ff,acc,cz,cx,pamb,tamb\n    else:\n        return slope,vz\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.OeiCeiling.arrival_ground_legs","title":"arrival_ground_legs","text":"<pre><code>arrival_ground_legs(ldw)\n</code></pre> <p>Compute fuel and time allowances for arrival ground phases</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def arrival_ground_legs(self,ldw):\n    \"\"\"Compute fuel and time allowances for arrival ground phases\n    \"\"\"\n    n_engine = self.aircraft.power_system.n_engine\n    reference_thrust = self.aircraft.power_system.get_reference_thrust()\n    fuel_type = self.aircraft.arrangement.fuel_type\n\n    time_landing = 180.\n    time_taxi_in = 420.\n\n    if fuel_type!=\"battery\":\n        engine_bpr = self.aircraft.airframe.nacelle.engine_bpr\n        fuel_mass_factor = earth.fuel_heat(\"kerosene\") / earth.fuel_heat(fuel_type)\n        fuel_landing = fuel_mass_factor*1e-4*(0.5+2.3/engine_bpr)*ldw\n        fuel_taxi_in = fuel_mass_factor*(26. + 1.8e-4*reference_thrust)*n_engine\n        return {\"fuel\":{\"landing\":fuel_landing,\"taxi_in\":fuel_taxi_in},\n                \"time\":{\"landing\":time_landing,\"taxi_in\":time_taxi_in}}\n    else:\n        enrg_landing = (0.25*43.1e6)*0.75e-4*ldw\n        enrg_taxi_in = (0.25*43.1e6)*(26. + 1.8e-4*reference_thrust)*n_engine\n        return {\"enrg\":{\"landing\":enrg_landing,\"taxi_in\":enrg_taxi_in},\n                \"time\":{\"landing\":time_landing,\"taxi_in\":time_taxi_in}}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.OeiCeiling.breguet_range","title":"breguet_range","text":"<pre><code>breguet_range(range, tow, ktow, altp, mach, disa)\n</code></pre> <p>Breguet range equation is dependant from power architecture</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def breguet_range(self,range,tow,ktow,altp,mach,disa):\n    \"\"\"Breguet range equation is dependant from power architecture\n    \"\"\"\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    tas = mach * earth.sound_speed(tamb)\n    time = 1.09*(range/tas)\n\n    dict = self.level_flight(pamb,tamb,mach,tow*ktow)\n    val = self.aircraft.power_system.specific_breguet_range(tow,range,tas,dict)\n    return val,time\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.OeiCeiling.departure_ground_legs","title":"departure_ground_legs","text":"<pre><code>departure_ground_legs(tow)\n</code></pre> <p>Compute fuel and time allowances for departure ground phases</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def departure_ground_legs(self,tow):\n    \"\"\"Compute fuel and time allowances for departure ground phases\n    \"\"\"\n    n_engine = self.aircraft.power_system.n_engine\n    reference_thrust = self.aircraft.power_system.get_reference_thrust()\n    fuel_type = self.aircraft.arrangement.fuel_type\n\n    time_taxi_out = 540.\n    time_take_off = 220.*tow/(reference_thrust*n_engine)\n\n    if fuel_type!=\"battery\":\n        engine_bpr = self.aircraft.airframe.nacelle.engine_bpr\n        fuel_mass_factor = earth.fuel_heat(\"kerosene\") / earth.fuel_heat(fuel_type)\n        fuel_taxi_out = fuel_mass_factor*(34. + 2.3e-4*reference_thrust)*n_engine\n        fuel_take_off = fuel_mass_factor*1e-4*(2.8+2.3/engine_bpr)*tow\n        return {\"fuel\":{\"taxi_out\":fuel_taxi_out,\"take_off\":fuel_take_off},\n                \"time\":{\"taxi_out\":time_taxi_out,\"take_off\":time_take_off}}\n    else:\n        enrg_taxi_out = (0.25*43.1e6)*(34. + 2.3e-4*reference_thrust)*n_engine\n        enrg_take_off = (0.25*43.1e6)*3.e-4*tow\n        return {\"enrg\":{\"taxi_out\":enrg_taxi_out,\"take_off\":enrg_take_off},\n                \"time\":{\"taxi_out\":time_taxi_out,\"take_off\":time_take_off}}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.OeiCeiling.descent","title":"descent","text":"<pre><code>descent(nei, altp, disa, speed_mode, speed, vz, mass)\n</code></pre> <p>Retrieve air path and flight characteristics in various conditions</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def descent(self,nei,altp,disa,speed_mode,speed,vz,mass):\n    \"\"\"Retrieve air path and flight characteristics in various conditions\n    \"\"\"\n    g = earth.gravity()\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    mach = self.get_mach(pamb,speed_mode,speed)\n\n    slope = vz / (mach * earth.sound_speed(tamb))\n    acc_factor = earth.climb_mode(speed_mode, mach, dtodz, tstd, disa)\n\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    fn = (slope * acc_factor + 1./lod) * (mass*g)\n    dict = self.aircraft.power_system.sc(self,pamb,tamb,mach,\"FID\", fn, nei)\n    ff = dict[\"sfc\"]*fn\n    thtl = dict[\"thtl\"]\n\n    return slope,thtl,fn,ff,cz,cx,pamb,tamb\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.OeiCeiling.eval","title":"eval","text":"<pre><code>eval(disa, altp, mass, rating, kfn, speed_mode)\n</code></pre> <p>Compute one engine inoperative maximum path</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def eval(self,disa,altp,mass,rating,kfn,speed_mode):\n    \"\"\"Compute one engine inoperative maximum path\n    \"\"\"\n    nei = 1.\n    path,vz,mach,cz = self.max_air_path(nei,altp,disa,speed_mode,mass,rating,kfn)\n\n    czmax = self.aircraft.aerodynamics.czmax_conf_clean\n    if cz &gt; czmax/1.1:\n        cz = czmax/1.1\n        pamb,tamb,tstd,dtodz = earth.atmosphere(self.altp, self.disa)\n        mach = self.speed_from_lift(pamb,tamb,cz,mass)\n        speed = self.get_speed(pamb,speed_mode,mach)\n        path,vz,fn,ff,acc,cz,cx,pamb,tamb = self.air_path(nei,altp,disa,speed_mode,speed,mass,rating,kfn, full_output=True)\n\n    w_aoa,_ = self.aircraft.aerodynamics.aoa(mach,cz)\n    return {\"path\":path, \"vz\":vz, \"mach\":mach, \"cz\":cz, \"aoa_wing\":w_aoa}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.OeiCeiling.eval_sar","title":"eval_sar","text":"<pre><code>eval_sar(altp, mass, mach, disa)\n</code></pre> <p>Evaluate Specific Air Range</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def eval_sar(self,altp,mass,mach,disa):\n    \"\"\"Evaluate Specific Air Range\n    \"\"\"\n    g = earth.gravity()\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    tas = mach * earth.sound_speed(tamb)\n\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    nei = 0\n    thrust = mass*g / lod\n    dict = self.aircraft.power_system.sc(pamb,tamb,mach,\"MCR\",thrust,nei)\n    dict[\"fn\"] = thrust\n    dict[\"cz\"] = cz\n    dict[\"cx\"] = cx\n    dict[\"lod\"] = lod\n    dict[\"sar\"] = self.aircraft.power_system.specific_air_range(mass,tas,dict)\n    return dict\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.OeiCeiling.get_mach","title":"get_mach","text":"<pre><code>get_mach(pamb, speed_mode, speed)\n</code></pre> <p>Retrieve Mach from CAS or mach depending on speed_mode</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def get_mach(self,pamb,speed_mode,speed):\n    \"\"\"Retrieve Mach from CAS or mach depending on speed_mode\n    \"\"\"\n    mach = {\"cas\" : earth.mach_from_vcas(pamb, speed),  # Input is CAS\n            \"mach\" : speed  # Input is mach\n            }.get(speed_mode, \"Erreur: select speed_mode equal to cas or mach\")\n    return mach\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.OeiCeiling.get_speed","title":"get_speed","text":"<pre><code>get_speed(pamb, speed_mode, mach)\n</code></pre> <p>retrieve CAS or Mach from mach depending on speed_mode</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def get_speed(self,pamb,speed_mode,mach):\n    \"\"\"retrieve CAS or Mach from mach depending on speed_mode\n    \"\"\"\n    speed = {\"cas\" : earth.vcas_from_mach(pamb, mach),  # CAS required\n             \"mach\" : mach  # mach required\n             }.get(speed_mode, \"Erreur: select speed_mode equal to cas or mach\")\n    return speed\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.OeiCeiling.get_vcas","title":"get_vcas","text":"<pre><code>get_vcas(pamb, speed_mode, speed)\n</code></pre> <p>Retrieve CAS from Mach or CAS depending on speed_mode</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def get_vcas(self,pamb,speed_mode,speed):\n    \"\"\"Retrieve CAS from Mach or CAS depending on speed_mode\n    \"\"\"\n    cas = {\"mach\" : earth.vcas_from_mach(pamb, speed),  # Input is CAS\n            \"cas\" : speed  # Input is mach\n            }.get(speed_mode, \"Erreur: select speed_mode equal to cas or mach\")\n    return cas\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.OeiCeiling.holding","title":"holding","text":"<pre><code>holding(time, mass, altp, mach, disa)\n</code></pre> <p>Holding equation is dependant from power architecture</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def holding(self,time,mass,altp,mach,disa):\n    \"\"\"Holding equation is dependant from power architecture\n    \"\"\"\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    tas = mach * earth.sound_speed(tamb)\n    dict = self.level_flight(pamb,tamb,mach,mass)\n    return self.aircraft.power_system.specific_holding(mass,time,tas,dict)\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.OeiCeiling.level_flight","title":"level_flight","text":"<pre><code>level_flight(pamb, tamb, mach, mass)\n</code></pre> <p>Level flight equilibrium</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def level_flight(self,pamb,tamb,mach,mass):\n    \"\"\"Level flight equilibrium\n    \"\"\"\n    g = earth.gravity()\n    r,gam,Cp,Cv = earth.gas_data()\n    tas = mach * earth.sound_speed(tamb)\n\n    cz = (2.*mass*g)/(gam*pamb*mach**2*self.aircraft.airframe.wing.area)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    thrust = (gam/2.)*pamb*mach**2*self.aircraft.airframe.wing.area*cx\n    dict = self.aircraft.power_system.sc(pamb,tamb,mach,\"MCR\",thrust)\n    dict[\"fn\"] = thrust\n    dict[\"cx\"] = cx\n    dict[\"cz\"] = cz\n    dict[\"lod\"] = lod\n    dict[\"sar\"] = self.aircraft.power_system.specific_air_range(mass,tas,dict)\n    return dict\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.OeiCeiling.lift_from_speed","title":"lift_from_speed","text":"<pre><code>lift_from_speed(pamb, tamb, mach, mass)\n</code></pre> <p>Retrieve cz from mach using simplified lift equation</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def lift_from_speed(self,pamb,tamb,mach,mass):\n    \"\"\"Retrieve cz from mach using simplified lift equation\n    \"\"\"\n    g = earth.gravity()\n    r,gam,Cp,Cv = earth.gas_data()\n    cz = (2.*mass*g)/(gam*pamb*mach**2*self.aircraft.airframe.wing.area)\n    return cz\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.OeiCeiling.max_air_path","title":"max_air_path","text":"<pre><code>max_air_path(\n    nei,\n    altp,\n    disa,\n    speed_mode,\n    mass,\n    rating,\n    kfn,\n    full_output=False,\n)\n</code></pre> <p>Optimize the speed of the aircraft to maximize the air path</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def max_air_path(self,nei,altp,disa,speed_mode,mass,rating,kfn, full_output=False):\n    \"\"\"Optimize the speed of the aircraft to maximize the air path\n    \"\"\"\n    def fct(cz):\n        pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n        mach = self.speed_from_lift(pamb,tamb,cz,mass)\n        speed = self.get_speed(pamb,speed_mode,mach)\n        slope,vz = self.air_path(nei,altp,disa,speed_mode,speed,mass,rating,kfn)\n        if isformax: return slope\n        else: return slope,vz,mach\n\n    cz_ini = 0.5\n    dcz = 0.05\n\n    isformax = True\n    cz,slope,rc = maximize_1d(cz_ini,dcz,[fct])\n    isformax = False\n\n    slope,vz,mach = fct(cz)\n    return slope,vz,mach,cz\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.OeiCeiling.propulsion_ceiling","title":"propulsion_ceiling","text":"<pre><code>propulsion_ceiling(\n    altp_ini,\n    nei,\n    vzreq,\n    disa,\n    speed_mode,\n    speed,\n    mass,\n    rating,\n    throttle,\n)\n</code></pre> <p>Optimize the speed of the aircraft to maximize the air path</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def propulsion_ceiling(self,altp_ini,nei,vzreq,disa,speed_mode,speed,mass,rating,throttle):\n    \"\"\"Optimize the speed of the aircraft to maximize the air path\n    \"\"\"\n    def fct_prop_ceiling(altp,nei,vzreq,disa,speed_mode,speed,mass,rating):\n        slope,vz = self.air_path(nei,altp,disa,speed_mode,speed,mass,rating,throttle)\n        delta_vz = vz - vzreq\n        return delta_vz\n\n    fct_arg = (nei,vzreq,disa,speed_mode,speed,mass,rating)\n\n    output_dict = fsolve(fct_prop_ceiling, x0 = altp_ini, args=fct_arg, full_output = True)\n\n    altp = output_dict[0][0]\n    rei = output_dict[2]\n    if(rei!=1): altp = np.NaN\n\n    return altp, rei\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.OeiCeiling.speed_from_lift","title":"speed_from_lift","text":"<pre><code>speed_from_lift(pamb, tamb, cz, mass)\n</code></pre> <p>Retrieve mach from cz using simplified lift equation</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def speed_from_lift(self,pamb,tamb,cz,mass):\n    \"\"\"Retrieve mach from cz using simplified lift equation\n    \"\"\"\n    g = earth.gravity()\n    r,gam,Cp,Cv = earth.gas_data()\n    mach = np.sqrt((mass*g)/(0.5*gam*pamb*self.aircraft.airframe.wing.area*cz))\n    return mach\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.Performance","title":"Performance","text":"<pre><code>Performance(aircraft)\n</code></pre> <p>               Bases: <code>object</code></p> <p>Master class for all aircraft performances</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def __init__(self, aircraft):\n    self.aircraft = aircraft\n\n    self.mission = None  # Initialized by the factory of the Aircraft.\n    self.take_off = TakeOff(aircraft)\n    self.approach = Approach(aircraft)\n    self.mcr_ceiling = McrCeiling(aircraft)\n    self.mcl_ceiling = MclCeiling(aircraft)\n    self.oei_ceiling = OeiCeiling(aircraft)\n    self.time_to_climb = TimeToClimb(aircraft)\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.Performance-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.Performance.analysis","title":"analysis","text":"<pre><code>analysis()\n</code></pre> <p>Evaluate general performances of the airplane</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def analysis(self):\n    \"\"\"Evaluate general performances of the airplane\n    \"\"\"\n    #---------------------------------------------------------------------------------------------------\n    self.mission.eval_cruise_point()\n\n    #---------------------------------------------------------------------------------------------------\n    self.take_off.disa = self.aircraft.requirement.take_off.disa\n    self.take_off.altp = self.aircraft.requirement.take_off.altp\n    self.take_off.kmtow = self.aircraft.requirement.take_off.kmtow\n    self.take_off.kvs1g = self.aircraft.requirement.take_off.kvs1g\n    self.take_off.s2_min_path = self.aircraft.requirement.take_off.s2_min_path\n    self.take_off.hld_conf = self.aircraft.performance.take_off.hld_conf\n    self.take_off.tofl_req = self.aircraft.requirement.take_off.tofl_req\n\n    rating = \"MTO\"\n    kfn = 1.\n    mass = self.take_off.kmtow*self.aircraft.weight_cg.mtow\n    to_dict = self.take_off.eval(self.take_off.disa, self.take_off.altp, mass, self.take_off.hld_conf,\n                                 rating, kfn, self.take_off.kvs1g, self.take_off.s2_min_path)\n\n    self.take_off.tofl_eff = to_dict[\"tofl\"]\n    self.take_off.kvs1g_eff = to_dict[\"kvs1g\"]\n    self.take_off.s2_path = to_dict[\"path\"]\n    self.take_off.v2 = to_dict[\"v2\"]\n    self.take_off.mach2 = to_dict[\"mach2\"]\n    self.take_off.limit = to_dict[\"limit\"]\n    self.take_off.aoa_wing = to_dict[\"aoa_wing\"]\n\n    #---------------------------------------------------------------------------------------------------\n    self.approach.disa = self.aircraft.requirement.approach.disa\n    self.approach.altp = self.aircraft.requirement.approach.altp\n    self.approach.kmlw = self.aircraft.requirement.approach.kmlw\n    self.approach.kvs1g = self.aircraft.requirement.approach.kvs1g\n    self.approach.hld_conf = self.aircraft.performance.approach.hld_conf\n    self.approach.app_speed_req = self.aircraft.requirement.approach.app_speed_req\n\n    mass = self.approach.kmlw*self.aircraft.weight_cg.mlw\n    ld_dict = self.approach.eval(self.approach.disa,self.approach.altp,mass,self.approach.hld_conf,self.approach.kvs1g)\n\n    self.approach.app_speed_eff = ld_dict[\"vapp\"]\n    self.approach.aoa_wing = ld_dict[\"aoa_wing\"]\n\n    #---------------------------------------------------------------------------------------------------\n    self.mcl_ceiling.disa = self.aircraft.requirement.mcl_ceiling.disa\n    self.mcl_ceiling.altp = self.aircraft.requirement.mcl_ceiling.altp\n    self.mcl_ceiling.mach = self.aircraft.requirement.mcl_ceiling.mach\n    self.mcl_ceiling.kmtow = self.aircraft.requirement.mcl_ceiling.kmtow\n    self.mcl_ceiling.rating = self.aircraft.requirement.mcl_ceiling.rating\n    self.mcl_ceiling.speed_mode = self.aircraft.requirement.mcl_ceiling.speed_mode\n    self.mcl_ceiling.vz_req = self.aircraft.requirement.mcl_ceiling.vz_req\n\n    kfn = 1.\n    mass = self.mcl_ceiling.kmtow*self.aircraft.weight_cg.mtow\n    cl_dict = self.mcl_ceiling.eval(self.mcl_ceiling.disa,self.mcl_ceiling.altp,self.mcl_ceiling.mach,mass,\n                                    self.mcl_ceiling.rating,kfn,self.mcl_ceiling.speed_mode)\n\n    self.mcl_ceiling.vz_eff = cl_dict[\"vz\"]\n    self.mcl_ceiling.aoa_wing = cl_dict[\"aoa_wing\"]\n\n    #---------------------------------------------------------------------------------------------------\n    self.mcr_ceiling.disa = self.aircraft.requirement.mcr_ceiling.disa\n    self.mcr_ceiling.altp = self.aircraft.requirement.mcr_ceiling.altp\n    self.mcr_ceiling.mach = self.aircraft.requirement.mcr_ceiling.mach\n    self.mcr_ceiling.kmtow = self.aircraft.requirement.mcr_ceiling.kmtow\n    self.mcr_ceiling.rating = self.aircraft.requirement.mcr_ceiling.rating\n    self.mcr_ceiling.speed_mode = self.aircraft.requirement.mcr_ceiling.speed_mode\n    self.mcr_ceiling.vz_req = self.aircraft.requirement.mcr_ceiling.vz_req\n\n    kfn = 1.\n    mass = self.mcr_ceiling.kmtow*self.aircraft.weight_cg.mtow\n    cl_dict = self.mcr_ceiling.eval(self.mcr_ceiling.disa,self.mcr_ceiling.altp,self.mcr_ceiling.mach,mass,\n                                    self.mcr_ceiling.rating,kfn,self.mcr_ceiling.speed_mode)\n\n    self.mcr_ceiling.vz_eff = cl_dict[\"vz\"]\n    self.mcr_ceiling.aoa_wing = cl_dict[\"aoa_wing\"]\n\n    #---------------------------------------------------------------------------------------------------\n    self.oei_ceiling.disa = self.aircraft.requirement.oei_ceiling.disa\n    self.oei_ceiling.altp = self.aircraft.requirement.oei_ceiling.altp\n    self.oei_ceiling.kmtow = self.aircraft.requirement.oei_ceiling.kmtow\n    self.oei_ceiling.rating = self.aircraft.requirement.oei_ceiling.rating\n    self.oei_ceiling.speed_mode = self.aircraft.requirement.oei_ceiling.speed_mode\n    self.oei_ceiling.path_req = self.aircraft.requirement.oei_ceiling.path_req\n\n    kfn = 1.\n    mass = self.oei_ceiling.kmtow*self.aircraft.weight_cg.mtow\n    ei_dict = self.oei_ceiling.eval(self.oei_ceiling.disa,self.oei_ceiling.altp,mass,self.oei_ceiling.rating,kfn,self.oei_ceiling.speed_mode)\n\n    self.oei_ceiling.path_eff = ei_dict[\"path\"]\n    self.oei_ceiling.mach_opt = ei_dict[\"mach\"]\n    self.oei_ceiling.aoa_wing = ei_dict[\"aoa_wing\"]\n\n    #---------------------------------------------------------------------------------------------------\n    self.time_to_climb.disa = self.aircraft.requirement.time_to_climb.disa\n    self.time_to_climb.cas1 = self.aircraft.requirement.time_to_climb.cas1\n    self.time_to_climb.altp1 = self.aircraft.requirement.time_to_climb.altp1\n    self.time_to_climb.cas2 = self.aircraft.requirement.time_to_climb.cas2\n    self.time_to_climb.altp2 = self.aircraft.requirement.time_to_climb.altp2\n    self.time_to_climb.mach = self.aircraft.requirement.time_to_climb.mach\n    self.time_to_climb.altp = self.aircraft.requirement.time_to_climb.altp\n    self.time_to_climb.ttc_req = self.aircraft.requirement.time_to_climb.ttc_req\n\n    rating = \"MCL\"\n    kfn = 1.\n    mass = self.aircraft.weight_cg.mtow\n    tc_dict = self.time_to_climb.eval(self.time_to_climb.disa,self.time_to_climb.altp,self.time_to_climb.mach,mass,\n                                      self.time_to_climb.altp1,self.time_to_climb.cas1,self.time_to_climb.altp2,\n                                      self.time_to_climb.cas2,rating,kfn)\n\n    self.time_to_climb.ttc_eff = tc_dict[\"ttc\"]\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.TakeOff","title":"TakeOff","text":"<pre><code>TakeOff(aircraft)\n</code></pre> <p>               Bases: <code>Flight</code></p> <p>Take Off Field Length</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def __init__(self, aircraft):\n    super(TakeOff, self).__init__(aircraft)\n\n    self.disa = None\n    self.altp = None\n    self.kmtow = None\n    self.kvs1g = None\n    self.s2_min_path = None\n    self.tofl_req = None\n    self.tofl_eff = None\n    self.hld_conf = self.aircraft.aerodynamics.hld_conf_to\n    self.kvs1g_eff = None\n    self.v2 = None\n    self.mach2 = None\n    self.s2_path = None\n    self.limit = None\n    self.aoa_wing = None\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.TakeOff-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.TakeOff.acceleration","title":"acceleration","text":"<pre><code>acceleration(\n    nei,\n    altp,\n    disa,\n    speed_mode,\n    speed,\n    mass,\n    rating,\n    throttle,\n    full_output=False,\n)\n</code></pre> <p>Aircraft acceleration on level flight</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def acceleration(self,nei,altp,disa,speed_mode,speed,mass,rating,throttle, full_output=False):\n    \"\"\"Aircraft acceleration on level flight\n    \"\"\"\n    r,gam,Cp,Cv = earth.gas_data()\n\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    mach = self.get_mach(pamb,speed_mode,speed)\n\n    dict = self.aircraft.power_system.thrust(pamb,tamb,mach,rating,throttle=throttle,nei=nei)\n    fn = dict[\"fn\"]\n    ff = dict[\"ff\"]\n\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    if(nei&gt;0):\n        dcx = self.aircraft.power_system.oei_drag(pamb,mach)\n        cx = cx + dcx*nei\n\n    acc = (fn - 0.5*gam*pamb*mach**2*self.aircraft.airframe.wing.area*cx) / mass\n\n    if full_output:\n        return acc,fn,ff,cz,cx,pamb,tamb\n    else:\n        return acc\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.TakeOff.air_path","title":"air_path","text":"<pre><code>air_path(\n    nei,\n    altp,\n    disa,\n    speed_mode,\n    speed,\n    mass,\n    rating,\n    kfn,\n    full_output=False,\n)\n</code></pre> <p>Retrieve air path in various conditions</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def air_path(self,nei,altp,disa,speed_mode,speed,mass,rating,kfn, full_output=False):\n    \"\"\"Retrieve air path in various conditions\n    \"\"\"\n    g = earth.gravity()\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    mach = self.get_mach(pamb,speed_mode,speed)\n\n    dict = self.aircraft.power_system.thrust(pamb,tamb,mach,rating,nei=nei)\n    fn = dict[\"fn\"]*kfn\n    ff = dict[\"ff\"]*kfn\n    if kfn!=1. and full_output:\n        print(\"WARNING, air_path method, kfn is different from 1, fuel flow may not be accurate\")\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    if(nei&gt;0):\n        dcx = self.aircraft.power_system.oei_drag(pamb,mach)\n        cx = cx + dcx*nei\n        lod = cz/cx\n\n    acc_factor = earth.climb_mode(speed_mode, mach, dtodz, tstd, disa)\n    slope = ( fn/(mass*g) - 1./lod ) / acc_factor\n    vz = slope * mach * earth.sound_speed(tamb)\n    acc = (acc_factor-1.)*g*slope\n    if full_output:\n        return slope,vz,fn,ff,acc,cz,cx,pamb,tamb\n    else:\n        return slope,vz\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.TakeOff.arrival_ground_legs","title":"arrival_ground_legs","text":"<pre><code>arrival_ground_legs(ldw)\n</code></pre> <p>Compute fuel and time allowances for arrival ground phases</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def arrival_ground_legs(self,ldw):\n    \"\"\"Compute fuel and time allowances for arrival ground phases\n    \"\"\"\n    n_engine = self.aircraft.power_system.n_engine\n    reference_thrust = self.aircraft.power_system.get_reference_thrust()\n    fuel_type = self.aircraft.arrangement.fuel_type\n\n    time_landing = 180.\n    time_taxi_in = 420.\n\n    if fuel_type!=\"battery\":\n        engine_bpr = self.aircraft.airframe.nacelle.engine_bpr\n        fuel_mass_factor = earth.fuel_heat(\"kerosene\") / earth.fuel_heat(fuel_type)\n        fuel_landing = fuel_mass_factor*1e-4*(0.5+2.3/engine_bpr)*ldw\n        fuel_taxi_in = fuel_mass_factor*(26. + 1.8e-4*reference_thrust)*n_engine\n        return {\"fuel\":{\"landing\":fuel_landing,\"taxi_in\":fuel_taxi_in},\n                \"time\":{\"landing\":time_landing,\"taxi_in\":time_taxi_in}}\n    else:\n        enrg_landing = (0.25*43.1e6)*0.75e-4*ldw\n        enrg_taxi_in = (0.25*43.1e6)*(26. + 1.8e-4*reference_thrust)*n_engine\n        return {\"enrg\":{\"landing\":enrg_landing,\"taxi_in\":enrg_taxi_in},\n                \"time\":{\"landing\":time_landing,\"taxi_in\":time_taxi_in}}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.TakeOff.breguet_range","title":"breguet_range","text":"<pre><code>breguet_range(range, tow, ktow, altp, mach, disa)\n</code></pre> <p>Breguet range equation is dependant from power architecture</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def breguet_range(self,range,tow,ktow,altp,mach,disa):\n    \"\"\"Breguet range equation is dependant from power architecture\n    \"\"\"\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    tas = mach * earth.sound_speed(tamb)\n    time = 1.09*(range/tas)\n\n    dict = self.level_flight(pamb,tamb,mach,tow*ktow)\n    val = self.aircraft.power_system.specific_breguet_range(tow,range,tas,dict)\n    return val,time\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.TakeOff.departure_ground_legs","title":"departure_ground_legs","text":"<pre><code>departure_ground_legs(tow)\n</code></pre> <p>Compute fuel and time allowances for departure ground phases</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def departure_ground_legs(self,tow):\n    \"\"\"Compute fuel and time allowances for departure ground phases\n    \"\"\"\n    n_engine = self.aircraft.power_system.n_engine\n    reference_thrust = self.aircraft.power_system.get_reference_thrust()\n    fuel_type = self.aircraft.arrangement.fuel_type\n\n    time_taxi_out = 540.\n    time_take_off = 220.*tow/(reference_thrust*n_engine)\n\n    if fuel_type!=\"battery\":\n        engine_bpr = self.aircraft.airframe.nacelle.engine_bpr\n        fuel_mass_factor = earth.fuel_heat(\"kerosene\") / earth.fuel_heat(fuel_type)\n        fuel_taxi_out = fuel_mass_factor*(34. + 2.3e-4*reference_thrust)*n_engine\n        fuel_take_off = fuel_mass_factor*1e-4*(2.8+2.3/engine_bpr)*tow\n        return {\"fuel\":{\"taxi_out\":fuel_taxi_out,\"take_off\":fuel_take_off},\n                \"time\":{\"taxi_out\":time_taxi_out,\"take_off\":time_take_off}}\n    else:\n        enrg_taxi_out = (0.25*43.1e6)*(34. + 2.3e-4*reference_thrust)*n_engine\n        enrg_take_off = (0.25*43.1e6)*3.e-4*tow\n        return {\"enrg\":{\"taxi_out\":enrg_taxi_out,\"take_off\":enrg_take_off},\n                \"time\":{\"taxi_out\":time_taxi_out,\"take_off\":time_take_off}}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.TakeOff.descent","title":"descent","text":"<pre><code>descent(nei, altp, disa, speed_mode, speed, vz, mass)\n</code></pre> <p>Retrieve air path and flight characteristics in various conditions</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def descent(self,nei,altp,disa,speed_mode,speed,vz,mass):\n    \"\"\"Retrieve air path and flight characteristics in various conditions\n    \"\"\"\n    g = earth.gravity()\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    mach = self.get_mach(pamb,speed_mode,speed)\n\n    slope = vz / (mach * earth.sound_speed(tamb))\n    acc_factor = earth.climb_mode(speed_mode, mach, dtodz, tstd, disa)\n\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    fn = (slope * acc_factor + 1./lod) * (mass*g)\n    dict = self.aircraft.power_system.sc(self,pamb,tamb,mach,\"FID\", fn, nei)\n    ff = dict[\"sfc\"]*fn\n    thtl = dict[\"thtl\"]\n\n    return slope,thtl,fn,ff,cz,cx,pamb,tamb\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.TakeOff.eval","title":"eval","text":"<pre><code>eval(\n    disa,\n    altp,\n    mass,\n    hld_conf,\n    rating,\n    kfn,\n    kvs1g,\n    s2_min_path,\n)\n</code></pre> <p>Take off field length and climb path with eventual kVs1g increase to recover min regulatory slope</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def eval(self,disa,altp,mass,hld_conf,rating,kfn,kvs1g,s2_min_path):\n    \"\"\"Take off field length and climb path with eventual kVs1g increase to recover min regulatory slope\n    \"\"\"\n    tofl,s2_path,cas,mach,cz,w_aoa = self.take_off(kvs1g,altp,disa,mass,hld_conf,rating,kfn)\n\n    if(s2_min_path&lt;s2_path):\n        limitation = \"fl\"   # field length\n    else:\n        dkvs1g = 0.005\n        kvs1g_ = np.array([0.,0.])\n        kvs1g_[0] = kvs1g\n        kvs1g_[1] = kvs1g + dkvs1g\n\n        s2_path_ = np.array([0.,0.])\n        s2_path_[0] = s2_path\n        tofl,s2_path_[1],cas,mach,cz,w_aoa = self.take_off(kvs1g_[1],altp,disa,mass,hld_conf,rating,kfn)\n\n        while(s2_path_[0]&lt;s2_path_[1] and s2_path_[1]&lt;s2_min_path):\n            kvs1g_[0] = kvs1g_[1]\n            kvs1g_[1] = kvs1g_[1] + dkvs1g\n            tofl,s2_path_[1],cas,mach,cz,w_aoa = self.take_off(kvs1g_[1],altp,disa,mass,hld_conf,rating,kfn)\n\n        if(s2_min_path&lt;s2_path_[1]):\n            kvs1g = kvs1g_[0] + ((kvs1g_[1]-kvs1g_[0])/(s2_path_[1]-s2_path_[0]))*(s2_min_path-s2_path_[0])\n            tofl,s2_path,cas,mach,cz,w_aoa = self.take_off(kvs1g,altp,disa,mass,hld_conf,rating,kfn)\n            s2_path = s2_min_path\n            limitation = \"s2\"   # second segment\n        else:\n            tofl,s2_path,cas,mach,cz,w_aoa = self.take_off(kvs1g,altp,disa,mass,hld_conf,rating,kfn)\n            limitation = \"s2 not reached\"\n\n    to_dict = {\"tofl\":tofl, \"kvs1g\":kvs1g, \"path\":s2_path, \"v2\":cas, \"mach2\":mach, \"limit\":limitation, \"cz\":cz, \"aoa_wing\":w_aoa}\n\n    return to_dict\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.TakeOff.eval_sar","title":"eval_sar","text":"<pre><code>eval_sar(altp, mass, mach, disa)\n</code></pre> <p>Evaluate Specific Air Range</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def eval_sar(self,altp,mass,mach,disa):\n    \"\"\"Evaluate Specific Air Range\n    \"\"\"\n    g = earth.gravity()\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    tas = mach * earth.sound_speed(tamb)\n\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    nei = 0\n    thrust = mass*g / lod\n    dict = self.aircraft.power_system.sc(pamb,tamb,mach,\"MCR\",thrust,nei)\n    dict[\"fn\"] = thrust\n    dict[\"cz\"] = cz\n    dict[\"cx\"] = cx\n    dict[\"lod\"] = lod\n    dict[\"sar\"] = self.aircraft.power_system.specific_air_range(mass,tas,dict)\n    return dict\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.TakeOff.get_mach","title":"get_mach","text":"<pre><code>get_mach(pamb, speed_mode, speed)\n</code></pre> <p>Retrieve Mach from CAS or mach depending on speed_mode</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def get_mach(self,pamb,speed_mode,speed):\n    \"\"\"Retrieve Mach from CAS or mach depending on speed_mode\n    \"\"\"\n    mach = {\"cas\" : earth.mach_from_vcas(pamb, speed),  # Input is CAS\n            \"mach\" : speed  # Input is mach\n            }.get(speed_mode, \"Erreur: select speed_mode equal to cas or mach\")\n    return mach\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.TakeOff.get_speed","title":"get_speed","text":"<pre><code>get_speed(pamb, speed_mode, mach)\n</code></pre> <p>retrieve CAS or Mach from mach depending on speed_mode</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def get_speed(self,pamb,speed_mode,mach):\n    \"\"\"retrieve CAS or Mach from mach depending on speed_mode\n    \"\"\"\n    speed = {\"cas\" : earth.vcas_from_mach(pamb, mach),  # CAS required\n             \"mach\" : mach  # mach required\n             }.get(speed_mode, \"Erreur: select speed_mode equal to cas or mach\")\n    return speed\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.TakeOff.get_vcas","title":"get_vcas","text":"<pre><code>get_vcas(pamb, speed_mode, speed)\n</code></pre> <p>Retrieve CAS from Mach or CAS depending on speed_mode</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def get_vcas(self,pamb,speed_mode,speed):\n    \"\"\"Retrieve CAS from Mach or CAS depending on speed_mode\n    \"\"\"\n    cas = {\"mach\" : earth.vcas_from_mach(pamb, speed),  # Input is CAS\n            \"cas\" : speed  # Input is mach\n            }.get(speed_mode, \"Erreur: select speed_mode equal to cas or mach\")\n    return cas\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.TakeOff.holding","title":"holding","text":"<pre><code>holding(time, mass, altp, mach, disa)\n</code></pre> <p>Holding equation is dependant from power architecture</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def holding(self,time,mass,altp,mach,disa):\n    \"\"\"Holding equation is dependant from power architecture\n    \"\"\"\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    tas = mach * earth.sound_speed(tamb)\n    dict = self.level_flight(pamb,tamb,mach,mass)\n    return self.aircraft.power_system.specific_holding(mass,time,tas,dict)\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.TakeOff.level_flight","title":"level_flight","text":"<pre><code>level_flight(pamb, tamb, mach, mass)\n</code></pre> <p>Level flight equilibrium</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def level_flight(self,pamb,tamb,mach,mass):\n    \"\"\"Level flight equilibrium\n    \"\"\"\n    g = earth.gravity()\n    r,gam,Cp,Cv = earth.gas_data()\n    tas = mach * earth.sound_speed(tamb)\n\n    cz = (2.*mass*g)/(gam*pamb*mach**2*self.aircraft.airframe.wing.area)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    thrust = (gam/2.)*pamb*mach**2*self.aircraft.airframe.wing.area*cx\n    dict = self.aircraft.power_system.sc(pamb,tamb,mach,\"MCR\",thrust)\n    dict[\"fn\"] = thrust\n    dict[\"cx\"] = cx\n    dict[\"cz\"] = cz\n    dict[\"lod\"] = lod\n    dict[\"sar\"] = self.aircraft.power_system.specific_air_range(mass,tas,dict)\n    return dict\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.TakeOff.lift_from_speed","title":"lift_from_speed","text":"<pre><code>lift_from_speed(pamb, tamb, mach, mass)\n</code></pre> <p>Retrieve cz from mach using simplified lift equation</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def lift_from_speed(self,pamb,tamb,mach,mass):\n    \"\"\"Retrieve cz from mach using simplified lift equation\n    \"\"\"\n    g = earth.gravity()\n    r,gam,Cp,Cv = earth.gas_data()\n    cz = (2.*mass*g)/(gam*pamb*mach**2*self.aircraft.airframe.wing.area)\n    return cz\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.TakeOff.max_air_path","title":"max_air_path","text":"<pre><code>max_air_path(\n    nei,\n    altp,\n    disa,\n    speed_mode,\n    mass,\n    rating,\n    kfn,\n    full_output=False,\n)\n</code></pre> <p>Optimize the speed of the aircraft to maximize the air path</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def max_air_path(self,nei,altp,disa,speed_mode,mass,rating,kfn, full_output=False):\n    \"\"\"Optimize the speed of the aircraft to maximize the air path\n    \"\"\"\n    def fct(cz):\n        pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n        mach = self.speed_from_lift(pamb,tamb,cz,mass)\n        speed = self.get_speed(pamb,speed_mode,mach)\n        slope,vz = self.air_path(nei,altp,disa,speed_mode,speed,mass,rating,kfn)\n        if isformax: return slope\n        else: return slope,vz,mach\n\n    cz_ini = 0.5\n    dcz = 0.05\n\n    isformax = True\n    cz,slope,rc = maximize_1d(cz_ini,dcz,[fct])\n    isformax = False\n\n    slope,vz,mach = fct(cz)\n    return slope,vz,mach,cz\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.TakeOff.propulsion_ceiling","title":"propulsion_ceiling","text":"<pre><code>propulsion_ceiling(\n    altp_ini,\n    nei,\n    vzreq,\n    disa,\n    speed_mode,\n    speed,\n    mass,\n    rating,\n    throttle,\n)\n</code></pre> <p>Optimize the speed of the aircraft to maximize the air path</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def propulsion_ceiling(self,altp_ini,nei,vzreq,disa,speed_mode,speed,mass,rating,throttle):\n    \"\"\"Optimize the speed of the aircraft to maximize the air path\n    \"\"\"\n    def fct_prop_ceiling(altp,nei,vzreq,disa,speed_mode,speed,mass,rating):\n        slope,vz = self.air_path(nei,altp,disa,speed_mode,speed,mass,rating,throttle)\n        delta_vz = vz - vzreq\n        return delta_vz\n\n    fct_arg = (nei,vzreq,disa,speed_mode,speed,mass,rating)\n\n    output_dict = fsolve(fct_prop_ceiling, x0 = altp_ini, args=fct_arg, full_output = True)\n\n    altp = output_dict[0][0]\n    rei = output_dict[2]\n    if(rei!=1): altp = np.NaN\n\n    return altp, rei\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.TakeOff.speed_from_lift","title":"speed_from_lift","text":"<pre><code>speed_from_lift(pamb, tamb, cz, mass)\n</code></pre> <p>Retrieve mach from cz using simplified lift equation</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def speed_from_lift(self,pamb,tamb,cz,mass):\n    \"\"\"Retrieve mach from cz using simplified lift equation\n    \"\"\"\n    g = earth.gravity()\n    r,gam,Cp,Cv = earth.gas_data()\n    mach = np.sqrt((mass*g)/(0.5*gam*pamb*self.aircraft.airframe.wing.area*cz))\n    return mach\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.TakeOff.take_off","title":"take_off","text":"<pre><code>take_off(kvs1g, altp, disa, mass, hld_conf, rating, kfn)\n</code></pre> <p>Take off field length and climb path at 35 ft depending on stall margin (kVs1g)</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def take_off(self,kvs1g,altp,disa,mass,hld_conf,rating,kfn):\n    \"\"\"Take off field length and climb path at 35 ft depending on stall margin (kVs1g)\n    \"\"\"\n    czmax,cz0 = self.aircraft.airframe.wing.high_lift(hld_conf)\n\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    rho,sig = earth.air_density(pamb, tamb)\n\n    cz_to = czmax / kvs1g**2\n    mach = self.speed_from_lift(pamb,tamb,cz_to,mass)\n    speed_factor = 0.7\n\n    nei = 0    # For Magic Line factor computation\n    throttle = 1.\n    dict = self.aircraft.power_system.thrust(pamb, tamb, speed_factor*mach, rating, throttle,nei)\n    fn = kfn*dict[\"fn\"]\n\n    ml_factor = mass**2 / (cz_to*fn*self.aircraft.airframe.wing.area*sig**0.8 )  # Magic Line factor\n    # tofl = 15.5*ml_factor + 100.    # Magic line\n    tofl = 10.7*ml_factor + 100.    # Magic line\n\n    nei = 1             # For 2nd segment computation\n    speed_mode = \"cas\"  # Constant CAS\n    speed = self.get_speed(pamb,speed_mode,mach)\n\n    s2_path,vz = self.air_path(nei,altp,disa,speed_mode,speed,mass,\"MTO\",kfn)\n\n    w_aoa_to,_ = self.aircraft.aerodynamics.aoa(mach,cz_to)\n\n    return tofl,s2_path,speed,mach,cz_to,w_aoa_to\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.TimeToClimb","title":"TimeToClimb","text":"<pre><code>TimeToClimb(aircraft)\n</code></pre> <p>               Bases: <code>Flight</code></p> <p>Definition of all mission types</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def __init__(self, aircraft):\n    super(TimeToClimb, self).__init__(aircraft)\n\n    self.disa = None\n    self.altp = None\n    self.mach = None\n    self.kmtow = None\n    self.cas1 = None\n    self.altp1 = None\n    self.cas2 = None\n    self.altp2 = None\n    self.altp = None\n    self.ttc_req = None\n    self.ttc_eff = None\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.TimeToClimb-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.TimeToClimb.acceleration","title":"acceleration","text":"<pre><code>acceleration(\n    nei,\n    altp,\n    disa,\n    speed_mode,\n    speed,\n    mass,\n    rating,\n    throttle,\n    full_output=False,\n)\n</code></pre> <p>Aircraft acceleration on level flight</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def acceleration(self,nei,altp,disa,speed_mode,speed,mass,rating,throttle, full_output=False):\n    \"\"\"Aircraft acceleration on level flight\n    \"\"\"\n    r,gam,Cp,Cv = earth.gas_data()\n\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    mach = self.get_mach(pamb,speed_mode,speed)\n\n    dict = self.aircraft.power_system.thrust(pamb,tamb,mach,rating,throttle=throttle,nei=nei)\n    fn = dict[\"fn\"]\n    ff = dict[\"ff\"]\n\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    if(nei&gt;0):\n        dcx = self.aircraft.power_system.oei_drag(pamb,mach)\n        cx = cx + dcx*nei\n\n    acc = (fn - 0.5*gam*pamb*mach**2*self.aircraft.airframe.wing.area*cx) / mass\n\n    if full_output:\n        return acc,fn,ff,cz,cx,pamb,tamb\n    else:\n        return acc\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.TimeToClimb.air_path","title":"air_path","text":"<pre><code>air_path(\n    nei,\n    altp,\n    disa,\n    speed_mode,\n    speed,\n    mass,\n    rating,\n    kfn,\n    full_output=False,\n)\n</code></pre> <p>Retrieve air path in various conditions</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def air_path(self,nei,altp,disa,speed_mode,speed,mass,rating,kfn, full_output=False):\n    \"\"\"Retrieve air path in various conditions\n    \"\"\"\n    g = earth.gravity()\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    mach = self.get_mach(pamb,speed_mode,speed)\n\n    dict = self.aircraft.power_system.thrust(pamb,tamb,mach,rating,nei=nei)\n    fn = dict[\"fn\"]*kfn\n    ff = dict[\"ff\"]*kfn\n    if kfn!=1. and full_output:\n        print(\"WARNING, air_path method, kfn is different from 1, fuel flow may not be accurate\")\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    if(nei&gt;0):\n        dcx = self.aircraft.power_system.oei_drag(pamb,mach)\n        cx = cx + dcx*nei\n        lod = cz/cx\n\n    acc_factor = earth.climb_mode(speed_mode, mach, dtodz, tstd, disa)\n    slope = ( fn/(mass*g) - 1./lod ) / acc_factor\n    vz = slope * mach * earth.sound_speed(tamb)\n    acc = (acc_factor-1.)*g*slope\n    if full_output:\n        return slope,vz,fn,ff,acc,cz,cx,pamb,tamb\n    else:\n        return slope,vz\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.TimeToClimb.arrival_ground_legs","title":"arrival_ground_legs","text":"<pre><code>arrival_ground_legs(ldw)\n</code></pre> <p>Compute fuel and time allowances for arrival ground phases</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def arrival_ground_legs(self,ldw):\n    \"\"\"Compute fuel and time allowances for arrival ground phases\n    \"\"\"\n    n_engine = self.aircraft.power_system.n_engine\n    reference_thrust = self.aircraft.power_system.get_reference_thrust()\n    fuel_type = self.aircraft.arrangement.fuel_type\n\n    time_landing = 180.\n    time_taxi_in = 420.\n\n    if fuel_type!=\"battery\":\n        engine_bpr = self.aircraft.airframe.nacelle.engine_bpr\n        fuel_mass_factor = earth.fuel_heat(\"kerosene\") / earth.fuel_heat(fuel_type)\n        fuel_landing = fuel_mass_factor*1e-4*(0.5+2.3/engine_bpr)*ldw\n        fuel_taxi_in = fuel_mass_factor*(26. + 1.8e-4*reference_thrust)*n_engine\n        return {\"fuel\":{\"landing\":fuel_landing,\"taxi_in\":fuel_taxi_in},\n                \"time\":{\"landing\":time_landing,\"taxi_in\":time_taxi_in}}\n    else:\n        enrg_landing = (0.25*43.1e6)*0.75e-4*ldw\n        enrg_taxi_in = (0.25*43.1e6)*(26. + 1.8e-4*reference_thrust)*n_engine\n        return {\"enrg\":{\"landing\":enrg_landing,\"taxi_in\":enrg_taxi_in},\n                \"time\":{\"landing\":time_landing,\"taxi_in\":time_taxi_in}}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.TimeToClimb.breguet_range","title":"breguet_range","text":"<pre><code>breguet_range(range, tow, ktow, altp, mach, disa)\n</code></pre> <p>Breguet range equation is dependant from power architecture</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def breguet_range(self,range,tow,ktow,altp,mach,disa):\n    \"\"\"Breguet range equation is dependant from power architecture\n    \"\"\"\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    tas = mach * earth.sound_speed(tamb)\n    time = 1.09*(range/tas)\n\n    dict = self.level_flight(pamb,tamb,mach,tow*ktow)\n    val = self.aircraft.power_system.specific_breguet_range(tow,range,tas,dict)\n    return val,time\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.TimeToClimb.departure_ground_legs","title":"departure_ground_legs","text":"<pre><code>departure_ground_legs(tow)\n</code></pre> <p>Compute fuel and time allowances for departure ground phases</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def departure_ground_legs(self,tow):\n    \"\"\"Compute fuel and time allowances for departure ground phases\n    \"\"\"\n    n_engine = self.aircraft.power_system.n_engine\n    reference_thrust = self.aircraft.power_system.get_reference_thrust()\n    fuel_type = self.aircraft.arrangement.fuel_type\n\n    time_taxi_out = 540.\n    time_take_off = 220.*tow/(reference_thrust*n_engine)\n\n    if fuel_type!=\"battery\":\n        engine_bpr = self.aircraft.airframe.nacelle.engine_bpr\n        fuel_mass_factor = earth.fuel_heat(\"kerosene\") / earth.fuel_heat(fuel_type)\n        fuel_taxi_out = fuel_mass_factor*(34. + 2.3e-4*reference_thrust)*n_engine\n        fuel_take_off = fuel_mass_factor*1e-4*(2.8+2.3/engine_bpr)*tow\n        return {\"fuel\":{\"taxi_out\":fuel_taxi_out,\"take_off\":fuel_take_off},\n                \"time\":{\"taxi_out\":time_taxi_out,\"take_off\":time_take_off}}\n    else:\n        enrg_taxi_out = (0.25*43.1e6)*(34. + 2.3e-4*reference_thrust)*n_engine\n        enrg_take_off = (0.25*43.1e6)*3.e-4*tow\n        return {\"enrg\":{\"taxi_out\":enrg_taxi_out,\"take_off\":enrg_take_off},\n                \"time\":{\"taxi_out\":time_taxi_out,\"take_off\":time_take_off}}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.TimeToClimb.descent","title":"descent","text":"<pre><code>descent(nei, altp, disa, speed_mode, speed, vz, mass)\n</code></pre> <p>Retrieve air path and flight characteristics in various conditions</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def descent(self,nei,altp,disa,speed_mode,speed,vz,mass):\n    \"\"\"Retrieve air path and flight characteristics in various conditions\n    \"\"\"\n    g = earth.gravity()\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    mach = self.get_mach(pamb,speed_mode,speed)\n\n    slope = vz / (mach * earth.sound_speed(tamb))\n    acc_factor = earth.climb_mode(speed_mode, mach, dtodz, tstd, disa)\n\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    fn = (slope * acc_factor + 1./lod) * (mass*g)\n    dict = self.aircraft.power_system.sc(self,pamb,tamb,mach,\"FID\", fn, nei)\n    ff = dict[\"sfc\"]*fn\n    thtl = dict[\"thtl\"]\n\n    return slope,thtl,fn,ff,cz,cx,pamb,tamb\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.TimeToClimb.eval","title":"eval","text":"<pre><code>eval(\n    disa,\n    toc,\n    mach,\n    mass,\n    altp1,\n    vcas1,\n    altp2,\n    vcas2,\n    rating,\n    kfn,\n)\n</code></pre> <p>Time to climb to initial cruise altitude For simplicity reasons, airplane mass is supposed constant</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def eval(self,disa,toc,mach,mass,altp1,vcas1,altp2,vcas2,rating,kfn):\n    \"\"\"\n    Time to climb to initial cruise altitude\n    For simplicity reasons, airplane mass is supposed constant\n    \"\"\"\n    if(vcas1&gt; unit.mps_kt(250.)):\n        print(\"vcas1 = \", unit.kt_mps(vcas1))\n        print(\"vcas1 must be lower than or equal to 250kt\")\n    if(vcas1&gt;vcas2):\n        print(\"vcas1 = \", unit.kt_mps(vcas1))\n        print(\"vcas2 = \", unit.kt_mps(vcas2))\n        print(\"vcas1 must be lower than or equal to vcas2\")\n\n    cross_over_altp = earth.cross_over_altp(vcas2, mach)\n\n    if(cross_over_altp&lt;altp1):\n        print(\"Cross over altitude is too low\")\n\n    if(toc&lt;cross_over_altp):\n        cross_over_altp = toc\n\n    # Duration of initial climb\n    #-----------------------------------------------------------------------------------------------------------\n    altp_0 = altp1\n    altp_2 = altp2\n    altp_1 = (altp_0+altp_2)/2.\n    altp = np.array([altp_0, altp_1, altp_2])\n\n    nei = 0\n    speed_mode = \"cas\"    # Constant CAS\n\n    slope,v_z0 = self.air_path(nei,altp[0],disa,speed_mode,vcas1,mass,rating,kfn)\n    slope,v_z1 = self.air_path(nei,altp[1],disa,speed_mode,vcas1,mass,rating,kfn)\n    slope,v_z2 = self.air_path(nei,altp[2],disa,speed_mode,vcas1,mass,rating,kfn)\n    v_z = np.array([v_z0, v_z1, v_z2])\n\n    if (v_z[0]&lt;0. or v_z[1]&lt;0. or v_z[2]&lt;0.):\n        print(\"Climb to acceleration altitude is not possible\")\n\n    A = vander3(altp)\n    B = 1./v_z\n    C = trinome(A,B)\n\n    time1 = ((C[0]*altp[2]/3. + C[1]/2.)*altp[2] + C[2])*altp[2]\n    time1 = time1 - ((C[0]*altp[0]/3. + C[1]/2.)*altp[0] + C[2])*altp[0]\n\n    # Acceleration\n    #-----------------------------------------------------------------------------------------------------------\n    vc0 = vcas1\n    vc2 = vcas2\n    vc1 = (vc0+vc2)/2.\n    vcas = np.array([vc0, vc1, vc2])\n\n    acc0 = self.acceleration(nei,altp[2],disa,speed_mode,vcas[0],mass,rating,kfn)\n    acc1 = self.acceleration(nei,altp[2],disa,speed_mode,vcas[1],mass,rating,kfn)\n    acc2 = self.acceleration(nei,altp[2],disa,speed_mode,vcas[2],mass,rating,kfn)\n    acc = np.array([acc0, acc1, acc2])\n\n    if(acc[0]&lt;0. or acc[1]&lt;0. or acc[2]&lt;0.):\n        print(\"Acceleration is not possible\")\n\n    A = vander3(vcas)\n    B = 1./acc\n    C = trinome(A,B)\n\n    time2 = ((C[0]*vcas[2]/3. + C[1]/2.)*vcas[2] + C[2])*vcas[2]\n    time2 = time2 - ((C[0]*vcas[0]/3. + C[1]/2.)*vcas[0] + C[2])*vcas[0]\n\n    # Duration of climb to cross over\n    #-----------------------------------------------------------------------------------------------------------\n    altp_0 = altp2\n    altp_2 = cross_over_altp\n    altp_1 = (altp_0+altp_2)/2.\n    altp = np.array([altp_0, altp_1, altp_2])\n\n    slope,v_z0 = self.air_path(nei,altp[0],disa,speed_mode,vcas2,mass,rating,kfn)\n    slope,v_z1 = self.air_path(nei,altp[1],disa,speed_mode,vcas2,mass,rating,kfn)\n    slope,v_z2 = self.air_path(nei,altp[2],disa,speed_mode,vcas2,mass,rating,kfn)\n    v_z = np.array([v_z0, v_z1, v_z2])\n\n    if(v_z[0]&lt;0. or v_z[1]&lt;0. or v_z[2]&lt;0.):\n        print(\"Climb to cross over altitude is not possible\")\n\n    A = vander3(altp)\n    B = 1./v_z\n    C = trinome(A,B)\n\n    time3 = ((C[0]*altp[2]/3. + C[1]/2.)*altp[2] + C[2])*altp[2]\n    time3 = time3 - ((C[0]*altp[0]/3. + C[1]/2.)*altp[0] + C[2])*altp[0]\n\n    # Duration of climb to altp\n    #-----------------------------------------------------------------------------------------------------------\n    if(cross_over_altp&lt;toc):\n        altp_0 = cross_over_altp\n        altp_2 = toc\n        altp_1 = (altp_0+altp_2)/2.\n        altp = np.array([altp_0, altp_1, altp_2])\n\n        speed_mode = \"mach\"    # mach\n\n        slope,v_z0 = self.air_path(nei,altp[0],disa,speed_mode,mach,mass,rating,kfn)\n        slope,v_z1 = self.air_path(nei,altp[1],disa,speed_mode,mach,mass,rating,kfn)\n        slope,v_z2 = self.air_path(nei,altp[2],disa,speed_mode,mach,mass,rating,kfn)\n        v_z = np.array([v_z0, v_z1, v_z2])\n\n        if(v_z[0]&lt;0. or v_z[1]&lt;0. or v_z[2]&lt;0.):\n            print(\"Climb to top of climb is not possible\")\n\n        A = vander3(altp)\n        B = 1./v_z\n        C = trinome(A,B)\n\n        time4 =  ((C[0]*altp[2]/3. + C[1]/2.)*altp[2] + C[2])*altp[2] \\\n               - ((C[0]*altp[0]/3. + C[1]/2.)*altp[0] + C[2])*altp[0]\n    else:\n        time4 = 0.\n\n    #    Total time\n    #-----------------------------------------------------------------------------------------------------------\n    ttc = time1 + time2 + time3 + time4\n\n    return {\"ttc\":ttc}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.TimeToClimb.eval_sar","title":"eval_sar","text":"<pre><code>eval_sar(altp, mass, mach, disa)\n</code></pre> <p>Evaluate Specific Air Range</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def eval_sar(self,altp,mass,mach,disa):\n    \"\"\"Evaluate Specific Air Range\n    \"\"\"\n    g = earth.gravity()\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    tas = mach * earth.sound_speed(tamb)\n\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    nei = 0\n    thrust = mass*g / lod\n    dict = self.aircraft.power_system.sc(pamb,tamb,mach,\"MCR\",thrust,nei)\n    dict[\"fn\"] = thrust\n    dict[\"cz\"] = cz\n    dict[\"cx\"] = cx\n    dict[\"lod\"] = lod\n    dict[\"sar\"] = self.aircraft.power_system.specific_air_range(mass,tas,dict)\n    return dict\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.TimeToClimb.get_mach","title":"get_mach","text":"<pre><code>get_mach(pamb, speed_mode, speed)\n</code></pre> <p>Retrieve Mach from CAS or mach depending on speed_mode</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def get_mach(self,pamb,speed_mode,speed):\n    \"\"\"Retrieve Mach from CAS or mach depending on speed_mode\n    \"\"\"\n    mach = {\"cas\" : earth.mach_from_vcas(pamb, speed),  # Input is CAS\n            \"mach\" : speed  # Input is mach\n            }.get(speed_mode, \"Erreur: select speed_mode equal to cas or mach\")\n    return mach\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.TimeToClimb.get_speed","title":"get_speed","text":"<pre><code>get_speed(pamb, speed_mode, mach)\n</code></pre> <p>retrieve CAS or Mach from mach depending on speed_mode</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def get_speed(self,pamb,speed_mode,mach):\n    \"\"\"retrieve CAS or Mach from mach depending on speed_mode\n    \"\"\"\n    speed = {\"cas\" : earth.vcas_from_mach(pamb, mach),  # CAS required\n             \"mach\" : mach  # mach required\n             }.get(speed_mode, \"Erreur: select speed_mode equal to cas or mach\")\n    return speed\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.TimeToClimb.get_vcas","title":"get_vcas","text":"<pre><code>get_vcas(pamb, speed_mode, speed)\n</code></pre> <p>Retrieve CAS from Mach or CAS depending on speed_mode</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def get_vcas(self,pamb,speed_mode,speed):\n    \"\"\"Retrieve CAS from Mach or CAS depending on speed_mode\n    \"\"\"\n    cas = {\"mach\" : earth.vcas_from_mach(pamb, speed),  # Input is CAS\n            \"cas\" : speed  # Input is mach\n            }.get(speed_mode, \"Erreur: select speed_mode equal to cas or mach\")\n    return cas\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.TimeToClimb.holding","title":"holding","text":"<pre><code>holding(time, mass, altp, mach, disa)\n</code></pre> <p>Holding equation is dependant from power architecture</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def holding(self,time,mass,altp,mach,disa):\n    \"\"\"Holding equation is dependant from power architecture\n    \"\"\"\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    tas = mach * earth.sound_speed(tamb)\n    dict = self.level_flight(pamb,tamb,mach,mass)\n    return self.aircraft.power_system.specific_holding(mass,time,tas,dict)\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.TimeToClimb.level_flight","title":"level_flight","text":"<pre><code>level_flight(pamb, tamb, mach, mass)\n</code></pre> <p>Level flight equilibrium</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def level_flight(self,pamb,tamb,mach,mass):\n    \"\"\"Level flight equilibrium\n    \"\"\"\n    g = earth.gravity()\n    r,gam,Cp,Cv = earth.gas_data()\n    tas = mach * earth.sound_speed(tamb)\n\n    cz = (2.*mass*g)/(gam*pamb*mach**2*self.aircraft.airframe.wing.area)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    thrust = (gam/2.)*pamb*mach**2*self.aircraft.airframe.wing.area*cx\n    dict = self.aircraft.power_system.sc(pamb,tamb,mach,\"MCR\",thrust)\n    dict[\"fn\"] = thrust\n    dict[\"cx\"] = cx\n    dict[\"cz\"] = cz\n    dict[\"lod\"] = lod\n    dict[\"sar\"] = self.aircraft.power_system.specific_air_range(mass,tas,dict)\n    return dict\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.TimeToClimb.lift_from_speed","title":"lift_from_speed","text":"<pre><code>lift_from_speed(pamb, tamb, mach, mass)\n</code></pre> <p>Retrieve cz from mach using simplified lift equation</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def lift_from_speed(self,pamb,tamb,mach,mass):\n    \"\"\"Retrieve cz from mach using simplified lift equation\n    \"\"\"\n    g = earth.gravity()\n    r,gam,Cp,Cv = earth.gas_data()\n    cz = (2.*mass*g)/(gam*pamb*mach**2*self.aircraft.airframe.wing.area)\n    return cz\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.TimeToClimb.max_air_path","title":"max_air_path","text":"<pre><code>max_air_path(\n    nei,\n    altp,\n    disa,\n    speed_mode,\n    mass,\n    rating,\n    kfn,\n    full_output=False,\n)\n</code></pre> <p>Optimize the speed of the aircraft to maximize the air path</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def max_air_path(self,nei,altp,disa,speed_mode,mass,rating,kfn, full_output=False):\n    \"\"\"Optimize the speed of the aircraft to maximize the air path\n    \"\"\"\n    def fct(cz):\n        pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n        mach = self.speed_from_lift(pamb,tamb,cz,mass)\n        speed = self.get_speed(pamb,speed_mode,mach)\n        slope,vz = self.air_path(nei,altp,disa,speed_mode,speed,mass,rating,kfn)\n        if isformax: return slope\n        else: return slope,vz,mach\n\n    cz_ini = 0.5\n    dcz = 0.05\n\n    isformax = True\n    cz,slope,rc = maximize_1d(cz_ini,dcz,[fct])\n    isformax = False\n\n    slope,vz,mach = fct(cz)\n    return slope,vz,mach,cz\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.TimeToClimb.propulsion_ceiling","title":"propulsion_ceiling","text":"<pre><code>propulsion_ceiling(\n    altp_ini,\n    nei,\n    vzreq,\n    disa,\n    speed_mode,\n    speed,\n    mass,\n    rating,\n    throttle,\n)\n</code></pre> <p>Optimize the speed of the aircraft to maximize the air path</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def propulsion_ceiling(self,altp_ini,nei,vzreq,disa,speed_mode,speed,mass,rating,throttle):\n    \"\"\"Optimize the speed of the aircraft to maximize the air path\n    \"\"\"\n    def fct_prop_ceiling(altp,nei,vzreq,disa,speed_mode,speed,mass,rating):\n        slope,vz = self.air_path(nei,altp,disa,speed_mode,speed,mass,rating,throttle)\n        delta_vz = vz - vzreq\n        return delta_vz\n\n    fct_arg = (nei,vzreq,disa,speed_mode,speed,mass,rating)\n\n    output_dict = fsolve(fct_prop_ceiling, x0 = altp_ini, args=fct_arg, full_output = True)\n\n    altp = output_dict[0][0]\n    rei = output_dict[2]\n    if(rei!=1): altp = np.NaN\n\n    return altp, rei\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance.TimeToClimb.speed_from_lift","title":"speed_from_lift","text":"<pre><code>speed_from_lift(pamb, tamb, cz, mass)\n</code></pre> <p>Retrieve mach from cz using simplified lift equation</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def speed_from_lift(self,pamb,tamb,cz,mass):\n    \"\"\"Retrieve mach from cz using simplified lift equation\n    \"\"\"\n    g = earth.gravity()\n    r,gam,Cp,Cv = earth.gas_data()\n    mach = np.sqrt((mass*g)/(0.5*gam*pamb*self.aircraft.airframe.wing.area*cz))\n    return mach\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/performance/#lh2pac.marilib.aircraft.performance-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/aircraft/requirement/","title":"Requirement","text":""},{"location":"reference/lh2pac/marilib/aircraft/requirement/#lh2pac.marilib.aircraft.requirement","title":"requirement","text":"<p>Created on Thu Jan 20 20:20:20 2020</p> <p>@author: Conceptual Airplane Design &amp; Operations (CADO team)          Nicolas PETEILH, Pascal ROCHES, Nicolas MONROLIN, Thierry DRUOT          Aircraft &amp; Systems, Air Transport Departement, ENAC</p>"},{"location":"reference/lh2pac/marilib/aircraft/requirement/#lh2pac.marilib.aircraft.requirement-classes","title":"Classes","text":""},{"location":"reference/lh2pac/marilib/aircraft/requirement/#lh2pac.marilib.aircraft.requirement.ApproachReq","title":"ApproachReq","text":"<pre><code>ApproachReq(arrangement, requirement)\n</code></pre> <p>               Bases: <code>object</code></p> <p>Initialize approach requirements</p> Source code in <code>src/lh2pac/marilib/aircraft/requirement.py</code> <pre><code>def __init__(self, arrangement, requirement):\n    self.disa = requirement.model_config.get__init(self,\"disa\")\n    self.altp = requirement.model_config.get__init(self,\"altp\")\n    self.kmlw = requirement.model_config.get__init(self,\"kmlw\")\n    self.kvs1g = requirement.model_config.get__init(self,\"kvs1g\")\n    self.app_speed_req = requirement.model_config.get__init(self,\"app_speed_req\", val=self.__app_speed_req(requirement))\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/requirement/#lh2pac.marilib.aircraft.requirement.ClimbReq","title":"ClimbReq","text":"<pre><code>ClimbReq(arrangement, requirement)\n</code></pre> <p>               Bases: <code>object</code></p> <p>A generic Climb requirement definition</p> Source code in <code>src/lh2pac/marilib/aircraft/requirement.py</code> <pre><code>def __init__(self, arrangement, requirement):\n    self.disa = requirement.model_config.get__init(self,\"disa\")\n    self.altp = requirement.model_config.get__init(self,\"altp\", val=self.top_of_climb(arrangement,requirement))\n    self.mach = requirement.model_config.get__init(self,\"mach\", val=self.trajectory_speed(arrangement,requirement))\n    self.kmtow = requirement.model_config.get__init(self,\"kmtow\")\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/requirement/#lh2pac.marilib.aircraft.requirement.MclCeilingReq","title":"MclCeilingReq","text":"<pre><code>MclCeilingReq(arrangement, requirement)\n</code></pre> <p>               Bases: <code>ClimbReq</code></p> <p>Initialize climb speed requirements in Maximum CLimb thrust rating</p> Source code in <code>src/lh2pac/marilib/aircraft/requirement.py</code> <pre><code>def __init__(self, arrangement, requirement):\n    super(MclCeilingReq, self).__init__(arrangement, requirement)\n    self.rating = requirement.model_config.get__init(self,\"rating\")\n    self.speed_mode = requirement.model_config.get__init(self,\"speed_mode\")\n    self.vz_req = requirement.model_config.get__init(self,\"vz_req\", val=unit.mps_ftpmin(300.))\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/requirement/#lh2pac.marilib.aircraft.requirement.McrCeilingReq","title":"McrCeilingReq","text":"<pre><code>McrCeilingReq(arrangement, requirement)\n</code></pre> <p>               Bases: <code>ClimbReq</code></p> <p>Initialize climb speed requirements in Maximum CRuise thrust rating</p> Source code in <code>src/lh2pac/marilib/aircraft/requirement.py</code> <pre><code>def __init__(self, arrangement, requirement):\n    super(McrCeilingReq, self).__init__(arrangement, requirement)\n    self.rating = requirement.model_config.get__init(self,\"rating\")\n    self.speed_mode = requirement.model_config.get__init(self,\"speed_mode\")\n    self.vz_req = requirement.model_config.get__init(self,\"vz_req\", val=unit.mps_ftpmin(0.))\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/requirement/#lh2pac.marilib.aircraft.requirement.OeiCeilingReq","title":"OeiCeilingReq","text":"<pre><code>OeiCeilingReq(arrangement, requirement)\n</code></pre> <p>               Bases: <code>object</code></p> <p>Initialize one engine inoperative ceiling requirements</p> Source code in <code>src/lh2pac/marilib/aircraft/requirement.py</code> <pre><code>def __init__(self, arrangement, requirement):\n    self.disa = requirement.model_config.get__init(self,\"disa\")\n    self.altp = requirement.model_config.get__init(self,\"altp\", val=0.40*requirement.cruise_altp)\n    self.kmtow = requirement.model_config.get__init(self,\"kmtow\")\n    self.rating = requirement.model_config.get__init(self,\"rating\")\n    self.speed_mode = requirement.model_config.get__init(self,\"speed_mode\")\n    self.path_req = requirement.model_config.get__init(self,\"path_req\", val=self.__oei_min_path(arrangement))\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/requirement/#lh2pac.marilib.aircraft.requirement.Requirement","title":"Requirement","text":"<pre><code>Requirement(\n    n_pax_ref=150.0,\n    design_range=unit.m_NM(3000.0),\n    cruise_mach=0.78,\n    cruise_altp=unit.m_ft(35000.0),\n    model_config=None,\n)\n</code></pre> <p>               Bases: <code>object</code></p> <p>Initialize top level aircraft requirements. The default requirements are for a typical jet liner.</p> <p>:param n_pax_ref: number of passangers. Default is 150. :param design_range: design range of the aircraft in meters. Default is equivalent to 3000 NM. :param cruise_mach: cruise Mach Number. Default is 0.78. :param cruise_altp: cruise altitude in meters. Default is equivalent to 35 000 ft.</p> Source code in <code>src/lh2pac/marilib/aircraft/requirement.py</code> <pre><code>def __init__(self, n_pax_ref = 150.,\n             design_range = unit.m_NM(3000.),\n             cruise_mach = 0.78,\n             cruise_altp = unit.m_ft(35000.),\n             model_config=None):\n    \"\"\"Initialize top level aircraft requirements. The default requirements are for a typical jet liner.\n\n    :param n_pax_ref: number of passangers. Default is 150.\n    :param design_range: design range of the aircraft in meters. Default is equivalent to 3000 NM.\n    :param cruise_mach: cruise Mach Number. Default is 0.78.\n    :param cruise_altp: cruise altitude in meters. Default is equivalent to 35 000 ft.\n    \"\"\"\n    self.cruise_altp = cruise_altp\n    self.cruise_mach = cruise_mach\n    self.design_range = design_range\n    self.n_pax_ref = n_pax_ref\n\n    if model_config is None:\n        self.model_config = ModelConfiguration()\n    else:\n        self.model_config = model_config()\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/requirement/#lh2pac.marilib.aircraft.requirement.Requirement-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/aircraft/requirement/#lh2pac.marilib.aircraft.requirement.Requirement.init_all_requirements","title":"init_all_requirements","text":"<pre><code>init_all_requirements(arrangement)\n</code></pre> <p>Initialize the following categories of requirements:</p> <ul> <li>Take-Off : :class:<code>TakeOffReq</code></li> <li>Approach : :class:<code>ApproachReq</code></li> <li>One Engine Inoperative ceiling : :class:<code>OeiCeilingReq</code></li> <li>Maximum Climb thrust : :class:<code>MclCeilingReq</code></li> <li>Maximum Cruise thrust : :class:<code>McrCeilingReq</code></li> <li>Time to climb requirements : :class:<code>TtcReq</code></li> </ul> Source code in <code>src/lh2pac/marilib/aircraft/requirement.py</code> <pre><code>def init_all_requirements(self,arrangement):\n    \"\"\"Initialize the following categories of requirements:\n\n     * Take-Off : :class:`TakeOffReq`\n     * Approach : :class:`ApproachReq`\n     * One Engine Inoperative ceiling : :class:`OeiCeilingReq`\n     * Maximum Climb thrust : :class:`MclCeilingReq`\n     * Maximum Cruise thrust : :class:`McrCeilingReq`\n     * Time to climb requirements : :class:`TtcReq`\n\n     \"\"\"\n    self.cruise_disa = 0.\n    self.cost_range = self.model_config.get__init(self, \"cost_range\", val=self.__cost_mission_range())\n    self.max_fuel_range_factor = self.model_config.get__init(self, \"max_fuel_range_factor\")\n    self.max_body_aspect_ratio = self.model_config.get__init(self, \"max_body_aspect_ratio\")\n    self.take_off = TakeOffReq(arrangement, self)\n    self.approach = ApproachReq(arrangement, self)\n    self.oei_ceiling = OeiCeilingReq(arrangement, self)\n    self.mcl_ceiling = MclCeilingReq(arrangement, self)\n    self.mcr_ceiling = McrCeilingReq(arrangement, self)\n    self.time_to_climb = TtcReq(arrangement, self)\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/requirement/#lh2pac.marilib.aircraft.requirement.TakeOffReq","title":"TakeOffReq","text":"<pre><code>TakeOffReq(arrangement, requirement)\n</code></pre> <p>               Bases: <code>object</code></p> <p>Initialize take off requirements</p> Source code in <code>src/lh2pac/marilib/aircraft/requirement.py</code> <pre><code>def __init__(self, arrangement, requirement):\n    self.disa = requirement.model_config.get__init(self,\"disa\")\n    self.altp = requirement.model_config.get__init(self,\"altp\")\n    self.kmtow = requirement.model_config.get__init(self,\"kmtow\")\n    self.kvs1g = requirement.model_config.get__init(self,\"kvs1g\")\n    self.s2_min_path = requirement.model_config.get__init(self,\"s2_min_path\", val=self.__s2_min_path(arrangement))\n    self.tofl_req = requirement.model_config.get__init(self,\"tofl_req\", val=self.__tofl_req(requirement))\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/requirement/#lh2pac.marilib.aircraft.requirement.TtcReq","title":"TtcReq","text":"<pre><code>TtcReq(arrangement, requirement)\n</code></pre> <p>               Bases: <code>ClimbReq</code></p> <p>Initialize time to climb requirements</p> Source code in <code>src/lh2pac/marilib/aircraft/requirement.py</code> <pre><code>def __init__(self, arrangement, requirement):\n    super(TtcReq, self).__init__(arrangement, requirement)\n    self.cas1 = requirement.model_config.get__init(self,\"cas1\", val=self.__ttc_cas1(requirement))\n    self.altp1 = requirement.model_config.get__init(self,\"altp1\")\n    self.cas2 = requirement.model_config.get__init(self,\"cas2\", val=self.__ttc_cas2(requirement))\n    self.altp2 = requirement.model_config.get__init(self,\"altp2\")\n    self.altp = requirement.model_config.get__init(self,\"altp\", val=self.top_of_climb(arrangement,requirement))\n    self.ttc_req = requirement.model_config.get__init(self,\"ttc_req\")\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/step_mission/","title":"Step mission","text":""},{"location":"reference/lh2pac/marilib/aircraft/step_mission/#lh2pac.marilib.aircraft.step_mission","title":"step_mission","text":"<p>Created on Thu Jan 20 20:20:20 2020</p> <p>@author: Conceptual Airplane Design &amp; Operations (CADO team)          Nicolas PETEILH, Pascal ROCHES, Nicolas MONROLIN, Thierry DRUOT          Aircraft &amp; Systems, Air Transport Departement, ENAC          Aircraft &amp; Systems, Air Transport Departement, ENAC</p>"},{"location":"reference/lh2pac/marilib/aircraft/step_mission/#lh2pac.marilib.aircraft.step_mission-classes","title":"Classes","text":""},{"location":"reference/lh2pac/marilib/aircraft/step_mission/#lh2pac.marilib.aircraft.step_mission.StepMission","title":"StepMission","text":"<pre><code>StepMission(aircraft)\n</code></pre> <p>               Bases: <code>Flight</code></p> <p>Mission simulated step by step This module precomputes a table of performances before resolving a time intergration of the trajectory using interpolated performances The table is function of pressure altitude and mass in each altitude layer where the speed is fixed :     low : between 1500ft and 10000ft     medium : between 10000ft and cross over altitude     high : from cross over altitude and over Precomputed performances are listed in f_key_list :     vz_mcr : vertical speed in MCR rating     xacc_lvf : level flight acceleration in MCL rating     xdot_mcl : horizontal speed when climbing in MCL rating     vz_mcl : vertical speed in MCL rating     ff_mcl : fuel flow in MCL rating     xdot_fid : horizontal speed when descending in FID rating     vz_fid : vertical speed in FID rating     ff_fid : fuel flow in FID rating     tas : current true air speed (whatever the layer)     sar : current specific air range     ff : fuel flow in level flight</p> Source code in <code>src/lh2pac/marilib/aircraft/step_mission.py</code> <pre><code>def __init__(self, aircraft):\n    self.aircraft = aircraft\n\n    altp_west = np.concatenate((np.arange(2000.,41000.,2000.),np.arange(43000.,85000.,4000.)))\n    altp_east = np.concatenate((np.arange(1000.,42000.,2000.),np.arange(45000.,87000.,4000.)))\n\n    self.heading_altp = {\"west\":[], \"east\":[]}\n    self.heading_altp[\"west\"] = [unit.m_ft(zp) for zp in altp_west]\n    self.heading_altp[\"east\"] = [unit.m_ft(zp) for zp in altp_east]\n\n    self.zstep = 100.\n    self.altp_list = np.arange(0., 16000., self.zstep)\n    self.altpz = self.altp_list[-1]\n\n    self.f_key_list = [\"vz_mcr\", \"acc_lvf\", \"dec_lvf\", \"xdot_mcl\", \"vz_mcl\", \"fn_mcl\", \"ff_mcl\",\n                       \"xdot_fid\", \"vz_fid\", \"fn_fid\", \"ff_fid\", \"pamb\", \"tamb\",\n                       \"mach\", \"cas\", \"tas\", \"sar\", \"fn_crz\", \"ff_crz\"]\n\n    self.data_dict = {}\n    self.data_func = {}\n\n    for key in self.f_key_list:\n        self.data_dict[key] = {\"low\":[],\"medium\":[],\"high\":[]}\n\n    self.data_dict[\"altp\"] = {\"low\":[],\"medium\":[],\"high\":[]}\n    self.data_dict[\"mass\"] = {\"low\":[],\"medium\":[],\"high\":[]}\n\n    self.tow = None\n    self.owe = None\n\n    self.heading = None\n    self.range = None\n\n    self.cruise_x_stop = None\n    self.level_blocker = None\n\n    self.altpw = None\n    self.altpx = None\n    self.altpy = None\n\n    self.cas1 = None\n    self.tas1 = None\n\n    self.cas2 = None\n    self.tas2 = None\n\n    self.mach = None\n\n    self.mass_list = None\n\n    self.change_altp = None\n    self.change_mass = None\n    self.change_cstr = None\n\n    self.flight_profile = None\n\n    self.park_mass = None\n\n    self.taxi_out_fuel = None\n    self.taxi_out_time = None\n    self.taxi_out_dist = None\n\n    self.take_off_fuel = None\n    self.take_off_time = None\n    self.take_off_dist = None\n\n    self.climb_fuel = None\n    self.climb_time = None\n    self.climb_dist = None\n\n    self.cruise_fuel = None\n    self.cruise_time = None\n    self.cruise_dist = None\n\n    self.descent_fuel = None\n    self.descent_time = None\n    self.descent_dist = None\n\n    self.landing_fuel = None\n    self.landing_time = None\n    self.landing_dist = None\n\n    self.taxi_in_fuel = None\n    self.taxi_in_time = None\n    self.taxi_in_dist = None\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/step_mission/#lh2pac.marilib.aircraft.step_mission.StepMission-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/aircraft/step_mission/#lh2pac.marilib.aircraft.step_mission.StepMission.acceleration","title":"acceleration","text":"<pre><code>acceleration(v, state)\n</code></pre> <p>Perform climb trajectory segment at constant Calibrated Air Speed (speed_mode=\"cas\" or constant Mach (speed_mode=\"mach\" The role of the time (t) is taken by true air speed (v) in the integration scheme and time takes part of the state vector state = [t,x,mass]</p> Source code in <code>src/lh2pac/marilib/aircraft/step_mission.py</code> <pre><code>def acceleration(self,v,state):\n    \"\"\"Perform climb trajectory segment at constant Calibrated Air Speed (speed_mode=\"cas\" or constant Mach (speed_mode=\"mach\"\n    The role of the time (t) is taken by true air speed (v) in the integration scheme and time takes part of the state vector\n    state = [t,x,mass]\n    \"\"\"\n    return  np.array([1.,v,self.get_val(\"ff_mcl\",self.altpx, state[2])]) / self.get_val(\"acc_lvf\",self.altpx, state[2])\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/step_mission/#lh2pac.marilib.aircraft.step_mission.StepMission.air_path","title":"air_path","text":"<pre><code>air_path(\n    nei,\n    altp,\n    disa,\n    speed_mode,\n    speed,\n    mass,\n    rating,\n    kfn,\n    full_output=False,\n)\n</code></pre> <p>Retrieve air path in various conditions</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def air_path(self,nei,altp,disa,speed_mode,speed,mass,rating,kfn, full_output=False):\n    \"\"\"Retrieve air path in various conditions\n    \"\"\"\n    g = earth.gravity()\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    mach = self.get_mach(pamb,speed_mode,speed)\n\n    dict = self.aircraft.power_system.thrust(pamb,tamb,mach,rating,nei=nei)\n    fn = dict[\"fn\"]*kfn\n    ff = dict[\"ff\"]*kfn\n    if kfn!=1. and full_output:\n        print(\"WARNING, air_path method, kfn is different from 1, fuel flow may not be accurate\")\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    if(nei&gt;0):\n        dcx = self.aircraft.power_system.oei_drag(pamb,mach)\n        cx = cx + dcx*nei\n        lod = cz/cx\n\n    acc_factor = earth.climb_mode(speed_mode, mach, dtodz, tstd, disa)\n    slope = ( fn/(mass*g) - 1./lod ) / acc_factor\n    vz = slope * mach * earth.sound_speed(tamb)\n    acc = (acc_factor-1.)*g*slope\n    if full_output:\n        return slope,vz,fn,ff,acc,cz,cx,pamb,tamb\n    else:\n        return slope,vz\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/step_mission/#lh2pac.marilib.aircraft.step_mission.StepMission.arrival_ground_legs","title":"arrival_ground_legs","text":"<pre><code>arrival_ground_legs(ldw)\n</code></pre> <p>Compute fuel and time allowances for arrival ground phases</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def arrival_ground_legs(self,ldw):\n    \"\"\"Compute fuel and time allowances for arrival ground phases\n    \"\"\"\n    n_engine = self.aircraft.power_system.n_engine\n    reference_thrust = self.aircraft.power_system.get_reference_thrust()\n    fuel_type = self.aircraft.arrangement.fuel_type\n\n    time_landing = 180.\n    time_taxi_in = 420.\n\n    if fuel_type!=\"battery\":\n        engine_bpr = self.aircraft.airframe.nacelle.engine_bpr\n        fuel_mass_factor = earth.fuel_heat(\"kerosene\") / earth.fuel_heat(fuel_type)\n        fuel_landing = fuel_mass_factor*1e-4*(0.5+2.3/engine_bpr)*ldw\n        fuel_taxi_in = fuel_mass_factor*(26. + 1.8e-4*reference_thrust)*n_engine\n        return {\"fuel\":{\"landing\":fuel_landing,\"taxi_in\":fuel_taxi_in},\n                \"time\":{\"landing\":time_landing,\"taxi_in\":time_taxi_in}}\n    else:\n        enrg_landing = (0.25*43.1e6)*0.75e-4*ldw\n        enrg_taxi_in = (0.25*43.1e6)*(26. + 1.8e-4*reference_thrust)*n_engine\n        return {\"enrg\":{\"landing\":enrg_landing,\"taxi_in\":enrg_taxi_in},\n                \"time\":{\"landing\":time_landing,\"taxi_in\":time_taxi_in}}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/step_mission/#lh2pac.marilib.aircraft.step_mission.StepMission.breguet_range","title":"breguet_range","text":"<pre><code>breguet_range(range, tow, ktow, altp, mach, disa)\n</code></pre> <p>Breguet range equation is dependant from power architecture</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def breguet_range(self,range,tow,ktow,altp,mach,disa):\n    \"\"\"Breguet range equation is dependant from power architecture\n    \"\"\"\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    tas = mach * earth.sound_speed(tamb)\n    time = 1.09*(range/tas)\n\n    dict = self.level_flight(pamb,tamb,mach,tow*ktow)\n    val = self.aircraft.power_system.specific_breguet_range(tow,range,tas,dict)\n    return val,time\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/step_mission/#lh2pac.marilib.aircraft.step_mission.StepMission.climb_path","title":"climb_path","text":"<pre><code>climb_path(z, state)\n</code></pre> <p>Perform climb trajectory segment at constant Calibrated Air Speed (speed_mode=\"cas\" or constant Mach (speed_mode=\"mach\" The role of the time (t) is taken by altitude (z) in the integration scheme and time takes part of the state vector state = [t,x,mass]</p> Source code in <code>src/lh2pac/marilib/aircraft/step_mission.py</code> <pre><code>def climb_path(self,z,state):\n    \"\"\"Perform climb trajectory segment at constant Calibrated Air Speed (speed_mode=\"cas\" or constant Mach (speed_mode=\"mach\"\n    The role of the time (t) is taken by altitude (z) in the integration scheme and time takes part of the state vector\n    state = [t,x,mass]\n    \"\"\"\n    return np.array([1.,\n                     self.get_val(\"xdot_mcl\",z,state[2]),\n                     self.get_val(\"ff_mcl\",z,state[2])]) / self.get_val(\"vz_mcl\",z,state[2])\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/step_mission/#lh2pac.marilib.aircraft.step_mission.StepMission.cruise","title":"cruise","text":"<pre><code>cruise(m, state)\n</code></pre> <p>Perform climb trajectory segment at constant Calibrated Air Speed (speed_mode=\"cas\" or constant Mach (speed_mode=\"mach\" The role of the time (t) is taken by the mass (m) in the integration scheme and time takes part of the state vector state = [t,x,z]</p> Source code in <code>src/lh2pac/marilib/aircraft/step_mission.py</code> <pre><code>def cruise(self,m,state):\n    \"\"\"Perform climb trajectory segment at constant Calibrated Air Speed (speed_mode=\"cas\" or constant Mach (speed_mode=\"mach\"\n    The role of the time (t) is taken by the mass (m) in the integration scheme and time takes part of the state vector\n    state = [t,x,z]\n    \"\"\"\n    return np.array([1., self.get_val(\"tas\",state[2],m), 0.]) / self.get_val(\"ff_crz\",state[2],m)\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/step_mission/#lh2pac.marilib.aircraft.step_mission.StepMission.cruise_stop","title":"cruise_stop","text":"<pre><code>cruise_stop(m, state)\n</code></pre> <p>Cruise stop event state = [t,x,z]</p> Source code in <code>src/lh2pac/marilib/aircraft/step_mission.py</code> <pre><code>def cruise_stop(self,m,state):\n    \"\"\"Cruise stop event\n    state = [t,x,z]\n    \"\"\"\n    return self.cruise_x_stop - state[1]\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/step_mission/#lh2pac.marilib.aircraft.step_mission.StepMission.deceleration","title":"deceleration","text":"<pre><code>deceleration(v, state)\n</code></pre> <p>Perform climb trajectory segment at constant Calibrated Air Speed (speed_mode=\"cas\" or constant Mach (speed_mode=\"mach\" The role of the time (t) is taken by true air speed (v) in the integration scheme and time takes part of the state vector state = [t,x,mass]</p> Source code in <code>src/lh2pac/marilib/aircraft/step_mission.py</code> <pre><code>def deceleration(self,v,state):\n    \"\"\"Perform climb trajectory segment at constant Calibrated Air Speed (speed_mode=\"cas\" or constant Mach (speed_mode=\"mach\"\n    The role of the time (t) is taken by true air speed (v) in the integration scheme and time takes part of the state vector\n    state = [t,x,mass]\n    \"\"\"\n    return  np.array([1.,v,self.get_val(\"ff_fid\",self.altpx, state[2])]) / self.get_val(\"dec_lvf\",self.altpx, state[2])\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/step_mission/#lh2pac.marilib.aircraft.step_mission.StepMission.departure_ground_legs","title":"departure_ground_legs","text":"<pre><code>departure_ground_legs(tow)\n</code></pre> <p>Compute fuel and time allowances for departure ground phases</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def departure_ground_legs(self,tow):\n    \"\"\"Compute fuel and time allowances for departure ground phases\n    \"\"\"\n    n_engine = self.aircraft.power_system.n_engine\n    reference_thrust = self.aircraft.power_system.get_reference_thrust()\n    fuel_type = self.aircraft.arrangement.fuel_type\n\n    time_taxi_out = 540.\n    time_take_off = 220.*tow/(reference_thrust*n_engine)\n\n    if fuel_type!=\"battery\":\n        engine_bpr = self.aircraft.airframe.nacelle.engine_bpr\n        fuel_mass_factor = earth.fuel_heat(\"kerosene\") / earth.fuel_heat(fuel_type)\n        fuel_taxi_out = fuel_mass_factor*(34. + 2.3e-4*reference_thrust)*n_engine\n        fuel_take_off = fuel_mass_factor*1e-4*(2.8+2.3/engine_bpr)*tow\n        return {\"fuel\":{\"taxi_out\":fuel_taxi_out,\"take_off\":fuel_take_off},\n                \"time\":{\"taxi_out\":time_taxi_out,\"take_off\":time_take_off}}\n    else:\n        enrg_taxi_out = (0.25*43.1e6)*(34. + 2.3e-4*reference_thrust)*n_engine\n        enrg_take_off = (0.25*43.1e6)*3.e-4*tow\n        return {\"enrg\":{\"taxi_out\":enrg_taxi_out,\"take_off\":enrg_take_off},\n                \"time\":{\"taxi_out\":time_taxi_out,\"take_off\":time_take_off}}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/step_mission/#lh2pac.marilib.aircraft.step_mission.StepMission.descent","title":"descent","text":"<pre><code>descent(nei, altp, disa, speed_mode, speed, vz, mass)\n</code></pre> <p>Retrieve air path and flight characteristics in various conditions</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def descent(self,nei,altp,disa,speed_mode,speed,vz,mass):\n    \"\"\"Retrieve air path and flight characteristics in various conditions\n    \"\"\"\n    g = earth.gravity()\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    mach = self.get_mach(pamb,speed_mode,speed)\n\n    slope = vz / (mach * earth.sound_speed(tamb))\n    acc_factor = earth.climb_mode(speed_mode, mach, dtodz, tstd, disa)\n\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    fn = (slope * acc_factor + 1./lod) * (mass*g)\n    dict = self.aircraft.power_system.sc(self,pamb,tamb,mach,\"FID\", fn, nei)\n    ff = dict[\"sfc\"]*fn\n    thtl = dict[\"thtl\"]\n\n    return slope,thtl,fn,ff,cz,cx,pamb,tamb\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/step_mission/#lh2pac.marilib.aircraft.step_mission.StepMission.descent_path","title":"descent_path","text":"<pre><code>descent_path(z, state)\n</code></pre> <p>Perform descent trajectory segment at constant Calibrated Air Speed (speed_mode=\"cas\" or constant Mach (speed_mode=\"mach\" The role of the time (t) is taken by altitude (z) in the integration scheme and time takes part of the state vector state = [t,x,mass]</p> Source code in <code>src/lh2pac/marilib/aircraft/step_mission.py</code> <pre><code>def descent_path(self,z,state):\n    \"\"\"Perform descent trajectory segment at constant Calibrated Air Speed (speed_mode=\"cas\" or constant Mach (speed_mode=\"mach\"\n    The role of the time (t) is taken by altitude (z) in the integration scheme and time takes part of the state vector\n    state = [t,x,mass]\n    \"\"\"\n    return np.array([1.,\n                     self.get_val(\"xdot_fid\",z,state[2]),\n                     self.get_val(\"ff_fid\",z,state[2])]) / self.get_val(\"vz_fid\",z,state[2])\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/step_mission/#lh2pac.marilib.aircraft.step_mission.StepMission.eval_sar","title":"eval_sar","text":"<pre><code>eval_sar(altp, mass, mach, disa)\n</code></pre> <p>Evaluate Specific Air Range</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def eval_sar(self,altp,mass,mach,disa):\n    \"\"\"Evaluate Specific Air Range\n    \"\"\"\n    g = earth.gravity()\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    tas = mach * earth.sound_speed(tamb)\n\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    nei = 0\n    thrust = mass*g / lod\n    dict = self.aircraft.power_system.sc(pamb,tamb,mach,\"MCR\",thrust,nei)\n    dict[\"fn\"] = thrust\n    dict[\"cz\"] = cz\n    dict[\"cx\"] = cx\n    dict[\"lod\"] = lod\n    dict[\"sar\"] = self.aircraft.power_system.specific_air_range(mass,tas,dict)\n    return dict\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/step_mission/#lh2pac.marilib.aircraft.step_mission.StepMission.fly_mission_end","title":"fly_mission_end","text":"<pre><code>fly_mission_end(start_mass, start_state, x_stop)\n</code></pre> <p>Perform level cruise sequence(s) and descent</p> Source code in <code>src/lh2pac/marilib/aircraft/step_mission.py</code> <pre><code>def fly_mission_end(self,start_mass,start_state,x_stop):\n    \"\"\"Perform level cruise sequence(s) and descent\n    \"\"\"\n    self.cruise_x_stop = x_stop\n    self.level_blocker = self.climb_dist\n    go_ahead = True\n    level_index = 0\n    sc = []\n    # First cruise segment, constant mach &amp; altitude, state = [t,x,z]\n    #---------------------------------------------------------------------------------------------------------------\n    m0 = start_mass\n    m1 = self.change_mass[1]\n    state0 = start_state\n    n = 5\n    t_eval = np.linspace(m0,m1,n)\n\n    sol = solve_ivp(self.cruise, [m0,m1], state0, t_eval=t_eval, method=\"RK45\", events=self.cruise_stop)\n\n    if (self.range-sol.y[1][-1])&lt;self.level_blocker:   # En of cruise is close, it is useless to climb to upper level\n        m1 = self.owe\n        t_eval = np.linspace(m0,m1,n)\n        sol = solve_ivp(self.cruise, [m0,m1], state0, t_eval=t_eval, method=\"RK45\", events=self.cruise_stop)\n        go_ahead = False\n\n    if np.size(sol.t_events)&gt;0:    # Cruise x stop has been reached, recompute segment up to range\n        m1 = sol.t_events[0][-1]\n        t_eval = np.linspace(m0,m1,n)\n        sol = solve_ivp(self.cruise, [m0,m1], state0, t_eval=t_eval, method=\"RK45\")\n        go_ahead = False\n\n    time = sol.y[0]\n    dist = sol.y[1]\n    altp = sol.y[2]\n    mass = sol.t\n    fn = [self.get_val(\"fn_crz\",z,m)[0] for z,m in zip(altp,mass)]\n    ff = [self.get_val(\"ff_crz\",z,m)[0] for z,m in zip(altp,mass)]\n    pamb = [self.get_val(\"pamb\",z,m)[0] for z,m in zip(altp,mass)]\n    tamb = [self.get_val(\"tamb\",z,m)[0] for z,m in zip(altp,mass)]\n    mach = np.ones(len(sol.t))*self.mach\n    tas = [ma*earth.sound_speed(t) for ma,t in zip(mach,tamb)]\n    cas = [earth.vcas_from_mach(p,ma) for p,ma in zip(pamb,mach)]\n    if go_ahead:\n        s5 = np.vstack((time,dist,altp,mass,pamb,tamb,mach,tas,cas,fn,ff))\n    else:\n        sc = np.vstack((time,dist,altp,mass,pamb,tamb,mach,tas,cas,fn,ff))\n\n    while go_ahead and level_index&lt;(np.size(self.change_altp)-2):\n        # Climb to next cruise level, constant mach, state = [t,x,m]\n        #---------------------------------------------------------------------------------------------------------------\n        z0 = self.change_altp[level_index]\n        z1 = self.change_altp[level_index+1]\n        state1 = np.array([sol.y[0][-1],\n                           sol.y[1][-1],\n                           sol.t[-1]])\n        n = 5\n        t_eval = np.linspace(z0,z1,n)\n\n        sol = solve_ivp(self.climb_path,[z0,z1],state1,t_eval=t_eval, method=\"RK45\")\n\n        time = sol.y[0]\n        dist = sol.y[1]\n        mass = sol.y[2]\n        altp = sol.t\n        fn = [self.get_val(\"fn_mcl\",z,m)[0] for z,m in zip(altp,mass)]\n        ff = [self.get_val(\"ff_mcl\",z,m)[0] for z,m in zip(altp,mass)]\n        pamb = [self.get_val(\"pamb\",z,m)[0] for z,m in zip(altp,mass)]\n        tamb = [self.get_val(\"tamb\",z,m)[0] for z,m in zip(altp,mass)]\n        cas = [self.get_val(\"cas\",z,m)[0] for z,m in zip(altp,mass)]\n        mach = [earth.mach_from_vcas(p,v) for p,v in zip(pamb,cas)]\n        tas = [ma*earth.sound_speed(t) for ma,t in zip(mach,tamb)]\n        s6 = np.vstack((time,dist,altp,mass,pamb,tamb,mach,tas,cas,fn,ff))\n\n        if sol.y[1][-1]&gt;self.cruise_x_stop:    # Cruise x stop has been reached during climb, extend previous segment\n            m1 = sol.y[2][-1]\n            t_eval = np.linspace(m0,m1,n)\n            sol = solve_ivp(self.cruise, [m0,m1], state0, t_eval=t_eval, method=\"RK45\", events=self.cruise_stop)\n            m1 = sol.t_events[0]\n            t_eval = np.linspace(m0,m1,n)\n            sol = solve_ivp(self.cruise, [m0,m1], state0, t_eval=t_eval, method=\"RK45\")\n            time = sol.y[0]\n            dist = sol.y[1]\n            altp = sol.y[2]\n            mass = sol.t\n            fn = [self.get_val(\"fn_crz\",z,m)[0] for z,m in zip(altp,mass)]\n            ff = [self.get_val(\"ff_crz\",z,m)[0] for z,m in zip(altp,mass)]\n            pamb = [self.get_val(\"pamb\",z,m)[0] for z,m in zip(altp,mass)]\n            tamb = [self.get_val(\"tamb\",z,m)[0] for z,m in zip(altp,mass)]\n            mach = np.ones(len(sol.t))*self.mach\n            tas = [ma*earth.sound_speed(t) for ma,t in zip(mach,tamb)]\n            cas = [earth.vcas_from_mach(p,ma) for p,ma in zip(pamb,mach)]\n            s5 = np.vstack((time,dist,altp,mass,pamb,tamb,mach,tas,cas,fn,ff))\n\n            if len(sc)==0:\n                sc = s5\n            else:\n                sc = np.hstack((sc,s5))\n\n            go_ahead = False\n\n        else:                               # Cruise x stop has not been reached\n            # Fly the next cruise segment, constant mach &amp; altitude, state = [t,x,z]\n            #---------------------------------------------------------------------------------------------------------------\n            m0 = sol.y[2][-1]\n            m1 = self.change_mass[level_index+2]\n            state0 = np.array([sol.y[0][-1],\n                               sol.y[1][-1],\n                               sol.t[-1]])\n            n = 5\n            t_eval = np.linspace(m0,m1,n)\n\n            sol = solve_ivp(self.cruise, [m0,m1], state0, t_eval=t_eval, method=\"RK45\", events=self.cruise_stop)\n\n            if np.size(sol.t_events)==0 and (self.range-sol.y[1][-1])&lt;self.level_blocker:   # En of cruise is close, it is useless to climb to upper level, extend\n                m1 = self.owe\n                t_eval = np.linspace(m0,m1,n)\n                sol = solve_ivp(self.cruise, [m0,m1], state0, t_eval=t_eval, method=\"RK45\", events=self.cruise_stop)\n                go_ahead = False\n\n            if np.size(sol.t_events)&gt;0:    # Cruise x stop has been reached, recompute segment up to range\n                m1 = sol.t_events[0][0]\n                t_eval = np.linspace(m0,m1,n)\n                sol = solve_ivp(self.cruise, [m0,m1], state0, t_eval=t_eval, method=\"RK45\")\n                go_ahead = False\n\n            time = sol.y[0]\n            dist = sol.y[1]\n            mass = sol.t\n            altp = sol.y[2]\n            fn = [self.get_val(\"fn_crz\",z,m)[0] for z,m in zip(altp,mass)]\n            ff = [self.get_val(\"ff_crz\",z,m)[0] for z,m in zip(altp,mass)]\n            pamb = [self.get_val(\"pamb\",z,m)[0] for z,m in zip(altp,mass)]\n            tamb = [self.get_val(\"tamb\",z,m)[0] for z,m in zip(altp,mass)]\n            cas = [self.get_val(\"cas\",z,m)[0] for z,m in zip(altp,mass)]\n            mach = [earth.mach_from_vcas(p,v) for p,v in zip(pamb,cas)]\n            tas = [ma*earth.sound_speed(t) for ma,t in zip(mach,tamb)]\n            s7 = np.vstack((time,dist,altp,mass,pamb,tamb,mach,tas,cas,fn,ff))\n\n            if len(sc)==0:\n                sc = np.hstack((s5,s6,s7))\n            else:\n                sc = np.hstack((sc,s6,s7))\n\n            level_index += 1\n\n    self.cruise_time = sol.y[0][-1] - self.climb_time\n    self.cruise_fuel = self.tow - sol.t[-1] - self.climb_fuel\n    self.cruise_dist = sol.y[1][-1] - self.climb_dist\n\n    # First descent segment, constant mach, state = [t,x,mass]\n    #---------------------------------------------------------------------------------------------------------------\n    z0 = sc[2][-1]\n    z1 = self.altpy\n    state0 = np.array([sc[0][-1],\n                       sc[1][-1],\n                       sc[3][-1]])\n    n = 5\n    t_eval = np.linspace(z0,z1,n)\n\n    sol = solve_ivp(self.descent_path,[z0,z1],state0,t_eval=t_eval, method=\"RK45\")\n\n    time = sol.y[0]\n    dist = sol.y[1]\n    mass = sol.y[2]\n    altp = sol.t\n    fn = [self.get_val(\"fn_fid\",z,m)[0] for z,m in zip(altp,mass)]\n    ff = [self.get_val(\"ff_fid\",z,m)[0] for z,m in zip(altp,mass)]\n    pamb = [self.get_val(\"pamb\",z,m)[0] for z,m in zip(altp,mass)]\n    tamb = [self.get_val(\"tamb\",z,m)[0] for z,m in zip(altp,mass)]\n    mach = np.ones(len(sol.t))*self.mach\n    cas = [earth.vcas_from_mach(p,ma) for p,ma in zip(pamb,mach)]\n    tas = [ma*earth.sound_speed(t) for ma,t in zip(mach,tamb)]\n    s1 = np.vstack((time,dist,altp,mass,pamb,tamb,mach,tas,cas,fn,ff))\n\n    # Second descent segment, constant cas2, state = [t,x,mass]\n    #---------------------------------------------------------------------------------------------------------------\n    z0 = self.altpy\n    z1 = self.altpx\n    state0 = np.array([sol.y[0][-1],\n                       sol.y[1][-1],\n                       sol.y[2][-1]])\n    n = 5\n    t_eval = np.linspace(z0,z1,n)\n\n    sol = solve_ivp(self.descent_path,[z0,z1],state0,t_eval=t_eval, method=\"RK45\")\n\n    time = sol.y[0]\n    dist = sol.y[1]\n    mass = sol.y[2]\n    altp = sol.t\n    fn = [self.get_val(\"fn_fid\",z,m)[0] for z,m in zip(altp,mass)]\n    ff = [self.get_val(\"ff_fid\",z,m)[0] for z,m in zip(altp,mass)]\n    pamb = [self.get_val(\"pamb\",z,m)[0] for z,m in zip(altp,mass)]\n    tamb = [self.get_val(\"tamb\",z,m)[0] for z,m in zip(altp,mass)]\n    cas = np.ones(len(sol.t))*self.cas2\n    mach = [earth.mach_from_vcas(p,v) for p,v in zip(pamb,cas)]\n    tas = [ma*earth.sound_speed(t) for ma,t in zip(mach,tamb)]\n    s2 = np.vstack((time,dist,altp,mass,pamb,tamb,mach,tas,cas,fn,ff))\n\n    # Desceleration fron cas2 to cas1, state = [t,x,mass]\n    #---------------------------------------------------------------------------------------------------------------\n    v0 = self.tas2\n    v1 = self.tas1\n    state0 = np.array([sol.y[0][-1],\n                       sol.y[1][-1],\n                       sol.y[2][-1]])\n    n = 5\n    t_eval = np.linspace(v0,v1,n)\n\n    sol = solve_ivp(self.deceleration,[v0,v1],state0,t_eval=t_eval, method=\"RK45\")\n\n    time = sol.y[0]\n    dist = sol.y[1]\n    mass = sol.y[2]\n    altp = np.ones(len(sol.t))*self.altpx\n    fn = [self.get_val(\"fn_fid\",z,m)[0] for z,m in zip(altp,mass)]\n    ff = [self.get_val(\"ff_fid\",z,m)[0] for z,m in zip(altp,mass)]\n    pamb = [self.get_val(\"pamb\",z,m)[0] for z,m in zip(altp,mass)]\n    tamb = [self.get_val(\"tamb\",z,m)[0] for z,m in zip(altp,mass)]\n    tas = sol.t\n    mach = [v/earth.sound_speed(tamb[0]) for v in tas]\n    cas = [earth.vcas_from_mach(pamb[0],ma) for ma in mach]\n    s3 = np.vstack((time,dist,altp,mass,pamb,tamb,mach,tas,cas,fn,ff))\n\n    # Last descent segment, constant cas1, state = [t,x,mass]\n    #---------------------------------------------------------------------------------------------------------------\n    z0 = self.altpx\n    z1 = self.altpw\n    state0 = np.array([sol.y[0][-1],\n                       sol.y[1][-1],\n                       sol.y[2][-1]])\n    n = 5\n    t_eval = np.linspace(z0,z1,n)\n\n    sol = solve_ivp(self.descent_path,[z0,z1],state0,t_eval=t_eval, method=\"RK45\")\n\n    time = sol.y[0]\n    dist = sol.y[1]\n    mass = sol.y[2]\n    altp = sol.t\n    fn = [self.get_val(\"fn_fid\",z,m)[0] for z,m in zip(altp,mass)]\n    ff = [self.get_val(\"ff_fid\",z,m)[0] for z,m in zip(altp,mass)]\n    pamb = [self.get_val(\"pamb\",z,m)[0] for z,m in zip(altp,mass)]\n    tamb = [self.get_val(\"tamb\",z,m)[0] for z,m in zip(altp,mass)]\n    cas = np.ones(len(sol.t))*self.cas1\n    mach = [earth.mach_from_vcas(p,v) for p,v in zip(pamb,cas)]\n    tas = [ma*earth.sound_speed(t) for ma,t in zip(mach,tamb)]\n    s4 = np.vstack((time,dist,altp,mass,pamb,tamb,mach,tas,cas,fn,ff))\n\n    sd = np.hstack((s1,s2,s3,s4))\n\n    self.descent_time = sol.y[0][-1] - self.climb_time - self.cruise_time\n    self.descent_fuel = self.tow - sol.y[2][-1] - self.climb_fuel - self.cruise_fuel\n    self.descent_dist = sol.y[1][-1] - self.climb_dist - self.cruise_dist\n\n    x_end = sd[1][-1]\n\n    return sc,sd,x_end\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/step_mission/#lh2pac.marilib.aircraft.step_mission.StepMission.fly_this_profile","title":"fly_this_profile","text":"<pre><code>fly_this_profile(disa, tow, flight_profile)\n</code></pre> <p>Compute fuel consumption along a given flight path Profile = array([time,dist,altp]) state = [m]</p> Source code in <code>src/lh2pac/marilib/aircraft/step_mission.py</code> <pre><code>def fly_this_profile(self,disa,tow,flight_profile):\n    \"\"\"Compute fuel consumption along a given flight path\n    Profile = array([time,dist,altp])\n    state = [m]\n    \"\"\"\n    g = earth.gravity()\n\n    # Remove doublets (connection points with the same date)\n    k_list = [k for k,t in enumerate(flight_profile[1:,0]) if t==flight_profile[k,0]]\n    profile = np.delete(flight_profile,k_list,axis=0)\n\n    time_ = profile[:,0]\n    nseg = len(time_) - 1   # Number of segments of the profile\n\n    dist_ = profile[:,1]\n    altp_ = profile[:,2]\n    pamb_ = profile[:,3]\n    tamb_ = profile[:,4]\n\n    # vtas_ = profile[:,5]\n    #\n    # # Build quadratic trajectory functions by segment\n    # # With quadratic function, acceleration is supposed constant along the segment\n    # coef = {\"dist\":[], \"altp\":[], \"pamb\":[], \"tamb\":[]}\n    # for k in range(nseg):\n    #     Ax   = np.array([[3.*time_[k]**2  , 2.*time_[k]     , 1.        , 0.],\n    #                      [   time_[k]**3  ,    time_[k]**2  , time_[k]  , 1.],\n    #                      [3.*time_[k+1]**2, 2.*time_[k+1]   , 1.        , 0.],\n    #                      [   time_[k+1]**3,    time_[k+1]**2, time_[k+1], 1.]])\n    #     Bx = [vtas_[k], dist_[k], vtas_[k+1], dist_[k+1]]\n    #     Cx = np.linalg.solve(Ax,Bx)\n    #     coef[\"dist\"].append(Cx)\n    #\n    #     A   = np.array([[time_[k]  , 1.],\n    #                     [time_[k+1], 1.]])\n    #\n    #     Bz = [altp_[k], altp_[k+1]]\n    #     Cz = np.linalg.solve(A,Bz)\n    #     coef[\"altp\"].append(Cz)\n    #\n    #     Bp = [pamb_[k], pamb_[k+1]]\n    #     Cp = np.linalg.solve(A,Bp)\n    #     coef[\"pamb\"].append(Cp)\n    #\n    #     Bt = [tamb_[k], tamb_[k+1]]\n    #     Ct = np.linalg.solve(A,Bt)\n    #     coef[\"tamb\"].append(Ct)\n    #\n    # # Interpolate into the trajectory\n    # def get_interp_data(t):\n    #     k = max(0,np.searchsorted(time_[:-1],t)-1)\n    #\n    #     x_d = 3.*coef[\"dist\"][k][0]*t**2 + 2.*coef[\"dist\"][k][1]*t + coef[\"dist\"][k][2]\n    #     z_d = coef[\"altp\"][k][0]\n    #     sin_path = z_d/x_d\n    #     tas = np.sqrt(x_d**2+z_d**2)\n    #     acc = 6.*coef[\"dist\"][k][0]*t + 2.*coef[\"dist\"][k][1]\n    #     zp = coef[\"altp\"][k][0]*t + coef[\"altp\"][k][1]\n    #     pamb = coef[\"pamb\"][k][0]*t + coef[\"pamb\"][k][1]\n    #     tamb = coef[\"tamb\"][k][0]*t + coef[\"tamb\"][k][1]\n    #     return zp,sin_path,tas,acc,pamb,tamb\n    #\n\n\n    # Build linear trajectory functions by segment\n    # With linear function, speed is supposed constant along the segment\n    coef = {\"dist\":[], \"altp\":[], \"pamb\":[], \"tamb\":[]}\n    for k in range(nseg):\n        A   = np.array([[time_[k]  , 1.],\n                        [time_[k+1], 1.]])\n\n        Bx = [dist_[k], dist_[k+1]]\n        Cx = np.linalg.solve(A,Bx)\n        coef[\"dist\"].append(Cx)\n\n        Bz = [altp_[k], altp_[k+1]]\n        Cz = np.linalg.solve(A,Bz)\n        coef[\"altp\"].append(Cz)\n\n        Bp = [pamb_[k], pamb_[k+1]]\n        Cp = np.linalg.solve(A,Bp)\n        coef[\"pamb\"].append(Cp)\n\n        Bt = [tamb_[k], tamb_[k+1]]\n        Ct = np.linalg.solve(A,Bt)\n        coef[\"tamb\"].append(Ct)\n\n    # Interpolate into the trajectory\n    def get_interp_data(t):\n        k = max(0,np.searchsorted(time_[:-1],t)-1)\n        x_d = coef[\"dist\"][k][0]\n        z_d = coef[\"altp\"][k][0]\n        zp = coef[\"altp\"][k][0]*t + coef[\"altp\"][k][1]\n        sin_path = z_d/x_d\n        tas = np.sqrt(x_d**2+z_d**2)\n        acc = 0.\n        pamb = coef[\"pamb\"][k][0]*t + coef[\"pamb\"][k][1]\n        tamb = coef[\"tamb\"][k][0]*t + coef[\"tamb\"][k][1]\n        return zp,sin_path,tas,acc,pamb,tamb\n\n\n\n\n    # Compute airplane performances at a given trajectory point\n    def all_values(t,mass):\n        altp,sin_path,tas,acc,pamb,tamb = get_interp_data(t)\n        # print(t,altp,sin_path,tas,acc,pamb,tamb)\n        vsnd = earth.sound_speed(tamb)\n        mach = tas/vsnd\n        cas = earth.vcas_from_mach(pamb,mach)\n\n        cz = self.lift_from_speed(pamb,tamb,mach,mass)\n        cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n        nei = 0.\n        fn = mass*g*(acc/g + sin_path + 1./lod)\n        fn1 = max(0.,fn)\n        dict = self.aircraft.power_system.sc(pamb,tamb,mach,\"MCL\",fn1,nei)\n        ff = dict[\"sfc\"]*fn\n\n        return pamb,tamb,mach,tas,cas,fn,ff,cz,cx,lod\n\n    # State dot function for ODE integrator\n    def state_dot(t,state):\n        pamb,tamb,mach,tas,cas,fn,ff,cz,cx,lod = all_values(t,state[0])\n        m_dot = np.array([-ff])\n        return m_dot\n\n    mass_ = [tow]\n\n    state0 = np.array([tow])\n\n    # Trajectory mass integration by segment\n    for k in range(len(time_)-1):\n        t0 = time_[k]\n        t1 = time_[k+1]\n        t_eval = [t1]\n        # print(\"-------&gt;\", t0)\n        sol = solve_ivp(state_dot,[t0,t1],state0,t_eval=t_eval, method=\"RK45\")\n        mass_.append(sol.y[0])\n        state0[0] = sol.y[0]\n\n    # Recompute all data at each given point\n    pamb_,tamb_,mach_,tas_,cas_,fn_,ff_,cz_,cx_,lod_ = [],[],[],[],[],[],[],[],[],[]\n    for t,m in zip(time_,mass_):\n        pamb,tamb,mach,tas,cas,fn,ff,cz,cx,lod = all_values(t,m)\n        pamb_.append(pamb)\n        tamb_.append(tamb)\n        mach_.append(mach)\n        tas_.append(tas)\n        cas_.append(cas)\n        fn_.append(fn)\n        ff_.append(ff)\n        cz_.append(cz)\n        cx_.append(cx)\n        lod_.append(lod)\n    st = np.vstack((time_,dist_,altp_,mass_,pamb_,tamb_,mach_,tas_,cas_,fn_,ff_,cz_,cx_,lod_))\n\n    flight_profile = st.transpose()\n\n    flight_profile = {\"label\":[\"time\",\"dist\",\"altp\",\"mass\",\"pamb\",\"tamb\",\"mach\",\"tas\",\"cas\",\"fn\",\"ff\",\"cz\",\"cx\",\"lod\"],\n                      \"unit\":[\"h\",\"NM\",\"ft\",\"kg\",\"Pa\",\"K\",\"mach\",\"kt\",\"kt\",\"kN\",\"kg/h\",\"no_dim\",\"no_dim\",\"no_dim\"],\n                      \"data\":flight_profile}\n\n    return flight_profile\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/step_mission/#lh2pac.marilib.aircraft.step_mission.StepMission.get_mach","title":"get_mach","text":"<pre><code>get_mach(pamb, speed_mode, speed)\n</code></pre> <p>Retrieve Mach from CAS or mach depending on speed_mode</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def get_mach(self,pamb,speed_mode,speed):\n    \"\"\"Retrieve Mach from CAS or mach depending on speed_mode\n    \"\"\"\n    mach = {\"cas\" : earth.mach_from_vcas(pamb, speed),  # Input is CAS\n            \"mach\" : speed  # Input is mach\n            }.get(speed_mode, \"Erreur: select speed_mode equal to cas or mach\")\n    return mach\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/step_mission/#lh2pac.marilib.aircraft.step_mission.StepMission.get_speed","title":"get_speed","text":"<pre><code>get_speed(pamb, speed_mode, mach)\n</code></pre> <p>retrieve CAS or Mach from mach depending on speed_mode</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def get_speed(self,pamb,speed_mode,mach):\n    \"\"\"retrieve CAS or Mach from mach depending on speed_mode\n    \"\"\"\n    speed = {\"cas\" : earth.vcas_from_mach(pamb, mach),  # CAS required\n             \"mach\" : mach  # mach required\n             }.get(speed_mode, \"Erreur: select speed_mode equal to cas or mach\")\n    return speed\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/step_mission/#lh2pac.marilib.aircraft.step_mission.StepMission.get_val","title":"get_val","text":"<pre><code>get_val(f_key, altp, mass, cas=None)\n</code></pre> <p>This function interpolates performances in the performance tables</p> Source code in <code>src/lh2pac/marilib/aircraft/step_mission.py</code> <pre><code>def get_val(self,f_key,altp,mass,cas=None):\n    \"\"\"This function interpolates performances in the performance tables\n    \"\"\"\n    if cas==None:\n        if altp&lt;=self.altpx:\n        # Climbing at constant cas1 inside lower layer\n            return self.data_func[f_key][\"low\"](mass,altp)\n        elif self.altpx&lt;altp and  altp&lt;=self.altpy:\n        # Climbing at constant cas2 inside medium layer\n            return self.data_func[f_key][\"medium\"](mass,altp)\n        elif self.altpy&lt;altp:\n        # Climbing or cruising at constant Mach inside upper layer\n            return self.data_func[f_key][\"high\"](mass,altp)\n    else:\n        # accelerating at constant altitude altpx\n        v1 = self.data_func[f_key][\"low\"](mass,self.altpx)\n        v2 = self.data_func[f_key][\"medium\"](mass,self.altpx)\n        print(\"coucou\")\n        print(altp,mass,v1,v2)\n        k = (cas-self.cas1) / (self.cas2-self.cas1)\n        return v1*(1.-k) + k*v2\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/step_mission/#lh2pac.marilib.aircraft.step_mission.StepMission.get_vcas","title":"get_vcas","text":"<pre><code>get_vcas(pamb, speed_mode, speed)\n</code></pre> <p>Retrieve CAS from Mach or CAS depending on speed_mode</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def get_vcas(self,pamb,speed_mode,speed):\n    \"\"\"Retrieve CAS from Mach or CAS depending on speed_mode\n    \"\"\"\n    cas = {\"mach\" : earth.vcas_from_mach(pamb, speed),  # Input is CAS\n            \"cas\" : speed  # Input is mach\n            }.get(speed_mode, \"Erreur: select speed_mode equal to cas or mach\")\n    return cas\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/step_mission/#lh2pac.marilib.aircraft.step_mission.StepMission.holding","title":"holding","text":"<pre><code>holding(time, mass, altp, mach, disa)\n</code></pre> <p>Holding equation is dependant from power architecture</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def holding(self,time,mass,altp,mach,disa):\n    \"\"\"Holding equation is dependant from power architecture\n    \"\"\"\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    tas = mach * earth.sound_speed(tamb)\n    dict = self.level_flight(pamb,tamb,mach,mass)\n    return self.aircraft.power_system.specific_holding(mass,time,tas,dict)\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/step_mission/#lh2pac.marilib.aircraft.step_mission.StepMission.level_flight","title":"level_flight","text":"<pre><code>level_flight(pamb, tamb, mach, mass)\n</code></pre> <p>Level flight equilibrium</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def level_flight(self,pamb,tamb,mach,mass):\n    \"\"\"Level flight equilibrium\n    \"\"\"\n    g = earth.gravity()\n    r,gam,Cp,Cv = earth.gas_data()\n    tas = mach * earth.sound_speed(tamb)\n\n    cz = (2.*mass*g)/(gam*pamb*mach**2*self.aircraft.airframe.wing.area)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    thrust = (gam/2.)*pamb*mach**2*self.aircraft.airframe.wing.area*cx\n    dict = self.aircraft.power_system.sc(pamb,tamb,mach,\"MCR\",thrust)\n    dict[\"fn\"] = thrust\n    dict[\"cx\"] = cx\n    dict[\"cz\"] = cz\n    dict[\"lod\"] = lod\n    dict[\"sar\"] = self.aircraft.power_system.specific_air_range(mass,tas,dict)\n    return dict\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/step_mission/#lh2pac.marilib.aircraft.step_mission.StepMission.lift_from_speed","title":"lift_from_speed","text":"<pre><code>lift_from_speed(pamb, tamb, mach, mass)\n</code></pre> <p>Retrieve cz from mach using simplified lift equation</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def lift_from_speed(self,pamb,tamb,mach,mass):\n    \"\"\"Retrieve cz from mach using simplified lift equation\n    \"\"\"\n    g = earth.gravity()\n    r,gam,Cp,Cv = earth.gas_data()\n    cz = (2.*mass*g)/(gam*pamb*mach**2*self.aircraft.airframe.wing.area)\n    return cz\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/step_mission/#lh2pac.marilib.aircraft.step_mission.StepMission.max_air_path","title":"max_air_path","text":"<pre><code>max_air_path(\n    nei,\n    altp,\n    disa,\n    speed_mode,\n    mass,\n    rating,\n    kfn,\n    full_output=False,\n)\n</code></pre> <p>Optimize the speed of the aircraft to maximize the air path</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def max_air_path(self,nei,altp,disa,speed_mode,mass,rating,kfn, full_output=False):\n    \"\"\"Optimize the speed of the aircraft to maximize the air path\n    \"\"\"\n    def fct(cz):\n        pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n        mach = self.speed_from_lift(pamb,tamb,cz,mass)\n        speed = self.get_speed(pamb,speed_mode,mach)\n        slope,vz = self.air_path(nei,altp,disa,speed_mode,speed,mass,rating,kfn)\n        if isformax: return slope\n        else: return slope,vz,mach\n\n    cz_ini = 0.5\n    dcz = 0.05\n\n    isformax = True\n    cz,slope,rc = maximize_1d(cz_ini,dcz,[fct])\n    isformax = False\n\n    slope,vz,mach = fct(cz)\n    return slope,vz,mach,cz\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/step_mission/#lh2pac.marilib.aircraft.step_mission.StepMission.propulsion_ceiling","title":"propulsion_ceiling","text":"<pre><code>propulsion_ceiling(\n    altp_ini,\n    nei,\n    vzreq,\n    disa,\n    speed_mode,\n    speed,\n    mass,\n    rating,\n    throttle,\n)\n</code></pre> <p>Optimize the speed of the aircraft to maximize the air path</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def propulsion_ceiling(self,altp_ini,nei,vzreq,disa,speed_mode,speed,mass,rating,throttle):\n    \"\"\"Optimize the speed of the aircraft to maximize the air path\n    \"\"\"\n    def fct_prop_ceiling(altp,nei,vzreq,disa,speed_mode,speed,mass,rating):\n        slope,vz = self.air_path(nei,altp,disa,speed_mode,speed,mass,rating,throttle)\n        delta_vz = vz - vzreq\n        return delta_vz\n\n    fct_arg = (nei,vzreq,disa,speed_mode,speed,mass,rating)\n\n    output_dict = fsolve(fct_prop_ceiling, x0 = altp_ini, args=fct_arg, full_output = True)\n\n    altp = output_dict[0][0]\n    rei = output_dict[2]\n    if(rei!=1): altp = np.NaN\n\n    return altp, rei\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/step_mission/#lh2pac.marilib.aircraft.step_mission.StepMission.set_flight_domain","title":"set_flight_domain","text":"<pre><code>set_flight_domain(\n    disa, tow, owe, cas1, altp2, cas2, cruise_mach\n)\n</code></pre> <p>Precomputation of all relevant quantities into a grid vs mass and altitude</p> Source code in <code>src/lh2pac/marilib/aircraft/step_mission.py</code> <pre><code>def set_flight_domain(self,disa,tow,owe,cas1,altp2,cas2,cruise_mach):\n    \"\"\"Precomputation of all relevant quantities into a grid vs mass and altitude\n    \"\"\"\n    if cas1&gt;cas2:\n        raise Exception(\"cas1 must be lower than cas2\")\n\n    self.tow = tow\n    self.owe = owe\n\n    self.altpx = altp2\n    self.cas1 = cas1\n    self.cas2 = cas2\n    self.mach = cruise_mach\n\n    pamb, tamb, tstd, dtodz = earth.atmosphere(self.altpx,disa)\n    sound_speed = earth.sound_speed(tamb)\n    self.tas1 = self.get_mach(pamb,\"cas\",cas1) * sound_speed\n    self.tas2 = self.get_mach(pamb,\"cas\",cas2) * sound_speed\n\n    self.altpy = earth.cross_over_altp(cas2,cruise_mach)\n    if self.altpy&lt;self.altpx:\n        raise Exception(\"Cross over altitude must be higher than altp2\")\n\n    n_mass = 5\n    self.mass_list = np.linspace(owe,tow,n_mass)\n    for layer in self.data_dict[\"altp\"].keys():\n        self.data_dict[\"mass\"][layer] = self.mass_list\n\n    g = earth.gravity()\n    nei = 0\n    daltg = 10. # Used to perform finite difference to compute dV / dh\n\n    for altp in self.altp_list:\n        pamb, tamb, tstd, dtodz = earth.atmosphere(altp,disa)\n        altg  = earth.altg_from_altp(altp,disa)\n        pamb_,tamb_,dtodz_ = earth.atmosphere_geo(altg+daltg,disa)\n\n        if altp&lt;=self.altpx+self.zstep:\n            layer = \"low\"\n            speed_mode = \"cas\"\n            speed = self.cas1\n            mach = self.get_mach(pamb,speed_mode,speed)\n            tas  = mach * earth.sound_speed(tamb)\n            tas_ = self.get_mach(pamb_,speed_mode,speed) * earth.sound_speed(tamb_)\n            dtas_o_dh = (tas_-tas) / daltg\n            fac = (1. + (tas/g)*dtas_o_dh)\n            self._fill_table(g,nei,pamb,tamb,mach,tas,fac,layer)\n            self.data_dict[\"altp\"][layer].append(altp)\n\n        if self.altpx-self.zstep&lt;=altp and altp&lt;=self.altpy+self.zstep:\n            layer = \"medium\"\n            speed_mode = \"cas\"\n            speed = self.cas2\n            mach = self.get_mach(pamb,speed_mode,speed)\n            tas  = mach * earth.sound_speed(tamb)\n            tas_ = self.get_mach(pamb_,speed_mode,speed) * earth.sound_speed(tamb_)\n            dtas_o_dh = (tas_-tas) / daltg\n            fac = (1. + (tas/g)*dtas_o_dh)\n            self._fill_table(g,nei,pamb,tamb,mach,tas,fac,layer)\n            self.data_dict[\"altp\"][layer].append(altp)\n\n        if self.altpy-self.zstep&lt;=altp:\n            layer = \"high\"\n            mach = cruise_mach\n            tas  = mach * earth.sound_speed(tamb)\n            tas_ = mach * earth.sound_speed(tamb_)\n            dtas_o_dh = (tas_-tas) / daltg\n            fac = (1. + (tas/g)*dtas_o_dh)\n            self._fill_table(g,nei,pamb,tamb,mach,tas,fac,layer)\n            self.data_dict[\"altp\"][layer].append(altp)\n\n    # Build interpolation functions\n    self.data_func = {}\n    for f_key in self.f_key_list:\n        self.data_func[f_key] = {}\n        for layer in self.data_dict[\"altp\"].keys():\n            self.data_func[f_key][layer] = interp2d(self.data_dict[\"mass\"][layer],\n                                                    self.data_dict[\"altp\"][layer],\n                                                    self.data_dict[f_key][layer],\n                                                    kind=\"linear\")\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/step_mission/#lh2pac.marilib.aircraft.step_mission.StepMission.speed_from_lift","title":"speed_from_lift","text":"<pre><code>speed_from_lift(pamb, tamb, cz, mass)\n</code></pre> <p>Retrieve mach from cz using simplified lift equation</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def speed_from_lift(self,pamb,tamb,cz,mass):\n    \"\"\"Retrieve mach from cz using simplified lift equation\n    \"\"\"\n    g = earth.gravity()\n    r,gam,Cp,Cv = earth.gas_data()\n    mach = np.sqrt((mass*g)/(0.5*gam*pamb*self.aircraft.airframe.wing.area*cz))\n    return mach\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/","title":"Airframe","text":""},{"location":"reference/lh2pac/marilib/aircraft/airframe/#lh2pac.marilib.aircraft.airframe","title":"airframe","text":"<p>This package defines the main aircraft components and assembly:</p> <ul> <li>all components are defined in :mod:<code>marilib.aircraft.airframe.component</code>.</li> <li>the airframe defined in :class:<code>airframe_root.Airframe</code> is kind of list of components.</li> </ul>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/airframe_root/","title":"Airframe root","text":""},{"location":"reference/lh2pac/marilib/aircraft/airframe/airframe_root/#lh2pac.marilib.aircraft.airframe.airframe_root","title":"airframe_root","text":"<p>:author: DRUOT Thierry, Nicolas Monrolin</p>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/airframe_root/#lh2pac.marilib.aircraft.airframe.airframe_root-classes","title":"Classes","text":""},{"location":"reference/lh2pac/marilib/aircraft/airframe/airframe_root/#lh2pac.marilib.aircraft.airframe.airframe_root.Airframe","title":"Airframe","text":"<pre><code>Airframe(aircraft)\n</code></pre> <p>               Bases: <code>object</code></p> <p>Logical aircraft components</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/airframe_root.py</code> <pre><code>def __init__(self, aircraft):\n    self.aircraft = aircraft\n\n    self.engine_analysis_order = []\n    self.mass_analysis_order = []\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/airframe_root/#lh2pac.marilib.aircraft.airframe.airframe_root.Airframe-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/aircraft/airframe/airframe_root/#lh2pac.marilib.aircraft.airframe.airframe_root.Airframe.geometry_analysis","title":"geometry_analysis","text":"<pre><code>geometry_analysis(hq_optim=False)\n</code></pre> <p>Crude geometry analysis of each component independantly by calling component.eval_geometry()</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/airframe_root.py</code> <pre><code>def geometry_analysis(self, hq_optim=False):\n    \"\"\"Crude geometry analysis of each component independantly by calling component.eval_geometry()\n    \"\"\"\n    stab_architecture = self.aircraft.arrangement.stab_architecture\n    number_of_engine = self.aircraft.arrangement.number_of_engine\n    power_architecture = self.aircraft.arrangement.power_architecture\n\n    self.aircraft.airframe.cabin.eval_geometry()\n    self.aircraft.airframe.body.eval_geometry()\n    self.aircraft.airframe.wing.eval_geometry(hq_optim)\n\n    for comp in self.aircraft.airframe:\n        if issubclass(type(comp),Tank):\n            comp.eval_geometry()\n\n    for comp in self.aircraft.airframe:\n        if issubclass(type(comp),Pod):\n            comp.eval_geometry()\n\n    self.aircraft.airframe.cargo.eval_geometry()\n\n    for comp in self.aircraft.airframe:\n        if issubclass(type(comp),Nacelle):\n            comp.eval_geometry()\n\n    if (stab_architecture in [\"classic\",\"t_tail\"]):\n        self.aircraft.airframe.vertical_stab.eval_geometry()\n        self.aircraft.airframe.horizontal_stab.eval_geometry()\n    elif (stab_architecture==\"h_tail\"):\n        self.aircraft.airframe.horizontal_stab.eval_geometry()\n        self.aircraft.airframe.vertical_stab.eval_geometry()\n        self.aircraft.airframe.other_vertical_stab.eval_geometry()\n\n    self.aircraft.airframe.landing_gear.eval_geometry()\n    self.aircraft.airframe.system.eval_geometry()\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/airframe_root/#lh2pac.marilib.aircraft.airframe.airframe_root.Airframe.statistical_pre_design","title":"statistical_pre_design","text":"<pre><code>statistical_pre_design()\n</code></pre> <p>Solves strong coupling and compute tail areas using volume coefficients</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/airframe_root.py</code> <pre><code>def statistical_pre_design(self):\n    \"\"\"Solves strong coupling and compute tail areas using volume coefficients\n    \"\"\"\n    stab_architecture = self.aircraft.arrangement.stab_architecture\n    number_of_engine = self.aircraft.arrangement.number_of_engine\n    power_architecture = self.aircraft.arrangement.power_architecture\n\n    self.aircraft.airframe.cabin.eval_geometry()\n    self.aircraft.airframe.body.eval_geometry()\n    self.aircraft.airframe.wing.eval_geometry()\n\n    for comp in self.aircraft.airframe:\n        if issubclass(type(comp),Tank):\n            comp.eval_geometry()\n\n    for comp in self.aircraft.airframe:\n        if issubclass(type(comp),Pod):\n            comp.eval_geometry()\n\n    self.aircraft.airframe.cargo.eval_geometry()\n\n    for comp in self.aircraft.airframe:\n        if issubclass(type(comp),Nacelle):\n            comp.eval_geometry()\n\n    def fct(x_in):\n        self.aircraft.airframe.vertical_stab.area = x_in[0]                           # Coupling variable\n        self.aircraft.airframe.horizontal_stab.area = x_in[1]                             # Coupling variable\n\n        if (stab_architecture in [\"classic\",\"t_tail\"]):\n            self.aircraft.airframe.vertical_stab.eval_geometry()\n            self.aircraft.airframe.horizontal_stab.eval_geometry()\n        elif (stab_architecture==\"h_tail\"):\n            self.aircraft.airframe.horizontal_stab.eval_geometry()\n            self.aircraft.airframe.vertical_stab.eval_geometry()\n            self.aircraft.airframe.other_vertical_stab.eval_geometry()\n\n        self.aircraft.airframe.horizontal_stab.eval_area()\n        self.aircraft.airframe.vertical_stab.eval_area()\n\n        y_out = np.array([x_in[0] - self.aircraft.airframe.vertical_stab.area,\n                          x_in[1] - self.aircraft.airframe.horizontal_stab.area])\n        return y_out\n\n    x_ini = np.array([self.aircraft.airframe.vertical_stab.area,\n                      self.aircraft.airframe.horizontal_stab.area])\n\n    output_dict = fsolve(fct, x0=x_ini, args=(), full_output=True)\n    if (output_dict[2]!=1): raise Exception(\"Convergence problem\")\n\n    if (stab_architecture in [\"classic\",\"t_tail\"]):\n        self.aircraft.airframe.vertical_stab.area = output_dict[0][0]\n        self.aircraft.airframe.vertical_stab.eval_geometry()\n        self.aircraft.airframe.horizontal_stab.area = output_dict[0][1]\n        self.aircraft.airframe.horizontal_stab.eval_geometry()\n    elif (stab_architecture==\"h_tail\"):\n        self.aircraft.airframe.horizontal_stab.area = output_dict[0][1]\n        self.aircraft.airframe.horizontal_stab.eval_geometry()\n        self.aircraft.airframe.vertical_stab.area = output_dict[0][0]\n        self.aircraft.airframe.vertical_stab.eval_geometry()\n        self.aircraft.airframe.other_vertical_stab.area = output_dict[0][0]\n        self.aircraft.airframe.other_vertical_stab.eval_geometry()\n\n    self.aircraft.airframe.landing_gear.eval_geometry()\n    self.aircraft.airframe.system.eval_geometry()\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/","title":"Component","text":""},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component","title":"component","text":"<p>Authors: DRUOT Thierry, Nicolas Monrolin</p> <p>This module describes all the components that can be included in an airframe. The :class:<code>Component</code> defines the common features of all components.</p> <p>.. note:: All physical parameters are given in SI units.</p>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component-classes","title":"Classes","text":""},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.BareFixedLandingGear","title":"BareFixedLandingGear","text":"<pre><code>BareFixedLandingGear(aircraft)\n</code></pre> <p>               Bases: <code>Component</code></p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def __init__(self, aircraft):\n    super(BareFixedLandingGear, self).__init__(aircraft)\n\n    self.wheel_count = aircraft.get_init(self,\"wheel_count\")\n    self.wheel_diameter = None\n    self.wheel_width = None\n\n    self.wheel_drag_area_factor = aircraft.get_init(self,\"wheel_drag_area_factor\")\n    self.mass_correction_factor = aircraft.get_init(self,\"mass_correction_factor\")\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.BareFixedLandingGear-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.BareFixedLandingGear.eval_geometry","title":"eval_geometry","text":"<pre><code>eval_geometry()\n</code></pre> <p>Estimates the geometry of the component from the aircraft requirements and statistical design laws.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def eval_geometry(self):\n    mtow = self.aircraft.weight_cg.mtow\n\n    self.wheel_diameter = 0.0254 * 1.8 * (mtow/self.wheel_count)**0.25\n    self.wheel_width = 0.45 * self.wheel_diameter\n\n    self.gross_wet_area = self.wheel_diameter * self.wheel_width * (1 + self.wheel_count) # Nose wheel and its leg stands for a main wheel\n    self.net_wet_area = self.gross_wet_area\n\n    # Drag model is based on drag area\n    self.form_factor = self.wheel_drag_area_factor\n    self.aero_length = 0.\n\n    wing_root_c = self.aircraft.airframe.wing.root_c\n    wing_root_loc = self.aircraft.airframe.wing.root_loc\n\n    self.frame_origin = wing_root_loc[0] + 0.80*wing_root_c\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.BareFixedLandingGear.eval_mass","title":"eval_mass","text":"<pre><code>eval_mass()\n</code></pre> <p>Estimates the geometry of the component from the aircraft requirements and statistical design laws.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def eval_mass(self):\n    mtow = self.aircraft.weight_cg.mtow\n    mlw = self.aircraft.weight_cg.mlw\n\n    self.mass = (0.02*mtow**1.03 + 0.012*mlw) * self.mass_correction_factor    # Landing gears\n    self.cg = self.frame_origin\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.BareFixedLandingGear.get_aero_length","title":"get_aero_length","text":"<pre><code>get_aero_length()\n</code></pre> <p>The characteristic aerodynamic length of the component (used for Reynolds number estimations for example).</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_aero_length(self):\n    \"\"\"The characteristic aerodynamic length of the component (used for Reynolds number estimations for example).\"\"\"\n    return self.aero_length\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.BareFixedLandingGear.get_cg_mwe","title":"get_cg_mwe","text":"<pre><code>get_cg_mwe()\n</code></pre> <p>Returns the position of the center of gravity of the manufacturer empty aircraft</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_cg_mwe(self):\n    \"\"\"Returns the position of the center of gravity of the manufacturer empty aircraft\"\"\"\n    return self.cg\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.BareFixedLandingGear.get_cg_owe","title":"get_cg_owe","text":"<pre><code>get_cg_owe()\n</code></pre> <p>Returns the position of the center of gravity of the operational empty aircraft</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_cg_owe(self):\n    \"\"\"Returns the position of the center of gravity of the operational empty aircraft\"\"\"\n    return self.cg\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.BareFixedLandingGear.get_form_factor","title":"get_form_factor","text":"<pre><code>get_form_factor()\n</code></pre> <p>Form factor used to estimate form drag.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_form_factor(self):\n    \"\"\"Form factor used to estimate form drag.\"\"\"\n    return self.form_factor\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.BareFixedLandingGear.get_inertia_tensor","title":"get_inertia_tensor","text":"<pre><code>get_inertia_tensor()\n</code></pre> <p>returns the inertia matrix of the component, if implemented.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_inertia_tensor(self):\n    \"\"\"returns the inertia matrix of the component, if implemented.\"\"\"\n    return self.inertia_tensor\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.BareFixedLandingGear.get_mass_mwe","title":"get_mass_mwe","text":"<pre><code>get_mass_mwe()\n</code></pre> <p>Returns the Manufacturer's Weight Empty, the mass (kg) of the component</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_mass_mwe(self):\n    \"\"\"Returns the *Manufacturer's Weight Empty*, the mass (kg) of the component\"\"\"\n    return self.mass\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.BareFixedLandingGear.get_mass_owe","title":"get_mass_owe","text":"<pre><code>get_mass_owe()\n</code></pre> <p>Returns the Operating Weight Empty, the mass (kg) of the component. Can differ from MWE for some components</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_mass_owe(self):\n    \"\"\"Returns the *Operating Weight Empty*, the mass (kg) of the component. Can differ from MWE for some components\"\"\"\n    return self.mass\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.BareFixedLandingGear.get_net_wet_area","title":"get_net_wet_area","text":"<pre><code>get_net_wet_area()\n</code></pre> <p>The net wet area of the component in contact with outer airflow, 0 if the component has no aerodynamic surface.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_net_wet_area(self):\n    \"\"\"The net wet area of the component in contact with outer airflow, 0 if the component has no aerodynamic surface.\"\"\"\n    return self.net_wet_area\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.BareFixedLandingGear.get_this_shape","title":"get_this_shape","text":"<pre><code>get_this_shape(name)\n</code></pre> <p>Contour curves for 3 view drawing nose1 : modern nose (A220, A350, 787) nose3 : classical Airbus nose nose2 : symetrical nose cone1 : classical tail cone cone2 : symetrical cone section : circle</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_this_shape(self, name): # TODO: is the docstring up to date ?\n    \"\"\"Contour curves for 3 view drawing\n    nose1 : modern nose (A220, A350, 787)\n    nose3 : classical Airbus nose\n    nose2 : symetrical nose\n    cone1 : classical tail cone\n    cone2 : symetrical cone\n    section : circle\n    \"\"\"\n    curve = {\n    \"nose1\":np.array([[ 0.0000 , 0.3339 , 0.3339 , 0.0000 ,  0.0000 ] ,\n                      [ 0.0050 , 0.3848 , 0.3084 , 0.0335 , -0.0335 ] ,\n                      [ 0.0150 , 0.4253 , 0.2881 , 0.0652 , -0.0652 ] ,\n                      [ 0.0500 , 0.5033 , 0.2490 , 0.1101 , -0.1101 ] ,\n                      [ 0.1000 , 0.5811 , 0.2100 , 0.1585 , -0.1585 ] ,\n                      [ 0.1800 , 0.6808 , 0.1600 , 0.2215 , -0.2215 ] ,\n                      [ 0.2773 , 0.7704 , 0.1151 , 0.2859 , -0.2859 ] ,\n                      [ 0.4191 , 0.8562 , 0.0721 , 0.3624 , -0.3624 ] ,\n                      [ 0.5610 , 0.9198 , 0.0402 , 0.4211 , -0.4211 ] ,\n                      [ 0.7738 , 0.9816 , 0.0092 , 0.4761 , -0.4761 ] ,\n                      [ 0.9156 , 0.9962 , 0.0019 , 0.4976 , -0.4976 ] ,\n                      [ 1.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ]]),\n\n    \"nose2\":np.array([[ 0.0000 , 0.5000 ,  0.5000 , 0.0000 ,  0.0000 ] ,\n                      [ 0.0050 , 0.5335 ,  0.4665 , 0.0335 , -0.0335 ] ,\n                      [ 0.0191 , 0.5646 ,  0.4354 , 0.0646 , -0.0646 ] ,\n                      [ 0.0624 , 0.6196 ,  0.3804 , 0.1196 , -0.1196 ] ,\n                      [ 0.1355 , 0.6878 ,  0.3122 , 0.1878 , -0.1878 ] ,\n                      [ 0.1922 , 0.7297 ,  0.2703 , 0.2297 , -0.2297 ] ,\n                      [ 0.2773 , 0.7859 ,  0.2141 , 0.2859 , -0.2859 ] ,\n                      [ 0.4191 , 0.8624 ,  0.1376 , 0.3624 , -0.3624 ] ,\n                      [ 0.5610 , 0.9211 ,  0.0789 , 0.4211 , -0.4211 ] ,\n                      [ 0.7738 , 0.9761 ,  0.0239 , 0.4761 , -0.4761 ] ,\n                      [ 0.9156 , 0.9976 ,  0.0024 , 0.4976 , -0.4976 ] ,\n                      [ 1.0000 , 1.0000 ,  0.0000 , 0.5000 , -0.5000 ]]),\n\n    \"nose3\":np.array([[ 0.0000 , 0.4453 , 0.4453 , 0.0000 ,  0.0000 ] ,\n                      [ 0.0050 , 0.4733 , 0.4112 , 0.0335 , -0.0335 ] ,\n                      [ 0.0191 , 0.5098 , 0.3833 , 0.0646 , -0.0646 ] ,\n                      [ 0.0624 , 0.5718 , 0.3188 , 0.1196 , -0.1196 ] ,\n                      [ 0.1355 , 0.6278 , 0.2531 , 0.1878 , -0.1878 ] ,\n                      [ 0.1922 , 0.7263 , 0.2142 , 0.2297 , -0.2297 ] ,\n                      [ 0.2773 , 0.8127 , 0.1631 , 0.2859 , -0.2859 ] ,\n                      [ 0.4191 , 0.8906 , 0.0962 , 0.3624 , -0.3624 ] ,\n                      [ 0.5610 , 0.9392 , 0.0536 , 0.4211 , -0.4211 ] ,\n                      [ 0.7738 , 0.9818 , 0.0122 , 0.4761 , -0.4761 ] ,\n                      [ 0.9156 , 0.9976 , 0.0025 , 0.4976 , -0.4976 ] ,\n                      [ 1.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ]]),\n\n    \"nose4\":np.array([[ 0.0000, 0.3700, 0.3700, 0.0000,  0.0000 ] ,\n                      [ 0.0050, 0.4200, 0.3200, 0.0335, -0.0335 ] ,\n                      [ 0.0150, 0.4500, 0.2900, 0.0652, -0.0652 ] ,\n                      [ 0.0500, 0.5000, 0.2400, 0.1200, -0.1200 ] ,\n                      [ 0.1000, 0.5500, 0.1900, 0.1750, -0.1750 ] ,\n                      [ 0.1800, 0.6000, 0.1400, 0.2400, -0.2400 ] ,\n                      [ 0.2773, 0.6450, 0.1000, 0.3000, -0.3000 ] ,\n                      [ 0.4191, 0.7000, 0.0500, 0.3700, -0.3700 ] ,\n                      [ 0.5610, 0.7550, 0.0250, 0.4300, -0.4300 ] ,\n                      [ 0.6200, 0.7800, 0.0180, 0.4500, -0.4500 ] ,\n                      [ 0.7700, 0.9700, 0.0090, 0.4850, -0.4850 ] ,\n                      [ 0.8100, 0.9900, 0.0060, 0.4900, -0.4900 ] ,\n                      [ 0.9100, 0.9970, 0.0030, 0.4976, -0.4976 ] ,\n                      [ 1.0000, 1.0000, 0.0000, 0.5000, -0.5000 ]]),\n\n    \"cone1\":np.array([[ 0.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ] ,\n                      [ 0.0213 , 1.0000 , 0.0082 , 0.5000 , -0.5000 ] ,\n                      [ 0.0638 , 1.0000 , 0.0230 , 0.4956 , -0.4956 ] ,\n                      [ 0.1064 , 1.0000 , 0.0393 , 0.4875 , -0.4875 ] ,\n                      [ 0.1489 , 1.0000 , 0.0556 , 0.4794 , -0.4794 ] ,\n                      [ 0.1915 , 1.0000 , 0.0786 , 0.4720 , -0.4720 ] ,\n                      [ 0.2766 , 1.0000 , 0.1334 , 0.4566 , -0.4566 ] ,\n                      [ 0.3617 , 1.0000 , 0.1964 , 0.4330 , -0.4330 ] ,\n                      [ 0.4894 , 1.0000 , 0.3024 , 0.3822 , -0.3822 ] ,\n                      [ 0.6170 , 1.0000 , 0.4159 , 0.3240 , -0.3240 ] ,\n                      [ 0.7447 , 1.0000 , 0.5374 , 0.2577 , -0.2577 ] ,\n                      [ 0.8723 , 1.0000 , 0.6627 , 0.1834 , -0.1834 ] ,\n                      [ 0.8936 , 0.9963 , 0.6901 , 0.1679 , -0.1679 ] ,\n                      [ 0.9149 , 0.9881 , 0.7139 , 0.1524 , -0.1524 ] ,\n                      [ 0.9362 , 0.9800 , 0.7413 , 0.1333 , -0.1333 ] ,\n                      [ 0.9574 , 0.9652 , 0.7687 , 0.1097 , -0.1097 ] ,\n                      [ 0.9787 , 0.9533 , 0.8043 , 0.0788 , -0.0788 ] ,\n                      [ 0.9894 , 0.9377 , 0.8280 , 0.0589 , -0.0589 ] ,\n                      [ 1.0000 , 0.9103 , 0.8784 , 0.0162 , -0.0162 ]]),\n\n    \"cone2\":np.array([[ 0.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ] ,\n                      [ 0.0213 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ] ,\n                      [ 0.0638 , 0.9956 , 0.0044 , 0.4956 , -0.4956 ] ,\n                      [ 0.1064 , 0.9875 , 0.0125 , 0.4875 , -0.4875 ] ,\n                      [ 0.1489 , 0.9794 , 0.0206 , 0.4794 , -0.4794 ] ,\n                      [ 0.1915 , 0.9720 , 0.0280 , 0.4720 , -0.4720 ] ,\n                      [ 0.2766 , 0.9566 , 0.0434 , 0.4566 , -0.4566 ] ,\n                      [ 0.3617 , 0.9330 , 0.0670 , 0.4330 , -0.4330 ] ,\n                      [ 0.4894 , 0.8822 , 0.1178 , 0.3822 , -0.3822 ] ,\n                      [ 0.6170 , 0.8240 , 0.1760 , 0.3240 , -0.3240 ] ,\n                      [ 0.7447 , 0.7577 , 0.2423 , 0.2577 , -0.2577 ] ,\n                      [ 0.8723 , 0.6834 , 0.3166 , 0.1834 , -0.1834 ] ,\n                      [ 0.8936 , 0.6679 , 0.3321 , 0.1679 , -0.1679 ] ,\n                      [ 0.9149 , 0.6524 , 0.3476 , 0.1524 , -0.1524 ] ,\n                      [ 0.9362 , 0.6333 , 0.3667 , 0.1333 , -0.1333 ] ,\n                      [ 0.9574 , 0.6097 , 0.3903 , 0.1097 , -0.1097 ] ,\n                      [ 0.9787 , 0.5788 , 0.4212 , 0.0788 , -0.0788 ] ,\n                      [ 0.9894 , 0.5589 , 0.4411 , 0.0589 , -0.0589 ] ,\n                      [ 1.0000 , 0.5162 , 0.4838 , 0.0162 , -0.0162 ]]),\n\n    \"sec1\":np.array([[  0.5000000 , 0.0000000 ,  0.0000000 ] ,\n                     [  0.4903926 , 0.0975452 , -0.0975452 ] ,\n                     [  0.4619398 , 0.1913417 , -0.1913417 ] ,\n                     [  0.4157348 , 0.2777851 , -0.2777851 ] ,\n                     [  0.3535534 , 0.3535534 , -0.3535534 ] ,\n                     [  0.2777851 , 0.4157348 , -0.4157348 ] ,\n                     [  0.1913417 , 0.4619398 , -0.4619398 ] ,\n                     [  0.0975452 , 0.4903926 , -0.4903926 ] ,\n                     [  0.0000000 , 0.5000000 , -0.5000000 ] ,\n                     [- 0.0975452 , 0.4903926 , -0.4903926 ] ,\n                     [- 0.1913417 , 0.4619398 , -0.4619398 ] ,\n                     [- 0.2777851 , 0.4157348 , -0.4157348 ] ,\n                     [- 0.3535534 , 0.3535534 , -0.3535534 ] ,\n                     [- 0.4157348 , 0.2777851 , -0.2777851 ] ,\n                     [- 0.4619398 , 0.1913417 , -0.1913417 ] ,\n                     [- 0.4903926 , 0.0975452 , -0.0975452 ] ,\n                     [- 0.5000000 , 0.0000000 ,  0.0000000 ]]),\n\n    \"sec2\":np.array([[ 0.5000000 , 0.0000000 ,  0.0000000] ,\n                     [ 0.4951963 , 0.0975452 , -0.0975452] ,\n                     [ 0.4809699 , 0.1913417 , -0.1913417] ,\n                     [ 0.4578674 , 0.2777851 , -0.2777851] ,\n                     [ 0.4267767 , 0.3535534 , -0.3535534] ,\n                     [ 0.3888926 , 0.4157348 , -0.4157348] ,\n                     [ 0.3456709 , 0.4619398 , -0.4619398] ,\n                     [ 0.2987726 , 0.4903926 , -0.4903926] ,\n                     [ 0.2500000 , 0.5000000 , -0.5000000] ,\n                     [ 0.0000000 , 0.5000000 , -0.5000000] ,\n                     [-0.2500000 , 0.5000000 , -0.5000000] ,\n                     [-0.2987726 , 0.4903926 , -0.4903926] ,\n                     [-0.3456709 , 0.4619398 , -0.4619398] ,\n                     [-0.3888926 , 0.4157348 , -0.4157348] ,\n                     [-0.4267767 , 0.3535534 , -0.3535534] ,\n                     [-0.4578674 , 0.2777851 , -0.2777851] ,\n                     [-0.4809699 , 0.1913417 , -0.1913417] ,\n                     [-0.4951963 , 0.0975452 , -0.0975452] ,\n                     [-0.5000000 , 0.0000000 ,  0.0000000]])}\n\n    return [curve[n] for n in name]\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.Cabin","title":"Cabin","text":"<pre><code>Cabin(aircraft)\n</code></pre> <p>               Bases: <code>Component</code></p> <p>The Cabin includes the passenger seats, the crew space and furnishings.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def __init__(self, aircraft):\n    super(Cabin, self).__init__(aircraft)\n\n    self.n_pax_ref = self.aircraft.requirement.n_pax_ref\n    self.n_pax_front = aircraft.get_init(self,\"n_pax_front\", val=self.__n_pax_front())\n    self.n_aisle = aircraft.get_init(self,\"n_aisle\", val=self.__n_aisle())\n    self.seat_width = aircraft.get_init(self,\"seat_width\")\n    self.seat_pitch = aircraft.get_init(self,\"seat_pitch\")\n    self.aisle_width = aircraft.get_init(self,\"aisle_width\")\n\n    self.width = None\n    self.length = None\n    self.co2_metric_area = None\n\n    self.m_pax_nominal = aircraft.get_init(self,\"m_pax_nominal\", val=self.__m_pax_nominal())\n    self.m_pax_max = aircraft.get_init(self,\"m_pax_max\", val=self.__m_pax_max())\n    self.m_pax_cabin = aircraft.get_init(self,\"m_pax_cabin\")\n    self.m_furnishing = None\n    self.m_op_item = None\n    self.nominal_payload = None\n    self.maximum_payload = None\n\n    self.cg_furnishing = np.full(3,None)\n    self.cg_op_item = np.full(3,None)\n\n    self.pax_max_fwd_cg = np.full(3,None)\n    self.pax_max_fwd_mass = None\n\n    self.pax_max_bwd_cg = np.full(3,None)\n    self.pax_max_bwd_mass = None\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.Cabin-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.Cabin.eval_geometry","title":"eval_geometry","text":"<pre><code>eval_geometry()\n</code></pre> <p>Estimates the geometry of the component from the aircraft requirements and statistical design laws.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def eval_geometry(self):\n    design_range = self.aircraft.requirement.design_range\n    self.width =  self.seat_width*self.n_pax_front + self.aisle_width*self.n_aisle + 0.10   # Statistical regression\n    self.length =  2.0*self.width + self.seat_pitch*self.n_pax_ref/self.n_pax_front \\\n                 + 2.0e-9*self.n_pax_ref*design_range    # Statistical regression\n    self.projected_area = 0.95*self.length*self.width       # Factor 0.95 accounts for tapered parts\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.Cabin.eval_mass","title":"eval_mass","text":"<pre><code>eval_mass()\n</code></pre> <p>Estimates the geometry of the component from the aircraft requirements and statistical design laws.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def eval_mass(self):\n    design_range = self.aircraft.requirement.design_range\n    cabin_frame_origin = self.aircraft.airframe.cabin.frame_origin\n\n    self.m_furnishing = (0.063*self.n_pax_ref**2 + 9.76*self.n_pax_ref)       # Furnishings mass\n    self.m_op_item = max(160., 5.2*(self.n_pax_ref*design_range*1e-6))        # Operator items mass\n\n    self.nominal_payload = self.n_pax_ref * self.m_pax_nominal\n    self.maximum_payload = self.n_pax_ref * self.m_pax_max\n\n    fwd_cabin_vec = np.array([self.aircraft.airframe.wing.mac_loc[0], 0., 0.]) + np.array([0.25*self.aircraft.airframe.wing.mac, 0., 0.]) - cabin_frame_origin\n    bwd_cabin_vec = cabin_frame_origin + np.array([self.length, 0., 0.]) - fwd_cabin_vec\n\n    self.pax_max_fwd_cg = cabin_frame_origin + 0.50*fwd_cabin_vec                   # Payload max forward CG\n    self.pax_max_fwd_mass = self.n_pax_ref*self.m_pax_cabin * fwd_cabin_vec[0]/self.length   # Payload mass for max forward CG\n\n    self.pax_max_bwd_cg = cabin_frame_origin + fwd_cabin_vec + 0.50*bwd_cabin_vec   # Payload max backward CG\n    self.pax_max_bwd_mass = self.n_pax_ref*self.m_pax_cabin * bwd_cabin_vec[0]/self.length   # Payload mass for max backward CG\n\n    x_cg_furnishing = self.frame_origin[0] + 0.55*self.length      # Rear cabin is heavier because of higher density\n    x_cg_op_item = x_cg_furnishing    # Operator items cg\n\n    self.cg_furnishing = np.array([x_cg_furnishing, 0., 0.])\n    self.cg_op_item = np.array([x_cg_op_item, 0., 0.])\n\n    self.mass = self.m_furnishing + self.m_op_item\n    self.cg = (self.cg_furnishing*self.m_furnishing + self.cg_op_item*self.m_op_item) / self.mass\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.Cabin.get_aero_length","title":"get_aero_length","text":"<pre><code>get_aero_length()\n</code></pre> <p>The characteristic aerodynamic length of the component (used for Reynolds number estimations for example).</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_aero_length(self):\n    \"\"\"The characteristic aerodynamic length of the component (used for Reynolds number estimations for example).\"\"\"\n    return self.aero_length\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.Cabin.get_cg_mwe","title":"get_cg_mwe","text":"<pre><code>get_cg_mwe()\n</code></pre> <p>Returns the position of the center of gravity of the manufacturer empty aircraft</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_cg_mwe(self):\n    return self.cg_furnishing\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.Cabin.get_cg_owe","title":"get_cg_owe","text":"<pre><code>get_cg_owe()\n</code></pre> <p>Returns the position of the center of gravity of the operational empty aircraft</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_cg_owe(self):\n    \"\"\"Returns the position of the center of gravity of the operational empty aircraft\"\"\"\n    return self.cg\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.Cabin.get_form_factor","title":"get_form_factor","text":"<pre><code>get_form_factor()\n</code></pre> <p>Form factor used to estimate form drag.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_form_factor(self):\n    \"\"\"Form factor used to estimate form drag.\"\"\"\n    return self.form_factor\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.Cabin.get_inertia_tensor","title":"get_inertia_tensor","text":"<pre><code>get_inertia_tensor()\n</code></pre> <p>returns the inertia matrix of the component, if implemented.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_inertia_tensor(self):\n    \"\"\"returns the inertia matrix of the component, if implemented.\"\"\"\n    return self.inertia_tensor\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.Cabin.get_mass_mwe","title":"get_mass_mwe","text":"<pre><code>get_mass_mwe()\n</code></pre> <p>Returns the Manufacturer's Weight Empty, the mass (kg) of the component</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_mass_mwe(self):\n    return self.m_furnishing\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.Cabin.get_mass_owe","title":"get_mass_owe","text":"<pre><code>get_mass_owe()\n</code></pre> <p>Returns the Operating Weight Empty, the mass (kg) of the component. Can differ from MWE for some components</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_mass_owe(self):\n    \"\"\"Returns the *Operating Weight Empty*, the mass (kg) of the component. Can differ from MWE for some components\"\"\"\n    return self.mass\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.Cabin.get_net_wet_area","title":"get_net_wet_area","text":"<pre><code>get_net_wet_area()\n</code></pre> <p>The net wet area of the component in contact with outer airflow, 0 if the component has no aerodynamic surface.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_net_wet_area(self):\n    \"\"\"The net wet area of the component in contact with outer airflow, 0 if the component has no aerodynamic surface.\"\"\"\n    return self.net_wet_area\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.Cabin.get_this_shape","title":"get_this_shape","text":"<pre><code>get_this_shape(name)\n</code></pre> <p>Contour curves for 3 view drawing nose1 : modern nose (A220, A350, 787) nose3 : classical Airbus nose nose2 : symetrical nose cone1 : classical tail cone cone2 : symetrical cone section : circle</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_this_shape(self, name): # TODO: is the docstring up to date ?\n    \"\"\"Contour curves for 3 view drawing\n    nose1 : modern nose (A220, A350, 787)\n    nose3 : classical Airbus nose\n    nose2 : symetrical nose\n    cone1 : classical tail cone\n    cone2 : symetrical cone\n    section : circle\n    \"\"\"\n    curve = {\n    \"nose1\":np.array([[ 0.0000 , 0.3339 , 0.3339 , 0.0000 ,  0.0000 ] ,\n                      [ 0.0050 , 0.3848 , 0.3084 , 0.0335 , -0.0335 ] ,\n                      [ 0.0150 , 0.4253 , 0.2881 , 0.0652 , -0.0652 ] ,\n                      [ 0.0500 , 0.5033 , 0.2490 , 0.1101 , -0.1101 ] ,\n                      [ 0.1000 , 0.5811 , 0.2100 , 0.1585 , -0.1585 ] ,\n                      [ 0.1800 , 0.6808 , 0.1600 , 0.2215 , -0.2215 ] ,\n                      [ 0.2773 , 0.7704 , 0.1151 , 0.2859 , -0.2859 ] ,\n                      [ 0.4191 , 0.8562 , 0.0721 , 0.3624 , -0.3624 ] ,\n                      [ 0.5610 , 0.9198 , 0.0402 , 0.4211 , -0.4211 ] ,\n                      [ 0.7738 , 0.9816 , 0.0092 , 0.4761 , -0.4761 ] ,\n                      [ 0.9156 , 0.9962 , 0.0019 , 0.4976 , -0.4976 ] ,\n                      [ 1.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ]]),\n\n    \"nose2\":np.array([[ 0.0000 , 0.5000 ,  0.5000 , 0.0000 ,  0.0000 ] ,\n                      [ 0.0050 , 0.5335 ,  0.4665 , 0.0335 , -0.0335 ] ,\n                      [ 0.0191 , 0.5646 ,  0.4354 , 0.0646 , -0.0646 ] ,\n                      [ 0.0624 , 0.6196 ,  0.3804 , 0.1196 , -0.1196 ] ,\n                      [ 0.1355 , 0.6878 ,  0.3122 , 0.1878 , -0.1878 ] ,\n                      [ 0.1922 , 0.7297 ,  0.2703 , 0.2297 , -0.2297 ] ,\n                      [ 0.2773 , 0.7859 ,  0.2141 , 0.2859 , -0.2859 ] ,\n                      [ 0.4191 , 0.8624 ,  0.1376 , 0.3624 , -0.3624 ] ,\n                      [ 0.5610 , 0.9211 ,  0.0789 , 0.4211 , -0.4211 ] ,\n                      [ 0.7738 , 0.9761 ,  0.0239 , 0.4761 , -0.4761 ] ,\n                      [ 0.9156 , 0.9976 ,  0.0024 , 0.4976 , -0.4976 ] ,\n                      [ 1.0000 , 1.0000 ,  0.0000 , 0.5000 , -0.5000 ]]),\n\n    \"nose3\":np.array([[ 0.0000 , 0.4453 , 0.4453 , 0.0000 ,  0.0000 ] ,\n                      [ 0.0050 , 0.4733 , 0.4112 , 0.0335 , -0.0335 ] ,\n                      [ 0.0191 , 0.5098 , 0.3833 , 0.0646 , -0.0646 ] ,\n                      [ 0.0624 , 0.5718 , 0.3188 , 0.1196 , -0.1196 ] ,\n                      [ 0.1355 , 0.6278 , 0.2531 , 0.1878 , -0.1878 ] ,\n                      [ 0.1922 , 0.7263 , 0.2142 , 0.2297 , -0.2297 ] ,\n                      [ 0.2773 , 0.8127 , 0.1631 , 0.2859 , -0.2859 ] ,\n                      [ 0.4191 , 0.8906 , 0.0962 , 0.3624 , -0.3624 ] ,\n                      [ 0.5610 , 0.9392 , 0.0536 , 0.4211 , -0.4211 ] ,\n                      [ 0.7738 , 0.9818 , 0.0122 , 0.4761 , -0.4761 ] ,\n                      [ 0.9156 , 0.9976 , 0.0025 , 0.4976 , -0.4976 ] ,\n                      [ 1.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ]]),\n\n    \"nose4\":np.array([[ 0.0000, 0.3700, 0.3700, 0.0000,  0.0000 ] ,\n                      [ 0.0050, 0.4200, 0.3200, 0.0335, -0.0335 ] ,\n                      [ 0.0150, 0.4500, 0.2900, 0.0652, -0.0652 ] ,\n                      [ 0.0500, 0.5000, 0.2400, 0.1200, -0.1200 ] ,\n                      [ 0.1000, 0.5500, 0.1900, 0.1750, -0.1750 ] ,\n                      [ 0.1800, 0.6000, 0.1400, 0.2400, -0.2400 ] ,\n                      [ 0.2773, 0.6450, 0.1000, 0.3000, -0.3000 ] ,\n                      [ 0.4191, 0.7000, 0.0500, 0.3700, -0.3700 ] ,\n                      [ 0.5610, 0.7550, 0.0250, 0.4300, -0.4300 ] ,\n                      [ 0.6200, 0.7800, 0.0180, 0.4500, -0.4500 ] ,\n                      [ 0.7700, 0.9700, 0.0090, 0.4850, -0.4850 ] ,\n                      [ 0.8100, 0.9900, 0.0060, 0.4900, -0.4900 ] ,\n                      [ 0.9100, 0.9970, 0.0030, 0.4976, -0.4976 ] ,\n                      [ 1.0000, 1.0000, 0.0000, 0.5000, -0.5000 ]]),\n\n    \"cone1\":np.array([[ 0.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ] ,\n                      [ 0.0213 , 1.0000 , 0.0082 , 0.5000 , -0.5000 ] ,\n                      [ 0.0638 , 1.0000 , 0.0230 , 0.4956 , -0.4956 ] ,\n                      [ 0.1064 , 1.0000 , 0.0393 , 0.4875 , -0.4875 ] ,\n                      [ 0.1489 , 1.0000 , 0.0556 , 0.4794 , -0.4794 ] ,\n                      [ 0.1915 , 1.0000 , 0.0786 , 0.4720 , -0.4720 ] ,\n                      [ 0.2766 , 1.0000 , 0.1334 , 0.4566 , -0.4566 ] ,\n                      [ 0.3617 , 1.0000 , 0.1964 , 0.4330 , -0.4330 ] ,\n                      [ 0.4894 , 1.0000 , 0.3024 , 0.3822 , -0.3822 ] ,\n                      [ 0.6170 , 1.0000 , 0.4159 , 0.3240 , -0.3240 ] ,\n                      [ 0.7447 , 1.0000 , 0.5374 , 0.2577 , -0.2577 ] ,\n                      [ 0.8723 , 1.0000 , 0.6627 , 0.1834 , -0.1834 ] ,\n                      [ 0.8936 , 0.9963 , 0.6901 , 0.1679 , -0.1679 ] ,\n                      [ 0.9149 , 0.9881 , 0.7139 , 0.1524 , -0.1524 ] ,\n                      [ 0.9362 , 0.9800 , 0.7413 , 0.1333 , -0.1333 ] ,\n                      [ 0.9574 , 0.9652 , 0.7687 , 0.1097 , -0.1097 ] ,\n                      [ 0.9787 , 0.9533 , 0.8043 , 0.0788 , -0.0788 ] ,\n                      [ 0.9894 , 0.9377 , 0.8280 , 0.0589 , -0.0589 ] ,\n                      [ 1.0000 , 0.9103 , 0.8784 , 0.0162 , -0.0162 ]]),\n\n    \"cone2\":np.array([[ 0.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ] ,\n                      [ 0.0213 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ] ,\n                      [ 0.0638 , 0.9956 , 0.0044 , 0.4956 , -0.4956 ] ,\n                      [ 0.1064 , 0.9875 , 0.0125 , 0.4875 , -0.4875 ] ,\n                      [ 0.1489 , 0.9794 , 0.0206 , 0.4794 , -0.4794 ] ,\n                      [ 0.1915 , 0.9720 , 0.0280 , 0.4720 , -0.4720 ] ,\n                      [ 0.2766 , 0.9566 , 0.0434 , 0.4566 , -0.4566 ] ,\n                      [ 0.3617 , 0.9330 , 0.0670 , 0.4330 , -0.4330 ] ,\n                      [ 0.4894 , 0.8822 , 0.1178 , 0.3822 , -0.3822 ] ,\n                      [ 0.6170 , 0.8240 , 0.1760 , 0.3240 , -0.3240 ] ,\n                      [ 0.7447 , 0.7577 , 0.2423 , 0.2577 , -0.2577 ] ,\n                      [ 0.8723 , 0.6834 , 0.3166 , 0.1834 , -0.1834 ] ,\n                      [ 0.8936 , 0.6679 , 0.3321 , 0.1679 , -0.1679 ] ,\n                      [ 0.9149 , 0.6524 , 0.3476 , 0.1524 , -0.1524 ] ,\n                      [ 0.9362 , 0.6333 , 0.3667 , 0.1333 , -0.1333 ] ,\n                      [ 0.9574 , 0.6097 , 0.3903 , 0.1097 , -0.1097 ] ,\n                      [ 0.9787 , 0.5788 , 0.4212 , 0.0788 , -0.0788 ] ,\n                      [ 0.9894 , 0.5589 , 0.4411 , 0.0589 , -0.0589 ] ,\n                      [ 1.0000 , 0.5162 , 0.4838 , 0.0162 , -0.0162 ]]),\n\n    \"sec1\":np.array([[  0.5000000 , 0.0000000 ,  0.0000000 ] ,\n                     [  0.4903926 , 0.0975452 , -0.0975452 ] ,\n                     [  0.4619398 , 0.1913417 , -0.1913417 ] ,\n                     [  0.4157348 , 0.2777851 , -0.2777851 ] ,\n                     [  0.3535534 , 0.3535534 , -0.3535534 ] ,\n                     [  0.2777851 , 0.4157348 , -0.4157348 ] ,\n                     [  0.1913417 , 0.4619398 , -0.4619398 ] ,\n                     [  0.0975452 , 0.4903926 , -0.4903926 ] ,\n                     [  0.0000000 , 0.5000000 , -0.5000000 ] ,\n                     [- 0.0975452 , 0.4903926 , -0.4903926 ] ,\n                     [- 0.1913417 , 0.4619398 , -0.4619398 ] ,\n                     [- 0.2777851 , 0.4157348 , -0.4157348 ] ,\n                     [- 0.3535534 , 0.3535534 , -0.3535534 ] ,\n                     [- 0.4157348 , 0.2777851 , -0.2777851 ] ,\n                     [- 0.4619398 , 0.1913417 , -0.1913417 ] ,\n                     [- 0.4903926 , 0.0975452 , -0.0975452 ] ,\n                     [- 0.5000000 , 0.0000000 ,  0.0000000 ]]),\n\n    \"sec2\":np.array([[ 0.5000000 , 0.0000000 ,  0.0000000] ,\n                     [ 0.4951963 , 0.0975452 , -0.0975452] ,\n                     [ 0.4809699 , 0.1913417 , -0.1913417] ,\n                     [ 0.4578674 , 0.2777851 , -0.2777851] ,\n                     [ 0.4267767 , 0.3535534 , -0.3535534] ,\n                     [ 0.3888926 , 0.4157348 , -0.4157348] ,\n                     [ 0.3456709 , 0.4619398 , -0.4619398] ,\n                     [ 0.2987726 , 0.4903926 , -0.4903926] ,\n                     [ 0.2500000 , 0.5000000 , -0.5000000] ,\n                     [ 0.0000000 , 0.5000000 , -0.5000000] ,\n                     [-0.2500000 , 0.5000000 , -0.5000000] ,\n                     [-0.2987726 , 0.4903926 , -0.4903926] ,\n                     [-0.3456709 , 0.4619398 , -0.4619398] ,\n                     [-0.3888926 , 0.4157348 , -0.4157348] ,\n                     [-0.4267767 , 0.3535534 , -0.3535534] ,\n                     [-0.4578674 , 0.2777851 , -0.2777851] ,\n                     [-0.4809699 , 0.1913417 , -0.1913417] ,\n                     [-0.4951963 , 0.0975452 , -0.0975452] ,\n                     [-0.5000000 , 0.0000000 ,  0.0000000]])}\n\n    return [curve[n] for n in name]\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.Cargo","title":"Cargo","text":"<pre><code>Cargo(aircraft)\n</code></pre> <p>               Bases: <code>Component</code></p> <p>The Cargo defines the space where luggage and other payload can be stored.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def __init__(self, aircraft):\n    super(Cargo, self).__init__(aircraft)\n\n    self.container_pallet_mass = None\n\n    self.freight_max_fwd_cg = np.full(3,None)\n    self.freight_max_fwd_mass = None\n\n    self.freight_max_bwd_cg = np.full(3,None)\n    self.freight_max_bwd_mass = None\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.Cargo-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.Cargo.eval_geometry","title":"eval_geometry","text":"<pre><code>eval_geometry()\n</code></pre> <p>Estimates the geometry of the component from the aircraft requirements and statistical design laws.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def eval_geometry(self):\n    self.frame_origin = self.aircraft.airframe.cabin.frame_origin\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.Cargo.eval_mass","title":"eval_mass","text":"<pre><code>eval_mass()\n</code></pre> <p>Estimates the geometry of the component from the aircraft requirements and statistical design laws.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def eval_mass(self):\n    n_pax_ref = self.aircraft.airframe.cabin.n_pax_ref\n    n_pax_front = self.aircraft.airframe.cabin.n_pax_front\n    m_pax_max = self.aircraft.airframe.cabin.m_pax_max\n    m_pax_cabin = self.aircraft.airframe.cabin.m_pax_cabin\n    body_width = self.aircraft.airframe.body.width\n    body_length = self.aircraft.airframe.body.length\n    wing_root_loc = self.aircraft.airframe.wing.root_loc\n    wing_root_c = self.aircraft.airframe.wing.root_c\n    cabin_length = self.aircraft.airframe.cabin.length\n\n    cargo_frame_origin = self.aircraft.airframe.cargo.frame_origin\n\n    if (n_pax_front&gt;=6):\n        forward_hold_length = wing_root_loc[0] - self.frame_origin[0]\n        backward_hold_length = self.frame_origin[0]+cabin_length - (wing_root_loc[0]+wing_root_c)\n        hold_length = forward_hold_length + backward_hold_length\n\n        self.container_pallet_mass = 4.36 * body_width * body_length        # Container and pallet mass\n        self.mass = self.container_pallet_mass\n\n        fwd_hold_vec = np.array([self.aircraft.airframe.wing.mac_loc[0], 0., 0.]) + np.array([0.25*self.aircraft.airframe.wing.mac, 0., 0.]) - cargo_frame_origin\n        bwd_hold_vec = cargo_frame_origin + np.array([hold_length, 0., 0.]) - fwd_hold_vec\n\n        self.freight_max_fwd_cg = cargo_frame_origin + 0.50*fwd_hold_vec                   # Payload max forward CG\n        self.freight_max_fwd_mass = n_pax_ref*(m_pax_max-m_pax_cabin) * fwd_hold_vec[0]/hold_length   # Payload mass for max forward CG\n\n        self.freight_max_bwd_cg = cargo_frame_origin + fwd_hold_vec + 0.50*bwd_hold_vec   # Payload max backward CG\n        self.freight_max_bwd_mass = n_pax_ref*(m_pax_max-m_pax_cabin) * bwd_hold_vec[0]/hold_length   # Payload mass for max backward CG\n\n        self.cg =   (self.freight_max_fwd_cg*self.freight_max_fwd_mass + self.freight_max_bwd_cg*self.freight_max_bwd_mass) \\\n                  / (self.freight_max_fwd_mass + self.freight_max_bwd_mass)\n\n    else:\n        self.freight_max_fwd_cg = np.array([0., 0., 0.])\n        self.freight_max_fwd_mass = 0.\n\n        self.freight_max_bwd_cg = np.array([0., 0., 0.])\n        self.freight_max_bwd_mass = 0.\n\n        self.mass = 0.\n        self.cg = np.array([0., 0., 0.])\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.Cargo.get_aero_length","title":"get_aero_length","text":"<pre><code>get_aero_length()\n</code></pre> <p>The characteristic aerodynamic length of the component (used for Reynolds number estimations for example).</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_aero_length(self):\n    \"\"\"The characteristic aerodynamic length of the component (used for Reynolds number estimations for example).\"\"\"\n    return self.aero_length\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.Cargo.get_cg_mwe","title":"get_cg_mwe","text":"<pre><code>get_cg_mwe()\n</code></pre> <p>Returns the position of the center of gravity of the manufacturer empty aircraft</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_cg_mwe(self):\n    return np.array([0., 0., 0.])\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.Cargo.get_cg_owe","title":"get_cg_owe","text":"<pre><code>get_cg_owe()\n</code></pre> <p>Returns the position of the center of gravity of the operational empty aircraft</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_cg_owe(self):\n    \"\"\"Returns the position of the center of gravity of the operational empty aircraft\"\"\"\n    return self.cg\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.Cargo.get_form_factor","title":"get_form_factor","text":"<pre><code>get_form_factor()\n</code></pre> <p>Form factor used to estimate form drag.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_form_factor(self):\n    \"\"\"Form factor used to estimate form drag.\"\"\"\n    return self.form_factor\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.Cargo.get_inertia_tensor","title":"get_inertia_tensor","text":"<pre><code>get_inertia_tensor()\n</code></pre> <p>returns the inertia matrix of the component, if implemented.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_inertia_tensor(self):\n    \"\"\"returns the inertia matrix of the component, if implemented.\"\"\"\n    return self.inertia_tensor\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.Cargo.get_mass_mwe","title":"get_mass_mwe","text":"<pre><code>get_mass_mwe()\n</code></pre> <p>Returns the Manufacturer's Weight Empty, the mass (kg) of the component</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_mass_mwe(self):\n    return 0.\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.Cargo.get_mass_owe","title":"get_mass_owe","text":"<pre><code>get_mass_owe()\n</code></pre> <p>Returns the Operating Weight Empty, the mass (kg) of the component. Can differ from MWE for some components</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_mass_owe(self):\n    \"\"\"Returns the *Operating Weight Empty*, the mass (kg) of the component. Can differ from MWE for some components\"\"\"\n    return self.mass\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.Cargo.get_net_wet_area","title":"get_net_wet_area","text":"<pre><code>get_net_wet_area()\n</code></pre> <p>The net wet area of the component in contact with outer airflow, 0 if the component has no aerodynamic surface.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_net_wet_area(self):\n    \"\"\"The net wet area of the component in contact with outer airflow, 0 if the component has no aerodynamic surface.\"\"\"\n    return self.net_wet_area\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.Cargo.get_this_shape","title":"get_this_shape","text":"<pre><code>get_this_shape(name)\n</code></pre> <p>Contour curves for 3 view drawing nose1 : modern nose (A220, A350, 787) nose3 : classical Airbus nose nose2 : symetrical nose cone1 : classical tail cone cone2 : symetrical cone section : circle</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_this_shape(self, name): # TODO: is the docstring up to date ?\n    \"\"\"Contour curves for 3 view drawing\n    nose1 : modern nose (A220, A350, 787)\n    nose3 : classical Airbus nose\n    nose2 : symetrical nose\n    cone1 : classical tail cone\n    cone2 : symetrical cone\n    section : circle\n    \"\"\"\n    curve = {\n    \"nose1\":np.array([[ 0.0000 , 0.3339 , 0.3339 , 0.0000 ,  0.0000 ] ,\n                      [ 0.0050 , 0.3848 , 0.3084 , 0.0335 , -0.0335 ] ,\n                      [ 0.0150 , 0.4253 , 0.2881 , 0.0652 , -0.0652 ] ,\n                      [ 0.0500 , 0.5033 , 0.2490 , 0.1101 , -0.1101 ] ,\n                      [ 0.1000 , 0.5811 , 0.2100 , 0.1585 , -0.1585 ] ,\n                      [ 0.1800 , 0.6808 , 0.1600 , 0.2215 , -0.2215 ] ,\n                      [ 0.2773 , 0.7704 , 0.1151 , 0.2859 , -0.2859 ] ,\n                      [ 0.4191 , 0.8562 , 0.0721 , 0.3624 , -0.3624 ] ,\n                      [ 0.5610 , 0.9198 , 0.0402 , 0.4211 , -0.4211 ] ,\n                      [ 0.7738 , 0.9816 , 0.0092 , 0.4761 , -0.4761 ] ,\n                      [ 0.9156 , 0.9962 , 0.0019 , 0.4976 , -0.4976 ] ,\n                      [ 1.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ]]),\n\n    \"nose2\":np.array([[ 0.0000 , 0.5000 ,  0.5000 , 0.0000 ,  0.0000 ] ,\n                      [ 0.0050 , 0.5335 ,  0.4665 , 0.0335 , -0.0335 ] ,\n                      [ 0.0191 , 0.5646 ,  0.4354 , 0.0646 , -0.0646 ] ,\n                      [ 0.0624 , 0.6196 ,  0.3804 , 0.1196 , -0.1196 ] ,\n                      [ 0.1355 , 0.6878 ,  0.3122 , 0.1878 , -0.1878 ] ,\n                      [ 0.1922 , 0.7297 ,  0.2703 , 0.2297 , -0.2297 ] ,\n                      [ 0.2773 , 0.7859 ,  0.2141 , 0.2859 , -0.2859 ] ,\n                      [ 0.4191 , 0.8624 ,  0.1376 , 0.3624 , -0.3624 ] ,\n                      [ 0.5610 , 0.9211 ,  0.0789 , 0.4211 , -0.4211 ] ,\n                      [ 0.7738 , 0.9761 ,  0.0239 , 0.4761 , -0.4761 ] ,\n                      [ 0.9156 , 0.9976 ,  0.0024 , 0.4976 , -0.4976 ] ,\n                      [ 1.0000 , 1.0000 ,  0.0000 , 0.5000 , -0.5000 ]]),\n\n    \"nose3\":np.array([[ 0.0000 , 0.4453 , 0.4453 , 0.0000 ,  0.0000 ] ,\n                      [ 0.0050 , 0.4733 , 0.4112 , 0.0335 , -0.0335 ] ,\n                      [ 0.0191 , 0.5098 , 0.3833 , 0.0646 , -0.0646 ] ,\n                      [ 0.0624 , 0.5718 , 0.3188 , 0.1196 , -0.1196 ] ,\n                      [ 0.1355 , 0.6278 , 0.2531 , 0.1878 , -0.1878 ] ,\n                      [ 0.1922 , 0.7263 , 0.2142 , 0.2297 , -0.2297 ] ,\n                      [ 0.2773 , 0.8127 , 0.1631 , 0.2859 , -0.2859 ] ,\n                      [ 0.4191 , 0.8906 , 0.0962 , 0.3624 , -0.3624 ] ,\n                      [ 0.5610 , 0.9392 , 0.0536 , 0.4211 , -0.4211 ] ,\n                      [ 0.7738 , 0.9818 , 0.0122 , 0.4761 , -0.4761 ] ,\n                      [ 0.9156 , 0.9976 , 0.0025 , 0.4976 , -0.4976 ] ,\n                      [ 1.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ]]),\n\n    \"nose4\":np.array([[ 0.0000, 0.3700, 0.3700, 0.0000,  0.0000 ] ,\n                      [ 0.0050, 0.4200, 0.3200, 0.0335, -0.0335 ] ,\n                      [ 0.0150, 0.4500, 0.2900, 0.0652, -0.0652 ] ,\n                      [ 0.0500, 0.5000, 0.2400, 0.1200, -0.1200 ] ,\n                      [ 0.1000, 0.5500, 0.1900, 0.1750, -0.1750 ] ,\n                      [ 0.1800, 0.6000, 0.1400, 0.2400, -0.2400 ] ,\n                      [ 0.2773, 0.6450, 0.1000, 0.3000, -0.3000 ] ,\n                      [ 0.4191, 0.7000, 0.0500, 0.3700, -0.3700 ] ,\n                      [ 0.5610, 0.7550, 0.0250, 0.4300, -0.4300 ] ,\n                      [ 0.6200, 0.7800, 0.0180, 0.4500, -0.4500 ] ,\n                      [ 0.7700, 0.9700, 0.0090, 0.4850, -0.4850 ] ,\n                      [ 0.8100, 0.9900, 0.0060, 0.4900, -0.4900 ] ,\n                      [ 0.9100, 0.9970, 0.0030, 0.4976, -0.4976 ] ,\n                      [ 1.0000, 1.0000, 0.0000, 0.5000, -0.5000 ]]),\n\n    \"cone1\":np.array([[ 0.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ] ,\n                      [ 0.0213 , 1.0000 , 0.0082 , 0.5000 , -0.5000 ] ,\n                      [ 0.0638 , 1.0000 , 0.0230 , 0.4956 , -0.4956 ] ,\n                      [ 0.1064 , 1.0000 , 0.0393 , 0.4875 , -0.4875 ] ,\n                      [ 0.1489 , 1.0000 , 0.0556 , 0.4794 , -0.4794 ] ,\n                      [ 0.1915 , 1.0000 , 0.0786 , 0.4720 , -0.4720 ] ,\n                      [ 0.2766 , 1.0000 , 0.1334 , 0.4566 , -0.4566 ] ,\n                      [ 0.3617 , 1.0000 , 0.1964 , 0.4330 , -0.4330 ] ,\n                      [ 0.4894 , 1.0000 , 0.3024 , 0.3822 , -0.3822 ] ,\n                      [ 0.6170 , 1.0000 , 0.4159 , 0.3240 , -0.3240 ] ,\n                      [ 0.7447 , 1.0000 , 0.5374 , 0.2577 , -0.2577 ] ,\n                      [ 0.8723 , 1.0000 , 0.6627 , 0.1834 , -0.1834 ] ,\n                      [ 0.8936 , 0.9963 , 0.6901 , 0.1679 , -0.1679 ] ,\n                      [ 0.9149 , 0.9881 , 0.7139 , 0.1524 , -0.1524 ] ,\n                      [ 0.9362 , 0.9800 , 0.7413 , 0.1333 , -0.1333 ] ,\n                      [ 0.9574 , 0.9652 , 0.7687 , 0.1097 , -0.1097 ] ,\n                      [ 0.9787 , 0.9533 , 0.8043 , 0.0788 , -0.0788 ] ,\n                      [ 0.9894 , 0.9377 , 0.8280 , 0.0589 , -0.0589 ] ,\n                      [ 1.0000 , 0.9103 , 0.8784 , 0.0162 , -0.0162 ]]),\n\n    \"cone2\":np.array([[ 0.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ] ,\n                      [ 0.0213 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ] ,\n                      [ 0.0638 , 0.9956 , 0.0044 , 0.4956 , -0.4956 ] ,\n                      [ 0.1064 , 0.9875 , 0.0125 , 0.4875 , -0.4875 ] ,\n                      [ 0.1489 , 0.9794 , 0.0206 , 0.4794 , -0.4794 ] ,\n                      [ 0.1915 , 0.9720 , 0.0280 , 0.4720 , -0.4720 ] ,\n                      [ 0.2766 , 0.9566 , 0.0434 , 0.4566 , -0.4566 ] ,\n                      [ 0.3617 , 0.9330 , 0.0670 , 0.4330 , -0.4330 ] ,\n                      [ 0.4894 , 0.8822 , 0.1178 , 0.3822 , -0.3822 ] ,\n                      [ 0.6170 , 0.8240 , 0.1760 , 0.3240 , -0.3240 ] ,\n                      [ 0.7447 , 0.7577 , 0.2423 , 0.2577 , -0.2577 ] ,\n                      [ 0.8723 , 0.6834 , 0.3166 , 0.1834 , -0.1834 ] ,\n                      [ 0.8936 , 0.6679 , 0.3321 , 0.1679 , -0.1679 ] ,\n                      [ 0.9149 , 0.6524 , 0.3476 , 0.1524 , -0.1524 ] ,\n                      [ 0.9362 , 0.6333 , 0.3667 , 0.1333 , -0.1333 ] ,\n                      [ 0.9574 , 0.6097 , 0.3903 , 0.1097 , -0.1097 ] ,\n                      [ 0.9787 , 0.5788 , 0.4212 , 0.0788 , -0.0788 ] ,\n                      [ 0.9894 , 0.5589 , 0.4411 , 0.0589 , -0.0589 ] ,\n                      [ 1.0000 , 0.5162 , 0.4838 , 0.0162 , -0.0162 ]]),\n\n    \"sec1\":np.array([[  0.5000000 , 0.0000000 ,  0.0000000 ] ,\n                     [  0.4903926 , 0.0975452 , -0.0975452 ] ,\n                     [  0.4619398 , 0.1913417 , -0.1913417 ] ,\n                     [  0.4157348 , 0.2777851 , -0.2777851 ] ,\n                     [  0.3535534 , 0.3535534 , -0.3535534 ] ,\n                     [  0.2777851 , 0.4157348 , -0.4157348 ] ,\n                     [  0.1913417 , 0.4619398 , -0.4619398 ] ,\n                     [  0.0975452 , 0.4903926 , -0.4903926 ] ,\n                     [  0.0000000 , 0.5000000 , -0.5000000 ] ,\n                     [- 0.0975452 , 0.4903926 , -0.4903926 ] ,\n                     [- 0.1913417 , 0.4619398 , -0.4619398 ] ,\n                     [- 0.2777851 , 0.4157348 , -0.4157348 ] ,\n                     [- 0.3535534 , 0.3535534 , -0.3535534 ] ,\n                     [- 0.4157348 , 0.2777851 , -0.2777851 ] ,\n                     [- 0.4619398 , 0.1913417 , -0.1913417 ] ,\n                     [- 0.4903926 , 0.0975452 , -0.0975452 ] ,\n                     [- 0.5000000 , 0.0000000 ,  0.0000000 ]]),\n\n    \"sec2\":np.array([[ 0.5000000 , 0.0000000 ,  0.0000000] ,\n                     [ 0.4951963 , 0.0975452 , -0.0975452] ,\n                     [ 0.4809699 , 0.1913417 , -0.1913417] ,\n                     [ 0.4578674 , 0.2777851 , -0.2777851] ,\n                     [ 0.4267767 , 0.3535534 , -0.3535534] ,\n                     [ 0.3888926 , 0.4157348 , -0.4157348] ,\n                     [ 0.3456709 , 0.4619398 , -0.4619398] ,\n                     [ 0.2987726 , 0.4903926 , -0.4903926] ,\n                     [ 0.2500000 , 0.5000000 , -0.5000000] ,\n                     [ 0.0000000 , 0.5000000 , -0.5000000] ,\n                     [-0.2500000 , 0.5000000 , -0.5000000] ,\n                     [-0.2987726 , 0.4903926 , -0.4903926] ,\n                     [-0.3456709 , 0.4619398 , -0.4619398] ,\n                     [-0.3888926 , 0.4157348 , -0.4157348] ,\n                     [-0.4267767 , 0.3535534 , -0.3535534] ,\n                     [-0.4578674 , 0.2777851 , -0.2777851] ,\n                     [-0.4809699 , 0.1913417 , -0.1913417] ,\n                     [-0.4951963 , 0.0975452 , -0.0975452] ,\n                     [-0.5000000 , 0.0000000 ,  0.0000000]])}\n\n    return [curve[n] for n in name]\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.Component","title":"Component","text":"<pre><code>Component(aircraft)\n</code></pre> <p>               Bases: <code>object</code></p> <p>Define common features for all airplane components. Every component will override the methods defined in this abstract class. A component is meant to be contained in an instance of :class:<code>marilib.aircraft.airframe.airframe_root.Airframe</code>.</p> <p>Attributs     * aircraft : the aircraft to which the component belongs. Needed for some pre-design methods (call to requirements) or multi-components interaction.     * frame_origin : [x,y,z] origin of the local coordinate system inside the global aircraft coordinate system.     * frame_angles : [psi,theta,phi] Euler angles to describe rotation of the local coordinate system.     * mass : the net mass of the component     * cg : [xg,yg,zg] the position of center of mass in local coordinates.     * inertia_tensor : the inertia tensor of the component     * gross_wet_area : wetted area of the component alone     * net_wet_area : wetted area of the component in the assembly (without footprints)     * aero_length : characteristic length of the component in the direction of the flow. Used for Reynolds number.     * form_factor : factor on skin friction to account for lift independent pressure drag</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def __init__(self, aircraft):\n    self.aircraft = aircraft\n\n    self.frame_origin = np.full(3,None)\n\n    self.mass = None\n    self.cg = np.full(3,None)\n    self.inertia_tensor = np.full((3,3),None)\n\n    self.gross_wet_area = 0.    # wetted area of the component alone\n    self.net_wet_area = 0.      # wetted area of the component in the assembly (without footprints)\n    self.aero_length = 1.       # characteristic length of the component in the direction of the flow\n    self.form_factor = 0.       # factor on skin friction to account for lift independent pressure drag\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.Component-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.Component.eval_geometry","title":"eval_geometry","text":"<pre><code>eval_geometry()\n</code></pre> <p>Estimates the geometry of the component from the aircraft requirements and statistical design laws.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def eval_geometry(self):\n    \"\"\"Estimates the geometry of the component from the aircraft requirements and statistical design laws.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.Component.eval_mass","title":"eval_mass","text":"<pre><code>eval_mass()\n</code></pre> <p>Estimates the geometry of the component from the aircraft requirements and statistical design laws.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def eval_mass(self):\n    \"\"\"Estimates the geometry of the component from the aircraft requirements and statistical design laws.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.Component.get_aero_length","title":"get_aero_length","text":"<pre><code>get_aero_length()\n</code></pre> <p>The characteristic aerodynamic length of the component (used for Reynolds number estimations for example).</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_aero_length(self):\n    \"\"\"The characteristic aerodynamic length of the component (used for Reynolds number estimations for example).\"\"\"\n    return self.aero_length\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.Component.get_cg_mwe","title":"get_cg_mwe","text":"<pre><code>get_cg_mwe()\n</code></pre> <p>Returns the position of the center of gravity of the manufacturer empty aircraft</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_cg_mwe(self):\n    \"\"\"Returns the position of the center of gravity of the manufacturer empty aircraft\"\"\"\n    return self.cg\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.Component.get_cg_owe","title":"get_cg_owe","text":"<pre><code>get_cg_owe()\n</code></pre> <p>Returns the position of the center of gravity of the operational empty aircraft</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_cg_owe(self):\n    \"\"\"Returns the position of the center of gravity of the operational empty aircraft\"\"\"\n    return self.cg\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.Component.get_form_factor","title":"get_form_factor","text":"<pre><code>get_form_factor()\n</code></pre> <p>Form factor used to estimate form drag.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_form_factor(self):\n    \"\"\"Form factor used to estimate form drag.\"\"\"\n    return self.form_factor\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.Component.get_inertia_tensor","title":"get_inertia_tensor","text":"<pre><code>get_inertia_tensor()\n</code></pre> <p>returns the inertia matrix of the component, if implemented.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_inertia_tensor(self):\n    \"\"\"returns the inertia matrix of the component, if implemented.\"\"\"\n    return self.inertia_tensor\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.Component.get_mass_mwe","title":"get_mass_mwe","text":"<pre><code>get_mass_mwe()\n</code></pre> <p>Returns the Manufacturer's Weight Empty, the mass (kg) of the component</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_mass_mwe(self):\n    \"\"\"Returns the *Manufacturer's Weight Empty*, the mass (kg) of the component\"\"\"\n    return self.mass\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.Component.get_mass_owe","title":"get_mass_owe","text":"<pre><code>get_mass_owe()\n</code></pre> <p>Returns the Operating Weight Empty, the mass (kg) of the component. Can differ from MWE for some components</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_mass_owe(self):\n    \"\"\"Returns the *Operating Weight Empty*, the mass (kg) of the component. Can differ from MWE for some components\"\"\"\n    return self.mass\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.Component.get_net_wet_area","title":"get_net_wet_area","text":"<pre><code>get_net_wet_area()\n</code></pre> <p>The net wet area of the component in contact with outer airflow, 0 if the component has no aerodynamic surface.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_net_wet_area(self):\n    \"\"\"The net wet area of the component in contact with outer airflow, 0 if the component has no aerodynamic surface.\"\"\"\n    return self.net_wet_area\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.Component.get_this_shape","title":"get_this_shape","text":"<pre><code>get_this_shape(name)\n</code></pre> <p>Contour curves for 3 view drawing nose1 : modern nose (A220, A350, 787) nose3 : classical Airbus nose nose2 : symetrical nose cone1 : classical tail cone cone2 : symetrical cone section : circle</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_this_shape(self, name): # TODO: is the docstring up to date ?\n    \"\"\"Contour curves for 3 view drawing\n    nose1 : modern nose (A220, A350, 787)\n    nose3 : classical Airbus nose\n    nose2 : symetrical nose\n    cone1 : classical tail cone\n    cone2 : symetrical cone\n    section : circle\n    \"\"\"\n    curve = {\n    \"nose1\":np.array([[ 0.0000 , 0.3339 , 0.3339 , 0.0000 ,  0.0000 ] ,\n                      [ 0.0050 , 0.3848 , 0.3084 , 0.0335 , -0.0335 ] ,\n                      [ 0.0150 , 0.4253 , 0.2881 , 0.0652 , -0.0652 ] ,\n                      [ 0.0500 , 0.5033 , 0.2490 , 0.1101 , -0.1101 ] ,\n                      [ 0.1000 , 0.5811 , 0.2100 , 0.1585 , -0.1585 ] ,\n                      [ 0.1800 , 0.6808 , 0.1600 , 0.2215 , -0.2215 ] ,\n                      [ 0.2773 , 0.7704 , 0.1151 , 0.2859 , -0.2859 ] ,\n                      [ 0.4191 , 0.8562 , 0.0721 , 0.3624 , -0.3624 ] ,\n                      [ 0.5610 , 0.9198 , 0.0402 , 0.4211 , -0.4211 ] ,\n                      [ 0.7738 , 0.9816 , 0.0092 , 0.4761 , -0.4761 ] ,\n                      [ 0.9156 , 0.9962 , 0.0019 , 0.4976 , -0.4976 ] ,\n                      [ 1.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ]]),\n\n    \"nose2\":np.array([[ 0.0000 , 0.5000 ,  0.5000 , 0.0000 ,  0.0000 ] ,\n                      [ 0.0050 , 0.5335 ,  0.4665 , 0.0335 , -0.0335 ] ,\n                      [ 0.0191 , 0.5646 ,  0.4354 , 0.0646 , -0.0646 ] ,\n                      [ 0.0624 , 0.6196 ,  0.3804 , 0.1196 , -0.1196 ] ,\n                      [ 0.1355 , 0.6878 ,  0.3122 , 0.1878 , -0.1878 ] ,\n                      [ 0.1922 , 0.7297 ,  0.2703 , 0.2297 , -0.2297 ] ,\n                      [ 0.2773 , 0.7859 ,  0.2141 , 0.2859 , -0.2859 ] ,\n                      [ 0.4191 , 0.8624 ,  0.1376 , 0.3624 , -0.3624 ] ,\n                      [ 0.5610 , 0.9211 ,  0.0789 , 0.4211 , -0.4211 ] ,\n                      [ 0.7738 , 0.9761 ,  0.0239 , 0.4761 , -0.4761 ] ,\n                      [ 0.9156 , 0.9976 ,  0.0024 , 0.4976 , -0.4976 ] ,\n                      [ 1.0000 , 1.0000 ,  0.0000 , 0.5000 , -0.5000 ]]),\n\n    \"nose3\":np.array([[ 0.0000 , 0.4453 , 0.4453 , 0.0000 ,  0.0000 ] ,\n                      [ 0.0050 , 0.4733 , 0.4112 , 0.0335 , -0.0335 ] ,\n                      [ 0.0191 , 0.5098 , 0.3833 , 0.0646 , -0.0646 ] ,\n                      [ 0.0624 , 0.5718 , 0.3188 , 0.1196 , -0.1196 ] ,\n                      [ 0.1355 , 0.6278 , 0.2531 , 0.1878 , -0.1878 ] ,\n                      [ 0.1922 , 0.7263 , 0.2142 , 0.2297 , -0.2297 ] ,\n                      [ 0.2773 , 0.8127 , 0.1631 , 0.2859 , -0.2859 ] ,\n                      [ 0.4191 , 0.8906 , 0.0962 , 0.3624 , -0.3624 ] ,\n                      [ 0.5610 , 0.9392 , 0.0536 , 0.4211 , -0.4211 ] ,\n                      [ 0.7738 , 0.9818 , 0.0122 , 0.4761 , -0.4761 ] ,\n                      [ 0.9156 , 0.9976 , 0.0025 , 0.4976 , -0.4976 ] ,\n                      [ 1.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ]]),\n\n    \"nose4\":np.array([[ 0.0000, 0.3700, 0.3700, 0.0000,  0.0000 ] ,\n                      [ 0.0050, 0.4200, 0.3200, 0.0335, -0.0335 ] ,\n                      [ 0.0150, 0.4500, 0.2900, 0.0652, -0.0652 ] ,\n                      [ 0.0500, 0.5000, 0.2400, 0.1200, -0.1200 ] ,\n                      [ 0.1000, 0.5500, 0.1900, 0.1750, -0.1750 ] ,\n                      [ 0.1800, 0.6000, 0.1400, 0.2400, -0.2400 ] ,\n                      [ 0.2773, 0.6450, 0.1000, 0.3000, -0.3000 ] ,\n                      [ 0.4191, 0.7000, 0.0500, 0.3700, -0.3700 ] ,\n                      [ 0.5610, 0.7550, 0.0250, 0.4300, -0.4300 ] ,\n                      [ 0.6200, 0.7800, 0.0180, 0.4500, -0.4500 ] ,\n                      [ 0.7700, 0.9700, 0.0090, 0.4850, -0.4850 ] ,\n                      [ 0.8100, 0.9900, 0.0060, 0.4900, -0.4900 ] ,\n                      [ 0.9100, 0.9970, 0.0030, 0.4976, -0.4976 ] ,\n                      [ 1.0000, 1.0000, 0.0000, 0.5000, -0.5000 ]]),\n\n    \"cone1\":np.array([[ 0.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ] ,\n                      [ 0.0213 , 1.0000 , 0.0082 , 0.5000 , -0.5000 ] ,\n                      [ 0.0638 , 1.0000 , 0.0230 , 0.4956 , -0.4956 ] ,\n                      [ 0.1064 , 1.0000 , 0.0393 , 0.4875 , -0.4875 ] ,\n                      [ 0.1489 , 1.0000 , 0.0556 , 0.4794 , -0.4794 ] ,\n                      [ 0.1915 , 1.0000 , 0.0786 , 0.4720 , -0.4720 ] ,\n                      [ 0.2766 , 1.0000 , 0.1334 , 0.4566 , -0.4566 ] ,\n                      [ 0.3617 , 1.0000 , 0.1964 , 0.4330 , -0.4330 ] ,\n                      [ 0.4894 , 1.0000 , 0.3024 , 0.3822 , -0.3822 ] ,\n                      [ 0.6170 , 1.0000 , 0.4159 , 0.3240 , -0.3240 ] ,\n                      [ 0.7447 , 1.0000 , 0.5374 , 0.2577 , -0.2577 ] ,\n                      [ 0.8723 , 1.0000 , 0.6627 , 0.1834 , -0.1834 ] ,\n                      [ 0.8936 , 0.9963 , 0.6901 , 0.1679 , -0.1679 ] ,\n                      [ 0.9149 , 0.9881 , 0.7139 , 0.1524 , -0.1524 ] ,\n                      [ 0.9362 , 0.9800 , 0.7413 , 0.1333 , -0.1333 ] ,\n                      [ 0.9574 , 0.9652 , 0.7687 , 0.1097 , -0.1097 ] ,\n                      [ 0.9787 , 0.9533 , 0.8043 , 0.0788 , -0.0788 ] ,\n                      [ 0.9894 , 0.9377 , 0.8280 , 0.0589 , -0.0589 ] ,\n                      [ 1.0000 , 0.9103 , 0.8784 , 0.0162 , -0.0162 ]]),\n\n    \"cone2\":np.array([[ 0.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ] ,\n                      [ 0.0213 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ] ,\n                      [ 0.0638 , 0.9956 , 0.0044 , 0.4956 , -0.4956 ] ,\n                      [ 0.1064 , 0.9875 , 0.0125 , 0.4875 , -0.4875 ] ,\n                      [ 0.1489 , 0.9794 , 0.0206 , 0.4794 , -0.4794 ] ,\n                      [ 0.1915 , 0.9720 , 0.0280 , 0.4720 , -0.4720 ] ,\n                      [ 0.2766 , 0.9566 , 0.0434 , 0.4566 , -0.4566 ] ,\n                      [ 0.3617 , 0.9330 , 0.0670 , 0.4330 , -0.4330 ] ,\n                      [ 0.4894 , 0.8822 , 0.1178 , 0.3822 , -0.3822 ] ,\n                      [ 0.6170 , 0.8240 , 0.1760 , 0.3240 , -0.3240 ] ,\n                      [ 0.7447 , 0.7577 , 0.2423 , 0.2577 , -0.2577 ] ,\n                      [ 0.8723 , 0.6834 , 0.3166 , 0.1834 , -0.1834 ] ,\n                      [ 0.8936 , 0.6679 , 0.3321 , 0.1679 , -0.1679 ] ,\n                      [ 0.9149 , 0.6524 , 0.3476 , 0.1524 , -0.1524 ] ,\n                      [ 0.9362 , 0.6333 , 0.3667 , 0.1333 , -0.1333 ] ,\n                      [ 0.9574 , 0.6097 , 0.3903 , 0.1097 , -0.1097 ] ,\n                      [ 0.9787 , 0.5788 , 0.4212 , 0.0788 , -0.0788 ] ,\n                      [ 0.9894 , 0.5589 , 0.4411 , 0.0589 , -0.0589 ] ,\n                      [ 1.0000 , 0.5162 , 0.4838 , 0.0162 , -0.0162 ]]),\n\n    \"sec1\":np.array([[  0.5000000 , 0.0000000 ,  0.0000000 ] ,\n                     [  0.4903926 , 0.0975452 , -0.0975452 ] ,\n                     [  0.4619398 , 0.1913417 , -0.1913417 ] ,\n                     [  0.4157348 , 0.2777851 , -0.2777851 ] ,\n                     [  0.3535534 , 0.3535534 , -0.3535534 ] ,\n                     [  0.2777851 , 0.4157348 , -0.4157348 ] ,\n                     [  0.1913417 , 0.4619398 , -0.4619398 ] ,\n                     [  0.0975452 , 0.4903926 , -0.4903926 ] ,\n                     [  0.0000000 , 0.5000000 , -0.5000000 ] ,\n                     [- 0.0975452 , 0.4903926 , -0.4903926 ] ,\n                     [- 0.1913417 , 0.4619398 , -0.4619398 ] ,\n                     [- 0.2777851 , 0.4157348 , -0.4157348 ] ,\n                     [- 0.3535534 , 0.3535534 , -0.3535534 ] ,\n                     [- 0.4157348 , 0.2777851 , -0.2777851 ] ,\n                     [- 0.4619398 , 0.1913417 , -0.1913417 ] ,\n                     [- 0.4903926 , 0.0975452 , -0.0975452 ] ,\n                     [- 0.5000000 , 0.0000000 ,  0.0000000 ]]),\n\n    \"sec2\":np.array([[ 0.5000000 , 0.0000000 ,  0.0000000] ,\n                     [ 0.4951963 , 0.0975452 , -0.0975452] ,\n                     [ 0.4809699 , 0.1913417 , -0.1913417] ,\n                     [ 0.4578674 , 0.2777851 , -0.2777851] ,\n                     [ 0.4267767 , 0.3535534 , -0.3535534] ,\n                     [ 0.3888926 , 0.4157348 , -0.4157348] ,\n                     [ 0.3456709 , 0.4619398 , -0.4619398] ,\n                     [ 0.2987726 , 0.4903926 , -0.4903926] ,\n                     [ 0.2500000 , 0.5000000 , -0.5000000] ,\n                     [ 0.0000000 , 0.5000000 , -0.5000000] ,\n                     [-0.2500000 , 0.5000000 , -0.5000000] ,\n                     [-0.2987726 , 0.4903926 , -0.4903926] ,\n                     [-0.3456709 , 0.4619398 , -0.4619398] ,\n                     [-0.3888926 , 0.4157348 , -0.4157348] ,\n                     [-0.4267767 , 0.3535534 , -0.3535534] ,\n                     [-0.4578674 , 0.2777851 , -0.2777851] ,\n                     [-0.4809699 , 0.1913417 , -0.1913417] ,\n                     [-0.4951963 , 0.0975452 , -0.0975452] ,\n                     [-0.5000000 , 0.0000000 ,  0.0000000]])}\n\n    return [curve[n] for n in name]\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.Fuselage","title":"Fuselage","text":"<pre><code>Fuselage(aircraft)\n</code></pre> <p>               Bases: <code>Component</code></p> <p>The skin of the aircraft body (tube and wing configuration)</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def __init__(self, aircraft):\n    super(Fuselage, self).__init__(aircraft)\n\n    self.forward_ratio = aircraft.get_init(self,\"forward_ratio\")\n    self.wall_thickness = aircraft.get_init(self,\"wall_thickness\")\n    self.rear_bulkhead_ratio = aircraft.get_init(self,\"rear_bulkhead_ratio\")\n    self.nose_cone_ratio = aircraft.get_init(self,\"nose_cone_ratio\")\n    self.tail_cone_ratio = aircraft.get_init(self,\"tail_cone_ratio\")\n    self.section_type = aircraft.get_init(self,\"section_type\")\n\n    self.width = None\n    self.height = None\n    self.length = None\n    self.aspect_ratio = None\n    self.nose_cone_length = None\n    self.tail_cone_length = None\n\n    self.mass_correction_factor = aircraft.get_init(self,\"mass_correction_factor\")\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.Fuselage-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.Fuselage.eval_geometry","title":"eval_geometry","text":"<pre><code>eval_geometry()\n</code></pre> <p>Estimates the geometry of the component from the aircraft requirements and statistical design laws.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def eval_geometry(self):\n    self.frame_origin = [0., 0., 0.]\n\n    cabin_width = self.aircraft.airframe.cabin.width\n    cabin_length = self.aircraft.airframe.cabin.length\n\n    self.width = cabin_width + self.wall_thickness      # fuselage walls are supposed 0.2m thick\n    self.height = 1.05 * self.width\n\n    self.aircraft.airframe.cabin.frame_origin = [self.forward_ratio*self.width, 0., 0.]     # cabin position inside the fuselage\n    self.aircraft.airframe.cargo.frame_origin = [self.forward_ratio*self.width, 0., 0.]     # cabin position inside the fuselage\n\n    if self.aircraft.arrangement.tank_architecture==\"rear\":\n        tank_length = self.aircraft.airframe.tank.ref_length * self.aircraft.airframe.tank.mfw_factor\n        self.length = cabin_length + tank_length + (self.forward_ratio + self.rear_bulkhead_ratio)*self.width\n    else:\n        self.length = cabin_length + (self.forward_ratio + self.rear_bulkhead_ratio)*self.width\n\n    self.aspect_ratio = self.length / self.height\n    self.nose_cone_length = self.nose_cone_ratio*self.width\n    self.tail_cone_length = self.tail_cone_ratio*self.width\n\n    self.gross_wet_area = 2.70*self.length*np.sqrt(self.width*self.height)\n    self.net_wet_area = self.gross_wet_area\n\n    self.aero_length = self.length\n    self.form_factor = 1.05\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.Fuselage.eval_mass","title":"eval_mass","text":"<pre><code>eval_mass()\n</code></pre> <p>Estimates the geometry of the component from the aircraft requirements and statistical design laws.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def eval_mass(self):\n    kfus = np.pi*self.length*np.sqrt(self.width*self.height)\n    self.mass = self.mass_correction_factor * 5.40*kfus**1.19      # Statistical regression versus fuselage built surface\n    self.cg = np.array([0.50*self.length, 0., 0.40*self.height])     # Middle of the fuselage\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.Fuselage.get_aero_length","title":"get_aero_length","text":"<pre><code>get_aero_length()\n</code></pre> <p>The characteristic aerodynamic length of the component (used for Reynolds number estimations for example).</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_aero_length(self):\n    \"\"\"The characteristic aerodynamic length of the component (used for Reynolds number estimations for example).\"\"\"\n    return self.aero_length\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.Fuselage.get_cg_mwe","title":"get_cg_mwe","text":"<pre><code>get_cg_mwe()\n</code></pre> <p>Returns the position of the center of gravity of the manufacturer empty aircraft</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_cg_mwe(self):\n    \"\"\"Returns the position of the center of gravity of the manufacturer empty aircraft\"\"\"\n    return self.cg\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.Fuselage.get_cg_owe","title":"get_cg_owe","text":"<pre><code>get_cg_owe()\n</code></pre> <p>Returns the position of the center of gravity of the operational empty aircraft</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_cg_owe(self):\n    \"\"\"Returns the position of the center of gravity of the operational empty aircraft\"\"\"\n    return self.cg\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.Fuselage.get_form_factor","title":"get_form_factor","text":"<pre><code>get_form_factor()\n</code></pre> <p>Form factor used to estimate form drag.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_form_factor(self):\n    \"\"\"Form factor used to estimate form drag.\"\"\"\n    return self.form_factor\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.Fuselage.get_inertia_tensor","title":"get_inertia_tensor","text":"<pre><code>get_inertia_tensor()\n</code></pre> <p>returns the inertia matrix of the component, if implemented.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_inertia_tensor(self):\n    \"\"\"returns the inertia matrix of the component, if implemented.\"\"\"\n    return self.inertia_tensor\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.Fuselage.get_mass_mwe","title":"get_mass_mwe","text":"<pre><code>get_mass_mwe()\n</code></pre> <p>Returns the Manufacturer's Weight Empty, the mass (kg) of the component</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_mass_mwe(self):\n    \"\"\"Returns the *Manufacturer's Weight Empty*, the mass (kg) of the component\"\"\"\n    return self.mass\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.Fuselage.get_mass_owe","title":"get_mass_owe","text":"<pre><code>get_mass_owe()\n</code></pre> <p>Returns the Operating Weight Empty, the mass (kg) of the component. Can differ from MWE for some components</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_mass_owe(self):\n    \"\"\"Returns the *Operating Weight Empty*, the mass (kg) of the component. Can differ from MWE for some components\"\"\"\n    return self.mass\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.Fuselage.get_net_wet_area","title":"get_net_wet_area","text":"<pre><code>get_net_wet_area()\n</code></pre> <p>The net wet area of the component in contact with outer airflow, 0 if the component has no aerodynamic surface.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_net_wet_area(self):\n    \"\"\"The net wet area of the component in contact with outer airflow, 0 if the component has no aerodynamic surface.\"\"\"\n    return self.net_wet_area\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.Fuselage.get_this_shape","title":"get_this_shape","text":"<pre><code>get_this_shape(name)\n</code></pre> <p>Contour curves for 3 view drawing nose1 : modern nose (A220, A350, 787) nose3 : classical Airbus nose nose2 : symetrical nose cone1 : classical tail cone cone2 : symetrical cone section : circle</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_this_shape(self, name): # TODO: is the docstring up to date ?\n    \"\"\"Contour curves for 3 view drawing\n    nose1 : modern nose (A220, A350, 787)\n    nose3 : classical Airbus nose\n    nose2 : symetrical nose\n    cone1 : classical tail cone\n    cone2 : symetrical cone\n    section : circle\n    \"\"\"\n    curve = {\n    \"nose1\":np.array([[ 0.0000 , 0.3339 , 0.3339 , 0.0000 ,  0.0000 ] ,\n                      [ 0.0050 , 0.3848 , 0.3084 , 0.0335 , -0.0335 ] ,\n                      [ 0.0150 , 0.4253 , 0.2881 , 0.0652 , -0.0652 ] ,\n                      [ 0.0500 , 0.5033 , 0.2490 , 0.1101 , -0.1101 ] ,\n                      [ 0.1000 , 0.5811 , 0.2100 , 0.1585 , -0.1585 ] ,\n                      [ 0.1800 , 0.6808 , 0.1600 , 0.2215 , -0.2215 ] ,\n                      [ 0.2773 , 0.7704 , 0.1151 , 0.2859 , -0.2859 ] ,\n                      [ 0.4191 , 0.8562 , 0.0721 , 0.3624 , -0.3624 ] ,\n                      [ 0.5610 , 0.9198 , 0.0402 , 0.4211 , -0.4211 ] ,\n                      [ 0.7738 , 0.9816 , 0.0092 , 0.4761 , -0.4761 ] ,\n                      [ 0.9156 , 0.9962 , 0.0019 , 0.4976 , -0.4976 ] ,\n                      [ 1.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ]]),\n\n    \"nose2\":np.array([[ 0.0000 , 0.5000 ,  0.5000 , 0.0000 ,  0.0000 ] ,\n                      [ 0.0050 , 0.5335 ,  0.4665 , 0.0335 , -0.0335 ] ,\n                      [ 0.0191 , 0.5646 ,  0.4354 , 0.0646 , -0.0646 ] ,\n                      [ 0.0624 , 0.6196 ,  0.3804 , 0.1196 , -0.1196 ] ,\n                      [ 0.1355 , 0.6878 ,  0.3122 , 0.1878 , -0.1878 ] ,\n                      [ 0.1922 , 0.7297 ,  0.2703 , 0.2297 , -0.2297 ] ,\n                      [ 0.2773 , 0.7859 ,  0.2141 , 0.2859 , -0.2859 ] ,\n                      [ 0.4191 , 0.8624 ,  0.1376 , 0.3624 , -0.3624 ] ,\n                      [ 0.5610 , 0.9211 ,  0.0789 , 0.4211 , -0.4211 ] ,\n                      [ 0.7738 , 0.9761 ,  0.0239 , 0.4761 , -0.4761 ] ,\n                      [ 0.9156 , 0.9976 ,  0.0024 , 0.4976 , -0.4976 ] ,\n                      [ 1.0000 , 1.0000 ,  0.0000 , 0.5000 , -0.5000 ]]),\n\n    \"nose3\":np.array([[ 0.0000 , 0.4453 , 0.4453 , 0.0000 ,  0.0000 ] ,\n                      [ 0.0050 , 0.4733 , 0.4112 , 0.0335 , -0.0335 ] ,\n                      [ 0.0191 , 0.5098 , 0.3833 , 0.0646 , -0.0646 ] ,\n                      [ 0.0624 , 0.5718 , 0.3188 , 0.1196 , -0.1196 ] ,\n                      [ 0.1355 , 0.6278 , 0.2531 , 0.1878 , -0.1878 ] ,\n                      [ 0.1922 , 0.7263 , 0.2142 , 0.2297 , -0.2297 ] ,\n                      [ 0.2773 , 0.8127 , 0.1631 , 0.2859 , -0.2859 ] ,\n                      [ 0.4191 , 0.8906 , 0.0962 , 0.3624 , -0.3624 ] ,\n                      [ 0.5610 , 0.9392 , 0.0536 , 0.4211 , -0.4211 ] ,\n                      [ 0.7738 , 0.9818 , 0.0122 , 0.4761 , -0.4761 ] ,\n                      [ 0.9156 , 0.9976 , 0.0025 , 0.4976 , -0.4976 ] ,\n                      [ 1.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ]]),\n\n    \"nose4\":np.array([[ 0.0000, 0.3700, 0.3700, 0.0000,  0.0000 ] ,\n                      [ 0.0050, 0.4200, 0.3200, 0.0335, -0.0335 ] ,\n                      [ 0.0150, 0.4500, 0.2900, 0.0652, -0.0652 ] ,\n                      [ 0.0500, 0.5000, 0.2400, 0.1200, -0.1200 ] ,\n                      [ 0.1000, 0.5500, 0.1900, 0.1750, -0.1750 ] ,\n                      [ 0.1800, 0.6000, 0.1400, 0.2400, -0.2400 ] ,\n                      [ 0.2773, 0.6450, 0.1000, 0.3000, -0.3000 ] ,\n                      [ 0.4191, 0.7000, 0.0500, 0.3700, -0.3700 ] ,\n                      [ 0.5610, 0.7550, 0.0250, 0.4300, -0.4300 ] ,\n                      [ 0.6200, 0.7800, 0.0180, 0.4500, -0.4500 ] ,\n                      [ 0.7700, 0.9700, 0.0090, 0.4850, -0.4850 ] ,\n                      [ 0.8100, 0.9900, 0.0060, 0.4900, -0.4900 ] ,\n                      [ 0.9100, 0.9970, 0.0030, 0.4976, -0.4976 ] ,\n                      [ 1.0000, 1.0000, 0.0000, 0.5000, -0.5000 ]]),\n\n    \"cone1\":np.array([[ 0.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ] ,\n                      [ 0.0213 , 1.0000 , 0.0082 , 0.5000 , -0.5000 ] ,\n                      [ 0.0638 , 1.0000 , 0.0230 , 0.4956 , -0.4956 ] ,\n                      [ 0.1064 , 1.0000 , 0.0393 , 0.4875 , -0.4875 ] ,\n                      [ 0.1489 , 1.0000 , 0.0556 , 0.4794 , -0.4794 ] ,\n                      [ 0.1915 , 1.0000 , 0.0786 , 0.4720 , -0.4720 ] ,\n                      [ 0.2766 , 1.0000 , 0.1334 , 0.4566 , -0.4566 ] ,\n                      [ 0.3617 , 1.0000 , 0.1964 , 0.4330 , -0.4330 ] ,\n                      [ 0.4894 , 1.0000 , 0.3024 , 0.3822 , -0.3822 ] ,\n                      [ 0.6170 , 1.0000 , 0.4159 , 0.3240 , -0.3240 ] ,\n                      [ 0.7447 , 1.0000 , 0.5374 , 0.2577 , -0.2577 ] ,\n                      [ 0.8723 , 1.0000 , 0.6627 , 0.1834 , -0.1834 ] ,\n                      [ 0.8936 , 0.9963 , 0.6901 , 0.1679 , -0.1679 ] ,\n                      [ 0.9149 , 0.9881 , 0.7139 , 0.1524 , -0.1524 ] ,\n                      [ 0.9362 , 0.9800 , 0.7413 , 0.1333 , -0.1333 ] ,\n                      [ 0.9574 , 0.9652 , 0.7687 , 0.1097 , -0.1097 ] ,\n                      [ 0.9787 , 0.9533 , 0.8043 , 0.0788 , -0.0788 ] ,\n                      [ 0.9894 , 0.9377 , 0.8280 , 0.0589 , -0.0589 ] ,\n                      [ 1.0000 , 0.9103 , 0.8784 , 0.0162 , -0.0162 ]]),\n\n    \"cone2\":np.array([[ 0.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ] ,\n                      [ 0.0213 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ] ,\n                      [ 0.0638 , 0.9956 , 0.0044 , 0.4956 , -0.4956 ] ,\n                      [ 0.1064 , 0.9875 , 0.0125 , 0.4875 , -0.4875 ] ,\n                      [ 0.1489 , 0.9794 , 0.0206 , 0.4794 , -0.4794 ] ,\n                      [ 0.1915 , 0.9720 , 0.0280 , 0.4720 , -0.4720 ] ,\n                      [ 0.2766 , 0.9566 , 0.0434 , 0.4566 , -0.4566 ] ,\n                      [ 0.3617 , 0.9330 , 0.0670 , 0.4330 , -0.4330 ] ,\n                      [ 0.4894 , 0.8822 , 0.1178 , 0.3822 , -0.3822 ] ,\n                      [ 0.6170 , 0.8240 , 0.1760 , 0.3240 , -0.3240 ] ,\n                      [ 0.7447 , 0.7577 , 0.2423 , 0.2577 , -0.2577 ] ,\n                      [ 0.8723 , 0.6834 , 0.3166 , 0.1834 , -0.1834 ] ,\n                      [ 0.8936 , 0.6679 , 0.3321 , 0.1679 , -0.1679 ] ,\n                      [ 0.9149 , 0.6524 , 0.3476 , 0.1524 , -0.1524 ] ,\n                      [ 0.9362 , 0.6333 , 0.3667 , 0.1333 , -0.1333 ] ,\n                      [ 0.9574 , 0.6097 , 0.3903 , 0.1097 , -0.1097 ] ,\n                      [ 0.9787 , 0.5788 , 0.4212 , 0.0788 , -0.0788 ] ,\n                      [ 0.9894 , 0.5589 , 0.4411 , 0.0589 , -0.0589 ] ,\n                      [ 1.0000 , 0.5162 , 0.4838 , 0.0162 , -0.0162 ]]),\n\n    \"sec1\":np.array([[  0.5000000 , 0.0000000 ,  0.0000000 ] ,\n                     [  0.4903926 , 0.0975452 , -0.0975452 ] ,\n                     [  0.4619398 , 0.1913417 , -0.1913417 ] ,\n                     [  0.4157348 , 0.2777851 , -0.2777851 ] ,\n                     [  0.3535534 , 0.3535534 , -0.3535534 ] ,\n                     [  0.2777851 , 0.4157348 , -0.4157348 ] ,\n                     [  0.1913417 , 0.4619398 , -0.4619398 ] ,\n                     [  0.0975452 , 0.4903926 , -0.4903926 ] ,\n                     [  0.0000000 , 0.5000000 , -0.5000000 ] ,\n                     [- 0.0975452 , 0.4903926 , -0.4903926 ] ,\n                     [- 0.1913417 , 0.4619398 , -0.4619398 ] ,\n                     [- 0.2777851 , 0.4157348 , -0.4157348 ] ,\n                     [- 0.3535534 , 0.3535534 , -0.3535534 ] ,\n                     [- 0.4157348 , 0.2777851 , -0.2777851 ] ,\n                     [- 0.4619398 , 0.1913417 , -0.1913417 ] ,\n                     [- 0.4903926 , 0.0975452 , -0.0975452 ] ,\n                     [- 0.5000000 , 0.0000000 ,  0.0000000 ]]),\n\n    \"sec2\":np.array([[ 0.5000000 , 0.0000000 ,  0.0000000] ,\n                     [ 0.4951963 , 0.0975452 , -0.0975452] ,\n                     [ 0.4809699 , 0.1913417 , -0.1913417] ,\n                     [ 0.4578674 , 0.2777851 , -0.2777851] ,\n                     [ 0.4267767 , 0.3535534 , -0.3535534] ,\n                     [ 0.3888926 , 0.4157348 , -0.4157348] ,\n                     [ 0.3456709 , 0.4619398 , -0.4619398] ,\n                     [ 0.2987726 , 0.4903926 , -0.4903926] ,\n                     [ 0.2500000 , 0.5000000 , -0.5000000] ,\n                     [ 0.0000000 , 0.5000000 , -0.5000000] ,\n                     [-0.2500000 , 0.5000000 , -0.5000000] ,\n                     [-0.2987726 , 0.4903926 , -0.4903926] ,\n                     [-0.3456709 , 0.4619398 , -0.4619398] ,\n                     [-0.3888926 , 0.4157348 , -0.4157348] ,\n                     [-0.4267767 , 0.3535534 , -0.3535534] ,\n                     [-0.4578674 , 0.2777851 , -0.2777851] ,\n                     [-0.4809699 , 0.1913417 , -0.1913417] ,\n                     [-0.4951963 , 0.0975452 , -0.0975452] ,\n                     [-0.5000000 , 0.0000000 ,  0.0000000]])}\n\n    return [curve[n] for n in name]\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.HtpClassic","title":"HtpClassic","text":"<pre><code>HtpClassic(aircraft)\n</code></pre> <p>               Bases: <code>Hstab</code></p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def __init__(self, aircraft):\n    super(HtpClassic, self).__init__(aircraft)\n\n    wing_area = aircraft.airframe.wing.area\n\n    self.area = 0.33*wing_area  # Design variable for hq_optim\n    self.span = None\n    self.aspect_ratio = aircraft.get_init(self,\"aspect_ratio\")\n    self.taper_ratio = aircraft.get_init(self,\"taper_ratio\")\n    self.toc = aircraft.get_init(self,\"toc\")\n    self.sweep25 = aircraft.get_init(self,\"sweep25\", val=self.__sweep25())\n    self.dihedral = aircraft.get_init(self,\"dihedral\")\n    self.volume_factor = aircraft.get_init(self,\"volume_factor\")\n    self.lever_arm = None\n\n    self.axe_loc = np.full(3,None)     # Position of the virtual central chord\n    self.axe_c = None                  # Length of the virtual central chord\n\n    self.tip_loc = np.full(3,None)      # Position of tip chord leading edge\n    self.tip_c = None                   # tip chord length\n\n    self.mac_loc = np.full(3,None)      # Position of MAC chord leading edge\n    self.mac = None\n\n    self.mass_correction_factor = aircraft.get_init(self,\"mass_correction_factor\")\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.HtpClassic-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.HtpClassic.eval_aero_data","title":"eval_aero_data","text":"<pre><code>eval_aero_data()\n</code></pre> <p>WARNING : output values are in Wing reference area</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def eval_aero_data(self):\n    \"\"\"WARNING : output values are in Wing reference area\n    \"\"\"\n    wing_area = self.aircraft.airframe.wing.area\n    cza_htp =  (np.pi*self.aspect_ratio)/(1+np.sqrt(1+(self.aspect_ratio/2)**2))*(self.area/wing_area)  # Helmbold formula\n    xlc_htp = self.mac_loc[0] + 0.25*self.mac   # Position of HTP center of lift\n    aoa_max_htp = unit.rad_deg(9.)              # Maximum angle of attack allowed for HTP\n    ki_htp = 1.2/(np.pi*self.aspect_ratio)      # HTP induced drag coefficient\n    return cza_htp, xlc_htp, aoa_max_htp, ki_htp\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.HtpClassic.eval_geometry","title":"eval_geometry","text":"<pre><code>eval_geometry()\n</code></pre> <p>Estimates the geometry of the component from the aircraft requirements and statistical design laws.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def eval_geometry(self):\n    body_height = self.aircraft.airframe.body.height\n    vtp_root_loc = self.aircraft.airframe.vertical_stab.root_loc\n    vtp_root_c = self.aircraft.airframe.vertical_stab.root_c\n    wing_mac_loc = self.aircraft.airframe.wing.mac_loc\n    wing_mac = self.aircraft.airframe.wing.mac\n\n    self.span = np.sqrt(self.aspect_ratio*self.area)\n    y_axe = 0.\n    y_tip = 0.5*self.span\n\n    htp_z_wise_anchor = 0.80       # Locate HTP versus end body height\n    z_axe = htp_z_wise_anchor*body_height\n    z_tip = z_axe + y_tip*np.tan(self.dihedral)\n\n    self.axe_c = 2.*self.area/(self.span*(1+self.taper_ratio))\n    self.tip_c = self.taper_ratio*self.axe_c\n\n    self.mac = self.span*(self.axe_c**2+self.tip_c**2+self.axe_c*self.tip_c)/(3.*self.area)\n    y_mac = y_tip**2*(2*self.tip_c+self.axe_c)/(3*self.area)\n    z_mac = z_tip**2*(2*self.tip_c+self.axe_c)/(3*self.area)\n    x_tip_local = 0.25*(self.axe_c-self.tip_c) + y_tip*np.tan(self.sweep25)\n    x_mac_local = y_tip*x_tip_local*(self.tip_c*2.+self.axe_c)/(3.*self.area)\n\n    x_axe = vtp_root_loc[0] + 0.50*vtp_root_c - 0.2*self.axe_c\n\n    x_tip = x_axe + x_tip_local\n    x_mac = x_axe + x_mac_local\n\n    self.lever_arm = (x_mac + 0.25*self.mac) - (wing_mac_loc[0] + 0.25*wing_mac)\n\n    self.axe_loc = np.array([x_axe, y_axe, z_axe])\n    self.tip_loc = np.array([x_tip, y_tip, z_tip])\n    self.mac_loc = np.array([x_mac, y_mac, z_mac])\n\n    self.frame_origin = self.axe_loc\n\n    self.gross_wet_area = 1.63*self.area\n    self.net_wet_area = self.gross_wet_area\n\n    self.aero_length = self.mac\n    self.form_factor = 1.40\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.HtpClassic.eval_mass","title":"eval_mass","text":"<pre><code>eval_mass()\n</code></pre> <p>Estimates the geometry of the component from the aircraft requirements and statistical design laws.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def eval_mass(self):\n    self.mass = self.mass_correction_factor * 22. * self.area\n    self.cg = self.mac_loc + 0.20*np.array([self.mac, 0., 0.])\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.HtpClassic.get_aero_length","title":"get_aero_length","text":"<pre><code>get_aero_length()\n</code></pre> <p>The characteristic aerodynamic length of the component (used for Reynolds number estimations for example).</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_aero_length(self):\n    \"\"\"The characteristic aerodynamic length of the component (used for Reynolds number estimations for example).\"\"\"\n    return self.aero_length\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.HtpClassic.get_cg_mwe","title":"get_cg_mwe","text":"<pre><code>get_cg_mwe()\n</code></pre> <p>Returns the position of the center of gravity of the manufacturer empty aircraft</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_cg_mwe(self):\n    \"\"\"Returns the position of the center of gravity of the manufacturer empty aircraft\"\"\"\n    return self.cg\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.HtpClassic.get_cg_owe","title":"get_cg_owe","text":"<pre><code>get_cg_owe()\n</code></pre> <p>Returns the position of the center of gravity of the operational empty aircraft</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_cg_owe(self):\n    \"\"\"Returns the position of the center of gravity of the operational empty aircraft\"\"\"\n    return self.cg\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.HtpClassic.get_form_factor","title":"get_form_factor","text":"<pre><code>get_form_factor()\n</code></pre> <p>Form factor used to estimate form drag.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_form_factor(self):\n    \"\"\"Form factor used to estimate form drag.\"\"\"\n    return self.form_factor\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.HtpClassic.get_inertia_tensor","title":"get_inertia_tensor","text":"<pre><code>get_inertia_tensor()\n</code></pre> <p>returns the inertia matrix of the component, if implemented.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_inertia_tensor(self):\n    \"\"\"returns the inertia matrix of the component, if implemented.\"\"\"\n    return self.inertia_tensor\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.HtpClassic.get_mass_mwe","title":"get_mass_mwe","text":"<pre><code>get_mass_mwe()\n</code></pre> <p>Returns the Manufacturer's Weight Empty, the mass (kg) of the component</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_mass_mwe(self):\n    \"\"\"Returns the *Manufacturer's Weight Empty*, the mass (kg) of the component\"\"\"\n    return self.mass\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.HtpClassic.get_mass_owe","title":"get_mass_owe","text":"<pre><code>get_mass_owe()\n</code></pre> <p>Returns the Operating Weight Empty, the mass (kg) of the component. Can differ from MWE for some components</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_mass_owe(self):\n    \"\"\"Returns the *Operating Weight Empty*, the mass (kg) of the component. Can differ from MWE for some components\"\"\"\n    return self.mass\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.HtpClassic.get_net_wet_area","title":"get_net_wet_area","text":"<pre><code>get_net_wet_area()\n</code></pre> <p>The net wet area of the component in contact with outer airflow, 0 if the component has no aerodynamic surface.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_net_wet_area(self):\n    \"\"\"The net wet area of the component in contact with outer airflow, 0 if the component has no aerodynamic surface.\"\"\"\n    return self.net_wet_area\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.HtpClassic.get_this_shape","title":"get_this_shape","text":"<pre><code>get_this_shape(name)\n</code></pre> <p>Contour curves for 3 view drawing nose1 : modern nose (A220, A350, 787) nose3 : classical Airbus nose nose2 : symetrical nose cone1 : classical tail cone cone2 : symetrical cone section : circle</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_this_shape(self, name): # TODO: is the docstring up to date ?\n    \"\"\"Contour curves for 3 view drawing\n    nose1 : modern nose (A220, A350, 787)\n    nose3 : classical Airbus nose\n    nose2 : symetrical nose\n    cone1 : classical tail cone\n    cone2 : symetrical cone\n    section : circle\n    \"\"\"\n    curve = {\n    \"nose1\":np.array([[ 0.0000 , 0.3339 , 0.3339 , 0.0000 ,  0.0000 ] ,\n                      [ 0.0050 , 0.3848 , 0.3084 , 0.0335 , -0.0335 ] ,\n                      [ 0.0150 , 0.4253 , 0.2881 , 0.0652 , -0.0652 ] ,\n                      [ 0.0500 , 0.5033 , 0.2490 , 0.1101 , -0.1101 ] ,\n                      [ 0.1000 , 0.5811 , 0.2100 , 0.1585 , -0.1585 ] ,\n                      [ 0.1800 , 0.6808 , 0.1600 , 0.2215 , -0.2215 ] ,\n                      [ 0.2773 , 0.7704 , 0.1151 , 0.2859 , -0.2859 ] ,\n                      [ 0.4191 , 0.8562 , 0.0721 , 0.3624 , -0.3624 ] ,\n                      [ 0.5610 , 0.9198 , 0.0402 , 0.4211 , -0.4211 ] ,\n                      [ 0.7738 , 0.9816 , 0.0092 , 0.4761 , -0.4761 ] ,\n                      [ 0.9156 , 0.9962 , 0.0019 , 0.4976 , -0.4976 ] ,\n                      [ 1.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ]]),\n\n    \"nose2\":np.array([[ 0.0000 , 0.5000 ,  0.5000 , 0.0000 ,  0.0000 ] ,\n                      [ 0.0050 , 0.5335 ,  0.4665 , 0.0335 , -0.0335 ] ,\n                      [ 0.0191 , 0.5646 ,  0.4354 , 0.0646 , -0.0646 ] ,\n                      [ 0.0624 , 0.6196 ,  0.3804 , 0.1196 , -0.1196 ] ,\n                      [ 0.1355 , 0.6878 ,  0.3122 , 0.1878 , -0.1878 ] ,\n                      [ 0.1922 , 0.7297 ,  0.2703 , 0.2297 , -0.2297 ] ,\n                      [ 0.2773 , 0.7859 ,  0.2141 , 0.2859 , -0.2859 ] ,\n                      [ 0.4191 , 0.8624 ,  0.1376 , 0.3624 , -0.3624 ] ,\n                      [ 0.5610 , 0.9211 ,  0.0789 , 0.4211 , -0.4211 ] ,\n                      [ 0.7738 , 0.9761 ,  0.0239 , 0.4761 , -0.4761 ] ,\n                      [ 0.9156 , 0.9976 ,  0.0024 , 0.4976 , -0.4976 ] ,\n                      [ 1.0000 , 1.0000 ,  0.0000 , 0.5000 , -0.5000 ]]),\n\n    \"nose3\":np.array([[ 0.0000 , 0.4453 , 0.4453 , 0.0000 ,  0.0000 ] ,\n                      [ 0.0050 , 0.4733 , 0.4112 , 0.0335 , -0.0335 ] ,\n                      [ 0.0191 , 0.5098 , 0.3833 , 0.0646 , -0.0646 ] ,\n                      [ 0.0624 , 0.5718 , 0.3188 , 0.1196 , -0.1196 ] ,\n                      [ 0.1355 , 0.6278 , 0.2531 , 0.1878 , -0.1878 ] ,\n                      [ 0.1922 , 0.7263 , 0.2142 , 0.2297 , -0.2297 ] ,\n                      [ 0.2773 , 0.8127 , 0.1631 , 0.2859 , -0.2859 ] ,\n                      [ 0.4191 , 0.8906 , 0.0962 , 0.3624 , -0.3624 ] ,\n                      [ 0.5610 , 0.9392 , 0.0536 , 0.4211 , -0.4211 ] ,\n                      [ 0.7738 , 0.9818 , 0.0122 , 0.4761 , -0.4761 ] ,\n                      [ 0.9156 , 0.9976 , 0.0025 , 0.4976 , -0.4976 ] ,\n                      [ 1.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ]]),\n\n    \"nose4\":np.array([[ 0.0000, 0.3700, 0.3700, 0.0000,  0.0000 ] ,\n                      [ 0.0050, 0.4200, 0.3200, 0.0335, -0.0335 ] ,\n                      [ 0.0150, 0.4500, 0.2900, 0.0652, -0.0652 ] ,\n                      [ 0.0500, 0.5000, 0.2400, 0.1200, -0.1200 ] ,\n                      [ 0.1000, 0.5500, 0.1900, 0.1750, -0.1750 ] ,\n                      [ 0.1800, 0.6000, 0.1400, 0.2400, -0.2400 ] ,\n                      [ 0.2773, 0.6450, 0.1000, 0.3000, -0.3000 ] ,\n                      [ 0.4191, 0.7000, 0.0500, 0.3700, -0.3700 ] ,\n                      [ 0.5610, 0.7550, 0.0250, 0.4300, -0.4300 ] ,\n                      [ 0.6200, 0.7800, 0.0180, 0.4500, -0.4500 ] ,\n                      [ 0.7700, 0.9700, 0.0090, 0.4850, -0.4850 ] ,\n                      [ 0.8100, 0.9900, 0.0060, 0.4900, -0.4900 ] ,\n                      [ 0.9100, 0.9970, 0.0030, 0.4976, -0.4976 ] ,\n                      [ 1.0000, 1.0000, 0.0000, 0.5000, -0.5000 ]]),\n\n    \"cone1\":np.array([[ 0.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ] ,\n                      [ 0.0213 , 1.0000 , 0.0082 , 0.5000 , -0.5000 ] ,\n                      [ 0.0638 , 1.0000 , 0.0230 , 0.4956 , -0.4956 ] ,\n                      [ 0.1064 , 1.0000 , 0.0393 , 0.4875 , -0.4875 ] ,\n                      [ 0.1489 , 1.0000 , 0.0556 , 0.4794 , -0.4794 ] ,\n                      [ 0.1915 , 1.0000 , 0.0786 , 0.4720 , -0.4720 ] ,\n                      [ 0.2766 , 1.0000 , 0.1334 , 0.4566 , -0.4566 ] ,\n                      [ 0.3617 , 1.0000 , 0.1964 , 0.4330 , -0.4330 ] ,\n                      [ 0.4894 , 1.0000 , 0.3024 , 0.3822 , -0.3822 ] ,\n                      [ 0.6170 , 1.0000 , 0.4159 , 0.3240 , -0.3240 ] ,\n                      [ 0.7447 , 1.0000 , 0.5374 , 0.2577 , -0.2577 ] ,\n                      [ 0.8723 , 1.0000 , 0.6627 , 0.1834 , -0.1834 ] ,\n                      [ 0.8936 , 0.9963 , 0.6901 , 0.1679 , -0.1679 ] ,\n                      [ 0.9149 , 0.9881 , 0.7139 , 0.1524 , -0.1524 ] ,\n                      [ 0.9362 , 0.9800 , 0.7413 , 0.1333 , -0.1333 ] ,\n                      [ 0.9574 , 0.9652 , 0.7687 , 0.1097 , -0.1097 ] ,\n                      [ 0.9787 , 0.9533 , 0.8043 , 0.0788 , -0.0788 ] ,\n                      [ 0.9894 , 0.9377 , 0.8280 , 0.0589 , -0.0589 ] ,\n                      [ 1.0000 , 0.9103 , 0.8784 , 0.0162 , -0.0162 ]]),\n\n    \"cone2\":np.array([[ 0.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ] ,\n                      [ 0.0213 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ] ,\n                      [ 0.0638 , 0.9956 , 0.0044 , 0.4956 , -0.4956 ] ,\n                      [ 0.1064 , 0.9875 , 0.0125 , 0.4875 , -0.4875 ] ,\n                      [ 0.1489 , 0.9794 , 0.0206 , 0.4794 , -0.4794 ] ,\n                      [ 0.1915 , 0.9720 , 0.0280 , 0.4720 , -0.4720 ] ,\n                      [ 0.2766 , 0.9566 , 0.0434 , 0.4566 , -0.4566 ] ,\n                      [ 0.3617 , 0.9330 , 0.0670 , 0.4330 , -0.4330 ] ,\n                      [ 0.4894 , 0.8822 , 0.1178 , 0.3822 , -0.3822 ] ,\n                      [ 0.6170 , 0.8240 , 0.1760 , 0.3240 , -0.3240 ] ,\n                      [ 0.7447 , 0.7577 , 0.2423 , 0.2577 , -0.2577 ] ,\n                      [ 0.8723 , 0.6834 , 0.3166 , 0.1834 , -0.1834 ] ,\n                      [ 0.8936 , 0.6679 , 0.3321 , 0.1679 , -0.1679 ] ,\n                      [ 0.9149 , 0.6524 , 0.3476 , 0.1524 , -0.1524 ] ,\n                      [ 0.9362 , 0.6333 , 0.3667 , 0.1333 , -0.1333 ] ,\n                      [ 0.9574 , 0.6097 , 0.3903 , 0.1097 , -0.1097 ] ,\n                      [ 0.9787 , 0.5788 , 0.4212 , 0.0788 , -0.0788 ] ,\n                      [ 0.9894 , 0.5589 , 0.4411 , 0.0589 , -0.0589 ] ,\n                      [ 1.0000 , 0.5162 , 0.4838 , 0.0162 , -0.0162 ]]),\n\n    \"sec1\":np.array([[  0.5000000 , 0.0000000 ,  0.0000000 ] ,\n                     [  0.4903926 , 0.0975452 , -0.0975452 ] ,\n                     [  0.4619398 , 0.1913417 , -0.1913417 ] ,\n                     [  0.4157348 , 0.2777851 , -0.2777851 ] ,\n                     [  0.3535534 , 0.3535534 , -0.3535534 ] ,\n                     [  0.2777851 , 0.4157348 , -0.4157348 ] ,\n                     [  0.1913417 , 0.4619398 , -0.4619398 ] ,\n                     [  0.0975452 , 0.4903926 , -0.4903926 ] ,\n                     [  0.0000000 , 0.5000000 , -0.5000000 ] ,\n                     [- 0.0975452 , 0.4903926 , -0.4903926 ] ,\n                     [- 0.1913417 , 0.4619398 , -0.4619398 ] ,\n                     [- 0.2777851 , 0.4157348 , -0.4157348 ] ,\n                     [- 0.3535534 , 0.3535534 , -0.3535534 ] ,\n                     [- 0.4157348 , 0.2777851 , -0.2777851 ] ,\n                     [- 0.4619398 , 0.1913417 , -0.1913417 ] ,\n                     [- 0.4903926 , 0.0975452 , -0.0975452 ] ,\n                     [- 0.5000000 , 0.0000000 ,  0.0000000 ]]),\n\n    \"sec2\":np.array([[ 0.5000000 , 0.0000000 ,  0.0000000] ,\n                     [ 0.4951963 , 0.0975452 , -0.0975452] ,\n                     [ 0.4809699 , 0.1913417 , -0.1913417] ,\n                     [ 0.4578674 , 0.2777851 , -0.2777851] ,\n                     [ 0.4267767 , 0.3535534 , -0.3535534] ,\n                     [ 0.3888926 , 0.4157348 , -0.4157348] ,\n                     [ 0.3456709 , 0.4619398 , -0.4619398] ,\n                     [ 0.2987726 , 0.4903926 , -0.4903926] ,\n                     [ 0.2500000 , 0.5000000 , -0.5000000] ,\n                     [ 0.0000000 , 0.5000000 , -0.5000000] ,\n                     [-0.2500000 , 0.5000000 , -0.5000000] ,\n                     [-0.2987726 , 0.4903926 , -0.4903926] ,\n                     [-0.3456709 , 0.4619398 , -0.4619398] ,\n                     [-0.3888926 , 0.4157348 , -0.4157348] ,\n                     [-0.4267767 , 0.3535534 , -0.3535534] ,\n                     [-0.4578674 , 0.2777851 , -0.2777851] ,\n                     [-0.4809699 , 0.1913417 , -0.1913417] ,\n                     [-0.4951963 , 0.0975452 , -0.0975452] ,\n                     [-0.5000000 , 0.0000000 ,  0.0000000]])}\n\n    return [curve[n] for n in name]\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.HtpHtail","title":"HtpHtail","text":"<pre><code>HtpHtail(aircraft)\n</code></pre> <p>               Bases: <code>Hstab</code></p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def __init__(self, aircraft):\n    super(HtpHtail, self).__init__(aircraft)\n\n    wing_area = aircraft.airframe.wing.area\n\n    self.area = 0.33*wing_area  # Design variable for hq_optim\n    self.span = None\n    self.aspect_ratio = aircraft.get_init(self,\"aspect_ratio\")\n    self.taper_ratio = aircraft.get_init(self,\"taper_ratio\")\n    self.toc = aircraft.get_init(self,\"toc\")\n    self.sweep25 = aircraft.get_init(self,\"sweep25\", val=self.__sweep25())\n    self.dihedral = aircraft.get_init(self,\"dihedral\")\n    self.volume_factor = aircraft.get_init(self,\"volume_factor\")\n    self.lever_arm = None\n\n    self.axe_loc = np.full(3,None)     # Position of the virtual central chord\n    self.axe_c = None                  # Length of the virtual central chord\n\n    self.tip_loc = np.full(3,None)      # Position of tip chord leading edge\n    self.tip_c = None                   # tip chord length\n\n    self.mac_loc = np.full(3,None)      # Position of MAC chord leading edge\n    self.mac = None\n\n    self.mass_correction_factor = aircraft.get_init(self,\"mass_correction_factor\")\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.HtpHtail-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.HtpHtail.eval_aero_data","title":"eval_aero_data","text":"<pre><code>eval_aero_data()\n</code></pre> <p>WARNING : output values are in Wing reference area</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def eval_aero_data(self):\n    \"\"\"WARNING : output values are in Wing reference area\n    \"\"\"\n    wing_area = self.aircraft.airframe.wing.area\n    # Helmbold formula corrected with endplate effect\n    cza_htp =  1.2*(np.pi*self.aspect_ratio)/(1+np.sqrt(1+(self.aspect_ratio/2)**2))*(self.area/wing_area)\n    xlc_htp = self.mac_loc[0] + 0.25*self.mac   # Position of HTP center of lift\n    aoa_max_htp = unit.rad_deg(9.)              # Maximum angle of attack allowed for HTP\n    ki_htp = 1.1/(np.pi*self.aspect_ratio)      # HTP induced drag coefficient\n    return cza_htp, xlc_htp, aoa_max_htp, ki_htp\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.HtpHtail.eval_geometry","title":"eval_geometry","text":"<pre><code>eval_geometry()\n</code></pre> <p>Estimates the geometry of the component from the aircraft requirements and statistical design laws.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def eval_geometry(self):\n    body_length = self.aircraft.airframe.body.length\n    body_height = self.aircraft.airframe.body.height\n    body_cone_length = self.aircraft.airframe.body.tail_cone_length\n    wing_mac_loc = self.aircraft.airframe.wing.mac_loc\n    wing_mac = self.aircraft.airframe.wing.mac\n\n    self.span = np.sqrt(self.aspect_ratio*self.area)\n    y_axe = 0.\n    y_tip = 0.5*self.span\n\n    htp_z_wise_anchor = 0.80       # Locate HTP versus end body height\n    z_axe = htp_z_wise_anchor*body_height\n    z_tip = z_axe + y_tip*np.tan(self.dihedral)\n\n    self.axe_c = 2.*self.area/(self.span*(1+self.taper_ratio))\n    self.tip_c = self.taper_ratio*self.axe_c\n\n    self.mac = self.span*(self.axe_c**2+self.tip_c**2+self.axe_c*self.tip_c)/(3.*self.area)\n    y_mac = y_tip**2*(2*self.tip_c+self.axe_c)/(3*self.area)\n    z_mac = z_tip**2*(2*self.tip_c+self.axe_c)/(3*self.area)\n    x_tip_local = 0.25*(self.axe_c-self.tip_c) + y_tip*np.tan(self.sweep25)\n    x_mac_local = y_tip*x_tip_local*(self.tip_c*2.+self.axe_c)/(3.*self.area)\n\n    htp_x_wise_anchor = 0.85\n    x_axe = body_length*(1-body_cone_length/body_length*(1-htp_x_wise_anchor)) - self.axe_c\n\n    x_tip = x_axe + x_tip_local\n    x_mac = x_axe + x_mac_local\n\n    self.lever_arm = (x_mac + 0.25*self.mac) - (wing_mac_loc[0] + 0.25*wing_mac)\n\n    self.axe_loc = np.array([x_axe, y_axe, z_axe])\n    self.tip_loc = np.array([x_tip, y_tip, z_tip])\n    self.mac_loc = np.array([x_mac, y_mac, z_mac])\n\n    self.frame_origin = self.axe_loc\n\n    self.gross_wet_area = 1.63*self.area\n    self.net_wet_area = self.gross_wet_area\n\n    self.aero_length = self.mac\n    self.form_factor = 1.40\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.HtpHtail.eval_mass","title":"eval_mass","text":"<pre><code>eval_mass()\n</code></pre> <p>Estimates the geometry of the component from the aircraft requirements and statistical design laws.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def eval_mass(self):\n    self.mass = self.mass_correction_factor * 22. * self.area\n    self.cg = self.mac_loc + 0.20*np.array([self.mac, 0., 0.])\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.HtpHtail.get_aero_length","title":"get_aero_length","text":"<pre><code>get_aero_length()\n</code></pre> <p>The characteristic aerodynamic length of the component (used for Reynolds number estimations for example).</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_aero_length(self):\n    \"\"\"The characteristic aerodynamic length of the component (used for Reynolds number estimations for example).\"\"\"\n    return self.aero_length\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.HtpHtail.get_cg_mwe","title":"get_cg_mwe","text":"<pre><code>get_cg_mwe()\n</code></pre> <p>Returns the position of the center of gravity of the manufacturer empty aircraft</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_cg_mwe(self):\n    \"\"\"Returns the position of the center of gravity of the manufacturer empty aircraft\"\"\"\n    return self.cg\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.HtpHtail.get_cg_owe","title":"get_cg_owe","text":"<pre><code>get_cg_owe()\n</code></pre> <p>Returns the position of the center of gravity of the operational empty aircraft</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_cg_owe(self):\n    \"\"\"Returns the position of the center of gravity of the operational empty aircraft\"\"\"\n    return self.cg\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.HtpHtail.get_form_factor","title":"get_form_factor","text":"<pre><code>get_form_factor()\n</code></pre> <p>Form factor used to estimate form drag.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_form_factor(self):\n    \"\"\"Form factor used to estimate form drag.\"\"\"\n    return self.form_factor\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.HtpHtail.get_inertia_tensor","title":"get_inertia_tensor","text":"<pre><code>get_inertia_tensor()\n</code></pre> <p>returns the inertia matrix of the component, if implemented.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_inertia_tensor(self):\n    \"\"\"returns the inertia matrix of the component, if implemented.\"\"\"\n    return self.inertia_tensor\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.HtpHtail.get_mass_mwe","title":"get_mass_mwe","text":"<pre><code>get_mass_mwe()\n</code></pre> <p>Returns the Manufacturer's Weight Empty, the mass (kg) of the component</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_mass_mwe(self):\n    \"\"\"Returns the *Manufacturer's Weight Empty*, the mass (kg) of the component\"\"\"\n    return self.mass\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.HtpHtail.get_mass_owe","title":"get_mass_owe","text":"<pre><code>get_mass_owe()\n</code></pre> <p>Returns the Operating Weight Empty, the mass (kg) of the component. Can differ from MWE for some components</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_mass_owe(self):\n    \"\"\"Returns the *Operating Weight Empty*, the mass (kg) of the component. Can differ from MWE for some components\"\"\"\n    return self.mass\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.HtpHtail.get_net_wet_area","title":"get_net_wet_area","text":"<pre><code>get_net_wet_area()\n</code></pre> <p>The net wet area of the component in contact with outer airflow, 0 if the component has no aerodynamic surface.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_net_wet_area(self):\n    \"\"\"The net wet area of the component in contact with outer airflow, 0 if the component has no aerodynamic surface.\"\"\"\n    return self.net_wet_area\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.HtpHtail.get_this_shape","title":"get_this_shape","text":"<pre><code>get_this_shape(name)\n</code></pre> <p>Contour curves for 3 view drawing nose1 : modern nose (A220, A350, 787) nose3 : classical Airbus nose nose2 : symetrical nose cone1 : classical tail cone cone2 : symetrical cone section : circle</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_this_shape(self, name): # TODO: is the docstring up to date ?\n    \"\"\"Contour curves for 3 view drawing\n    nose1 : modern nose (A220, A350, 787)\n    nose3 : classical Airbus nose\n    nose2 : symetrical nose\n    cone1 : classical tail cone\n    cone2 : symetrical cone\n    section : circle\n    \"\"\"\n    curve = {\n    \"nose1\":np.array([[ 0.0000 , 0.3339 , 0.3339 , 0.0000 ,  0.0000 ] ,\n                      [ 0.0050 , 0.3848 , 0.3084 , 0.0335 , -0.0335 ] ,\n                      [ 0.0150 , 0.4253 , 0.2881 , 0.0652 , -0.0652 ] ,\n                      [ 0.0500 , 0.5033 , 0.2490 , 0.1101 , -0.1101 ] ,\n                      [ 0.1000 , 0.5811 , 0.2100 , 0.1585 , -0.1585 ] ,\n                      [ 0.1800 , 0.6808 , 0.1600 , 0.2215 , -0.2215 ] ,\n                      [ 0.2773 , 0.7704 , 0.1151 , 0.2859 , -0.2859 ] ,\n                      [ 0.4191 , 0.8562 , 0.0721 , 0.3624 , -0.3624 ] ,\n                      [ 0.5610 , 0.9198 , 0.0402 , 0.4211 , -0.4211 ] ,\n                      [ 0.7738 , 0.9816 , 0.0092 , 0.4761 , -0.4761 ] ,\n                      [ 0.9156 , 0.9962 , 0.0019 , 0.4976 , -0.4976 ] ,\n                      [ 1.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ]]),\n\n    \"nose2\":np.array([[ 0.0000 , 0.5000 ,  0.5000 , 0.0000 ,  0.0000 ] ,\n                      [ 0.0050 , 0.5335 ,  0.4665 , 0.0335 , -0.0335 ] ,\n                      [ 0.0191 , 0.5646 ,  0.4354 , 0.0646 , -0.0646 ] ,\n                      [ 0.0624 , 0.6196 ,  0.3804 , 0.1196 , -0.1196 ] ,\n                      [ 0.1355 , 0.6878 ,  0.3122 , 0.1878 , -0.1878 ] ,\n                      [ 0.1922 , 0.7297 ,  0.2703 , 0.2297 , -0.2297 ] ,\n                      [ 0.2773 , 0.7859 ,  0.2141 , 0.2859 , -0.2859 ] ,\n                      [ 0.4191 , 0.8624 ,  0.1376 , 0.3624 , -0.3624 ] ,\n                      [ 0.5610 , 0.9211 ,  0.0789 , 0.4211 , -0.4211 ] ,\n                      [ 0.7738 , 0.9761 ,  0.0239 , 0.4761 , -0.4761 ] ,\n                      [ 0.9156 , 0.9976 ,  0.0024 , 0.4976 , -0.4976 ] ,\n                      [ 1.0000 , 1.0000 ,  0.0000 , 0.5000 , -0.5000 ]]),\n\n    \"nose3\":np.array([[ 0.0000 , 0.4453 , 0.4453 , 0.0000 ,  0.0000 ] ,\n                      [ 0.0050 , 0.4733 , 0.4112 , 0.0335 , -0.0335 ] ,\n                      [ 0.0191 , 0.5098 , 0.3833 , 0.0646 , -0.0646 ] ,\n                      [ 0.0624 , 0.5718 , 0.3188 , 0.1196 , -0.1196 ] ,\n                      [ 0.1355 , 0.6278 , 0.2531 , 0.1878 , -0.1878 ] ,\n                      [ 0.1922 , 0.7263 , 0.2142 , 0.2297 , -0.2297 ] ,\n                      [ 0.2773 , 0.8127 , 0.1631 , 0.2859 , -0.2859 ] ,\n                      [ 0.4191 , 0.8906 , 0.0962 , 0.3624 , -0.3624 ] ,\n                      [ 0.5610 , 0.9392 , 0.0536 , 0.4211 , -0.4211 ] ,\n                      [ 0.7738 , 0.9818 , 0.0122 , 0.4761 , -0.4761 ] ,\n                      [ 0.9156 , 0.9976 , 0.0025 , 0.4976 , -0.4976 ] ,\n                      [ 1.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ]]),\n\n    \"nose4\":np.array([[ 0.0000, 0.3700, 0.3700, 0.0000,  0.0000 ] ,\n                      [ 0.0050, 0.4200, 0.3200, 0.0335, -0.0335 ] ,\n                      [ 0.0150, 0.4500, 0.2900, 0.0652, -0.0652 ] ,\n                      [ 0.0500, 0.5000, 0.2400, 0.1200, -0.1200 ] ,\n                      [ 0.1000, 0.5500, 0.1900, 0.1750, -0.1750 ] ,\n                      [ 0.1800, 0.6000, 0.1400, 0.2400, -0.2400 ] ,\n                      [ 0.2773, 0.6450, 0.1000, 0.3000, -0.3000 ] ,\n                      [ 0.4191, 0.7000, 0.0500, 0.3700, -0.3700 ] ,\n                      [ 0.5610, 0.7550, 0.0250, 0.4300, -0.4300 ] ,\n                      [ 0.6200, 0.7800, 0.0180, 0.4500, -0.4500 ] ,\n                      [ 0.7700, 0.9700, 0.0090, 0.4850, -0.4850 ] ,\n                      [ 0.8100, 0.9900, 0.0060, 0.4900, -0.4900 ] ,\n                      [ 0.9100, 0.9970, 0.0030, 0.4976, -0.4976 ] ,\n                      [ 1.0000, 1.0000, 0.0000, 0.5000, -0.5000 ]]),\n\n    \"cone1\":np.array([[ 0.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ] ,\n                      [ 0.0213 , 1.0000 , 0.0082 , 0.5000 , -0.5000 ] ,\n                      [ 0.0638 , 1.0000 , 0.0230 , 0.4956 , -0.4956 ] ,\n                      [ 0.1064 , 1.0000 , 0.0393 , 0.4875 , -0.4875 ] ,\n                      [ 0.1489 , 1.0000 , 0.0556 , 0.4794 , -0.4794 ] ,\n                      [ 0.1915 , 1.0000 , 0.0786 , 0.4720 , -0.4720 ] ,\n                      [ 0.2766 , 1.0000 , 0.1334 , 0.4566 , -0.4566 ] ,\n                      [ 0.3617 , 1.0000 , 0.1964 , 0.4330 , -0.4330 ] ,\n                      [ 0.4894 , 1.0000 , 0.3024 , 0.3822 , -0.3822 ] ,\n                      [ 0.6170 , 1.0000 , 0.4159 , 0.3240 , -0.3240 ] ,\n                      [ 0.7447 , 1.0000 , 0.5374 , 0.2577 , -0.2577 ] ,\n                      [ 0.8723 , 1.0000 , 0.6627 , 0.1834 , -0.1834 ] ,\n                      [ 0.8936 , 0.9963 , 0.6901 , 0.1679 , -0.1679 ] ,\n                      [ 0.9149 , 0.9881 , 0.7139 , 0.1524 , -0.1524 ] ,\n                      [ 0.9362 , 0.9800 , 0.7413 , 0.1333 , -0.1333 ] ,\n                      [ 0.9574 , 0.9652 , 0.7687 , 0.1097 , -0.1097 ] ,\n                      [ 0.9787 , 0.9533 , 0.8043 , 0.0788 , -0.0788 ] ,\n                      [ 0.9894 , 0.9377 , 0.8280 , 0.0589 , -0.0589 ] ,\n                      [ 1.0000 , 0.9103 , 0.8784 , 0.0162 , -0.0162 ]]),\n\n    \"cone2\":np.array([[ 0.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ] ,\n                      [ 0.0213 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ] ,\n                      [ 0.0638 , 0.9956 , 0.0044 , 0.4956 , -0.4956 ] ,\n                      [ 0.1064 , 0.9875 , 0.0125 , 0.4875 , -0.4875 ] ,\n                      [ 0.1489 , 0.9794 , 0.0206 , 0.4794 , -0.4794 ] ,\n                      [ 0.1915 , 0.9720 , 0.0280 , 0.4720 , -0.4720 ] ,\n                      [ 0.2766 , 0.9566 , 0.0434 , 0.4566 , -0.4566 ] ,\n                      [ 0.3617 , 0.9330 , 0.0670 , 0.4330 , -0.4330 ] ,\n                      [ 0.4894 , 0.8822 , 0.1178 , 0.3822 , -0.3822 ] ,\n                      [ 0.6170 , 0.8240 , 0.1760 , 0.3240 , -0.3240 ] ,\n                      [ 0.7447 , 0.7577 , 0.2423 , 0.2577 , -0.2577 ] ,\n                      [ 0.8723 , 0.6834 , 0.3166 , 0.1834 , -0.1834 ] ,\n                      [ 0.8936 , 0.6679 , 0.3321 , 0.1679 , -0.1679 ] ,\n                      [ 0.9149 , 0.6524 , 0.3476 , 0.1524 , -0.1524 ] ,\n                      [ 0.9362 , 0.6333 , 0.3667 , 0.1333 , -0.1333 ] ,\n                      [ 0.9574 , 0.6097 , 0.3903 , 0.1097 , -0.1097 ] ,\n                      [ 0.9787 , 0.5788 , 0.4212 , 0.0788 , -0.0788 ] ,\n                      [ 0.9894 , 0.5589 , 0.4411 , 0.0589 , -0.0589 ] ,\n                      [ 1.0000 , 0.5162 , 0.4838 , 0.0162 , -0.0162 ]]),\n\n    \"sec1\":np.array([[  0.5000000 , 0.0000000 ,  0.0000000 ] ,\n                     [  0.4903926 , 0.0975452 , -0.0975452 ] ,\n                     [  0.4619398 , 0.1913417 , -0.1913417 ] ,\n                     [  0.4157348 , 0.2777851 , -0.2777851 ] ,\n                     [  0.3535534 , 0.3535534 , -0.3535534 ] ,\n                     [  0.2777851 , 0.4157348 , -0.4157348 ] ,\n                     [  0.1913417 , 0.4619398 , -0.4619398 ] ,\n                     [  0.0975452 , 0.4903926 , -0.4903926 ] ,\n                     [  0.0000000 , 0.5000000 , -0.5000000 ] ,\n                     [- 0.0975452 , 0.4903926 , -0.4903926 ] ,\n                     [- 0.1913417 , 0.4619398 , -0.4619398 ] ,\n                     [- 0.2777851 , 0.4157348 , -0.4157348 ] ,\n                     [- 0.3535534 , 0.3535534 , -0.3535534 ] ,\n                     [- 0.4157348 , 0.2777851 , -0.2777851 ] ,\n                     [- 0.4619398 , 0.1913417 , -0.1913417 ] ,\n                     [- 0.4903926 , 0.0975452 , -0.0975452 ] ,\n                     [- 0.5000000 , 0.0000000 ,  0.0000000 ]]),\n\n    \"sec2\":np.array([[ 0.5000000 , 0.0000000 ,  0.0000000] ,\n                     [ 0.4951963 , 0.0975452 , -0.0975452] ,\n                     [ 0.4809699 , 0.1913417 , -0.1913417] ,\n                     [ 0.4578674 , 0.2777851 , -0.2777851] ,\n                     [ 0.4267767 , 0.3535534 , -0.3535534] ,\n                     [ 0.3888926 , 0.4157348 , -0.4157348] ,\n                     [ 0.3456709 , 0.4619398 , -0.4619398] ,\n                     [ 0.2987726 , 0.4903926 , -0.4903926] ,\n                     [ 0.2500000 , 0.5000000 , -0.5000000] ,\n                     [ 0.0000000 , 0.5000000 , -0.5000000] ,\n                     [-0.2500000 , 0.5000000 , -0.5000000] ,\n                     [-0.2987726 , 0.4903926 , -0.4903926] ,\n                     [-0.3456709 , 0.4619398 , -0.4619398] ,\n                     [-0.3888926 , 0.4157348 , -0.4157348] ,\n                     [-0.4267767 , 0.3535534 , -0.3535534] ,\n                     [-0.4578674 , 0.2777851 , -0.2777851] ,\n                     [-0.4809699 , 0.1913417 , -0.1913417] ,\n                     [-0.4951963 , 0.0975452 , -0.0975452] ,\n                     [-0.5000000 , 0.0000000 ,  0.0000000]])}\n\n    return [curve[n] for n in name]\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.HtpTtail","title":"HtpTtail","text":"<pre><code>HtpTtail(aircraft)\n</code></pre> <p>               Bases: <code>Hstab</code></p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def __init__(self, aircraft):\n    super(HtpTtail, self).__init__(aircraft)\n\n    wing_area = aircraft.airframe.wing.area\n\n    self.area = 0.33*wing_area  # Design variable for hq_optim\n    self.span = None\n    self.aspect_ratio = aircraft.get_init(self,\"aspect_ratio\")\n    self.taper_ratio = aircraft.get_init(self,\"taper_ratio\")\n    self.height_ratio = aircraft.get_init(self,\"height_ratio\")\n    self.toc = aircraft.get_init(self,\"toc\")\n    self.sweep25 = aircraft.get_init(self,\"sweep25\", val=self.__sweep25())\n    self.dihedral = aircraft.get_init(self,\"dihedral\")\n    self.volume_factor = aircraft.get_init(self,\"volume_factor\")\n    self.lever_arm = None\n\n    self.axe_loc = np.full(3,None)     # Position of the central chord\n    self.axe_c = None                  # Length of the central chord\n\n    self.tip_loc = np.full(3,None)      # Position of tip chord leading edge\n    self.tip_c = None                   # tip chord length\n\n    self.mac_loc = np.full(3,None)      # Position of MAC chord leading edge\n    self.mac = None\n\n    self.mass_correction_factor = aircraft.get_init(self,\"mass_correction_factor\")\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.HtpTtail-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.HtpTtail.eval_aero_data","title":"eval_aero_data","text":"<pre><code>eval_aero_data()\n</code></pre> <p>WARNING : output values are in Wing reference area</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def eval_aero_data(self):\n    \"\"\"WARNING : output values are in Wing reference area\n    \"\"\"\n    wing_area = self.aircraft.airframe.wing.area\n    cza_htp =  (np.pi*self.aspect_ratio)/(1+np.sqrt(1+(self.aspect_ratio/2)**2))*(self.area/wing_area)  # Helmbold formula\n    xlc_htp = self.mac_loc[0] + 0.25*self.mac   # Position of HTP center of lift\n    aoa_max_htp = unit.rad_deg(9.)              # Maximum angle of attack allowed for HTP\n    ki_htp = 1.2/(np.pi*self.aspect_ratio)      # HTP induced drag coefficient\n    return cza_htp, xlc_htp, aoa_max_htp, ki_htp\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.HtpTtail.eval_geometry","title":"eval_geometry","text":"<pre><code>eval_geometry()\n</code></pre> <p>Estimates the geometry of the component from the aircraft requirements and statistical design laws.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def eval_geometry(self):\n    body_height = self.aircraft.airframe.body.height\n    vtp_tip_loc = self.aircraft.airframe.vertical_stab.tip_loc\n    vtp_tip_c = self.aircraft.airframe.vertical_stab.tip_c\n    vtp_height = self.aircraft.airframe.vertical_stab.height\n    wing_mac_loc = self.aircraft.airframe.wing.mac_loc\n    wing_mac = self.aircraft.airframe.wing.mac\n\n    self.span = np.sqrt(self.aspect_ratio*self.area)\n    y_axe = 0.\n    y_tip = 0.5*self.span\n\n    z_axe = (1.-self.height_ratio)*body_height + self.height_ratio*(body_height+vtp_height)\n    z_tip = z_axe + y_tip*np.tan(self.dihedral)\n\n    self.axe_c = 2.*self.area/(self.span*(1+self.taper_ratio))\n    self.tip_c = self.taper_ratio*self.axe_c\n\n    self.mac = self.span*(self.axe_c**2+self.tip_c**2+self.axe_c*self.tip_c)/(3.*self.area)\n    y_mac = y_tip**2*(2*self.tip_c+self.axe_c)/(3*self.area)\n    z_mac = z_tip**2*(2*self.tip_c+self.axe_c)/(3*self.area)\n    x_tip_local = 0.25*(self.axe_c-self.tip_c) + y_tip*np.tan(self.sweep25)\n    x_mac_local = y_tip*x_tip_local*(self.tip_c*2.+self.axe_c)/(3.*self.area)\n\n    x_axe = vtp_tip_loc[0] + 0.30*vtp_tip_c - 0.80*self.tip_c\n\n    x_tip = x_axe + x_tip_local\n    x_mac = x_axe + x_mac_local\n\n    self.lever_arm = (x_mac + 0.25*self.mac) - (wing_mac_loc[0] + 0.25*wing_mac)\n\n    self.axe_loc = np.array([x_axe, y_axe, z_axe])\n    self.tip_loc = np.array([x_tip, y_tip, z_tip])\n    self.mac_loc = np.array([x_mac, y_mac, z_mac])\n\n    self.frame_origin = self.axe_loc\n\n    self.gross_wet_area = 2.01*self.area\n    self.net_wet_area = self.gross_wet_area\n\n    self.aero_length = self.mac\n    self.form_factor = 1.40\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.HtpTtail.eval_mass","title":"eval_mass","text":"<pre><code>eval_mass()\n</code></pre> <p>Estimates the geometry of the component from the aircraft requirements and statistical design laws.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def eval_mass(self):\n    self.mass = self.mass_correction_factor * 22. * self.area\n    self.cg = self.mac_loc + 0.20*np.array([self.mac, 0., 0.])\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.HtpTtail.get_aero_length","title":"get_aero_length","text":"<pre><code>get_aero_length()\n</code></pre> <p>The characteristic aerodynamic length of the component (used for Reynolds number estimations for example).</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_aero_length(self):\n    \"\"\"The characteristic aerodynamic length of the component (used for Reynolds number estimations for example).\"\"\"\n    return self.aero_length\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.HtpTtail.get_cg_mwe","title":"get_cg_mwe","text":"<pre><code>get_cg_mwe()\n</code></pre> <p>Returns the position of the center of gravity of the manufacturer empty aircraft</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_cg_mwe(self):\n    \"\"\"Returns the position of the center of gravity of the manufacturer empty aircraft\"\"\"\n    return self.cg\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.HtpTtail.get_cg_owe","title":"get_cg_owe","text":"<pre><code>get_cg_owe()\n</code></pre> <p>Returns the position of the center of gravity of the operational empty aircraft</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_cg_owe(self):\n    \"\"\"Returns the position of the center of gravity of the operational empty aircraft\"\"\"\n    return self.cg\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.HtpTtail.get_form_factor","title":"get_form_factor","text":"<pre><code>get_form_factor()\n</code></pre> <p>Form factor used to estimate form drag.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_form_factor(self):\n    \"\"\"Form factor used to estimate form drag.\"\"\"\n    return self.form_factor\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.HtpTtail.get_inertia_tensor","title":"get_inertia_tensor","text":"<pre><code>get_inertia_tensor()\n</code></pre> <p>returns the inertia matrix of the component, if implemented.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_inertia_tensor(self):\n    \"\"\"returns the inertia matrix of the component, if implemented.\"\"\"\n    return self.inertia_tensor\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.HtpTtail.get_mass_mwe","title":"get_mass_mwe","text":"<pre><code>get_mass_mwe()\n</code></pre> <p>Returns the Manufacturer's Weight Empty, the mass (kg) of the component</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_mass_mwe(self):\n    \"\"\"Returns the *Manufacturer's Weight Empty*, the mass (kg) of the component\"\"\"\n    return self.mass\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.HtpTtail.get_mass_owe","title":"get_mass_owe","text":"<pre><code>get_mass_owe()\n</code></pre> <p>Returns the Operating Weight Empty, the mass (kg) of the component. Can differ from MWE for some components</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_mass_owe(self):\n    \"\"\"Returns the *Operating Weight Empty*, the mass (kg) of the component. Can differ from MWE for some components\"\"\"\n    return self.mass\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.HtpTtail.get_net_wet_area","title":"get_net_wet_area","text":"<pre><code>get_net_wet_area()\n</code></pre> <p>The net wet area of the component in contact with outer airflow, 0 if the component has no aerodynamic surface.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_net_wet_area(self):\n    \"\"\"The net wet area of the component in contact with outer airflow, 0 if the component has no aerodynamic surface.\"\"\"\n    return self.net_wet_area\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.HtpTtail.get_this_shape","title":"get_this_shape","text":"<pre><code>get_this_shape(name)\n</code></pre> <p>Contour curves for 3 view drawing nose1 : modern nose (A220, A350, 787) nose3 : classical Airbus nose nose2 : symetrical nose cone1 : classical tail cone cone2 : symetrical cone section : circle</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_this_shape(self, name): # TODO: is the docstring up to date ?\n    \"\"\"Contour curves for 3 view drawing\n    nose1 : modern nose (A220, A350, 787)\n    nose3 : classical Airbus nose\n    nose2 : symetrical nose\n    cone1 : classical tail cone\n    cone2 : symetrical cone\n    section : circle\n    \"\"\"\n    curve = {\n    \"nose1\":np.array([[ 0.0000 , 0.3339 , 0.3339 , 0.0000 ,  0.0000 ] ,\n                      [ 0.0050 , 0.3848 , 0.3084 , 0.0335 , -0.0335 ] ,\n                      [ 0.0150 , 0.4253 , 0.2881 , 0.0652 , -0.0652 ] ,\n                      [ 0.0500 , 0.5033 , 0.2490 , 0.1101 , -0.1101 ] ,\n                      [ 0.1000 , 0.5811 , 0.2100 , 0.1585 , -0.1585 ] ,\n                      [ 0.1800 , 0.6808 , 0.1600 , 0.2215 , -0.2215 ] ,\n                      [ 0.2773 , 0.7704 , 0.1151 , 0.2859 , -0.2859 ] ,\n                      [ 0.4191 , 0.8562 , 0.0721 , 0.3624 , -0.3624 ] ,\n                      [ 0.5610 , 0.9198 , 0.0402 , 0.4211 , -0.4211 ] ,\n                      [ 0.7738 , 0.9816 , 0.0092 , 0.4761 , -0.4761 ] ,\n                      [ 0.9156 , 0.9962 , 0.0019 , 0.4976 , -0.4976 ] ,\n                      [ 1.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ]]),\n\n    \"nose2\":np.array([[ 0.0000 , 0.5000 ,  0.5000 , 0.0000 ,  0.0000 ] ,\n                      [ 0.0050 , 0.5335 ,  0.4665 , 0.0335 , -0.0335 ] ,\n                      [ 0.0191 , 0.5646 ,  0.4354 , 0.0646 , -0.0646 ] ,\n                      [ 0.0624 , 0.6196 ,  0.3804 , 0.1196 , -0.1196 ] ,\n                      [ 0.1355 , 0.6878 ,  0.3122 , 0.1878 , -0.1878 ] ,\n                      [ 0.1922 , 0.7297 ,  0.2703 , 0.2297 , -0.2297 ] ,\n                      [ 0.2773 , 0.7859 ,  0.2141 , 0.2859 , -0.2859 ] ,\n                      [ 0.4191 , 0.8624 ,  0.1376 , 0.3624 , -0.3624 ] ,\n                      [ 0.5610 , 0.9211 ,  0.0789 , 0.4211 , -0.4211 ] ,\n                      [ 0.7738 , 0.9761 ,  0.0239 , 0.4761 , -0.4761 ] ,\n                      [ 0.9156 , 0.9976 ,  0.0024 , 0.4976 , -0.4976 ] ,\n                      [ 1.0000 , 1.0000 ,  0.0000 , 0.5000 , -0.5000 ]]),\n\n    \"nose3\":np.array([[ 0.0000 , 0.4453 , 0.4453 , 0.0000 ,  0.0000 ] ,\n                      [ 0.0050 , 0.4733 , 0.4112 , 0.0335 , -0.0335 ] ,\n                      [ 0.0191 , 0.5098 , 0.3833 , 0.0646 , -0.0646 ] ,\n                      [ 0.0624 , 0.5718 , 0.3188 , 0.1196 , -0.1196 ] ,\n                      [ 0.1355 , 0.6278 , 0.2531 , 0.1878 , -0.1878 ] ,\n                      [ 0.1922 , 0.7263 , 0.2142 , 0.2297 , -0.2297 ] ,\n                      [ 0.2773 , 0.8127 , 0.1631 , 0.2859 , -0.2859 ] ,\n                      [ 0.4191 , 0.8906 , 0.0962 , 0.3624 , -0.3624 ] ,\n                      [ 0.5610 , 0.9392 , 0.0536 , 0.4211 , -0.4211 ] ,\n                      [ 0.7738 , 0.9818 , 0.0122 , 0.4761 , -0.4761 ] ,\n                      [ 0.9156 , 0.9976 , 0.0025 , 0.4976 , -0.4976 ] ,\n                      [ 1.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ]]),\n\n    \"nose4\":np.array([[ 0.0000, 0.3700, 0.3700, 0.0000,  0.0000 ] ,\n                      [ 0.0050, 0.4200, 0.3200, 0.0335, -0.0335 ] ,\n                      [ 0.0150, 0.4500, 0.2900, 0.0652, -0.0652 ] ,\n                      [ 0.0500, 0.5000, 0.2400, 0.1200, -0.1200 ] ,\n                      [ 0.1000, 0.5500, 0.1900, 0.1750, -0.1750 ] ,\n                      [ 0.1800, 0.6000, 0.1400, 0.2400, -0.2400 ] ,\n                      [ 0.2773, 0.6450, 0.1000, 0.3000, -0.3000 ] ,\n                      [ 0.4191, 0.7000, 0.0500, 0.3700, -0.3700 ] ,\n                      [ 0.5610, 0.7550, 0.0250, 0.4300, -0.4300 ] ,\n                      [ 0.6200, 0.7800, 0.0180, 0.4500, -0.4500 ] ,\n                      [ 0.7700, 0.9700, 0.0090, 0.4850, -0.4850 ] ,\n                      [ 0.8100, 0.9900, 0.0060, 0.4900, -0.4900 ] ,\n                      [ 0.9100, 0.9970, 0.0030, 0.4976, -0.4976 ] ,\n                      [ 1.0000, 1.0000, 0.0000, 0.5000, -0.5000 ]]),\n\n    \"cone1\":np.array([[ 0.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ] ,\n                      [ 0.0213 , 1.0000 , 0.0082 , 0.5000 , -0.5000 ] ,\n                      [ 0.0638 , 1.0000 , 0.0230 , 0.4956 , -0.4956 ] ,\n                      [ 0.1064 , 1.0000 , 0.0393 , 0.4875 , -0.4875 ] ,\n                      [ 0.1489 , 1.0000 , 0.0556 , 0.4794 , -0.4794 ] ,\n                      [ 0.1915 , 1.0000 , 0.0786 , 0.4720 , -0.4720 ] ,\n                      [ 0.2766 , 1.0000 , 0.1334 , 0.4566 , -0.4566 ] ,\n                      [ 0.3617 , 1.0000 , 0.1964 , 0.4330 , -0.4330 ] ,\n                      [ 0.4894 , 1.0000 , 0.3024 , 0.3822 , -0.3822 ] ,\n                      [ 0.6170 , 1.0000 , 0.4159 , 0.3240 , -0.3240 ] ,\n                      [ 0.7447 , 1.0000 , 0.5374 , 0.2577 , -0.2577 ] ,\n                      [ 0.8723 , 1.0000 , 0.6627 , 0.1834 , -0.1834 ] ,\n                      [ 0.8936 , 0.9963 , 0.6901 , 0.1679 , -0.1679 ] ,\n                      [ 0.9149 , 0.9881 , 0.7139 , 0.1524 , -0.1524 ] ,\n                      [ 0.9362 , 0.9800 , 0.7413 , 0.1333 , -0.1333 ] ,\n                      [ 0.9574 , 0.9652 , 0.7687 , 0.1097 , -0.1097 ] ,\n                      [ 0.9787 , 0.9533 , 0.8043 , 0.0788 , -0.0788 ] ,\n                      [ 0.9894 , 0.9377 , 0.8280 , 0.0589 , -0.0589 ] ,\n                      [ 1.0000 , 0.9103 , 0.8784 , 0.0162 , -0.0162 ]]),\n\n    \"cone2\":np.array([[ 0.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ] ,\n                      [ 0.0213 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ] ,\n                      [ 0.0638 , 0.9956 , 0.0044 , 0.4956 , -0.4956 ] ,\n                      [ 0.1064 , 0.9875 , 0.0125 , 0.4875 , -0.4875 ] ,\n                      [ 0.1489 , 0.9794 , 0.0206 , 0.4794 , -0.4794 ] ,\n                      [ 0.1915 , 0.9720 , 0.0280 , 0.4720 , -0.4720 ] ,\n                      [ 0.2766 , 0.9566 , 0.0434 , 0.4566 , -0.4566 ] ,\n                      [ 0.3617 , 0.9330 , 0.0670 , 0.4330 , -0.4330 ] ,\n                      [ 0.4894 , 0.8822 , 0.1178 , 0.3822 , -0.3822 ] ,\n                      [ 0.6170 , 0.8240 , 0.1760 , 0.3240 , -0.3240 ] ,\n                      [ 0.7447 , 0.7577 , 0.2423 , 0.2577 , -0.2577 ] ,\n                      [ 0.8723 , 0.6834 , 0.3166 , 0.1834 , -0.1834 ] ,\n                      [ 0.8936 , 0.6679 , 0.3321 , 0.1679 , -0.1679 ] ,\n                      [ 0.9149 , 0.6524 , 0.3476 , 0.1524 , -0.1524 ] ,\n                      [ 0.9362 , 0.6333 , 0.3667 , 0.1333 , -0.1333 ] ,\n                      [ 0.9574 , 0.6097 , 0.3903 , 0.1097 , -0.1097 ] ,\n                      [ 0.9787 , 0.5788 , 0.4212 , 0.0788 , -0.0788 ] ,\n                      [ 0.9894 , 0.5589 , 0.4411 , 0.0589 , -0.0589 ] ,\n                      [ 1.0000 , 0.5162 , 0.4838 , 0.0162 , -0.0162 ]]),\n\n    \"sec1\":np.array([[  0.5000000 , 0.0000000 ,  0.0000000 ] ,\n                     [  0.4903926 , 0.0975452 , -0.0975452 ] ,\n                     [  0.4619398 , 0.1913417 , -0.1913417 ] ,\n                     [  0.4157348 , 0.2777851 , -0.2777851 ] ,\n                     [  0.3535534 , 0.3535534 , -0.3535534 ] ,\n                     [  0.2777851 , 0.4157348 , -0.4157348 ] ,\n                     [  0.1913417 , 0.4619398 , -0.4619398 ] ,\n                     [  0.0975452 , 0.4903926 , -0.4903926 ] ,\n                     [  0.0000000 , 0.5000000 , -0.5000000 ] ,\n                     [- 0.0975452 , 0.4903926 , -0.4903926 ] ,\n                     [- 0.1913417 , 0.4619398 , -0.4619398 ] ,\n                     [- 0.2777851 , 0.4157348 , -0.4157348 ] ,\n                     [- 0.3535534 , 0.3535534 , -0.3535534 ] ,\n                     [- 0.4157348 , 0.2777851 , -0.2777851 ] ,\n                     [- 0.4619398 , 0.1913417 , -0.1913417 ] ,\n                     [- 0.4903926 , 0.0975452 , -0.0975452 ] ,\n                     [- 0.5000000 , 0.0000000 ,  0.0000000 ]]),\n\n    \"sec2\":np.array([[ 0.5000000 , 0.0000000 ,  0.0000000] ,\n                     [ 0.4951963 , 0.0975452 , -0.0975452] ,\n                     [ 0.4809699 , 0.1913417 , -0.1913417] ,\n                     [ 0.4578674 , 0.2777851 , -0.2777851] ,\n                     [ 0.4267767 , 0.3535534 , -0.3535534] ,\n                     [ 0.3888926 , 0.4157348 , -0.4157348] ,\n                     [ 0.3456709 , 0.4619398 , -0.4619398] ,\n                     [ 0.2987726 , 0.4903926 , -0.4903926] ,\n                     [ 0.2500000 , 0.5000000 , -0.5000000] ,\n                     [ 0.0000000 , 0.5000000 , -0.5000000] ,\n                     [-0.2500000 , 0.5000000 , -0.5000000] ,\n                     [-0.2987726 , 0.4903926 , -0.4903926] ,\n                     [-0.3456709 , 0.4619398 , -0.4619398] ,\n                     [-0.3888926 , 0.4157348 , -0.4157348] ,\n                     [-0.4267767 , 0.3535534 , -0.3535534] ,\n                     [-0.4578674 , 0.2777851 , -0.2777851] ,\n                     [-0.4809699 , 0.1913417 , -0.1913417] ,\n                     [-0.4951963 , 0.0975452 , -0.0975452] ,\n                     [-0.5000000 , 0.0000000 ,  0.0000000]])}\n\n    return [curve[n] for n in name]\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.RetractableLandingGear","title":"RetractableLandingGear","text":"<pre><code>RetractableLandingGear(aircraft)\n</code></pre> <p>               Bases: <code>Component</code></p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def __init__(self, aircraft):\n    super(RetractableLandingGear, self).__init__(aircraft)\n\n    self.mass_correction_factor = aircraft.get_init(self,\"mass_correction_factor\")\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.RetractableLandingGear-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.RetractableLandingGear.eval_geometry","title":"eval_geometry","text":"<pre><code>eval_geometry()\n</code></pre> <p>Estimates the geometry of the component from the aircraft requirements and statistical design laws.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def eval_geometry(self):\n    wing_root_c = self.aircraft.airframe.wing.root_c\n    wing_root_loc = self.aircraft.airframe.wing.root_loc\n\n    self.frame_origin = wing_root_loc[0] + 0.85*wing_root_c\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.RetractableLandingGear.eval_mass","title":"eval_mass","text":"<pre><code>eval_mass()\n</code></pre> <p>Estimates the geometry of the component from the aircraft requirements and statistical design laws.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def eval_mass(self):\n    mtow = self.aircraft.weight_cg.mtow\n    mlw = self.aircraft.weight_cg.mlw\n\n    self.mass = (0.015*mtow**1.03 + 0.012*mlw) * self.mass_correction_factor    # Landing gears\n    self.cg = self.frame_origin\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.RetractableLandingGear.get_aero_length","title":"get_aero_length","text":"<pre><code>get_aero_length()\n</code></pre> <p>The characteristic aerodynamic length of the component (used for Reynolds number estimations for example).</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_aero_length(self):\n    \"\"\"The characteristic aerodynamic length of the component (used for Reynolds number estimations for example).\"\"\"\n    return self.aero_length\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.RetractableLandingGear.get_cg_mwe","title":"get_cg_mwe","text":"<pre><code>get_cg_mwe()\n</code></pre> <p>Returns the position of the center of gravity of the manufacturer empty aircraft</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_cg_mwe(self):\n    \"\"\"Returns the position of the center of gravity of the manufacturer empty aircraft\"\"\"\n    return self.cg\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.RetractableLandingGear.get_cg_owe","title":"get_cg_owe","text":"<pre><code>get_cg_owe()\n</code></pre> <p>Returns the position of the center of gravity of the operational empty aircraft</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_cg_owe(self):\n    \"\"\"Returns the position of the center of gravity of the operational empty aircraft\"\"\"\n    return self.cg\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.RetractableLandingGear.get_form_factor","title":"get_form_factor","text":"<pre><code>get_form_factor()\n</code></pre> <p>Form factor used to estimate form drag.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_form_factor(self):\n    \"\"\"Form factor used to estimate form drag.\"\"\"\n    return self.form_factor\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.RetractableLandingGear.get_inertia_tensor","title":"get_inertia_tensor","text":"<pre><code>get_inertia_tensor()\n</code></pre> <p>returns the inertia matrix of the component, if implemented.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_inertia_tensor(self):\n    \"\"\"returns the inertia matrix of the component, if implemented.\"\"\"\n    return self.inertia_tensor\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.RetractableLandingGear.get_mass_mwe","title":"get_mass_mwe","text":"<pre><code>get_mass_mwe()\n</code></pre> <p>Returns the Manufacturer's Weight Empty, the mass (kg) of the component</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_mass_mwe(self):\n    \"\"\"Returns the *Manufacturer's Weight Empty*, the mass (kg) of the component\"\"\"\n    return self.mass\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.RetractableLandingGear.get_mass_owe","title":"get_mass_owe","text":"<pre><code>get_mass_owe()\n</code></pre> <p>Returns the Operating Weight Empty, the mass (kg) of the component. Can differ from MWE for some components</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_mass_owe(self):\n    \"\"\"Returns the *Operating Weight Empty*, the mass (kg) of the component. Can differ from MWE for some components\"\"\"\n    return self.mass\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.RetractableLandingGear.get_net_wet_area","title":"get_net_wet_area","text":"<pre><code>get_net_wet_area()\n</code></pre> <p>The net wet area of the component in contact with outer airflow, 0 if the component has no aerodynamic surface.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_net_wet_area(self):\n    \"\"\"The net wet area of the component in contact with outer airflow, 0 if the component has no aerodynamic surface.\"\"\"\n    return self.net_wet_area\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.RetractableLandingGear.get_this_shape","title":"get_this_shape","text":"<pre><code>get_this_shape(name)\n</code></pre> <p>Contour curves for 3 view drawing nose1 : modern nose (A220, A350, 787) nose3 : classical Airbus nose nose2 : symetrical nose cone1 : classical tail cone cone2 : symetrical cone section : circle</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_this_shape(self, name): # TODO: is the docstring up to date ?\n    \"\"\"Contour curves for 3 view drawing\n    nose1 : modern nose (A220, A350, 787)\n    nose3 : classical Airbus nose\n    nose2 : symetrical nose\n    cone1 : classical tail cone\n    cone2 : symetrical cone\n    section : circle\n    \"\"\"\n    curve = {\n    \"nose1\":np.array([[ 0.0000 , 0.3339 , 0.3339 , 0.0000 ,  0.0000 ] ,\n                      [ 0.0050 , 0.3848 , 0.3084 , 0.0335 , -0.0335 ] ,\n                      [ 0.0150 , 0.4253 , 0.2881 , 0.0652 , -0.0652 ] ,\n                      [ 0.0500 , 0.5033 , 0.2490 , 0.1101 , -0.1101 ] ,\n                      [ 0.1000 , 0.5811 , 0.2100 , 0.1585 , -0.1585 ] ,\n                      [ 0.1800 , 0.6808 , 0.1600 , 0.2215 , -0.2215 ] ,\n                      [ 0.2773 , 0.7704 , 0.1151 , 0.2859 , -0.2859 ] ,\n                      [ 0.4191 , 0.8562 , 0.0721 , 0.3624 , -0.3624 ] ,\n                      [ 0.5610 , 0.9198 , 0.0402 , 0.4211 , -0.4211 ] ,\n                      [ 0.7738 , 0.9816 , 0.0092 , 0.4761 , -0.4761 ] ,\n                      [ 0.9156 , 0.9962 , 0.0019 , 0.4976 , -0.4976 ] ,\n                      [ 1.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ]]),\n\n    \"nose2\":np.array([[ 0.0000 , 0.5000 ,  0.5000 , 0.0000 ,  0.0000 ] ,\n                      [ 0.0050 , 0.5335 ,  0.4665 , 0.0335 , -0.0335 ] ,\n                      [ 0.0191 , 0.5646 ,  0.4354 , 0.0646 , -0.0646 ] ,\n                      [ 0.0624 , 0.6196 ,  0.3804 , 0.1196 , -0.1196 ] ,\n                      [ 0.1355 , 0.6878 ,  0.3122 , 0.1878 , -0.1878 ] ,\n                      [ 0.1922 , 0.7297 ,  0.2703 , 0.2297 , -0.2297 ] ,\n                      [ 0.2773 , 0.7859 ,  0.2141 , 0.2859 , -0.2859 ] ,\n                      [ 0.4191 , 0.8624 ,  0.1376 , 0.3624 , -0.3624 ] ,\n                      [ 0.5610 , 0.9211 ,  0.0789 , 0.4211 , -0.4211 ] ,\n                      [ 0.7738 , 0.9761 ,  0.0239 , 0.4761 , -0.4761 ] ,\n                      [ 0.9156 , 0.9976 ,  0.0024 , 0.4976 , -0.4976 ] ,\n                      [ 1.0000 , 1.0000 ,  0.0000 , 0.5000 , -0.5000 ]]),\n\n    \"nose3\":np.array([[ 0.0000 , 0.4453 , 0.4453 , 0.0000 ,  0.0000 ] ,\n                      [ 0.0050 , 0.4733 , 0.4112 , 0.0335 , -0.0335 ] ,\n                      [ 0.0191 , 0.5098 , 0.3833 , 0.0646 , -0.0646 ] ,\n                      [ 0.0624 , 0.5718 , 0.3188 , 0.1196 , -0.1196 ] ,\n                      [ 0.1355 , 0.6278 , 0.2531 , 0.1878 , -0.1878 ] ,\n                      [ 0.1922 , 0.7263 , 0.2142 , 0.2297 , -0.2297 ] ,\n                      [ 0.2773 , 0.8127 , 0.1631 , 0.2859 , -0.2859 ] ,\n                      [ 0.4191 , 0.8906 , 0.0962 , 0.3624 , -0.3624 ] ,\n                      [ 0.5610 , 0.9392 , 0.0536 , 0.4211 , -0.4211 ] ,\n                      [ 0.7738 , 0.9818 , 0.0122 , 0.4761 , -0.4761 ] ,\n                      [ 0.9156 , 0.9976 , 0.0025 , 0.4976 , -0.4976 ] ,\n                      [ 1.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ]]),\n\n    \"nose4\":np.array([[ 0.0000, 0.3700, 0.3700, 0.0000,  0.0000 ] ,\n                      [ 0.0050, 0.4200, 0.3200, 0.0335, -0.0335 ] ,\n                      [ 0.0150, 0.4500, 0.2900, 0.0652, -0.0652 ] ,\n                      [ 0.0500, 0.5000, 0.2400, 0.1200, -0.1200 ] ,\n                      [ 0.1000, 0.5500, 0.1900, 0.1750, -0.1750 ] ,\n                      [ 0.1800, 0.6000, 0.1400, 0.2400, -0.2400 ] ,\n                      [ 0.2773, 0.6450, 0.1000, 0.3000, -0.3000 ] ,\n                      [ 0.4191, 0.7000, 0.0500, 0.3700, -0.3700 ] ,\n                      [ 0.5610, 0.7550, 0.0250, 0.4300, -0.4300 ] ,\n                      [ 0.6200, 0.7800, 0.0180, 0.4500, -0.4500 ] ,\n                      [ 0.7700, 0.9700, 0.0090, 0.4850, -0.4850 ] ,\n                      [ 0.8100, 0.9900, 0.0060, 0.4900, -0.4900 ] ,\n                      [ 0.9100, 0.9970, 0.0030, 0.4976, -0.4976 ] ,\n                      [ 1.0000, 1.0000, 0.0000, 0.5000, -0.5000 ]]),\n\n    \"cone1\":np.array([[ 0.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ] ,\n                      [ 0.0213 , 1.0000 , 0.0082 , 0.5000 , -0.5000 ] ,\n                      [ 0.0638 , 1.0000 , 0.0230 , 0.4956 , -0.4956 ] ,\n                      [ 0.1064 , 1.0000 , 0.0393 , 0.4875 , -0.4875 ] ,\n                      [ 0.1489 , 1.0000 , 0.0556 , 0.4794 , -0.4794 ] ,\n                      [ 0.1915 , 1.0000 , 0.0786 , 0.4720 , -0.4720 ] ,\n                      [ 0.2766 , 1.0000 , 0.1334 , 0.4566 , -0.4566 ] ,\n                      [ 0.3617 , 1.0000 , 0.1964 , 0.4330 , -0.4330 ] ,\n                      [ 0.4894 , 1.0000 , 0.3024 , 0.3822 , -0.3822 ] ,\n                      [ 0.6170 , 1.0000 , 0.4159 , 0.3240 , -0.3240 ] ,\n                      [ 0.7447 , 1.0000 , 0.5374 , 0.2577 , -0.2577 ] ,\n                      [ 0.8723 , 1.0000 , 0.6627 , 0.1834 , -0.1834 ] ,\n                      [ 0.8936 , 0.9963 , 0.6901 , 0.1679 , -0.1679 ] ,\n                      [ 0.9149 , 0.9881 , 0.7139 , 0.1524 , -0.1524 ] ,\n                      [ 0.9362 , 0.9800 , 0.7413 , 0.1333 , -0.1333 ] ,\n                      [ 0.9574 , 0.9652 , 0.7687 , 0.1097 , -0.1097 ] ,\n                      [ 0.9787 , 0.9533 , 0.8043 , 0.0788 , -0.0788 ] ,\n                      [ 0.9894 , 0.9377 , 0.8280 , 0.0589 , -0.0589 ] ,\n                      [ 1.0000 , 0.9103 , 0.8784 , 0.0162 , -0.0162 ]]),\n\n    \"cone2\":np.array([[ 0.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ] ,\n                      [ 0.0213 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ] ,\n                      [ 0.0638 , 0.9956 , 0.0044 , 0.4956 , -0.4956 ] ,\n                      [ 0.1064 , 0.9875 , 0.0125 , 0.4875 , -0.4875 ] ,\n                      [ 0.1489 , 0.9794 , 0.0206 , 0.4794 , -0.4794 ] ,\n                      [ 0.1915 , 0.9720 , 0.0280 , 0.4720 , -0.4720 ] ,\n                      [ 0.2766 , 0.9566 , 0.0434 , 0.4566 , -0.4566 ] ,\n                      [ 0.3617 , 0.9330 , 0.0670 , 0.4330 , -0.4330 ] ,\n                      [ 0.4894 , 0.8822 , 0.1178 , 0.3822 , -0.3822 ] ,\n                      [ 0.6170 , 0.8240 , 0.1760 , 0.3240 , -0.3240 ] ,\n                      [ 0.7447 , 0.7577 , 0.2423 , 0.2577 , -0.2577 ] ,\n                      [ 0.8723 , 0.6834 , 0.3166 , 0.1834 , -0.1834 ] ,\n                      [ 0.8936 , 0.6679 , 0.3321 , 0.1679 , -0.1679 ] ,\n                      [ 0.9149 , 0.6524 , 0.3476 , 0.1524 , -0.1524 ] ,\n                      [ 0.9362 , 0.6333 , 0.3667 , 0.1333 , -0.1333 ] ,\n                      [ 0.9574 , 0.6097 , 0.3903 , 0.1097 , -0.1097 ] ,\n                      [ 0.9787 , 0.5788 , 0.4212 , 0.0788 , -0.0788 ] ,\n                      [ 0.9894 , 0.5589 , 0.4411 , 0.0589 , -0.0589 ] ,\n                      [ 1.0000 , 0.5162 , 0.4838 , 0.0162 , -0.0162 ]]),\n\n    \"sec1\":np.array([[  0.5000000 , 0.0000000 ,  0.0000000 ] ,\n                     [  0.4903926 , 0.0975452 , -0.0975452 ] ,\n                     [  0.4619398 , 0.1913417 , -0.1913417 ] ,\n                     [  0.4157348 , 0.2777851 , -0.2777851 ] ,\n                     [  0.3535534 , 0.3535534 , -0.3535534 ] ,\n                     [  0.2777851 , 0.4157348 , -0.4157348 ] ,\n                     [  0.1913417 , 0.4619398 , -0.4619398 ] ,\n                     [  0.0975452 , 0.4903926 , -0.4903926 ] ,\n                     [  0.0000000 , 0.5000000 , -0.5000000 ] ,\n                     [- 0.0975452 , 0.4903926 , -0.4903926 ] ,\n                     [- 0.1913417 , 0.4619398 , -0.4619398 ] ,\n                     [- 0.2777851 , 0.4157348 , -0.4157348 ] ,\n                     [- 0.3535534 , 0.3535534 , -0.3535534 ] ,\n                     [- 0.4157348 , 0.2777851 , -0.2777851 ] ,\n                     [- 0.4619398 , 0.1913417 , -0.1913417 ] ,\n                     [- 0.4903926 , 0.0975452 , -0.0975452 ] ,\n                     [- 0.5000000 , 0.0000000 ,  0.0000000 ]]),\n\n    \"sec2\":np.array([[ 0.5000000 , 0.0000000 ,  0.0000000] ,\n                     [ 0.4951963 , 0.0975452 , -0.0975452] ,\n                     [ 0.4809699 , 0.1913417 , -0.1913417] ,\n                     [ 0.4578674 , 0.2777851 , -0.2777851] ,\n                     [ 0.4267767 , 0.3535534 , -0.3535534] ,\n                     [ 0.3888926 , 0.4157348 , -0.4157348] ,\n                     [ 0.3456709 , 0.4619398 , -0.4619398] ,\n                     [ 0.2987726 , 0.4903926 , -0.4903926] ,\n                     [ 0.2500000 , 0.5000000 , -0.5000000] ,\n                     [ 0.0000000 , 0.5000000 , -0.5000000] ,\n                     [-0.2500000 , 0.5000000 , -0.5000000] ,\n                     [-0.2987726 , 0.4903926 , -0.4903926] ,\n                     [-0.3456709 , 0.4619398 , -0.4619398] ,\n                     [-0.3888926 , 0.4157348 , -0.4157348] ,\n                     [-0.4267767 , 0.3535534 , -0.3535534] ,\n                     [-0.4578674 , 0.2777851 , -0.2777851] ,\n                     [-0.4809699 , 0.1913417 , -0.1913417] ,\n                     [-0.4951963 , 0.0975452 , -0.0975452] ,\n                     [-0.5000000 , 0.0000000 ,  0.0000000]])}\n\n    return [curve[n] for n in name]\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.TankFuselageFloor","title":"TankFuselageFloor","text":"<pre><code>TankFuselageFloor(aircraft)\n</code></pre> <p>               Bases: <code>Tank</code></p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def __init__(self, aircraft):\n    super(TankFuselageFloor, self).__init__(aircraft)\n\n    self.gravimetric_index = aircraft.get_init(self,\"gravimetric_index\")\n    self.volumetric_index = aircraft.get_init(self,\"volumetric_index\")\n\n    self.length = None\n    self.width = None\n    self.height = None\n\n    self.fuel_pressure = aircraft.get_init(self,\"fuel_pressure\", val=self.fuel_over_pressure(aircraft))\n    self.fuel_density = None\n\n    self.gross_volume = None\n    self.shell_specific_volume = None\n    self.shell_specific_mass = None\n\n    self.max_volume = None\n    self.mfw_volume_limited = None\n\n    self.fuel_max_fwd_cg = np.full(3,None)\n    self.fuel_max_fwd_mass = None\n\n    self.fuel_max_bwd_cg = np.full(3,None)\n    self.fuel_max_bwd_mass = None\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.TankFuselageFloor-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.TankFuselageFloor.eval_geometry","title":"eval_geometry","text":"<pre><code>eval_geometry()\n</code></pre> <p>Estimates the geometry of the component from the aircraft requirements and statistical design laws.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def eval_geometry(self):\n    body_loc = self.aircraft.airframe.body.frame_origin\n    body_width = self.aircraft.airframe.body.width\n    body_height = self.aircraft.airframe.body.height\n    body_length = self.aircraft.airframe.body.length\n    forward_ratio = self.aircraft.airframe.body.forward_ratio\n    body_wall_thickness = self.aircraft.airframe.body.wall_thickness\n\n    x_axe = body_loc[0] + forward_ratio*body_width\n    y_axe = 0.\n    z_axe = body_loc[2] + 0.05*body_height\n\n    self.frame_origin = [x_axe, y_axe, z_axe]\n\n    self.length = 0.20 * body_length\n    self.width = body_width - 2.*body_wall_thickness\n    self.height = 0.10 * body_height\n\n    self.gross_volume = 0.85 * (self.height * self.width * self.length)\n\n    if self.aircraft.arrangement.fuel_type in [\"liquid_h2\",\"compressed_h2\"]:\n        # Volume of the tank structure\n        self.shell_specific_volume = self.gross_volume*(1.-self.volumetric_index) * self.mfw_factor      # mfw_factorr controls tank height\n        # Volume of the fuel\n        self.max_volume = self.gross_volume * self.volumetric_index * self.mfw_factor      # mfw_factorr controls tank height\n\n    else:\n        self.shell_specific_volume = 0.\n        self.max_volume = self.gross_volume * self.mfw_factor      # mfw_factorr controls tank height\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.TankFuselageFloor.eval_mass","title":"eval_mass","text":"<pre><code>eval_mass()\n</code></pre> <p>Estimates the geometry of the component from the aircraft requirements and statistical design laws.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def eval_mass(self):\n    fuel_type = self.aircraft.arrangement.fuel_type\n    body_width = self.aircraft.airframe.body.width\n    body_tail_cone_ratio = self.aircraft.airframe.body.tail_cone_ratio\n    body_rear_bulkhead_ratio = self.aircraft.airframe.body.rear_bulkhead_ratio\n\n    # REMARK : if fuel is \"Battery\", fuel density will be battery density\n    self.fuel_density = earth.fuel_density(fuel_type, self.fuel_pressure)\n    self.mfw_volume_limited = self.max_volume*self.fuel_density\n\n    # Tank equiped structural mass\n    if self.aircraft.arrangement.fuel_type in [\"liquid_h2\",\"compressed_h2\"]:\n        self.shell_specific_mass = self.gross_volume*(1./self.gravimetric_index-1.)*self.volumetric_index*self.fuel_density\n    else:\n        self.shell_specific_mass = 0.\n\n    self.mass = self.shell_specific_mass\n\n    self.cg = self.frame_origin[0] + 0.5 * self.length\n\n    self.fuel_max_fwd_cg = self.cg    # Fuel max Forward CG\n    self.fuel_max_fwd_mass = self.max_volume*self.fuel_density\n\n    self.fuel_max_bwd_cg = self.cg    # Fuel max Backward CG\n    self.fuel_max_bwd_mass = self.max_volume*self.fuel_density\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.TankFuselageFloor.get_aero_length","title":"get_aero_length","text":"<pre><code>get_aero_length()\n</code></pre> <p>The characteristic aerodynamic length of the component (used for Reynolds number estimations for example).</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_aero_length(self):\n    \"\"\"The characteristic aerodynamic length of the component (used for Reynolds number estimations for example).\"\"\"\n    return self.aero_length\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.TankFuselageFloor.get_cg_mwe","title":"get_cg_mwe","text":"<pre><code>get_cg_mwe()\n</code></pre> <p>Returns the position of the center of gravity of the manufacturer empty aircraft</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_cg_mwe(self):\n    \"\"\"Returns the position of the center of gravity of the manufacturer empty aircraft\"\"\"\n    return self.cg\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.TankFuselageFloor.get_cg_owe","title":"get_cg_owe","text":"<pre><code>get_cg_owe()\n</code></pre> <p>Returns the position of the center of gravity of the operational empty aircraft</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_cg_owe(self):\n    \"\"\"Returns the position of the center of gravity of the operational empty aircraft\"\"\"\n    return self.cg\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.TankFuselageFloor.get_form_factor","title":"get_form_factor","text":"<pre><code>get_form_factor()\n</code></pre> <p>Form factor used to estimate form drag.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_form_factor(self):\n    \"\"\"Form factor used to estimate form drag.\"\"\"\n    return self.form_factor\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.TankFuselageFloor.get_inertia_tensor","title":"get_inertia_tensor","text":"<pre><code>get_inertia_tensor()\n</code></pre> <p>returns the inertia matrix of the component, if implemented.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_inertia_tensor(self):\n    \"\"\"returns the inertia matrix of the component, if implemented.\"\"\"\n    return self.inertia_tensor\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.TankFuselageFloor.get_mass_mwe","title":"get_mass_mwe","text":"<pre><code>get_mass_mwe()\n</code></pre> <p>Returns the Manufacturer's Weight Empty, the mass (kg) of the component</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_mass_mwe(self):\n    \"\"\"Returns the *Manufacturer's Weight Empty*, the mass (kg) of the component\"\"\"\n    return self.mass\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.TankFuselageFloor.get_mass_owe","title":"get_mass_owe","text":"<pre><code>get_mass_owe()\n</code></pre> <p>Returns the Operating Weight Empty, the mass (kg) of the component. Can differ from MWE for some components</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_mass_owe(self):\n    \"\"\"Returns the *Operating Weight Empty*, the mass (kg) of the component. Can differ from MWE for some components\"\"\"\n    return self.mass\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.TankFuselageFloor.get_net_wet_area","title":"get_net_wet_area","text":"<pre><code>get_net_wet_area()\n</code></pre> <p>The net wet area of the component in contact with outer airflow, 0 if the component has no aerodynamic surface.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_net_wet_area(self):\n    \"\"\"The net wet area of the component in contact with outer airflow, 0 if the component has no aerodynamic surface.\"\"\"\n    return self.net_wet_area\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.TankFuselageFloor.get_this_shape","title":"get_this_shape","text":"<pre><code>get_this_shape(name)\n</code></pre> <p>Contour curves for 3 view drawing nose1 : modern nose (A220, A350, 787) nose3 : classical Airbus nose nose2 : symetrical nose cone1 : classical tail cone cone2 : symetrical cone section : circle</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_this_shape(self, name): # TODO: is the docstring up to date ?\n    \"\"\"Contour curves for 3 view drawing\n    nose1 : modern nose (A220, A350, 787)\n    nose3 : classical Airbus nose\n    nose2 : symetrical nose\n    cone1 : classical tail cone\n    cone2 : symetrical cone\n    section : circle\n    \"\"\"\n    curve = {\n    \"nose1\":np.array([[ 0.0000 , 0.3339 , 0.3339 , 0.0000 ,  0.0000 ] ,\n                      [ 0.0050 , 0.3848 , 0.3084 , 0.0335 , -0.0335 ] ,\n                      [ 0.0150 , 0.4253 , 0.2881 , 0.0652 , -0.0652 ] ,\n                      [ 0.0500 , 0.5033 , 0.2490 , 0.1101 , -0.1101 ] ,\n                      [ 0.1000 , 0.5811 , 0.2100 , 0.1585 , -0.1585 ] ,\n                      [ 0.1800 , 0.6808 , 0.1600 , 0.2215 , -0.2215 ] ,\n                      [ 0.2773 , 0.7704 , 0.1151 , 0.2859 , -0.2859 ] ,\n                      [ 0.4191 , 0.8562 , 0.0721 , 0.3624 , -0.3624 ] ,\n                      [ 0.5610 , 0.9198 , 0.0402 , 0.4211 , -0.4211 ] ,\n                      [ 0.7738 , 0.9816 , 0.0092 , 0.4761 , -0.4761 ] ,\n                      [ 0.9156 , 0.9962 , 0.0019 , 0.4976 , -0.4976 ] ,\n                      [ 1.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ]]),\n\n    \"nose2\":np.array([[ 0.0000 , 0.5000 ,  0.5000 , 0.0000 ,  0.0000 ] ,\n                      [ 0.0050 , 0.5335 ,  0.4665 , 0.0335 , -0.0335 ] ,\n                      [ 0.0191 , 0.5646 ,  0.4354 , 0.0646 , -0.0646 ] ,\n                      [ 0.0624 , 0.6196 ,  0.3804 , 0.1196 , -0.1196 ] ,\n                      [ 0.1355 , 0.6878 ,  0.3122 , 0.1878 , -0.1878 ] ,\n                      [ 0.1922 , 0.7297 ,  0.2703 , 0.2297 , -0.2297 ] ,\n                      [ 0.2773 , 0.7859 ,  0.2141 , 0.2859 , -0.2859 ] ,\n                      [ 0.4191 , 0.8624 ,  0.1376 , 0.3624 , -0.3624 ] ,\n                      [ 0.5610 , 0.9211 ,  0.0789 , 0.4211 , -0.4211 ] ,\n                      [ 0.7738 , 0.9761 ,  0.0239 , 0.4761 , -0.4761 ] ,\n                      [ 0.9156 , 0.9976 ,  0.0024 , 0.4976 , -0.4976 ] ,\n                      [ 1.0000 , 1.0000 ,  0.0000 , 0.5000 , -0.5000 ]]),\n\n    \"nose3\":np.array([[ 0.0000 , 0.4453 , 0.4453 , 0.0000 ,  0.0000 ] ,\n                      [ 0.0050 , 0.4733 , 0.4112 , 0.0335 , -0.0335 ] ,\n                      [ 0.0191 , 0.5098 , 0.3833 , 0.0646 , -0.0646 ] ,\n                      [ 0.0624 , 0.5718 , 0.3188 , 0.1196 , -0.1196 ] ,\n                      [ 0.1355 , 0.6278 , 0.2531 , 0.1878 , -0.1878 ] ,\n                      [ 0.1922 , 0.7263 , 0.2142 , 0.2297 , -0.2297 ] ,\n                      [ 0.2773 , 0.8127 , 0.1631 , 0.2859 , -0.2859 ] ,\n                      [ 0.4191 , 0.8906 , 0.0962 , 0.3624 , -0.3624 ] ,\n                      [ 0.5610 , 0.9392 , 0.0536 , 0.4211 , -0.4211 ] ,\n                      [ 0.7738 , 0.9818 , 0.0122 , 0.4761 , -0.4761 ] ,\n                      [ 0.9156 , 0.9976 , 0.0025 , 0.4976 , -0.4976 ] ,\n                      [ 1.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ]]),\n\n    \"nose4\":np.array([[ 0.0000, 0.3700, 0.3700, 0.0000,  0.0000 ] ,\n                      [ 0.0050, 0.4200, 0.3200, 0.0335, -0.0335 ] ,\n                      [ 0.0150, 0.4500, 0.2900, 0.0652, -0.0652 ] ,\n                      [ 0.0500, 0.5000, 0.2400, 0.1200, -0.1200 ] ,\n                      [ 0.1000, 0.5500, 0.1900, 0.1750, -0.1750 ] ,\n                      [ 0.1800, 0.6000, 0.1400, 0.2400, -0.2400 ] ,\n                      [ 0.2773, 0.6450, 0.1000, 0.3000, -0.3000 ] ,\n                      [ 0.4191, 0.7000, 0.0500, 0.3700, -0.3700 ] ,\n                      [ 0.5610, 0.7550, 0.0250, 0.4300, -0.4300 ] ,\n                      [ 0.6200, 0.7800, 0.0180, 0.4500, -0.4500 ] ,\n                      [ 0.7700, 0.9700, 0.0090, 0.4850, -0.4850 ] ,\n                      [ 0.8100, 0.9900, 0.0060, 0.4900, -0.4900 ] ,\n                      [ 0.9100, 0.9970, 0.0030, 0.4976, -0.4976 ] ,\n                      [ 1.0000, 1.0000, 0.0000, 0.5000, -0.5000 ]]),\n\n    \"cone1\":np.array([[ 0.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ] ,\n                      [ 0.0213 , 1.0000 , 0.0082 , 0.5000 , -0.5000 ] ,\n                      [ 0.0638 , 1.0000 , 0.0230 , 0.4956 , -0.4956 ] ,\n                      [ 0.1064 , 1.0000 , 0.0393 , 0.4875 , -0.4875 ] ,\n                      [ 0.1489 , 1.0000 , 0.0556 , 0.4794 , -0.4794 ] ,\n                      [ 0.1915 , 1.0000 , 0.0786 , 0.4720 , -0.4720 ] ,\n                      [ 0.2766 , 1.0000 , 0.1334 , 0.4566 , -0.4566 ] ,\n                      [ 0.3617 , 1.0000 , 0.1964 , 0.4330 , -0.4330 ] ,\n                      [ 0.4894 , 1.0000 , 0.3024 , 0.3822 , -0.3822 ] ,\n                      [ 0.6170 , 1.0000 , 0.4159 , 0.3240 , -0.3240 ] ,\n                      [ 0.7447 , 1.0000 , 0.5374 , 0.2577 , -0.2577 ] ,\n                      [ 0.8723 , 1.0000 , 0.6627 , 0.1834 , -0.1834 ] ,\n                      [ 0.8936 , 0.9963 , 0.6901 , 0.1679 , -0.1679 ] ,\n                      [ 0.9149 , 0.9881 , 0.7139 , 0.1524 , -0.1524 ] ,\n                      [ 0.9362 , 0.9800 , 0.7413 , 0.1333 , -0.1333 ] ,\n                      [ 0.9574 , 0.9652 , 0.7687 , 0.1097 , -0.1097 ] ,\n                      [ 0.9787 , 0.9533 , 0.8043 , 0.0788 , -0.0788 ] ,\n                      [ 0.9894 , 0.9377 , 0.8280 , 0.0589 , -0.0589 ] ,\n                      [ 1.0000 , 0.9103 , 0.8784 , 0.0162 , -0.0162 ]]),\n\n    \"cone2\":np.array([[ 0.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ] ,\n                      [ 0.0213 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ] ,\n                      [ 0.0638 , 0.9956 , 0.0044 , 0.4956 , -0.4956 ] ,\n                      [ 0.1064 , 0.9875 , 0.0125 , 0.4875 , -0.4875 ] ,\n                      [ 0.1489 , 0.9794 , 0.0206 , 0.4794 , -0.4794 ] ,\n                      [ 0.1915 , 0.9720 , 0.0280 , 0.4720 , -0.4720 ] ,\n                      [ 0.2766 , 0.9566 , 0.0434 , 0.4566 , -0.4566 ] ,\n                      [ 0.3617 , 0.9330 , 0.0670 , 0.4330 , -0.4330 ] ,\n                      [ 0.4894 , 0.8822 , 0.1178 , 0.3822 , -0.3822 ] ,\n                      [ 0.6170 , 0.8240 , 0.1760 , 0.3240 , -0.3240 ] ,\n                      [ 0.7447 , 0.7577 , 0.2423 , 0.2577 , -0.2577 ] ,\n                      [ 0.8723 , 0.6834 , 0.3166 , 0.1834 , -0.1834 ] ,\n                      [ 0.8936 , 0.6679 , 0.3321 , 0.1679 , -0.1679 ] ,\n                      [ 0.9149 , 0.6524 , 0.3476 , 0.1524 , -0.1524 ] ,\n                      [ 0.9362 , 0.6333 , 0.3667 , 0.1333 , -0.1333 ] ,\n                      [ 0.9574 , 0.6097 , 0.3903 , 0.1097 , -0.1097 ] ,\n                      [ 0.9787 , 0.5788 , 0.4212 , 0.0788 , -0.0788 ] ,\n                      [ 0.9894 , 0.5589 , 0.4411 , 0.0589 , -0.0589 ] ,\n                      [ 1.0000 , 0.5162 , 0.4838 , 0.0162 , -0.0162 ]]),\n\n    \"sec1\":np.array([[  0.5000000 , 0.0000000 ,  0.0000000 ] ,\n                     [  0.4903926 , 0.0975452 , -0.0975452 ] ,\n                     [  0.4619398 , 0.1913417 , -0.1913417 ] ,\n                     [  0.4157348 , 0.2777851 , -0.2777851 ] ,\n                     [  0.3535534 , 0.3535534 , -0.3535534 ] ,\n                     [  0.2777851 , 0.4157348 , -0.4157348 ] ,\n                     [  0.1913417 , 0.4619398 , -0.4619398 ] ,\n                     [  0.0975452 , 0.4903926 , -0.4903926 ] ,\n                     [  0.0000000 , 0.5000000 , -0.5000000 ] ,\n                     [- 0.0975452 , 0.4903926 , -0.4903926 ] ,\n                     [- 0.1913417 , 0.4619398 , -0.4619398 ] ,\n                     [- 0.2777851 , 0.4157348 , -0.4157348 ] ,\n                     [- 0.3535534 , 0.3535534 , -0.3535534 ] ,\n                     [- 0.4157348 , 0.2777851 , -0.2777851 ] ,\n                     [- 0.4619398 , 0.1913417 , -0.1913417 ] ,\n                     [- 0.4903926 , 0.0975452 , -0.0975452 ] ,\n                     [- 0.5000000 , 0.0000000 ,  0.0000000 ]]),\n\n    \"sec2\":np.array([[ 0.5000000 , 0.0000000 ,  0.0000000] ,\n                     [ 0.4951963 , 0.0975452 , -0.0975452] ,\n                     [ 0.4809699 , 0.1913417 , -0.1913417] ,\n                     [ 0.4578674 , 0.2777851 , -0.2777851] ,\n                     [ 0.4267767 , 0.3535534 , -0.3535534] ,\n                     [ 0.3888926 , 0.4157348 , -0.4157348] ,\n                     [ 0.3456709 , 0.4619398 , -0.4619398] ,\n                     [ 0.2987726 , 0.4903926 , -0.4903926] ,\n                     [ 0.2500000 , 0.5000000 , -0.5000000] ,\n                     [ 0.0000000 , 0.5000000 , -0.5000000] ,\n                     [-0.2500000 , 0.5000000 , -0.5000000] ,\n                     [-0.2987726 , 0.4903926 , -0.4903926] ,\n                     [-0.3456709 , 0.4619398 , -0.4619398] ,\n                     [-0.3888926 , 0.4157348 , -0.4157348] ,\n                     [-0.4267767 , 0.3535534 , -0.3535534] ,\n                     [-0.4578674 , 0.2777851 , -0.2777851] ,\n                     [-0.4809699 , 0.1913417 , -0.1913417] ,\n                     [-0.4951963 , 0.0975452 , -0.0975452] ,\n                     [-0.5000000 , 0.0000000 ,  0.0000000]])}\n\n    return [curve[n] for n in name]\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.TankPiggyBack","title":"TankPiggyBack","text":"<pre><code>TankPiggyBack(aircraft)\n</code></pre> <p>               Bases: <code>Pod</code></p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def __init__(self, aircraft):\n    super(TankPiggyBack, self).__init__(aircraft)\n\n    n_pax_ref = self.aircraft.requirement.n_pax_ref\n    n_pax_front = self.aircraft.airframe.cabin.n_pax_front\n    n_aisle = self.aircraft.airframe.cabin.n_aisle\n\n    self.fuel_pressure = aircraft.get_init(self,\"fuel_pressure\", val=self.fuel_over_pressure(aircraft))\n    self.fuel_density = None\n\n    # Estimations based on fuselage dimension estimation\n    length = 0.75*(7.8*(0.38*n_pax_front + 1.05*n_aisle + 0.55) + 0.005*(n_pax_ref/n_pax_front)**2.25)\n    width = 0.80*(0.38*n_pax_front + 1.05*n_aisle + 0.55)\n\n    self.dry_bay_length = aircraft.get_init(self,\"dry_bay_length\")\n    self.ref_length = aircraft.get_init(self,\"ref_length\", val=length)\n    self.length = None\n    self.width = aircraft.get_init(self,\"width\", val=width)\n    self.x_loc_ratio = aircraft.get_init(self,\"x_loc_ratio\")\n    self.z_loc_ratio = aircraft.get_init(self,\"z_loc_ratio\")\n    self.wing_axe_c = None\n    self.wing_axe_x = None\n    self.wing_axe_z = None\n\n    self.max_volume = None\n    self.mfw_volume_limited = None\n\n    self.fuel_max_fwd_cg = np.full(3,None)\n    self.fuel_max_fwd_mass = None\n\n    self.fuel_max_bwd_cg = np.full(3,None)\n    self.fuel_max_bwd_mass = None\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.TankPiggyBack-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.TankPiggyBack.eval_geometry","title":"eval_geometry","text":"<pre><code>eval_geometry()\n</code></pre> <p>Estimates the geometry of the component from the aircraft requirements and statistical design laws.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def eval_geometry(self):\n    body_width = self.aircraft.airframe.body.width\n    wing_mac_loc = self.aircraft.airframe.wing.mac_loc\n    wing_root_c = self.aircraft.airframe.wing.root_c\n    wing_root_loc = self.aircraft.airframe.wing.root_loc\n\n    self.length = self.ref_length * self.mfw_factor\n\n    x_axe = wing_mac_loc[0] - self.x_loc_ratio*self.length\n    y_axe = 0.\n    z_axe = 1.07*body_width + self.z_loc_ratio*self.width\n\n    self.frame_origin = [x_axe, y_axe, z_axe]\n\n    self.wing_axe_c = wing_root_c\n    self.wing_axe_x = wing_root_loc[0]\n    self.wing_axe_z = wing_root_loc[2]\n\n    self.gross_wet_area = 0.85*3.14*self.width*self.length\n    self.net_wet_area = self.gross_wet_area\n    self.aero_length = self.length\n    self.form_factor = 1.05\n\n    # Compute fuel volume\n    self.size_fuel_tank(\"external\")\n\n    self.max_volume = self.fuel_volume\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.TankPiggyBack.eval_mass","title":"eval_mass","text":"<pre><code>eval_mass()\n</code></pre> <p>Estimates the geometry of the component from the aircraft requirements and statistical design laws.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def eval_mass(self):\n    fuel_type = self.aircraft.arrangement.fuel_type\n\n    # REMARK : if fuel is \"Battery\", fuel density will be battery density\n    self.fuel_density = earth.fuel_density(fuel_type, self.fuel_pressure)\n    self.mfw_volume_limited = self.max_volume*self.fuel_density\n\n    self.mass_fuel_tank(\"external\")\n\n    self.mass = self.structure_shell_mass + self.shell_specific_mass\n    self.cg = self.frame_origin[0] + 0.45*np.array([self.length, 0., 0.])\n\n    self.fuel_max_fwd_cg = self.cg    # Fuel max Forward CG\n    self.fuel_max_fwd_mass = self.max_volume*self.fuel_density\n\n    self.fuel_max_bwd_cg = self.cg    # Fuel max Backward CG\n    self.fuel_max_bwd_mass = self.max_volume*self.fuel_density\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.TankPiggyBack.get_aero_length","title":"get_aero_length","text":"<pre><code>get_aero_length()\n</code></pre> <p>The characteristic aerodynamic length of the component (used for Reynolds number estimations for example).</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_aero_length(self):\n    \"\"\"The characteristic aerodynamic length of the component (used for Reynolds number estimations for example).\"\"\"\n    return self.aero_length\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.TankPiggyBack.get_cg_mwe","title":"get_cg_mwe","text":"<pre><code>get_cg_mwe()\n</code></pre> <p>Returns the position of the center of gravity of the manufacturer empty aircraft</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_cg_mwe(self):\n    \"\"\"Returns the position of the center of gravity of the manufacturer empty aircraft\"\"\"\n    return self.cg\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.TankPiggyBack.get_cg_owe","title":"get_cg_owe","text":"<pre><code>get_cg_owe()\n</code></pre> <p>Returns the position of the center of gravity of the operational empty aircraft</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_cg_owe(self):\n    \"\"\"Returns the position of the center of gravity of the operational empty aircraft\"\"\"\n    return self.cg\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.TankPiggyBack.get_form_factor","title":"get_form_factor","text":"<pre><code>get_form_factor()\n</code></pre> <p>Form factor used to estimate form drag.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_form_factor(self):\n    \"\"\"Form factor used to estimate form drag.\"\"\"\n    return self.form_factor\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.TankPiggyBack.get_inertia_tensor","title":"get_inertia_tensor","text":"<pre><code>get_inertia_tensor()\n</code></pre> <p>returns the inertia matrix of the component, if implemented.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_inertia_tensor(self):\n    \"\"\"returns the inertia matrix of the component, if implemented.\"\"\"\n    return self.inertia_tensor\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.TankPiggyBack.get_mass_mwe","title":"get_mass_mwe","text":"<pre><code>get_mass_mwe()\n</code></pre> <p>Returns the Manufacturer's Weight Empty, the mass (kg) of the component</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_mass_mwe(self):\n    \"\"\"Returns the *Manufacturer's Weight Empty*, the mass (kg) of the component\"\"\"\n    return self.mass\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.TankPiggyBack.get_mass_owe","title":"get_mass_owe","text":"<pre><code>get_mass_owe()\n</code></pre> <p>Returns the Operating Weight Empty, the mass (kg) of the component. Can differ from MWE for some components</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_mass_owe(self):\n    \"\"\"Returns the *Operating Weight Empty*, the mass (kg) of the component. Can differ from MWE for some components\"\"\"\n    return self.mass\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.TankPiggyBack.get_net_wet_area","title":"get_net_wet_area","text":"<pre><code>get_net_wet_area()\n</code></pre> <p>The net wet area of the component in contact with outer airflow, 0 if the component has no aerodynamic surface.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_net_wet_area(self):\n    \"\"\"The net wet area of the component in contact with outer airflow, 0 if the component has no aerodynamic surface.\"\"\"\n    return self.net_wet_area\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.TankPiggyBack.get_this_shape","title":"get_this_shape","text":"<pre><code>get_this_shape(name)\n</code></pre> <p>Contour curves for 3 view drawing nose1 : modern nose (A220, A350, 787) nose3 : classical Airbus nose nose2 : symetrical nose cone1 : classical tail cone cone2 : symetrical cone section : circle</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_this_shape(self, name): # TODO: is the docstring up to date ?\n    \"\"\"Contour curves for 3 view drawing\n    nose1 : modern nose (A220, A350, 787)\n    nose3 : classical Airbus nose\n    nose2 : symetrical nose\n    cone1 : classical tail cone\n    cone2 : symetrical cone\n    section : circle\n    \"\"\"\n    curve = {\n    \"nose1\":np.array([[ 0.0000 , 0.3339 , 0.3339 , 0.0000 ,  0.0000 ] ,\n                      [ 0.0050 , 0.3848 , 0.3084 , 0.0335 , -0.0335 ] ,\n                      [ 0.0150 , 0.4253 , 0.2881 , 0.0652 , -0.0652 ] ,\n                      [ 0.0500 , 0.5033 , 0.2490 , 0.1101 , -0.1101 ] ,\n                      [ 0.1000 , 0.5811 , 0.2100 , 0.1585 , -0.1585 ] ,\n                      [ 0.1800 , 0.6808 , 0.1600 , 0.2215 , -0.2215 ] ,\n                      [ 0.2773 , 0.7704 , 0.1151 , 0.2859 , -0.2859 ] ,\n                      [ 0.4191 , 0.8562 , 0.0721 , 0.3624 , -0.3624 ] ,\n                      [ 0.5610 , 0.9198 , 0.0402 , 0.4211 , -0.4211 ] ,\n                      [ 0.7738 , 0.9816 , 0.0092 , 0.4761 , -0.4761 ] ,\n                      [ 0.9156 , 0.9962 , 0.0019 , 0.4976 , -0.4976 ] ,\n                      [ 1.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ]]),\n\n    \"nose2\":np.array([[ 0.0000 , 0.5000 ,  0.5000 , 0.0000 ,  0.0000 ] ,\n                      [ 0.0050 , 0.5335 ,  0.4665 , 0.0335 , -0.0335 ] ,\n                      [ 0.0191 , 0.5646 ,  0.4354 , 0.0646 , -0.0646 ] ,\n                      [ 0.0624 , 0.6196 ,  0.3804 , 0.1196 , -0.1196 ] ,\n                      [ 0.1355 , 0.6878 ,  0.3122 , 0.1878 , -0.1878 ] ,\n                      [ 0.1922 , 0.7297 ,  0.2703 , 0.2297 , -0.2297 ] ,\n                      [ 0.2773 , 0.7859 ,  0.2141 , 0.2859 , -0.2859 ] ,\n                      [ 0.4191 , 0.8624 ,  0.1376 , 0.3624 , -0.3624 ] ,\n                      [ 0.5610 , 0.9211 ,  0.0789 , 0.4211 , -0.4211 ] ,\n                      [ 0.7738 , 0.9761 ,  0.0239 , 0.4761 , -0.4761 ] ,\n                      [ 0.9156 , 0.9976 ,  0.0024 , 0.4976 , -0.4976 ] ,\n                      [ 1.0000 , 1.0000 ,  0.0000 , 0.5000 , -0.5000 ]]),\n\n    \"nose3\":np.array([[ 0.0000 , 0.4453 , 0.4453 , 0.0000 ,  0.0000 ] ,\n                      [ 0.0050 , 0.4733 , 0.4112 , 0.0335 , -0.0335 ] ,\n                      [ 0.0191 , 0.5098 , 0.3833 , 0.0646 , -0.0646 ] ,\n                      [ 0.0624 , 0.5718 , 0.3188 , 0.1196 , -0.1196 ] ,\n                      [ 0.1355 , 0.6278 , 0.2531 , 0.1878 , -0.1878 ] ,\n                      [ 0.1922 , 0.7263 , 0.2142 , 0.2297 , -0.2297 ] ,\n                      [ 0.2773 , 0.8127 , 0.1631 , 0.2859 , -0.2859 ] ,\n                      [ 0.4191 , 0.8906 , 0.0962 , 0.3624 , -0.3624 ] ,\n                      [ 0.5610 , 0.9392 , 0.0536 , 0.4211 , -0.4211 ] ,\n                      [ 0.7738 , 0.9818 , 0.0122 , 0.4761 , -0.4761 ] ,\n                      [ 0.9156 , 0.9976 , 0.0025 , 0.4976 , -0.4976 ] ,\n                      [ 1.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ]]),\n\n    \"nose4\":np.array([[ 0.0000, 0.3700, 0.3700, 0.0000,  0.0000 ] ,\n                      [ 0.0050, 0.4200, 0.3200, 0.0335, -0.0335 ] ,\n                      [ 0.0150, 0.4500, 0.2900, 0.0652, -0.0652 ] ,\n                      [ 0.0500, 0.5000, 0.2400, 0.1200, -0.1200 ] ,\n                      [ 0.1000, 0.5500, 0.1900, 0.1750, -0.1750 ] ,\n                      [ 0.1800, 0.6000, 0.1400, 0.2400, -0.2400 ] ,\n                      [ 0.2773, 0.6450, 0.1000, 0.3000, -0.3000 ] ,\n                      [ 0.4191, 0.7000, 0.0500, 0.3700, -0.3700 ] ,\n                      [ 0.5610, 0.7550, 0.0250, 0.4300, -0.4300 ] ,\n                      [ 0.6200, 0.7800, 0.0180, 0.4500, -0.4500 ] ,\n                      [ 0.7700, 0.9700, 0.0090, 0.4850, -0.4850 ] ,\n                      [ 0.8100, 0.9900, 0.0060, 0.4900, -0.4900 ] ,\n                      [ 0.9100, 0.9970, 0.0030, 0.4976, -0.4976 ] ,\n                      [ 1.0000, 1.0000, 0.0000, 0.5000, -0.5000 ]]),\n\n    \"cone1\":np.array([[ 0.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ] ,\n                      [ 0.0213 , 1.0000 , 0.0082 , 0.5000 , -0.5000 ] ,\n                      [ 0.0638 , 1.0000 , 0.0230 , 0.4956 , -0.4956 ] ,\n                      [ 0.1064 , 1.0000 , 0.0393 , 0.4875 , -0.4875 ] ,\n                      [ 0.1489 , 1.0000 , 0.0556 , 0.4794 , -0.4794 ] ,\n                      [ 0.1915 , 1.0000 , 0.0786 , 0.4720 , -0.4720 ] ,\n                      [ 0.2766 , 1.0000 , 0.1334 , 0.4566 , -0.4566 ] ,\n                      [ 0.3617 , 1.0000 , 0.1964 , 0.4330 , -0.4330 ] ,\n                      [ 0.4894 , 1.0000 , 0.3024 , 0.3822 , -0.3822 ] ,\n                      [ 0.6170 , 1.0000 , 0.4159 , 0.3240 , -0.3240 ] ,\n                      [ 0.7447 , 1.0000 , 0.5374 , 0.2577 , -0.2577 ] ,\n                      [ 0.8723 , 1.0000 , 0.6627 , 0.1834 , -0.1834 ] ,\n                      [ 0.8936 , 0.9963 , 0.6901 , 0.1679 , -0.1679 ] ,\n                      [ 0.9149 , 0.9881 , 0.7139 , 0.1524 , -0.1524 ] ,\n                      [ 0.9362 , 0.9800 , 0.7413 , 0.1333 , -0.1333 ] ,\n                      [ 0.9574 , 0.9652 , 0.7687 , 0.1097 , -0.1097 ] ,\n                      [ 0.9787 , 0.9533 , 0.8043 , 0.0788 , -0.0788 ] ,\n                      [ 0.9894 , 0.9377 , 0.8280 , 0.0589 , -0.0589 ] ,\n                      [ 1.0000 , 0.9103 , 0.8784 , 0.0162 , -0.0162 ]]),\n\n    \"cone2\":np.array([[ 0.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ] ,\n                      [ 0.0213 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ] ,\n                      [ 0.0638 , 0.9956 , 0.0044 , 0.4956 , -0.4956 ] ,\n                      [ 0.1064 , 0.9875 , 0.0125 , 0.4875 , -0.4875 ] ,\n                      [ 0.1489 , 0.9794 , 0.0206 , 0.4794 , -0.4794 ] ,\n                      [ 0.1915 , 0.9720 , 0.0280 , 0.4720 , -0.4720 ] ,\n                      [ 0.2766 , 0.9566 , 0.0434 , 0.4566 , -0.4566 ] ,\n                      [ 0.3617 , 0.9330 , 0.0670 , 0.4330 , -0.4330 ] ,\n                      [ 0.4894 , 0.8822 , 0.1178 , 0.3822 , -0.3822 ] ,\n                      [ 0.6170 , 0.8240 , 0.1760 , 0.3240 , -0.3240 ] ,\n                      [ 0.7447 , 0.7577 , 0.2423 , 0.2577 , -0.2577 ] ,\n                      [ 0.8723 , 0.6834 , 0.3166 , 0.1834 , -0.1834 ] ,\n                      [ 0.8936 , 0.6679 , 0.3321 , 0.1679 , -0.1679 ] ,\n                      [ 0.9149 , 0.6524 , 0.3476 , 0.1524 , -0.1524 ] ,\n                      [ 0.9362 , 0.6333 , 0.3667 , 0.1333 , -0.1333 ] ,\n                      [ 0.9574 , 0.6097 , 0.3903 , 0.1097 , -0.1097 ] ,\n                      [ 0.9787 , 0.5788 , 0.4212 , 0.0788 , -0.0788 ] ,\n                      [ 0.9894 , 0.5589 , 0.4411 , 0.0589 , -0.0589 ] ,\n                      [ 1.0000 , 0.5162 , 0.4838 , 0.0162 , -0.0162 ]]),\n\n    \"sec1\":np.array([[  0.5000000 , 0.0000000 ,  0.0000000 ] ,\n                     [  0.4903926 , 0.0975452 , -0.0975452 ] ,\n                     [  0.4619398 , 0.1913417 , -0.1913417 ] ,\n                     [  0.4157348 , 0.2777851 , -0.2777851 ] ,\n                     [  0.3535534 , 0.3535534 , -0.3535534 ] ,\n                     [  0.2777851 , 0.4157348 , -0.4157348 ] ,\n                     [  0.1913417 , 0.4619398 , -0.4619398 ] ,\n                     [  0.0975452 , 0.4903926 , -0.4903926 ] ,\n                     [  0.0000000 , 0.5000000 , -0.5000000 ] ,\n                     [- 0.0975452 , 0.4903926 , -0.4903926 ] ,\n                     [- 0.1913417 , 0.4619398 , -0.4619398 ] ,\n                     [- 0.2777851 , 0.4157348 , -0.4157348 ] ,\n                     [- 0.3535534 , 0.3535534 , -0.3535534 ] ,\n                     [- 0.4157348 , 0.2777851 , -0.2777851 ] ,\n                     [- 0.4619398 , 0.1913417 , -0.1913417 ] ,\n                     [- 0.4903926 , 0.0975452 , -0.0975452 ] ,\n                     [- 0.5000000 , 0.0000000 ,  0.0000000 ]]),\n\n    \"sec2\":np.array([[ 0.5000000 , 0.0000000 ,  0.0000000] ,\n                     [ 0.4951963 , 0.0975452 , -0.0975452] ,\n                     [ 0.4809699 , 0.1913417 , -0.1913417] ,\n                     [ 0.4578674 , 0.2777851 , -0.2777851] ,\n                     [ 0.4267767 , 0.3535534 , -0.3535534] ,\n                     [ 0.3888926 , 0.4157348 , -0.4157348] ,\n                     [ 0.3456709 , 0.4619398 , -0.4619398] ,\n                     [ 0.2987726 , 0.4903926 , -0.4903926] ,\n                     [ 0.2500000 , 0.5000000 , -0.5000000] ,\n                     [ 0.0000000 , 0.5000000 , -0.5000000] ,\n                     [-0.2500000 , 0.5000000 , -0.5000000] ,\n                     [-0.2987726 , 0.4903926 , -0.4903926] ,\n                     [-0.3456709 , 0.4619398 , -0.4619398] ,\n                     [-0.3888926 , 0.4157348 , -0.4157348] ,\n                     [-0.4267767 , 0.3535534 , -0.3535534] ,\n                     [-0.4578674 , 0.2777851 , -0.2777851] ,\n                     [-0.4809699 , 0.1913417 , -0.1913417] ,\n                     [-0.4951963 , 0.0975452 , -0.0975452] ,\n                     [-0.5000000 , 0.0000000 ,  0.0000000]])}\n\n    return [curve[n] for n in name]\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.TankRearFuselage","title":"TankRearFuselage","text":"<pre><code>TankRearFuselage(aircraft)\n</code></pre> <p>               Bases: <code>Tank</code></p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def __init__(self, aircraft):\n    super(TankRearFuselage, self).__init__(aircraft)\n\n    self.gravimetric_index = aircraft.get_init(self,\"gravimetric_index\")\n    self.volumetric_index = aircraft.get_init(self,\"volumetric_index\")\n\n    self.ref_length = aircraft.get_init(self,\"ref_length\")\n    self.length = None\n    self.width_rear_factor = aircraft.get_init(self,\"width_rear_factor\")\n\n    self.width_rear = None\n    self.width_front = None\n\n    self.fuel_pressure = aircraft.get_init(self,\"fuel_pressure\", val=self.fuel_over_pressure(aircraft))\n    self.fuel_density = None\n\n    self.cylindric_gross_volume = None\n    self.cone_gross_volume = None\n    self.gross_volume = None\n\n    self.cylindric_volume = None\n    self.cone_volume = None\n\n    self.shell_specific_volume = None\n    self.shell_specific_mass = None\n\n    self.max_volume = None\n    self.mfw_volume_limited = None\n\n    self.fuel_max_fwd_cg = np.full(3,None)\n    self.fuel_max_fwd_mass = None\n\n    self.fuel_max_bwd_cg = np.full(3,None)\n    self.fuel_max_bwd_mass = None\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.TankRearFuselage-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.TankRearFuselage.eval_geometry","title":"eval_geometry","text":"<pre><code>eval_geometry()\n</code></pre> <p>Estimates the geometry of the component from the aircraft requirements and statistical design laws.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def eval_geometry(self):\n    body_loc = self.aircraft.airframe.body.frame_origin\n    body_width = self.aircraft.airframe.body.width\n    body_length = self.aircraft.airframe.body.length\n    body_wall_thickness = self.aircraft.airframe.body.wall_thickness\n    body_tail_cone_ratio = self.aircraft.airframe.body.tail_cone_ratio\n    body_rear_bulkhead_ratio = self.aircraft.airframe.body.rear_bulkhead_ratio\n\n    # Tank is supposed to be composed of an eventual cylindrical part of length lcyl and a cone trunc\n    # self.mfw_factor controls the tank length\n    self.length = self.ref_length * self.mfw_factor\n\n    # ref_length is used only to compute cyv and cov\n    lcyl = max(0.,self.length - body_width*(body_tail_cone_ratio-body_rear_bulkhead_ratio))\n\n    # x is the fraction of tank length which is in the fuselage cone\n    x = self.length/((body_tail_cone_ratio-body_rear_bulkhead_ratio)*body_width)\n    self.width_front = min(1.,self.width_rear_factor+(1.-self.width_rear_factor)*x)*(body_width-2.*body_wall_thickness)\n    self.width_rear = self.width_rear_factor*(body_width-2.*body_wall_thickness)\n\n    self.gross_cylindric_volume = 0.9 * (1/4)*np.pi*lcyl*self.width_front**2\n    self.gross_cone_volume = 0.9 * (1/12)*np.pi*(self.length-lcyl)*(self.width_front**2+self.width_front*self.width_rear+self.width_rear**2)\n    self.gross_volume = self.gross_cylindric_volume + self.gross_cone_volume\n\n    x_axe = body_loc[0] + body_length - body_tail_cone_ratio*body_width - self.length\n    y_axe = 0.\n    z_axe = body_loc[2] + 0.6*body_width\n\n    self.frame_origin = [x_axe, y_axe, z_axe]\n\n    if self.aircraft.arrangement.fuel_type in [\"liquid_h2\",\"compressed_h2\"]:\n\n        self.cylindric_volume = self.gross_cylindric_volume * self.volumetric_index\n        self.cone_volume = self.gross_cone_volume * self.volumetric_index\n\n        # Volume of the tank structure\n        self.shell_specific_volume = self.gross_volume*(1.-self.volumetric_index)\n        # Volume of the fuel\n        self.max_volume = self.cylindric_volume + self.cone_volume\n\n    else:\n        self.cylindric_volume = self.gross_cylindric_volume\n        self.cone_volume = self.gross_cone_volume\n\n        self.shell_specific_volume = 0.\n        self.max_volume = self.cylindric_volume + self.cone_volume\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.TankRearFuselage.eval_mass","title":"eval_mass","text":"<pre><code>eval_mass()\n</code></pre> <p>Estimates the geometry of the component from the aircraft requirements and statistical design laws.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def eval_mass(self):\n    fuel_type = self.aircraft.arrangement.fuel_type\n    body_width = self.aircraft.airframe.body.width\n    body_tail_cone_ratio = self.aircraft.airframe.body.tail_cone_ratio\n    body_rear_bulkhead_ratio = self.aircraft.airframe.body.rear_bulkhead_ratio\n\n    # REMARK : if fuel is \"Battery\", fuel density will be battery density\n    self.fuel_density = earth.fuel_density(fuel_type, self.fuel_pressure)\n    self.mfw_volume_limited = self.max_volume*self.fuel_density\n\n    # Tank equiped structural mass\n    if self.aircraft.arrangement.fuel_type in [\"liquid_h2\",\"compressed_h2\"]:\n        self.shell_specific_mass = self.gross_volume*(1./self.gravimetric_index-1.)*self.volumetric_index*self.fuel_density\n    else:\n        self.shell_specific_mass = 0.\n\n    self.mass = self.shell_specific_mass\n\n    lcyl = max(0.,self.length - body_width*(body_tail_cone_ratio-body_rear_bulkhead_ratio))\n    V = (1./12.)*self.length*np.sqrt(self.width_front**2+self.width_front*self.width_rear+self.width_rear**2)   # Tank conic part\n    v = (1./12.)*self.length*np.sqrt(self.width_rear**2)                                                        # Un-used tail part\n    self.cg = self.frame_origin[0] + 0.5*lcyl + 0.25*self.length*(1.+body_rear_bulkhead_ratio*body_width/self.length-3.*v/V)\n\n    self.fuel_max_fwd_cg = self.cg    # Fuel max Forward CG\n    self.fuel_max_fwd_mass = self.max_volume*self.fuel_density\n\n    self.fuel_max_bwd_cg = self.cg    # Fuel max Backward CG\n    self.fuel_max_bwd_mass = self.max_volume*self.fuel_density\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.TankRearFuselage.get_aero_length","title":"get_aero_length","text":"<pre><code>get_aero_length()\n</code></pre> <p>The characteristic aerodynamic length of the component (used for Reynolds number estimations for example).</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_aero_length(self):\n    \"\"\"The characteristic aerodynamic length of the component (used for Reynolds number estimations for example).\"\"\"\n    return self.aero_length\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.TankRearFuselage.get_cg_mwe","title":"get_cg_mwe","text":"<pre><code>get_cg_mwe()\n</code></pre> <p>Returns the position of the center of gravity of the manufacturer empty aircraft</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_cg_mwe(self):\n    \"\"\"Returns the position of the center of gravity of the manufacturer empty aircraft\"\"\"\n    return self.cg\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.TankRearFuselage.get_cg_owe","title":"get_cg_owe","text":"<pre><code>get_cg_owe()\n</code></pre> <p>Returns the position of the center of gravity of the operational empty aircraft</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_cg_owe(self):\n    \"\"\"Returns the position of the center of gravity of the operational empty aircraft\"\"\"\n    return self.cg\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.TankRearFuselage.get_form_factor","title":"get_form_factor","text":"<pre><code>get_form_factor()\n</code></pre> <p>Form factor used to estimate form drag.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_form_factor(self):\n    \"\"\"Form factor used to estimate form drag.\"\"\"\n    return self.form_factor\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.TankRearFuselage.get_inertia_tensor","title":"get_inertia_tensor","text":"<pre><code>get_inertia_tensor()\n</code></pre> <p>returns the inertia matrix of the component, if implemented.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_inertia_tensor(self):\n    \"\"\"returns the inertia matrix of the component, if implemented.\"\"\"\n    return self.inertia_tensor\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.TankRearFuselage.get_mass_mwe","title":"get_mass_mwe","text":"<pre><code>get_mass_mwe()\n</code></pre> <p>Returns the Manufacturer's Weight Empty, the mass (kg) of the component</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_mass_mwe(self):\n    \"\"\"Returns the *Manufacturer's Weight Empty*, the mass (kg) of the component\"\"\"\n    return self.mass\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.TankRearFuselage.get_mass_owe","title":"get_mass_owe","text":"<pre><code>get_mass_owe()\n</code></pre> <p>Returns the Operating Weight Empty, the mass (kg) of the component. Can differ from MWE for some components</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_mass_owe(self):\n    \"\"\"Returns the *Operating Weight Empty*, the mass (kg) of the component. Can differ from MWE for some components\"\"\"\n    return self.mass\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.TankRearFuselage.get_net_wet_area","title":"get_net_wet_area","text":"<pre><code>get_net_wet_area()\n</code></pre> <p>The net wet area of the component in contact with outer airflow, 0 if the component has no aerodynamic surface.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_net_wet_area(self):\n    \"\"\"The net wet area of the component in contact with outer airflow, 0 if the component has no aerodynamic surface.\"\"\"\n    return self.net_wet_area\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.TankRearFuselage.get_this_shape","title":"get_this_shape","text":"<pre><code>get_this_shape(name)\n</code></pre> <p>Contour curves for 3 view drawing nose1 : modern nose (A220, A350, 787) nose3 : classical Airbus nose nose2 : symetrical nose cone1 : classical tail cone cone2 : symetrical cone section : circle</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_this_shape(self, name): # TODO: is the docstring up to date ?\n    \"\"\"Contour curves for 3 view drawing\n    nose1 : modern nose (A220, A350, 787)\n    nose3 : classical Airbus nose\n    nose2 : symetrical nose\n    cone1 : classical tail cone\n    cone2 : symetrical cone\n    section : circle\n    \"\"\"\n    curve = {\n    \"nose1\":np.array([[ 0.0000 , 0.3339 , 0.3339 , 0.0000 ,  0.0000 ] ,\n                      [ 0.0050 , 0.3848 , 0.3084 , 0.0335 , -0.0335 ] ,\n                      [ 0.0150 , 0.4253 , 0.2881 , 0.0652 , -0.0652 ] ,\n                      [ 0.0500 , 0.5033 , 0.2490 , 0.1101 , -0.1101 ] ,\n                      [ 0.1000 , 0.5811 , 0.2100 , 0.1585 , -0.1585 ] ,\n                      [ 0.1800 , 0.6808 , 0.1600 , 0.2215 , -0.2215 ] ,\n                      [ 0.2773 , 0.7704 , 0.1151 , 0.2859 , -0.2859 ] ,\n                      [ 0.4191 , 0.8562 , 0.0721 , 0.3624 , -0.3624 ] ,\n                      [ 0.5610 , 0.9198 , 0.0402 , 0.4211 , -0.4211 ] ,\n                      [ 0.7738 , 0.9816 , 0.0092 , 0.4761 , -0.4761 ] ,\n                      [ 0.9156 , 0.9962 , 0.0019 , 0.4976 , -0.4976 ] ,\n                      [ 1.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ]]),\n\n    \"nose2\":np.array([[ 0.0000 , 0.5000 ,  0.5000 , 0.0000 ,  0.0000 ] ,\n                      [ 0.0050 , 0.5335 ,  0.4665 , 0.0335 , -0.0335 ] ,\n                      [ 0.0191 , 0.5646 ,  0.4354 , 0.0646 , -0.0646 ] ,\n                      [ 0.0624 , 0.6196 ,  0.3804 , 0.1196 , -0.1196 ] ,\n                      [ 0.1355 , 0.6878 ,  0.3122 , 0.1878 , -0.1878 ] ,\n                      [ 0.1922 , 0.7297 ,  0.2703 , 0.2297 , -0.2297 ] ,\n                      [ 0.2773 , 0.7859 ,  0.2141 , 0.2859 , -0.2859 ] ,\n                      [ 0.4191 , 0.8624 ,  0.1376 , 0.3624 , -0.3624 ] ,\n                      [ 0.5610 , 0.9211 ,  0.0789 , 0.4211 , -0.4211 ] ,\n                      [ 0.7738 , 0.9761 ,  0.0239 , 0.4761 , -0.4761 ] ,\n                      [ 0.9156 , 0.9976 ,  0.0024 , 0.4976 , -0.4976 ] ,\n                      [ 1.0000 , 1.0000 ,  0.0000 , 0.5000 , -0.5000 ]]),\n\n    \"nose3\":np.array([[ 0.0000 , 0.4453 , 0.4453 , 0.0000 ,  0.0000 ] ,\n                      [ 0.0050 , 0.4733 , 0.4112 , 0.0335 , -0.0335 ] ,\n                      [ 0.0191 , 0.5098 , 0.3833 , 0.0646 , -0.0646 ] ,\n                      [ 0.0624 , 0.5718 , 0.3188 , 0.1196 , -0.1196 ] ,\n                      [ 0.1355 , 0.6278 , 0.2531 , 0.1878 , -0.1878 ] ,\n                      [ 0.1922 , 0.7263 , 0.2142 , 0.2297 , -0.2297 ] ,\n                      [ 0.2773 , 0.8127 , 0.1631 , 0.2859 , -0.2859 ] ,\n                      [ 0.4191 , 0.8906 , 0.0962 , 0.3624 , -0.3624 ] ,\n                      [ 0.5610 , 0.9392 , 0.0536 , 0.4211 , -0.4211 ] ,\n                      [ 0.7738 , 0.9818 , 0.0122 , 0.4761 , -0.4761 ] ,\n                      [ 0.9156 , 0.9976 , 0.0025 , 0.4976 , -0.4976 ] ,\n                      [ 1.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ]]),\n\n    \"nose4\":np.array([[ 0.0000, 0.3700, 0.3700, 0.0000,  0.0000 ] ,\n                      [ 0.0050, 0.4200, 0.3200, 0.0335, -0.0335 ] ,\n                      [ 0.0150, 0.4500, 0.2900, 0.0652, -0.0652 ] ,\n                      [ 0.0500, 0.5000, 0.2400, 0.1200, -0.1200 ] ,\n                      [ 0.1000, 0.5500, 0.1900, 0.1750, -0.1750 ] ,\n                      [ 0.1800, 0.6000, 0.1400, 0.2400, -0.2400 ] ,\n                      [ 0.2773, 0.6450, 0.1000, 0.3000, -0.3000 ] ,\n                      [ 0.4191, 0.7000, 0.0500, 0.3700, -0.3700 ] ,\n                      [ 0.5610, 0.7550, 0.0250, 0.4300, -0.4300 ] ,\n                      [ 0.6200, 0.7800, 0.0180, 0.4500, -0.4500 ] ,\n                      [ 0.7700, 0.9700, 0.0090, 0.4850, -0.4850 ] ,\n                      [ 0.8100, 0.9900, 0.0060, 0.4900, -0.4900 ] ,\n                      [ 0.9100, 0.9970, 0.0030, 0.4976, -0.4976 ] ,\n                      [ 1.0000, 1.0000, 0.0000, 0.5000, -0.5000 ]]),\n\n    \"cone1\":np.array([[ 0.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ] ,\n                      [ 0.0213 , 1.0000 , 0.0082 , 0.5000 , -0.5000 ] ,\n                      [ 0.0638 , 1.0000 , 0.0230 , 0.4956 , -0.4956 ] ,\n                      [ 0.1064 , 1.0000 , 0.0393 , 0.4875 , -0.4875 ] ,\n                      [ 0.1489 , 1.0000 , 0.0556 , 0.4794 , -0.4794 ] ,\n                      [ 0.1915 , 1.0000 , 0.0786 , 0.4720 , -0.4720 ] ,\n                      [ 0.2766 , 1.0000 , 0.1334 , 0.4566 , -0.4566 ] ,\n                      [ 0.3617 , 1.0000 , 0.1964 , 0.4330 , -0.4330 ] ,\n                      [ 0.4894 , 1.0000 , 0.3024 , 0.3822 , -0.3822 ] ,\n                      [ 0.6170 , 1.0000 , 0.4159 , 0.3240 , -0.3240 ] ,\n                      [ 0.7447 , 1.0000 , 0.5374 , 0.2577 , -0.2577 ] ,\n                      [ 0.8723 , 1.0000 , 0.6627 , 0.1834 , -0.1834 ] ,\n                      [ 0.8936 , 0.9963 , 0.6901 , 0.1679 , -0.1679 ] ,\n                      [ 0.9149 , 0.9881 , 0.7139 , 0.1524 , -0.1524 ] ,\n                      [ 0.9362 , 0.9800 , 0.7413 , 0.1333 , -0.1333 ] ,\n                      [ 0.9574 , 0.9652 , 0.7687 , 0.1097 , -0.1097 ] ,\n                      [ 0.9787 , 0.9533 , 0.8043 , 0.0788 , -0.0788 ] ,\n                      [ 0.9894 , 0.9377 , 0.8280 , 0.0589 , -0.0589 ] ,\n                      [ 1.0000 , 0.9103 , 0.8784 , 0.0162 , -0.0162 ]]),\n\n    \"cone2\":np.array([[ 0.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ] ,\n                      [ 0.0213 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ] ,\n                      [ 0.0638 , 0.9956 , 0.0044 , 0.4956 , -0.4956 ] ,\n                      [ 0.1064 , 0.9875 , 0.0125 , 0.4875 , -0.4875 ] ,\n                      [ 0.1489 , 0.9794 , 0.0206 , 0.4794 , -0.4794 ] ,\n                      [ 0.1915 , 0.9720 , 0.0280 , 0.4720 , -0.4720 ] ,\n                      [ 0.2766 , 0.9566 , 0.0434 , 0.4566 , -0.4566 ] ,\n                      [ 0.3617 , 0.9330 , 0.0670 , 0.4330 , -0.4330 ] ,\n                      [ 0.4894 , 0.8822 , 0.1178 , 0.3822 , -0.3822 ] ,\n                      [ 0.6170 , 0.8240 , 0.1760 , 0.3240 , -0.3240 ] ,\n                      [ 0.7447 , 0.7577 , 0.2423 , 0.2577 , -0.2577 ] ,\n                      [ 0.8723 , 0.6834 , 0.3166 , 0.1834 , -0.1834 ] ,\n                      [ 0.8936 , 0.6679 , 0.3321 , 0.1679 , -0.1679 ] ,\n                      [ 0.9149 , 0.6524 , 0.3476 , 0.1524 , -0.1524 ] ,\n                      [ 0.9362 , 0.6333 , 0.3667 , 0.1333 , -0.1333 ] ,\n                      [ 0.9574 , 0.6097 , 0.3903 , 0.1097 , -0.1097 ] ,\n                      [ 0.9787 , 0.5788 , 0.4212 , 0.0788 , -0.0788 ] ,\n                      [ 0.9894 , 0.5589 , 0.4411 , 0.0589 , -0.0589 ] ,\n                      [ 1.0000 , 0.5162 , 0.4838 , 0.0162 , -0.0162 ]]),\n\n    \"sec1\":np.array([[  0.5000000 , 0.0000000 ,  0.0000000 ] ,\n                     [  0.4903926 , 0.0975452 , -0.0975452 ] ,\n                     [  0.4619398 , 0.1913417 , -0.1913417 ] ,\n                     [  0.4157348 , 0.2777851 , -0.2777851 ] ,\n                     [  0.3535534 , 0.3535534 , -0.3535534 ] ,\n                     [  0.2777851 , 0.4157348 , -0.4157348 ] ,\n                     [  0.1913417 , 0.4619398 , -0.4619398 ] ,\n                     [  0.0975452 , 0.4903926 , -0.4903926 ] ,\n                     [  0.0000000 , 0.5000000 , -0.5000000 ] ,\n                     [- 0.0975452 , 0.4903926 , -0.4903926 ] ,\n                     [- 0.1913417 , 0.4619398 , -0.4619398 ] ,\n                     [- 0.2777851 , 0.4157348 , -0.4157348 ] ,\n                     [- 0.3535534 , 0.3535534 , -0.3535534 ] ,\n                     [- 0.4157348 , 0.2777851 , -0.2777851 ] ,\n                     [- 0.4619398 , 0.1913417 , -0.1913417 ] ,\n                     [- 0.4903926 , 0.0975452 , -0.0975452 ] ,\n                     [- 0.5000000 , 0.0000000 ,  0.0000000 ]]),\n\n    \"sec2\":np.array([[ 0.5000000 , 0.0000000 ,  0.0000000] ,\n                     [ 0.4951963 , 0.0975452 , -0.0975452] ,\n                     [ 0.4809699 , 0.1913417 , -0.1913417] ,\n                     [ 0.4578674 , 0.2777851 , -0.2777851] ,\n                     [ 0.4267767 , 0.3535534 , -0.3535534] ,\n                     [ 0.3888926 , 0.4157348 , -0.4157348] ,\n                     [ 0.3456709 , 0.4619398 , -0.4619398] ,\n                     [ 0.2987726 , 0.4903926 , -0.4903926] ,\n                     [ 0.2500000 , 0.5000000 , -0.5000000] ,\n                     [ 0.0000000 , 0.5000000 , -0.5000000] ,\n                     [-0.2500000 , 0.5000000 , -0.5000000] ,\n                     [-0.2987726 , 0.4903926 , -0.4903926] ,\n                     [-0.3456709 , 0.4619398 , -0.4619398] ,\n                     [-0.3888926 , 0.4157348 , -0.4157348] ,\n                     [-0.4267767 , 0.3535534 , -0.3535534] ,\n                     [-0.4578674 , 0.2777851 , -0.2777851] ,\n                     [-0.4809699 , 0.1913417 , -0.1913417] ,\n                     [-0.4951963 , 0.0975452 , -0.0975452] ,\n                     [-0.5000000 , 0.0000000 ,  0.0000000]])}\n\n    return [curve[n] for n in name]\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.TankWingBox","title":"TankWingBox","text":"<pre><code>TankWingBox(aircraft)\n</code></pre> <p>               Bases: <code>Tank</code></p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def __init__(self, aircraft):\n    super(TankWingBox, self).__init__(aircraft)\n\n    self.gravimetric_index = aircraft.get_init(self,\"gravimetric_index\")\n    self.volumetric_index = aircraft.get_init(self,\"volumetric_index\")\n\n    self.fuel_pressure = aircraft.get_init(self,\"fuel_pressure\", val=self.fuel_over_pressure(aircraft))\n    self.fuel_density = None\n\n    self.cantilever_gross_volume = None\n    self.central_gross_volume = None\n    self.gross_volume = None\n    self.cantilever_volume = None\n    self.central_volume = None\n\n    self.shell_specific_volume = None\n    self.max_volume = None\n    self.mfw_volume_limited = None\n\n    self.fuel_max_fwd_cg = np.full(3,None)\n    self.fuel_max_fwd_mass = None\n\n    self.fuel_max_bwd_cg = np.full(3,None)\n    self.fuel_max_bwd_mass = None\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.TankWingBox-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.TankWingBox.eval_geometry","title":"eval_geometry","text":"<pre><code>eval_geometry()\n</code></pre> <p>Estimates the geometry of the component from the aircraft requirements and statistical design laws.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def eval_geometry(self):\n    body_width = self.aircraft.airframe.body.width\n    wing_area = self.aircraft.airframe.wing.area\n    wing_mac = self.aircraft.airframe.wing.mac\n    wing_root_loc = self.aircraft.airframe.wing.root_loc\n    wing_root_toc = self.aircraft.airframe.wing.root_toc\n    wing_root_c = self.aircraft.airframe.wing.root_c\n    wing_kink_loc = self.aircraft.airframe.wing.kink_loc\n    wing_kink_toc = self.aircraft.airframe.wing.kink_toc\n    wing_kink_c = self.aircraft.airframe.wing.kink_c\n    wing_tip_loc = self.aircraft.airframe.wing.tip_loc\n    wing_tip_toc = self.aircraft.airframe.wing.tip_toc\n    wing_tip_c = self.aircraft.airframe.wing.tip_c\n    wing_fsr = self.aircraft.airframe.wing.front_spar_ratio\n    wing_rsr = self.aircraft.airframe.wing.rear_spar_ratio\n    fuel_type = self.aircraft.arrangement.fuel_type\n\n    root_sec = (wing_rsr - wing_fsr)*wing_root_toc*wing_root_c**2\n    kink_sec = (wing_rsr - wing_fsr)*wing_kink_toc*wing_kink_c**2\n    tip_sec = (wing_rsr - wing_fsr)*wing_tip_toc*wing_tip_c**2\n\n    self.cantilever_gross_volume = (2./3.)*(\n        0.9*(wing_kink_loc[1]-wing_root_loc[1])*(root_sec+kink_sec+np.sqrt(root_sec*kink_sec))\n      + 0.7*(wing_tip_loc[1]-wing_kink_loc[1])*(kink_sec+tip_sec+np.sqrt(kink_sec*tip_sec)))\n    self.central_gross_volume = 0.8*(wing_rsr - wing_fsr) * body_width * wing_root_toc * wing_root_c**2\n    self.gross_volume = self.central_gross_volume + self.cantilever_gross_volume\n\n    cav = self.cantilever_gross_volume / self.gross_volume\n    cev = self.central_gross_volume / self.gross_volume\n\n    if self.aircraft.arrangement.fuel_type in [\"liquid_h2\",\"compressed_h2\"]:\n\n        # self.mfw_factor controls the fuel volumes giving priority to cantilever\n        self.central_volume = max(0, (self.mfw_factor-cav)/cev) * self.central_gross_volume * self.volumetric_index\n        self.cantilever_volume = min(1, self.mfw_factor/cav) * self.cantilever_gross_volume * self.volumetric_index\n\n        # Volume of the tank structure\n        self.shell_specific_volume = self.gross_volume*(1.-self.volumetric_index)\n\n        # Volume of the fuel\n        self.max_volume = self.central_volume + self.cantilever_volume\n\n    else:\n\n        # self.mfw_factor controls the fuel volumes giving priority to cantilever\n        self.central_volume = max(0, (self.mfw_factor-cav)/cev) * self.central_gross_volume\n        self.cantilever_volume = min(1, self.mfw_factor/cav) * self.cantilever_gross_volume\n\n        self.shell_specific_volume = 0.\n        self.max_volume = self.central_volume + self.cantilever_volume\n\n    self.frame_origin = [wing_root_loc[0], 0., wing_root_loc[2]]\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.TankWingBox.eval_mass","title":"eval_mass","text":"<pre><code>eval_mass()\n</code></pre> <p>Estimates the geometry of the component from the aircraft requirements and statistical design laws.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def eval_mass(self):\n    fuel_type = self.aircraft.arrangement.fuel_type\n    wing_root_c = self.aircraft.airframe.wing.root_c\n    wing_root_loc = self.aircraft.airframe.wing.root_loc\n    wing_kink_c = self.aircraft.airframe.wing.kink_c\n    wing_kink_loc = self.aircraft.airframe.wing.kink_loc\n    wing_tip_c = self.aircraft.airframe.wing.tip_c\n    wing_tip_loc = self.aircraft.airframe.wing.tip_loc\n\n    self.fuel_cantilever_cg =  0.25*(wing_root_loc + 0.40*np.array([wing_root_c, 0., 0.])) \\\n                              + 0.65*(wing_kink_loc + 0.40*np.array([wing_kink_c, 0., 0.])) \\\n                              + 0.10*(wing_tip_loc + 0.40*np.array([wing_tip_c, 0., 0.]))\n\n    self.fuel_central_cg = wing_root_loc + 0.40*np.array([wing_root_c, 0., 0.])\n\n    self.fuel_total_cg = (  self.fuel_central_cg*self.central_volume\n                          + self.fuel_cantilever_cg*self.cantilever_volume\n                          ) / (self.central_volume + self.cantilever_volume)\n\n    # REMARK : if fuel_type is \"Battery\", fuel density will be battery density\n    self.fuel_density = earth.fuel_density(fuel_type, self.fuel_pressure)\n    self.mfw_volume_limited = self.max_volume*self.fuel_density\n\n    # Tank equiped structural mass\n    if self.aircraft.arrangement.fuel_type in [\"liquid_h2\",\"compressed_h2\"]:\n        self.shell_specific_mass = self.gross_volume*(1./self.gravimetric_index-1.)*self.volumetric_index*self.fuel_density\n    else:\n        self.shell_specific_mass = 0.\n\n    self.mass = self.shell_specific_mass\n    self.cg = self.fuel_total_cg\n\n    self.fuel_max_fwd_cg = self.fuel_central_cg    # Fuel max forward CG, central tank is forward only within backward swept wing\n    self.fuel_max_fwd_mass = self.central_volume*self.fuel_density\n\n    self.fuel_max_bwd_cg = self.fuel_cantilever_cg    # Fuel max Backward CG\n    self.fuel_max_bwd_mass = self.cantilever_volume*self.fuel_density\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.TankWingBox.get_aero_length","title":"get_aero_length","text":"<pre><code>get_aero_length()\n</code></pre> <p>The characteristic aerodynamic length of the component (used for Reynolds number estimations for example).</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_aero_length(self):\n    \"\"\"The characteristic aerodynamic length of the component (used for Reynolds number estimations for example).\"\"\"\n    return self.aero_length\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.TankWingBox.get_cg_mwe","title":"get_cg_mwe","text":"<pre><code>get_cg_mwe()\n</code></pre> <p>Returns the position of the center of gravity of the manufacturer empty aircraft</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_cg_mwe(self):\n    \"\"\"Returns the position of the center of gravity of the manufacturer empty aircraft\"\"\"\n    return self.cg\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.TankWingBox.get_cg_owe","title":"get_cg_owe","text":"<pre><code>get_cg_owe()\n</code></pre> <p>Returns the position of the center of gravity of the operational empty aircraft</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_cg_owe(self):\n    \"\"\"Returns the position of the center of gravity of the operational empty aircraft\"\"\"\n    return self.cg\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.TankWingBox.get_form_factor","title":"get_form_factor","text":"<pre><code>get_form_factor()\n</code></pre> <p>Form factor used to estimate form drag.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_form_factor(self):\n    \"\"\"Form factor used to estimate form drag.\"\"\"\n    return self.form_factor\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.TankWingBox.get_inertia_tensor","title":"get_inertia_tensor","text":"<pre><code>get_inertia_tensor()\n</code></pre> <p>returns the inertia matrix of the component, if implemented.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_inertia_tensor(self):\n    \"\"\"returns the inertia matrix of the component, if implemented.\"\"\"\n    return self.inertia_tensor\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.TankWingBox.get_mass_mwe","title":"get_mass_mwe","text":"<pre><code>get_mass_mwe()\n</code></pre> <p>Returns the Manufacturer's Weight Empty, the mass (kg) of the component</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_mass_mwe(self):\n    \"\"\"Returns the *Manufacturer's Weight Empty*, the mass (kg) of the component\"\"\"\n    return self.mass\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.TankWingBox.get_mass_owe","title":"get_mass_owe","text":"<pre><code>get_mass_owe()\n</code></pre> <p>Returns the Operating Weight Empty, the mass (kg) of the component. Can differ from MWE for some components</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_mass_owe(self):\n    \"\"\"Returns the *Operating Weight Empty*, the mass (kg) of the component. Can differ from MWE for some components\"\"\"\n    return self.mass\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.TankWingBox.get_net_wet_area","title":"get_net_wet_area","text":"<pre><code>get_net_wet_area()\n</code></pre> <p>The net wet area of the component in contact with outer airflow, 0 if the component has no aerodynamic surface.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_net_wet_area(self):\n    \"\"\"The net wet area of the component in contact with outer airflow, 0 if the component has no aerodynamic surface.\"\"\"\n    return self.net_wet_area\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.TankWingBox.get_this_shape","title":"get_this_shape","text":"<pre><code>get_this_shape(name)\n</code></pre> <p>Contour curves for 3 view drawing nose1 : modern nose (A220, A350, 787) nose3 : classical Airbus nose nose2 : symetrical nose cone1 : classical tail cone cone2 : symetrical cone section : circle</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_this_shape(self, name): # TODO: is the docstring up to date ?\n    \"\"\"Contour curves for 3 view drawing\n    nose1 : modern nose (A220, A350, 787)\n    nose3 : classical Airbus nose\n    nose2 : symetrical nose\n    cone1 : classical tail cone\n    cone2 : symetrical cone\n    section : circle\n    \"\"\"\n    curve = {\n    \"nose1\":np.array([[ 0.0000 , 0.3339 , 0.3339 , 0.0000 ,  0.0000 ] ,\n                      [ 0.0050 , 0.3848 , 0.3084 , 0.0335 , -0.0335 ] ,\n                      [ 0.0150 , 0.4253 , 0.2881 , 0.0652 , -0.0652 ] ,\n                      [ 0.0500 , 0.5033 , 0.2490 , 0.1101 , -0.1101 ] ,\n                      [ 0.1000 , 0.5811 , 0.2100 , 0.1585 , -0.1585 ] ,\n                      [ 0.1800 , 0.6808 , 0.1600 , 0.2215 , -0.2215 ] ,\n                      [ 0.2773 , 0.7704 , 0.1151 , 0.2859 , -0.2859 ] ,\n                      [ 0.4191 , 0.8562 , 0.0721 , 0.3624 , -0.3624 ] ,\n                      [ 0.5610 , 0.9198 , 0.0402 , 0.4211 , -0.4211 ] ,\n                      [ 0.7738 , 0.9816 , 0.0092 , 0.4761 , -0.4761 ] ,\n                      [ 0.9156 , 0.9962 , 0.0019 , 0.4976 , -0.4976 ] ,\n                      [ 1.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ]]),\n\n    \"nose2\":np.array([[ 0.0000 , 0.5000 ,  0.5000 , 0.0000 ,  0.0000 ] ,\n                      [ 0.0050 , 0.5335 ,  0.4665 , 0.0335 , -0.0335 ] ,\n                      [ 0.0191 , 0.5646 ,  0.4354 , 0.0646 , -0.0646 ] ,\n                      [ 0.0624 , 0.6196 ,  0.3804 , 0.1196 , -0.1196 ] ,\n                      [ 0.1355 , 0.6878 ,  0.3122 , 0.1878 , -0.1878 ] ,\n                      [ 0.1922 , 0.7297 ,  0.2703 , 0.2297 , -0.2297 ] ,\n                      [ 0.2773 , 0.7859 ,  0.2141 , 0.2859 , -0.2859 ] ,\n                      [ 0.4191 , 0.8624 ,  0.1376 , 0.3624 , -0.3624 ] ,\n                      [ 0.5610 , 0.9211 ,  0.0789 , 0.4211 , -0.4211 ] ,\n                      [ 0.7738 , 0.9761 ,  0.0239 , 0.4761 , -0.4761 ] ,\n                      [ 0.9156 , 0.9976 ,  0.0024 , 0.4976 , -0.4976 ] ,\n                      [ 1.0000 , 1.0000 ,  0.0000 , 0.5000 , -0.5000 ]]),\n\n    \"nose3\":np.array([[ 0.0000 , 0.4453 , 0.4453 , 0.0000 ,  0.0000 ] ,\n                      [ 0.0050 , 0.4733 , 0.4112 , 0.0335 , -0.0335 ] ,\n                      [ 0.0191 , 0.5098 , 0.3833 , 0.0646 , -0.0646 ] ,\n                      [ 0.0624 , 0.5718 , 0.3188 , 0.1196 , -0.1196 ] ,\n                      [ 0.1355 , 0.6278 , 0.2531 , 0.1878 , -0.1878 ] ,\n                      [ 0.1922 , 0.7263 , 0.2142 , 0.2297 , -0.2297 ] ,\n                      [ 0.2773 , 0.8127 , 0.1631 , 0.2859 , -0.2859 ] ,\n                      [ 0.4191 , 0.8906 , 0.0962 , 0.3624 , -0.3624 ] ,\n                      [ 0.5610 , 0.9392 , 0.0536 , 0.4211 , -0.4211 ] ,\n                      [ 0.7738 , 0.9818 , 0.0122 , 0.4761 , -0.4761 ] ,\n                      [ 0.9156 , 0.9976 , 0.0025 , 0.4976 , -0.4976 ] ,\n                      [ 1.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ]]),\n\n    \"nose4\":np.array([[ 0.0000, 0.3700, 0.3700, 0.0000,  0.0000 ] ,\n                      [ 0.0050, 0.4200, 0.3200, 0.0335, -0.0335 ] ,\n                      [ 0.0150, 0.4500, 0.2900, 0.0652, -0.0652 ] ,\n                      [ 0.0500, 0.5000, 0.2400, 0.1200, -0.1200 ] ,\n                      [ 0.1000, 0.5500, 0.1900, 0.1750, -0.1750 ] ,\n                      [ 0.1800, 0.6000, 0.1400, 0.2400, -0.2400 ] ,\n                      [ 0.2773, 0.6450, 0.1000, 0.3000, -0.3000 ] ,\n                      [ 0.4191, 0.7000, 0.0500, 0.3700, -0.3700 ] ,\n                      [ 0.5610, 0.7550, 0.0250, 0.4300, -0.4300 ] ,\n                      [ 0.6200, 0.7800, 0.0180, 0.4500, -0.4500 ] ,\n                      [ 0.7700, 0.9700, 0.0090, 0.4850, -0.4850 ] ,\n                      [ 0.8100, 0.9900, 0.0060, 0.4900, -0.4900 ] ,\n                      [ 0.9100, 0.9970, 0.0030, 0.4976, -0.4976 ] ,\n                      [ 1.0000, 1.0000, 0.0000, 0.5000, -0.5000 ]]),\n\n    \"cone1\":np.array([[ 0.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ] ,\n                      [ 0.0213 , 1.0000 , 0.0082 , 0.5000 , -0.5000 ] ,\n                      [ 0.0638 , 1.0000 , 0.0230 , 0.4956 , -0.4956 ] ,\n                      [ 0.1064 , 1.0000 , 0.0393 , 0.4875 , -0.4875 ] ,\n                      [ 0.1489 , 1.0000 , 0.0556 , 0.4794 , -0.4794 ] ,\n                      [ 0.1915 , 1.0000 , 0.0786 , 0.4720 , -0.4720 ] ,\n                      [ 0.2766 , 1.0000 , 0.1334 , 0.4566 , -0.4566 ] ,\n                      [ 0.3617 , 1.0000 , 0.1964 , 0.4330 , -0.4330 ] ,\n                      [ 0.4894 , 1.0000 , 0.3024 , 0.3822 , -0.3822 ] ,\n                      [ 0.6170 , 1.0000 , 0.4159 , 0.3240 , -0.3240 ] ,\n                      [ 0.7447 , 1.0000 , 0.5374 , 0.2577 , -0.2577 ] ,\n                      [ 0.8723 , 1.0000 , 0.6627 , 0.1834 , -0.1834 ] ,\n                      [ 0.8936 , 0.9963 , 0.6901 , 0.1679 , -0.1679 ] ,\n                      [ 0.9149 , 0.9881 , 0.7139 , 0.1524 , -0.1524 ] ,\n                      [ 0.9362 , 0.9800 , 0.7413 , 0.1333 , -0.1333 ] ,\n                      [ 0.9574 , 0.9652 , 0.7687 , 0.1097 , -0.1097 ] ,\n                      [ 0.9787 , 0.9533 , 0.8043 , 0.0788 , -0.0788 ] ,\n                      [ 0.9894 , 0.9377 , 0.8280 , 0.0589 , -0.0589 ] ,\n                      [ 1.0000 , 0.9103 , 0.8784 , 0.0162 , -0.0162 ]]),\n\n    \"cone2\":np.array([[ 0.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ] ,\n                      [ 0.0213 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ] ,\n                      [ 0.0638 , 0.9956 , 0.0044 , 0.4956 , -0.4956 ] ,\n                      [ 0.1064 , 0.9875 , 0.0125 , 0.4875 , -0.4875 ] ,\n                      [ 0.1489 , 0.9794 , 0.0206 , 0.4794 , -0.4794 ] ,\n                      [ 0.1915 , 0.9720 , 0.0280 , 0.4720 , -0.4720 ] ,\n                      [ 0.2766 , 0.9566 , 0.0434 , 0.4566 , -0.4566 ] ,\n                      [ 0.3617 , 0.9330 , 0.0670 , 0.4330 , -0.4330 ] ,\n                      [ 0.4894 , 0.8822 , 0.1178 , 0.3822 , -0.3822 ] ,\n                      [ 0.6170 , 0.8240 , 0.1760 , 0.3240 , -0.3240 ] ,\n                      [ 0.7447 , 0.7577 , 0.2423 , 0.2577 , -0.2577 ] ,\n                      [ 0.8723 , 0.6834 , 0.3166 , 0.1834 , -0.1834 ] ,\n                      [ 0.8936 , 0.6679 , 0.3321 , 0.1679 , -0.1679 ] ,\n                      [ 0.9149 , 0.6524 , 0.3476 , 0.1524 , -0.1524 ] ,\n                      [ 0.9362 , 0.6333 , 0.3667 , 0.1333 , -0.1333 ] ,\n                      [ 0.9574 , 0.6097 , 0.3903 , 0.1097 , -0.1097 ] ,\n                      [ 0.9787 , 0.5788 , 0.4212 , 0.0788 , -0.0788 ] ,\n                      [ 0.9894 , 0.5589 , 0.4411 , 0.0589 , -0.0589 ] ,\n                      [ 1.0000 , 0.5162 , 0.4838 , 0.0162 , -0.0162 ]]),\n\n    \"sec1\":np.array([[  0.5000000 , 0.0000000 ,  0.0000000 ] ,\n                     [  0.4903926 , 0.0975452 , -0.0975452 ] ,\n                     [  0.4619398 , 0.1913417 , -0.1913417 ] ,\n                     [  0.4157348 , 0.2777851 , -0.2777851 ] ,\n                     [  0.3535534 , 0.3535534 , -0.3535534 ] ,\n                     [  0.2777851 , 0.4157348 , -0.4157348 ] ,\n                     [  0.1913417 , 0.4619398 , -0.4619398 ] ,\n                     [  0.0975452 , 0.4903926 , -0.4903926 ] ,\n                     [  0.0000000 , 0.5000000 , -0.5000000 ] ,\n                     [- 0.0975452 , 0.4903926 , -0.4903926 ] ,\n                     [- 0.1913417 , 0.4619398 , -0.4619398 ] ,\n                     [- 0.2777851 , 0.4157348 , -0.4157348 ] ,\n                     [- 0.3535534 , 0.3535534 , -0.3535534 ] ,\n                     [- 0.4157348 , 0.2777851 , -0.2777851 ] ,\n                     [- 0.4619398 , 0.1913417 , -0.1913417 ] ,\n                     [- 0.4903926 , 0.0975452 , -0.0975452 ] ,\n                     [- 0.5000000 , 0.0000000 ,  0.0000000 ]]),\n\n    \"sec2\":np.array([[ 0.5000000 , 0.0000000 ,  0.0000000] ,\n                     [ 0.4951963 , 0.0975452 , -0.0975452] ,\n                     [ 0.4809699 , 0.1913417 , -0.1913417] ,\n                     [ 0.4578674 , 0.2777851 , -0.2777851] ,\n                     [ 0.4267767 , 0.3535534 , -0.3535534] ,\n                     [ 0.3888926 , 0.4157348 , -0.4157348] ,\n                     [ 0.3456709 , 0.4619398 , -0.4619398] ,\n                     [ 0.2987726 , 0.4903926 , -0.4903926] ,\n                     [ 0.2500000 , 0.5000000 , -0.5000000] ,\n                     [ 0.0000000 , 0.5000000 , -0.5000000] ,\n                     [-0.2500000 , 0.5000000 , -0.5000000] ,\n                     [-0.2987726 , 0.4903926 , -0.4903926] ,\n                     [-0.3456709 , 0.4619398 , -0.4619398] ,\n                     [-0.3888926 , 0.4157348 , -0.4157348] ,\n                     [-0.4267767 , 0.3535534 , -0.3535534] ,\n                     [-0.4578674 , 0.2777851 , -0.2777851] ,\n                     [-0.4809699 , 0.1913417 , -0.1913417] ,\n                     [-0.4951963 , 0.0975452 , -0.0975452] ,\n                     [-0.5000000 , 0.0000000 ,  0.0000000]])}\n\n    return [curve[n] for n in name]\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.TankWingPod","title":"TankWingPod","text":"<pre><code>TankWingPod(aircraft, side)\n</code></pre> <p>               Bases: <code>Pod</code></p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def __init__(self, aircraft, side):\n    super(TankWingPod, self).__init__(aircraft)\n\n    self.airplane_side = side\n\n    n_pax_ref = self.aircraft.requirement.n_pax_ref\n    n_pax_front = self.aircraft.airframe.cabin.n_pax_front\n    n_aisle = self.aircraft.airframe.cabin.n_aisle\n\n    self.span_ratio = aircraft.get_init(self,\"span_ratio\")\n    self.fuel_pressure = aircraft.get_init(self,\"fuel_pressure\", val=self.fuel_over_pressure(aircraft))\n    self.fuel_density = None\n\n    length = 0.35*(7.8*(0.38*n_pax_front + 1.05*n_aisle + 0.55) + 0.005*(n_pax_ref/n_pax_front)**2.25)\n    width = 0.80*(0.38*n_pax_front + 1.05*n_aisle + 0.55)\n\n    self.dry_bay_length = aircraft.get_init(self,\"dry_bay_length\")\n    self.ref_length = aircraft.get_init(self,\"ref_length\", val=length)\n    self.length = None\n\n    self.width = aircraft.get_init(self,\"width\", val=width)\n    self.x_loc_ratio = aircraft.get_init(self,\"x_loc_ratio\")\n    self.z_loc_ratio = aircraft.get_init(self,\"z_loc_ratio\")\n    self.wing_axe_c = None\n    self.wing_axe_x = None\n    self.wing_axe_z = None\n\n    self.max_volume = None\n    self.mfw_volume_limited = None\n\n    self.fuel_max_fwd_cg = np.full(3,None)\n    self.fuel_max_fwd_mass = None\n\n    self.fuel_max_bwd_cg = np.full(3,None)\n    self.fuel_max_bwd_mass = None\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.TankWingPod-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.TankWingPod.eval_geometry","title":"eval_geometry","text":"<pre><code>eval_geometry()\n</code></pre> <p>Estimates the geometry of the component from the aircraft requirements and statistical design laws.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def eval_geometry(self):\n    body_width = self.aircraft.airframe.body.width\n    tank_width = self.aircraft.airframe.tank.width\n\n    wing_sweep25 = self.aircraft.airframe.wing.sweep25\n    wing_dihedral = self.aircraft.airframe.wing.dihedral\n    wing_root_loc = self.aircraft.airframe.wing.root_loc\n    wing_kink_c = self.aircraft.airframe.wing.kink_c\n    wing_kink_loc = self.aircraft.airframe.wing.kink_loc\n    wing_tip_c = self.aircraft.airframe.wing.tip_c\n    wing_tip_loc = self.aircraft.airframe.wing.tip_loc\n\n    self.length = self.ref_length * self.mfw_factor\n\n    lateral_margin = self.aircraft.airframe.nacelle.lateral_margin\n\n    tan_phi0 = 0.25*(wing_kink_c-wing_tip_c)/(wing_tip_loc[1]-wing_kink_loc[1]) + np.tan(wing_sweep25)\n\n    if (self.aircraft.arrangement.nacelle_attachment == \"pods\"):\n        y_axe = 0.6 * body_width + (0.5 + lateral_margin)*tank_width\n    else:\n        y_axe = self.span_ratio * wing_tip_loc[1]\n\n    x_axe = wing_root_loc[0] + (y_axe-wing_root_loc[1])*tan_phi0 - self.x_loc_ratio*self.length\n    z_axe = wing_root_loc[2] + (y_axe-wing_root_loc[2])*np.tan(wing_dihedral) - self.z_loc_ratio*self.width\n\n    self.frame_origin = [x_axe, y_axe*self.get_side(), z_axe]\n\n    self.wing_axe_c = wing_kink_c - (wing_kink_c-wing_tip_c)/(wing_tip_loc[1]-wing_kink_loc[1])*(y_axe-wing_kink_loc[1])\n    self.wing_axe_x = wing_kink_loc[0] - (wing_kink_loc[0]-wing_tip_loc[0])/(wing_tip_loc[1]-wing_kink_loc[1])*(y_axe-wing_kink_loc[1])\n    self.wing_axe_z = wing_kink_loc[2] - (wing_kink_loc[2]-wing_tip_loc[2])/(wing_tip_loc[1]-wing_kink_loc[1])*(y_axe-wing_kink_loc[1])\n\n    self.gross_wet_area = 0.85*3.14*self.width*self.length\n    self.net_wet_area = 0.95*self.gross_wet_area\n    self.aero_length = self.length\n    self.form_factor = 1.05\n\n    # Compute fuel volume\n    self.size_fuel_tank(\"external\")\n\n    self.max_volume = self.fuel_volume\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.TankWingPod.eval_mass","title":"eval_mass","text":"<pre><code>eval_mass()\n</code></pre> <p>Estimates the geometry of the component from the aircraft requirements and statistical design laws.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def eval_mass(self):\n    fuel_type = self.aircraft.arrangement.fuel_type\n\n    # REMARK : if fuel is \"Battery\", fuel density will be battery density\n    self.fuel_density = earth.fuel_density(fuel_type, self.fuel_pressure)\n    self.mfw_volume_limited = self.max_volume*self.fuel_density\n\n    self.mass_fuel_tank(\"external\")\n\n\n    # Tank equiped structural mass\n    if self.aircraft.arrangement.fuel_type in [\"liquid_h2\",\"compressed_h2\"]:\n        self.shell_specific_mass = self.external_pod_volume*(1./self.gravimetric_index-1.)*self.volumetric_index*self.fuel_density\n    else:\n        self.shell_specific_mass = 0.\n\n    self.mass = self.structure_shell_mass + self.shell_specific_mass\n    self.cg = self.frame_origin + 0.45*np.array([self.length, 0., 0.])\n\n    self.fuel_max_fwd_cg = self.cg    # Fuel max Forward CG\n    self.fuel_max_fwd_mass = self.max_volume*self.fuel_density\n\n    self.fuel_max_bwd_cg = self.cg    # Fuel max Backward CG\n    self.fuel_max_bwd_mass = self.max_volume*self.fuel_density\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.TankWingPod.get_aero_length","title":"get_aero_length","text":"<pre><code>get_aero_length()\n</code></pre> <p>The characteristic aerodynamic length of the component (used for Reynolds number estimations for example).</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_aero_length(self):\n    \"\"\"The characteristic aerodynamic length of the component (used for Reynolds number estimations for example).\"\"\"\n    return self.aero_length\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.TankWingPod.get_cg_mwe","title":"get_cg_mwe","text":"<pre><code>get_cg_mwe()\n</code></pre> <p>Returns the position of the center of gravity of the manufacturer empty aircraft</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_cg_mwe(self):\n    \"\"\"Returns the position of the center of gravity of the manufacturer empty aircraft\"\"\"\n    return self.cg\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.TankWingPod.get_cg_owe","title":"get_cg_owe","text":"<pre><code>get_cg_owe()\n</code></pre> <p>Returns the position of the center of gravity of the operational empty aircraft</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_cg_owe(self):\n    \"\"\"Returns the position of the center of gravity of the operational empty aircraft\"\"\"\n    return self.cg\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.TankWingPod.get_form_factor","title":"get_form_factor","text":"<pre><code>get_form_factor()\n</code></pre> <p>Form factor used to estimate form drag.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_form_factor(self):\n    \"\"\"Form factor used to estimate form drag.\"\"\"\n    return self.form_factor\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.TankWingPod.get_inertia_tensor","title":"get_inertia_tensor","text":"<pre><code>get_inertia_tensor()\n</code></pre> <p>returns the inertia matrix of the component, if implemented.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_inertia_tensor(self):\n    \"\"\"returns the inertia matrix of the component, if implemented.\"\"\"\n    return self.inertia_tensor\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.TankWingPod.get_mass_mwe","title":"get_mass_mwe","text":"<pre><code>get_mass_mwe()\n</code></pre> <p>Returns the Manufacturer's Weight Empty, the mass (kg) of the component</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_mass_mwe(self):\n    \"\"\"Returns the *Manufacturer's Weight Empty*, the mass (kg) of the component\"\"\"\n    return self.mass\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.TankWingPod.get_mass_owe","title":"get_mass_owe","text":"<pre><code>get_mass_owe()\n</code></pre> <p>Returns the Operating Weight Empty, the mass (kg) of the component. Can differ from MWE for some components</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_mass_owe(self):\n    \"\"\"Returns the *Operating Weight Empty*, the mass (kg) of the component. Can differ from MWE for some components\"\"\"\n    return self.mass\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.TankWingPod.get_net_wet_area","title":"get_net_wet_area","text":"<pre><code>get_net_wet_area()\n</code></pre> <p>The net wet area of the component in contact with outer airflow, 0 if the component has no aerodynamic surface.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_net_wet_area(self):\n    \"\"\"The net wet area of the component in contact with outer airflow, 0 if the component has no aerodynamic surface.\"\"\"\n    return self.net_wet_area\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.TankWingPod.get_this_shape","title":"get_this_shape","text":"<pre><code>get_this_shape(name)\n</code></pre> <p>Contour curves for 3 view drawing nose1 : modern nose (A220, A350, 787) nose3 : classical Airbus nose nose2 : symetrical nose cone1 : classical tail cone cone2 : symetrical cone section : circle</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_this_shape(self, name): # TODO: is the docstring up to date ?\n    \"\"\"Contour curves for 3 view drawing\n    nose1 : modern nose (A220, A350, 787)\n    nose3 : classical Airbus nose\n    nose2 : symetrical nose\n    cone1 : classical tail cone\n    cone2 : symetrical cone\n    section : circle\n    \"\"\"\n    curve = {\n    \"nose1\":np.array([[ 0.0000 , 0.3339 , 0.3339 , 0.0000 ,  0.0000 ] ,\n                      [ 0.0050 , 0.3848 , 0.3084 , 0.0335 , -0.0335 ] ,\n                      [ 0.0150 , 0.4253 , 0.2881 , 0.0652 , -0.0652 ] ,\n                      [ 0.0500 , 0.5033 , 0.2490 , 0.1101 , -0.1101 ] ,\n                      [ 0.1000 , 0.5811 , 0.2100 , 0.1585 , -0.1585 ] ,\n                      [ 0.1800 , 0.6808 , 0.1600 , 0.2215 , -0.2215 ] ,\n                      [ 0.2773 , 0.7704 , 0.1151 , 0.2859 , -0.2859 ] ,\n                      [ 0.4191 , 0.8562 , 0.0721 , 0.3624 , -0.3624 ] ,\n                      [ 0.5610 , 0.9198 , 0.0402 , 0.4211 , -0.4211 ] ,\n                      [ 0.7738 , 0.9816 , 0.0092 , 0.4761 , -0.4761 ] ,\n                      [ 0.9156 , 0.9962 , 0.0019 , 0.4976 , -0.4976 ] ,\n                      [ 1.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ]]),\n\n    \"nose2\":np.array([[ 0.0000 , 0.5000 ,  0.5000 , 0.0000 ,  0.0000 ] ,\n                      [ 0.0050 , 0.5335 ,  0.4665 , 0.0335 , -0.0335 ] ,\n                      [ 0.0191 , 0.5646 ,  0.4354 , 0.0646 , -0.0646 ] ,\n                      [ 0.0624 , 0.6196 ,  0.3804 , 0.1196 , -0.1196 ] ,\n                      [ 0.1355 , 0.6878 ,  0.3122 , 0.1878 , -0.1878 ] ,\n                      [ 0.1922 , 0.7297 ,  0.2703 , 0.2297 , -0.2297 ] ,\n                      [ 0.2773 , 0.7859 ,  0.2141 , 0.2859 , -0.2859 ] ,\n                      [ 0.4191 , 0.8624 ,  0.1376 , 0.3624 , -0.3624 ] ,\n                      [ 0.5610 , 0.9211 ,  0.0789 , 0.4211 , -0.4211 ] ,\n                      [ 0.7738 , 0.9761 ,  0.0239 , 0.4761 , -0.4761 ] ,\n                      [ 0.9156 , 0.9976 ,  0.0024 , 0.4976 , -0.4976 ] ,\n                      [ 1.0000 , 1.0000 ,  0.0000 , 0.5000 , -0.5000 ]]),\n\n    \"nose3\":np.array([[ 0.0000 , 0.4453 , 0.4453 , 0.0000 ,  0.0000 ] ,\n                      [ 0.0050 , 0.4733 , 0.4112 , 0.0335 , -0.0335 ] ,\n                      [ 0.0191 , 0.5098 , 0.3833 , 0.0646 , -0.0646 ] ,\n                      [ 0.0624 , 0.5718 , 0.3188 , 0.1196 , -0.1196 ] ,\n                      [ 0.1355 , 0.6278 , 0.2531 , 0.1878 , -0.1878 ] ,\n                      [ 0.1922 , 0.7263 , 0.2142 , 0.2297 , -0.2297 ] ,\n                      [ 0.2773 , 0.8127 , 0.1631 , 0.2859 , -0.2859 ] ,\n                      [ 0.4191 , 0.8906 , 0.0962 , 0.3624 , -0.3624 ] ,\n                      [ 0.5610 , 0.9392 , 0.0536 , 0.4211 , -0.4211 ] ,\n                      [ 0.7738 , 0.9818 , 0.0122 , 0.4761 , -0.4761 ] ,\n                      [ 0.9156 , 0.9976 , 0.0025 , 0.4976 , -0.4976 ] ,\n                      [ 1.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ]]),\n\n    \"nose4\":np.array([[ 0.0000, 0.3700, 0.3700, 0.0000,  0.0000 ] ,\n                      [ 0.0050, 0.4200, 0.3200, 0.0335, -0.0335 ] ,\n                      [ 0.0150, 0.4500, 0.2900, 0.0652, -0.0652 ] ,\n                      [ 0.0500, 0.5000, 0.2400, 0.1200, -0.1200 ] ,\n                      [ 0.1000, 0.5500, 0.1900, 0.1750, -0.1750 ] ,\n                      [ 0.1800, 0.6000, 0.1400, 0.2400, -0.2400 ] ,\n                      [ 0.2773, 0.6450, 0.1000, 0.3000, -0.3000 ] ,\n                      [ 0.4191, 0.7000, 0.0500, 0.3700, -0.3700 ] ,\n                      [ 0.5610, 0.7550, 0.0250, 0.4300, -0.4300 ] ,\n                      [ 0.6200, 0.7800, 0.0180, 0.4500, -0.4500 ] ,\n                      [ 0.7700, 0.9700, 0.0090, 0.4850, -0.4850 ] ,\n                      [ 0.8100, 0.9900, 0.0060, 0.4900, -0.4900 ] ,\n                      [ 0.9100, 0.9970, 0.0030, 0.4976, -0.4976 ] ,\n                      [ 1.0000, 1.0000, 0.0000, 0.5000, -0.5000 ]]),\n\n    \"cone1\":np.array([[ 0.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ] ,\n                      [ 0.0213 , 1.0000 , 0.0082 , 0.5000 , -0.5000 ] ,\n                      [ 0.0638 , 1.0000 , 0.0230 , 0.4956 , -0.4956 ] ,\n                      [ 0.1064 , 1.0000 , 0.0393 , 0.4875 , -0.4875 ] ,\n                      [ 0.1489 , 1.0000 , 0.0556 , 0.4794 , -0.4794 ] ,\n                      [ 0.1915 , 1.0000 , 0.0786 , 0.4720 , -0.4720 ] ,\n                      [ 0.2766 , 1.0000 , 0.1334 , 0.4566 , -0.4566 ] ,\n                      [ 0.3617 , 1.0000 , 0.1964 , 0.4330 , -0.4330 ] ,\n                      [ 0.4894 , 1.0000 , 0.3024 , 0.3822 , -0.3822 ] ,\n                      [ 0.6170 , 1.0000 , 0.4159 , 0.3240 , -0.3240 ] ,\n                      [ 0.7447 , 1.0000 , 0.5374 , 0.2577 , -0.2577 ] ,\n                      [ 0.8723 , 1.0000 , 0.6627 , 0.1834 , -0.1834 ] ,\n                      [ 0.8936 , 0.9963 , 0.6901 , 0.1679 , -0.1679 ] ,\n                      [ 0.9149 , 0.9881 , 0.7139 , 0.1524 , -0.1524 ] ,\n                      [ 0.9362 , 0.9800 , 0.7413 , 0.1333 , -0.1333 ] ,\n                      [ 0.9574 , 0.9652 , 0.7687 , 0.1097 , -0.1097 ] ,\n                      [ 0.9787 , 0.9533 , 0.8043 , 0.0788 , -0.0788 ] ,\n                      [ 0.9894 , 0.9377 , 0.8280 , 0.0589 , -0.0589 ] ,\n                      [ 1.0000 , 0.9103 , 0.8784 , 0.0162 , -0.0162 ]]),\n\n    \"cone2\":np.array([[ 0.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ] ,\n                      [ 0.0213 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ] ,\n                      [ 0.0638 , 0.9956 , 0.0044 , 0.4956 , -0.4956 ] ,\n                      [ 0.1064 , 0.9875 , 0.0125 , 0.4875 , -0.4875 ] ,\n                      [ 0.1489 , 0.9794 , 0.0206 , 0.4794 , -0.4794 ] ,\n                      [ 0.1915 , 0.9720 , 0.0280 , 0.4720 , -0.4720 ] ,\n                      [ 0.2766 , 0.9566 , 0.0434 , 0.4566 , -0.4566 ] ,\n                      [ 0.3617 , 0.9330 , 0.0670 , 0.4330 , -0.4330 ] ,\n                      [ 0.4894 , 0.8822 , 0.1178 , 0.3822 , -0.3822 ] ,\n                      [ 0.6170 , 0.8240 , 0.1760 , 0.3240 , -0.3240 ] ,\n                      [ 0.7447 , 0.7577 , 0.2423 , 0.2577 , -0.2577 ] ,\n                      [ 0.8723 , 0.6834 , 0.3166 , 0.1834 , -0.1834 ] ,\n                      [ 0.8936 , 0.6679 , 0.3321 , 0.1679 , -0.1679 ] ,\n                      [ 0.9149 , 0.6524 , 0.3476 , 0.1524 , -0.1524 ] ,\n                      [ 0.9362 , 0.6333 , 0.3667 , 0.1333 , -0.1333 ] ,\n                      [ 0.9574 , 0.6097 , 0.3903 , 0.1097 , -0.1097 ] ,\n                      [ 0.9787 , 0.5788 , 0.4212 , 0.0788 , -0.0788 ] ,\n                      [ 0.9894 , 0.5589 , 0.4411 , 0.0589 , -0.0589 ] ,\n                      [ 1.0000 , 0.5162 , 0.4838 , 0.0162 , -0.0162 ]]),\n\n    \"sec1\":np.array([[  0.5000000 , 0.0000000 ,  0.0000000 ] ,\n                     [  0.4903926 , 0.0975452 , -0.0975452 ] ,\n                     [  0.4619398 , 0.1913417 , -0.1913417 ] ,\n                     [  0.4157348 , 0.2777851 , -0.2777851 ] ,\n                     [  0.3535534 , 0.3535534 , -0.3535534 ] ,\n                     [  0.2777851 , 0.4157348 , -0.4157348 ] ,\n                     [  0.1913417 , 0.4619398 , -0.4619398 ] ,\n                     [  0.0975452 , 0.4903926 , -0.4903926 ] ,\n                     [  0.0000000 , 0.5000000 , -0.5000000 ] ,\n                     [- 0.0975452 , 0.4903926 , -0.4903926 ] ,\n                     [- 0.1913417 , 0.4619398 , -0.4619398 ] ,\n                     [- 0.2777851 , 0.4157348 , -0.4157348 ] ,\n                     [- 0.3535534 , 0.3535534 , -0.3535534 ] ,\n                     [- 0.4157348 , 0.2777851 , -0.2777851 ] ,\n                     [- 0.4619398 , 0.1913417 , -0.1913417 ] ,\n                     [- 0.4903926 , 0.0975452 , -0.0975452 ] ,\n                     [- 0.5000000 , 0.0000000 ,  0.0000000 ]]),\n\n    \"sec2\":np.array([[ 0.5000000 , 0.0000000 ,  0.0000000] ,\n                     [ 0.4951963 , 0.0975452 , -0.0975452] ,\n                     [ 0.4809699 , 0.1913417 , -0.1913417] ,\n                     [ 0.4578674 , 0.2777851 , -0.2777851] ,\n                     [ 0.4267767 , 0.3535534 , -0.3535534] ,\n                     [ 0.3888926 , 0.4157348 , -0.4157348] ,\n                     [ 0.3456709 , 0.4619398 , -0.4619398] ,\n                     [ 0.2987726 , 0.4903926 , -0.4903926] ,\n                     [ 0.2500000 , 0.5000000 , -0.5000000] ,\n                     [ 0.0000000 , 0.5000000 , -0.5000000] ,\n                     [-0.2500000 , 0.5000000 , -0.5000000] ,\n                     [-0.2987726 , 0.4903926 , -0.4903926] ,\n                     [-0.3456709 , 0.4619398 , -0.4619398] ,\n                     [-0.3888926 , 0.4157348 , -0.4157348] ,\n                     [-0.4267767 , 0.3535534 , -0.3535534] ,\n                     [-0.4578674 , 0.2777851 , -0.2777851] ,\n                     [-0.4809699 , 0.1913417 , -0.1913417] ,\n                     [-0.4951963 , 0.0975452 , -0.0975452] ,\n                     [-0.5000000 , 0.0000000 ,  0.0000000]])}\n\n    return [curve[n] for n in name]\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.VtpClassic","title":"VtpClassic","text":"<pre><code>VtpClassic(aircraft)\n</code></pre> <p>               Bases: <code>Vstab</code></p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def __init__(self, aircraft):\n    super(VtpClassic, self).__init__(aircraft)\n\n    wing_area = aircraft.airframe.wing.area\n\n    self.area = 0.20*wing_area  # Design variable for hq_optim\n    self.height = None\n    self.aspect_ratio = aircraft.get_init(self,\"aspect_ratio\")\n    self.taper_ratio = aircraft.get_init(self,\"taper_ratio\")\n    self.toc = aircraft.get_init(self,\"toc\")\n    self.sweep25 = aircraft.get_init(self,\"sweep25\", val=self.__sweep25())\n    self.thrust_volume_factor = aircraft.get_init(self,\"thrust_volume_factor\")\n    self.wing_volume_factor = aircraft.get_init(self,\"wing_volume_factor\")\n    self.anchor_ratio = aircraft.get_init(self,\"anchor_ratio\")\n    self.lever_arm = None\n\n    self.root_loc = np.full(3,None)     # Position of root chord leading edge\n    self.root_c = None                  # root chord length\n\n    self.tip_loc = np.full(3,None)      # Position of tip chord leading edge\n    self.tip_c = None                   # tip chord length\n\n    self.mac_loc = np.full(3,None)      # Position of MAC chord leading edge\n    self.mac = None\n\n    self.mass_correction_factor = aircraft.get_init(self,\"mass_correction_factor\")\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.VtpClassic-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.VtpClassic.eval_aero_data","title":"eval_aero_data","text":"<pre><code>eval_aero_data()\n</code></pre> <p>WARNING : output values are in Wing reference area</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def eval_aero_data(self):\n    \"\"\"WARNING : output values are in Wing reference area\n    \"\"\"\n    wing_area = self.aircraft.airframe.wing.area\n    cyb_vtp =  (np.pi*self.aspect_ratio)/(1+np.sqrt(1+(self.aspect_ratio/2)**2))*(self.area/wing_area)   # Helmbold formula\n    xlc_vtp = self.mac_loc[0] + 0.25*self.mac   # Position of VTP center of lift\n    aoa_max_vtp = unit.rad_deg(30.)             # Maximum angle of attack allowed for VTP\n    ki_vtp = 1.3/(np.pi*self.aspect_ratio)      # VTP induced drag coefficient\n    return cyb_vtp, xlc_vtp, aoa_max_vtp, ki_vtp\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.VtpClassic.eval_geometry","title":"eval_geometry","text":"<pre><code>eval_geometry()\n</code></pre> <p>Estimates the geometry of the component from the aircraft requirements and statistical design laws.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def eval_geometry(self):\n    body_length = self.aircraft.airframe.body.length\n    body_height = self.aircraft.airframe.body.height\n    tail_cone_length = self.aircraft.airframe.body.tail_cone_length\n    wing_mac_loc = self.aircraft.airframe.wing.mac_loc\n    wing_mac = self.aircraft.airframe.wing.mac\n\n    self.height = np.sqrt(self.aspect_ratio*self.area)\n    self.root_c = 2*self.area/(self.height*(1+self.taper_ratio))\n    self.tip_c = self.taper_ratio*self.root_c\n\n    x_root = body_length*(1-tail_cone_length/body_length*(1-self.anchor_ratio)) - self.root_c\n    x_tip = x_root + 0.25*(self.root_c-self.tip_c) + self.height*np.tan(self.sweep25)\n\n    y_root = 0.\n    y_tip = 0.\n\n    z_root = body_height\n    z_tip = z_root + self.height\n\n    self.mac = self.height*(self.root_c**2+self.tip_c**2+self.root_c*self.tip_c)/(3*self.area)\n    x_mac = x_root+(x_tip-x_root)*self.height*(2*self.tip_c+self.root_c)/(6*self.area)\n    y_mac = 0.\n    z_mac = z_tip**2*(2*self.tip_c+self.root_c)/(6*self.area)\n\n    self.lever_arm = (x_mac + 0.25*self.mac) - (wing_mac_loc[0] + 0.25*wing_mac)\n\n    self.root_loc = np.array([x_root, y_root, z_root])\n    self.tip_loc = np.array([x_tip, y_tip, z_tip])\n    self.mac_loc = np.array([x_mac, y_mac, z_mac])\n\n    self.frame_origin = [x_root, 0., z_root]\n\n    self.gross_wet_area = 2.01*self.area\n    self.net_wet_area = self.gross_wet_area\n\n    self.aero_length = self.mac\n    self.form_factor = 1.40\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.VtpClassic.eval_mass","title":"eval_mass","text":"<pre><code>eval_mass()\n</code></pre> <p>Estimates the geometry of the component from the aircraft requirements and statistical design laws.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def eval_mass(self):\n    self.mass = self.mass_correction_factor * 25. * self.area\n    self.cg = self.mac_loc + 0.20*np.array([self.mac, 0., 0.])\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.VtpClassic.get_aero_length","title":"get_aero_length","text":"<pre><code>get_aero_length()\n</code></pre> <p>The characteristic aerodynamic length of the component (used for Reynolds number estimations for example).</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_aero_length(self):\n    \"\"\"The characteristic aerodynamic length of the component (used for Reynolds number estimations for example).\"\"\"\n    return self.aero_length\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.VtpClassic.get_cg_mwe","title":"get_cg_mwe","text":"<pre><code>get_cg_mwe()\n</code></pre> <p>Returns the position of the center of gravity of the manufacturer empty aircraft</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_cg_mwe(self):\n    \"\"\"Returns the position of the center of gravity of the manufacturer empty aircraft\"\"\"\n    return self.cg\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.VtpClassic.get_cg_owe","title":"get_cg_owe","text":"<pre><code>get_cg_owe()\n</code></pre> <p>Returns the position of the center of gravity of the operational empty aircraft</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_cg_owe(self):\n    \"\"\"Returns the position of the center of gravity of the operational empty aircraft\"\"\"\n    return self.cg\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.VtpClassic.get_form_factor","title":"get_form_factor","text":"<pre><code>get_form_factor()\n</code></pre> <p>Form factor used to estimate form drag.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_form_factor(self):\n    \"\"\"Form factor used to estimate form drag.\"\"\"\n    return self.form_factor\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.VtpClassic.get_inertia_tensor","title":"get_inertia_tensor","text":"<pre><code>get_inertia_tensor()\n</code></pre> <p>returns the inertia matrix of the component, if implemented.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_inertia_tensor(self):\n    \"\"\"returns the inertia matrix of the component, if implemented.\"\"\"\n    return self.inertia_tensor\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.VtpClassic.get_mass_mwe","title":"get_mass_mwe","text":"<pre><code>get_mass_mwe()\n</code></pre> <p>Returns the Manufacturer's Weight Empty, the mass (kg) of the component</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_mass_mwe(self):\n    \"\"\"Returns the *Manufacturer's Weight Empty*, the mass (kg) of the component\"\"\"\n    return self.mass\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.VtpClassic.get_mass_owe","title":"get_mass_owe","text":"<pre><code>get_mass_owe()\n</code></pre> <p>Returns the Operating Weight Empty, the mass (kg) of the component. Can differ from MWE for some components</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_mass_owe(self):\n    \"\"\"Returns the *Operating Weight Empty*, the mass (kg) of the component. Can differ from MWE for some components\"\"\"\n    return self.mass\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.VtpClassic.get_net_wet_area","title":"get_net_wet_area","text":"<pre><code>get_net_wet_area()\n</code></pre> <p>The net wet area of the component in contact with outer airflow, 0 if the component has no aerodynamic surface.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_net_wet_area(self):\n    \"\"\"The net wet area of the component in contact with outer airflow, 0 if the component has no aerodynamic surface.\"\"\"\n    return self.net_wet_area\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.VtpClassic.get_this_shape","title":"get_this_shape","text":"<pre><code>get_this_shape(name)\n</code></pre> <p>Contour curves for 3 view drawing nose1 : modern nose (A220, A350, 787) nose3 : classical Airbus nose nose2 : symetrical nose cone1 : classical tail cone cone2 : symetrical cone section : circle</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_this_shape(self, name): # TODO: is the docstring up to date ?\n    \"\"\"Contour curves for 3 view drawing\n    nose1 : modern nose (A220, A350, 787)\n    nose3 : classical Airbus nose\n    nose2 : symetrical nose\n    cone1 : classical tail cone\n    cone2 : symetrical cone\n    section : circle\n    \"\"\"\n    curve = {\n    \"nose1\":np.array([[ 0.0000 , 0.3339 , 0.3339 , 0.0000 ,  0.0000 ] ,\n                      [ 0.0050 , 0.3848 , 0.3084 , 0.0335 , -0.0335 ] ,\n                      [ 0.0150 , 0.4253 , 0.2881 , 0.0652 , -0.0652 ] ,\n                      [ 0.0500 , 0.5033 , 0.2490 , 0.1101 , -0.1101 ] ,\n                      [ 0.1000 , 0.5811 , 0.2100 , 0.1585 , -0.1585 ] ,\n                      [ 0.1800 , 0.6808 , 0.1600 , 0.2215 , -0.2215 ] ,\n                      [ 0.2773 , 0.7704 , 0.1151 , 0.2859 , -0.2859 ] ,\n                      [ 0.4191 , 0.8562 , 0.0721 , 0.3624 , -0.3624 ] ,\n                      [ 0.5610 , 0.9198 , 0.0402 , 0.4211 , -0.4211 ] ,\n                      [ 0.7738 , 0.9816 , 0.0092 , 0.4761 , -0.4761 ] ,\n                      [ 0.9156 , 0.9962 , 0.0019 , 0.4976 , -0.4976 ] ,\n                      [ 1.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ]]),\n\n    \"nose2\":np.array([[ 0.0000 , 0.5000 ,  0.5000 , 0.0000 ,  0.0000 ] ,\n                      [ 0.0050 , 0.5335 ,  0.4665 , 0.0335 , -0.0335 ] ,\n                      [ 0.0191 , 0.5646 ,  0.4354 , 0.0646 , -0.0646 ] ,\n                      [ 0.0624 , 0.6196 ,  0.3804 , 0.1196 , -0.1196 ] ,\n                      [ 0.1355 , 0.6878 ,  0.3122 , 0.1878 , -0.1878 ] ,\n                      [ 0.1922 , 0.7297 ,  0.2703 , 0.2297 , -0.2297 ] ,\n                      [ 0.2773 , 0.7859 ,  0.2141 , 0.2859 , -0.2859 ] ,\n                      [ 0.4191 , 0.8624 ,  0.1376 , 0.3624 , -0.3624 ] ,\n                      [ 0.5610 , 0.9211 ,  0.0789 , 0.4211 , -0.4211 ] ,\n                      [ 0.7738 , 0.9761 ,  0.0239 , 0.4761 , -0.4761 ] ,\n                      [ 0.9156 , 0.9976 ,  0.0024 , 0.4976 , -0.4976 ] ,\n                      [ 1.0000 , 1.0000 ,  0.0000 , 0.5000 , -0.5000 ]]),\n\n    \"nose3\":np.array([[ 0.0000 , 0.4453 , 0.4453 , 0.0000 ,  0.0000 ] ,\n                      [ 0.0050 , 0.4733 , 0.4112 , 0.0335 , -0.0335 ] ,\n                      [ 0.0191 , 0.5098 , 0.3833 , 0.0646 , -0.0646 ] ,\n                      [ 0.0624 , 0.5718 , 0.3188 , 0.1196 , -0.1196 ] ,\n                      [ 0.1355 , 0.6278 , 0.2531 , 0.1878 , -0.1878 ] ,\n                      [ 0.1922 , 0.7263 , 0.2142 , 0.2297 , -0.2297 ] ,\n                      [ 0.2773 , 0.8127 , 0.1631 , 0.2859 , -0.2859 ] ,\n                      [ 0.4191 , 0.8906 , 0.0962 , 0.3624 , -0.3624 ] ,\n                      [ 0.5610 , 0.9392 , 0.0536 , 0.4211 , -0.4211 ] ,\n                      [ 0.7738 , 0.9818 , 0.0122 , 0.4761 , -0.4761 ] ,\n                      [ 0.9156 , 0.9976 , 0.0025 , 0.4976 , -0.4976 ] ,\n                      [ 1.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ]]),\n\n    \"nose4\":np.array([[ 0.0000, 0.3700, 0.3700, 0.0000,  0.0000 ] ,\n                      [ 0.0050, 0.4200, 0.3200, 0.0335, -0.0335 ] ,\n                      [ 0.0150, 0.4500, 0.2900, 0.0652, -0.0652 ] ,\n                      [ 0.0500, 0.5000, 0.2400, 0.1200, -0.1200 ] ,\n                      [ 0.1000, 0.5500, 0.1900, 0.1750, -0.1750 ] ,\n                      [ 0.1800, 0.6000, 0.1400, 0.2400, -0.2400 ] ,\n                      [ 0.2773, 0.6450, 0.1000, 0.3000, -0.3000 ] ,\n                      [ 0.4191, 0.7000, 0.0500, 0.3700, -0.3700 ] ,\n                      [ 0.5610, 0.7550, 0.0250, 0.4300, -0.4300 ] ,\n                      [ 0.6200, 0.7800, 0.0180, 0.4500, -0.4500 ] ,\n                      [ 0.7700, 0.9700, 0.0090, 0.4850, -0.4850 ] ,\n                      [ 0.8100, 0.9900, 0.0060, 0.4900, -0.4900 ] ,\n                      [ 0.9100, 0.9970, 0.0030, 0.4976, -0.4976 ] ,\n                      [ 1.0000, 1.0000, 0.0000, 0.5000, -0.5000 ]]),\n\n    \"cone1\":np.array([[ 0.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ] ,\n                      [ 0.0213 , 1.0000 , 0.0082 , 0.5000 , -0.5000 ] ,\n                      [ 0.0638 , 1.0000 , 0.0230 , 0.4956 , -0.4956 ] ,\n                      [ 0.1064 , 1.0000 , 0.0393 , 0.4875 , -0.4875 ] ,\n                      [ 0.1489 , 1.0000 , 0.0556 , 0.4794 , -0.4794 ] ,\n                      [ 0.1915 , 1.0000 , 0.0786 , 0.4720 , -0.4720 ] ,\n                      [ 0.2766 , 1.0000 , 0.1334 , 0.4566 , -0.4566 ] ,\n                      [ 0.3617 , 1.0000 , 0.1964 , 0.4330 , -0.4330 ] ,\n                      [ 0.4894 , 1.0000 , 0.3024 , 0.3822 , -0.3822 ] ,\n                      [ 0.6170 , 1.0000 , 0.4159 , 0.3240 , -0.3240 ] ,\n                      [ 0.7447 , 1.0000 , 0.5374 , 0.2577 , -0.2577 ] ,\n                      [ 0.8723 , 1.0000 , 0.6627 , 0.1834 , -0.1834 ] ,\n                      [ 0.8936 , 0.9963 , 0.6901 , 0.1679 , -0.1679 ] ,\n                      [ 0.9149 , 0.9881 , 0.7139 , 0.1524 , -0.1524 ] ,\n                      [ 0.9362 , 0.9800 , 0.7413 , 0.1333 , -0.1333 ] ,\n                      [ 0.9574 , 0.9652 , 0.7687 , 0.1097 , -0.1097 ] ,\n                      [ 0.9787 , 0.9533 , 0.8043 , 0.0788 , -0.0788 ] ,\n                      [ 0.9894 , 0.9377 , 0.8280 , 0.0589 , -0.0589 ] ,\n                      [ 1.0000 , 0.9103 , 0.8784 , 0.0162 , -0.0162 ]]),\n\n    \"cone2\":np.array([[ 0.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ] ,\n                      [ 0.0213 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ] ,\n                      [ 0.0638 , 0.9956 , 0.0044 , 0.4956 , -0.4956 ] ,\n                      [ 0.1064 , 0.9875 , 0.0125 , 0.4875 , -0.4875 ] ,\n                      [ 0.1489 , 0.9794 , 0.0206 , 0.4794 , -0.4794 ] ,\n                      [ 0.1915 , 0.9720 , 0.0280 , 0.4720 , -0.4720 ] ,\n                      [ 0.2766 , 0.9566 , 0.0434 , 0.4566 , -0.4566 ] ,\n                      [ 0.3617 , 0.9330 , 0.0670 , 0.4330 , -0.4330 ] ,\n                      [ 0.4894 , 0.8822 , 0.1178 , 0.3822 , -0.3822 ] ,\n                      [ 0.6170 , 0.8240 , 0.1760 , 0.3240 , -0.3240 ] ,\n                      [ 0.7447 , 0.7577 , 0.2423 , 0.2577 , -0.2577 ] ,\n                      [ 0.8723 , 0.6834 , 0.3166 , 0.1834 , -0.1834 ] ,\n                      [ 0.8936 , 0.6679 , 0.3321 , 0.1679 , -0.1679 ] ,\n                      [ 0.9149 , 0.6524 , 0.3476 , 0.1524 , -0.1524 ] ,\n                      [ 0.9362 , 0.6333 , 0.3667 , 0.1333 , -0.1333 ] ,\n                      [ 0.9574 , 0.6097 , 0.3903 , 0.1097 , -0.1097 ] ,\n                      [ 0.9787 , 0.5788 , 0.4212 , 0.0788 , -0.0788 ] ,\n                      [ 0.9894 , 0.5589 , 0.4411 , 0.0589 , -0.0589 ] ,\n                      [ 1.0000 , 0.5162 , 0.4838 , 0.0162 , -0.0162 ]]),\n\n    \"sec1\":np.array([[  0.5000000 , 0.0000000 ,  0.0000000 ] ,\n                     [  0.4903926 , 0.0975452 , -0.0975452 ] ,\n                     [  0.4619398 , 0.1913417 , -0.1913417 ] ,\n                     [  0.4157348 , 0.2777851 , -0.2777851 ] ,\n                     [  0.3535534 , 0.3535534 , -0.3535534 ] ,\n                     [  0.2777851 , 0.4157348 , -0.4157348 ] ,\n                     [  0.1913417 , 0.4619398 , -0.4619398 ] ,\n                     [  0.0975452 , 0.4903926 , -0.4903926 ] ,\n                     [  0.0000000 , 0.5000000 , -0.5000000 ] ,\n                     [- 0.0975452 , 0.4903926 , -0.4903926 ] ,\n                     [- 0.1913417 , 0.4619398 , -0.4619398 ] ,\n                     [- 0.2777851 , 0.4157348 , -0.4157348 ] ,\n                     [- 0.3535534 , 0.3535534 , -0.3535534 ] ,\n                     [- 0.4157348 , 0.2777851 , -0.2777851 ] ,\n                     [- 0.4619398 , 0.1913417 , -0.1913417 ] ,\n                     [- 0.4903926 , 0.0975452 , -0.0975452 ] ,\n                     [- 0.5000000 , 0.0000000 ,  0.0000000 ]]),\n\n    \"sec2\":np.array([[ 0.5000000 , 0.0000000 ,  0.0000000] ,\n                     [ 0.4951963 , 0.0975452 , -0.0975452] ,\n                     [ 0.4809699 , 0.1913417 , -0.1913417] ,\n                     [ 0.4578674 , 0.2777851 , -0.2777851] ,\n                     [ 0.4267767 , 0.3535534 , -0.3535534] ,\n                     [ 0.3888926 , 0.4157348 , -0.4157348] ,\n                     [ 0.3456709 , 0.4619398 , -0.4619398] ,\n                     [ 0.2987726 , 0.4903926 , -0.4903926] ,\n                     [ 0.2500000 , 0.5000000 , -0.5000000] ,\n                     [ 0.0000000 , 0.5000000 , -0.5000000] ,\n                     [-0.2500000 , 0.5000000 , -0.5000000] ,\n                     [-0.2987726 , 0.4903926 , -0.4903926] ,\n                     [-0.3456709 , 0.4619398 , -0.4619398] ,\n                     [-0.3888926 , 0.4157348 , -0.4157348] ,\n                     [-0.4267767 , 0.3535534 , -0.3535534] ,\n                     [-0.4578674 , 0.2777851 , -0.2777851] ,\n                     [-0.4809699 , 0.1913417 , -0.1913417] ,\n                     [-0.4951963 , 0.0975452 , -0.0975452] ,\n                     [-0.5000000 , 0.0000000 ,  0.0000000]])}\n\n    return [curve[n] for n in name]\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.VtpHtail","title":"VtpHtail","text":"<pre><code>VtpHtail(aircraft, side)\n</code></pre> <p>               Bases: <code>Vstab</code></p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def __init__(self, aircraft, side):\n    super(VtpHtail, self).__init__(aircraft)\n\n    self.airplane_side = side\n\n    wing_area = aircraft.airframe.wing.area\n\n    self.area = 0.10*wing_area  # Design variable for hq_optim\n    self.height = None\n    self.aspect_ratio = aircraft.get_init(self,\"aspect_ratio\")\n    self.taper_ratio = aircraft.get_init(self,\"taper_ratio\")\n    self.toc = aircraft.get_init(self,\"toc\")\n    self.sweep25 = aircraft.get_init(self,\"sweep25\", val=self.__sweep25())\n    self.thrust_volume_factor = aircraft.get_init(self,\"thrust_volume_factor\")\n    self.wing_volume_factor = aircraft.get_init(self,\"wing_volume_factor\")\n    self.lever_arm = None\n\n    self.root_loc = np.full(3,None)     # Position of root chord leading edge\n    self.root_c = None                  # root chord length\n\n    self.tip_loc = np.full(3,None)      # Position of tip chord leading edge\n    self.tip_c = None                   # tip chord length\n\n    self.mac_loc = np.full(3,None)      # Position of MAC chord leading edge\n    self.mac = None\n\n    self.mass_correction_factor = aircraft.get_init(self,\"mass_correction_factor\")\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.VtpHtail-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.VtpHtail.eval_aero_data","title":"eval_aero_data","text":"<pre><code>eval_aero_data()\n</code></pre> <p>WARNING : output values are in Wing reference area</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def eval_aero_data(self):\n    \"\"\"WARNING : output values are in Wing reference area\n    \"\"\"\n    wing_area = self.aircraft.airframe.wing.area\n    cyb_vtp =  (np.pi*self.aspect_ratio)/(1+np.sqrt(1+(self.aspect_ratio/2)**2))*(self.area/wing_area)   # Helmbold formula\n    xlc_vtp = self.mac_loc[0] + 0.25*self.mac   # Position of VTP center of lift\n    aoa_max_vtp = unit.rad_deg(35.)             # Maximum angle of attack allowed for VTP\n    ki_vtp = 1.3/(np.pi*self.aspect_ratio)      # VTP induced drag coefficient\n    return cyb_vtp, xlc_vtp, aoa_max_vtp, ki_vtp\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.VtpHtail.eval_geometry","title":"eval_geometry","text":"<pre><code>eval_geometry()\n</code></pre> <p>Estimates the geometry of the component from the aircraft requirements and statistical design laws.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def eval_geometry(self):\n    htp_tip_loc = self.aircraft.airframe.horizontal_stab.tip_loc\n    wing_mac_loc = self.aircraft.airframe.wing.mac_loc\n    wing_mac = self.aircraft.airframe.wing.mac\n\n    self.height = np.sqrt(self.aspect_ratio*(self.area))\n    self.root_c = 2*(self.area)/(self.height*(1+self.taper_ratio))\n    self.tip_c = self.taper_ratio*self.root_c\n\n    x_root = htp_tip_loc[0]\n    x_tip = x_root + 0.25*(self.root_c-self.tip_c) + self.height*np.tan(self.sweep25)\n\n    y_root = htp_tip_loc[1]\n    y_tip = htp_tip_loc[1]\n\n    z_root = htp_tip_loc[2]\n    z_tip = z_root + self.height\n\n    self.mac = self.height*(self.root_c**2+self.tip_c**2+self.root_c*self.tip_c)/(3*(self.area))\n    x_mac = x_root+(x_tip-x_root)*self.height*(2*self.tip_c+self.root_c)/(6*(self.area))\n    y_mac = y_tip\n    z_mac = z_tip**2*(2*self.tip_c+self.root_c)/(6*self.area)\n\n    self.lever_arm = (x_mac + 0.25*self.mac) - (wing_mac_loc[0] + 0.25*wing_mac)\n\n    self.root_loc = np.array([x_root, y_root*self.get_side(), z_root])\n    self.tip_loc = np.array([x_tip, y_tip*self.get_side(), z_tip])\n    self.mac_loc = np.array([x_mac, y_mac*self.get_side(), z_mac])\n\n    self.frame_origin = [x_root, y_root, z_root]\n\n    self.gross_wet_area = 2.01*self.area\n    self.net_wet_area = self.gross_wet_area\n\n    self.aero_length = self.mac\n    self.form_factor = 1.40\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.VtpHtail.eval_mass","title":"eval_mass","text":"<pre><code>eval_mass()\n</code></pre> <p>Estimates the geometry of the component from the aircraft requirements and statistical design laws.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def eval_mass(self):\n    self.mass = self.mass_correction_factor * 25. * self.area\n    self.cg = self.mac_loc + 0.20*np.array([self.mac, 0., 0.])\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.VtpHtail.get_aero_length","title":"get_aero_length","text":"<pre><code>get_aero_length()\n</code></pre> <p>The characteristic aerodynamic length of the component (used for Reynolds number estimations for example).</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_aero_length(self):\n    \"\"\"The characteristic aerodynamic length of the component (used for Reynolds number estimations for example).\"\"\"\n    return self.aero_length\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.VtpHtail.get_cg_mwe","title":"get_cg_mwe","text":"<pre><code>get_cg_mwe()\n</code></pre> <p>Returns the position of the center of gravity of the manufacturer empty aircraft</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_cg_mwe(self):\n    \"\"\"Returns the position of the center of gravity of the manufacturer empty aircraft\"\"\"\n    return self.cg\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.VtpHtail.get_cg_owe","title":"get_cg_owe","text":"<pre><code>get_cg_owe()\n</code></pre> <p>Returns the position of the center of gravity of the operational empty aircraft</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_cg_owe(self):\n    \"\"\"Returns the position of the center of gravity of the operational empty aircraft\"\"\"\n    return self.cg\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.VtpHtail.get_form_factor","title":"get_form_factor","text":"<pre><code>get_form_factor()\n</code></pre> <p>Form factor used to estimate form drag.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_form_factor(self):\n    \"\"\"Form factor used to estimate form drag.\"\"\"\n    return self.form_factor\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.VtpHtail.get_inertia_tensor","title":"get_inertia_tensor","text":"<pre><code>get_inertia_tensor()\n</code></pre> <p>returns the inertia matrix of the component, if implemented.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_inertia_tensor(self):\n    \"\"\"returns the inertia matrix of the component, if implemented.\"\"\"\n    return self.inertia_tensor\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.VtpHtail.get_mass_mwe","title":"get_mass_mwe","text":"<pre><code>get_mass_mwe()\n</code></pre> <p>Returns the Manufacturer's Weight Empty, the mass (kg) of the component</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_mass_mwe(self):\n    \"\"\"Returns the *Manufacturer's Weight Empty*, the mass (kg) of the component\"\"\"\n    return self.mass\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.VtpHtail.get_mass_owe","title":"get_mass_owe","text":"<pre><code>get_mass_owe()\n</code></pre> <p>Returns the Operating Weight Empty, the mass (kg) of the component. Can differ from MWE for some components</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_mass_owe(self):\n    \"\"\"Returns the *Operating Weight Empty*, the mass (kg) of the component. Can differ from MWE for some components\"\"\"\n    return self.mass\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.VtpHtail.get_net_wet_area","title":"get_net_wet_area","text":"<pre><code>get_net_wet_area()\n</code></pre> <p>The net wet area of the component in contact with outer airflow, 0 if the component has no aerodynamic surface.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_net_wet_area(self):\n    \"\"\"The net wet area of the component in contact with outer airflow, 0 if the component has no aerodynamic surface.\"\"\"\n    return self.net_wet_area\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.VtpHtail.get_this_shape","title":"get_this_shape","text":"<pre><code>get_this_shape(name)\n</code></pre> <p>Contour curves for 3 view drawing nose1 : modern nose (A220, A350, 787) nose3 : classical Airbus nose nose2 : symetrical nose cone1 : classical tail cone cone2 : symetrical cone section : circle</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_this_shape(self, name): # TODO: is the docstring up to date ?\n    \"\"\"Contour curves for 3 view drawing\n    nose1 : modern nose (A220, A350, 787)\n    nose3 : classical Airbus nose\n    nose2 : symetrical nose\n    cone1 : classical tail cone\n    cone2 : symetrical cone\n    section : circle\n    \"\"\"\n    curve = {\n    \"nose1\":np.array([[ 0.0000 , 0.3339 , 0.3339 , 0.0000 ,  0.0000 ] ,\n                      [ 0.0050 , 0.3848 , 0.3084 , 0.0335 , -0.0335 ] ,\n                      [ 0.0150 , 0.4253 , 0.2881 , 0.0652 , -0.0652 ] ,\n                      [ 0.0500 , 0.5033 , 0.2490 , 0.1101 , -0.1101 ] ,\n                      [ 0.1000 , 0.5811 , 0.2100 , 0.1585 , -0.1585 ] ,\n                      [ 0.1800 , 0.6808 , 0.1600 , 0.2215 , -0.2215 ] ,\n                      [ 0.2773 , 0.7704 , 0.1151 , 0.2859 , -0.2859 ] ,\n                      [ 0.4191 , 0.8562 , 0.0721 , 0.3624 , -0.3624 ] ,\n                      [ 0.5610 , 0.9198 , 0.0402 , 0.4211 , -0.4211 ] ,\n                      [ 0.7738 , 0.9816 , 0.0092 , 0.4761 , -0.4761 ] ,\n                      [ 0.9156 , 0.9962 , 0.0019 , 0.4976 , -0.4976 ] ,\n                      [ 1.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ]]),\n\n    \"nose2\":np.array([[ 0.0000 , 0.5000 ,  0.5000 , 0.0000 ,  0.0000 ] ,\n                      [ 0.0050 , 0.5335 ,  0.4665 , 0.0335 , -0.0335 ] ,\n                      [ 0.0191 , 0.5646 ,  0.4354 , 0.0646 , -0.0646 ] ,\n                      [ 0.0624 , 0.6196 ,  0.3804 , 0.1196 , -0.1196 ] ,\n                      [ 0.1355 , 0.6878 ,  0.3122 , 0.1878 , -0.1878 ] ,\n                      [ 0.1922 , 0.7297 ,  0.2703 , 0.2297 , -0.2297 ] ,\n                      [ 0.2773 , 0.7859 ,  0.2141 , 0.2859 , -0.2859 ] ,\n                      [ 0.4191 , 0.8624 ,  0.1376 , 0.3624 , -0.3624 ] ,\n                      [ 0.5610 , 0.9211 ,  0.0789 , 0.4211 , -0.4211 ] ,\n                      [ 0.7738 , 0.9761 ,  0.0239 , 0.4761 , -0.4761 ] ,\n                      [ 0.9156 , 0.9976 ,  0.0024 , 0.4976 , -0.4976 ] ,\n                      [ 1.0000 , 1.0000 ,  0.0000 , 0.5000 , -0.5000 ]]),\n\n    \"nose3\":np.array([[ 0.0000 , 0.4453 , 0.4453 , 0.0000 ,  0.0000 ] ,\n                      [ 0.0050 , 0.4733 , 0.4112 , 0.0335 , -0.0335 ] ,\n                      [ 0.0191 , 0.5098 , 0.3833 , 0.0646 , -0.0646 ] ,\n                      [ 0.0624 , 0.5718 , 0.3188 , 0.1196 , -0.1196 ] ,\n                      [ 0.1355 , 0.6278 , 0.2531 , 0.1878 , -0.1878 ] ,\n                      [ 0.1922 , 0.7263 , 0.2142 , 0.2297 , -0.2297 ] ,\n                      [ 0.2773 , 0.8127 , 0.1631 , 0.2859 , -0.2859 ] ,\n                      [ 0.4191 , 0.8906 , 0.0962 , 0.3624 , -0.3624 ] ,\n                      [ 0.5610 , 0.9392 , 0.0536 , 0.4211 , -0.4211 ] ,\n                      [ 0.7738 , 0.9818 , 0.0122 , 0.4761 , -0.4761 ] ,\n                      [ 0.9156 , 0.9976 , 0.0025 , 0.4976 , -0.4976 ] ,\n                      [ 1.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ]]),\n\n    \"nose4\":np.array([[ 0.0000, 0.3700, 0.3700, 0.0000,  0.0000 ] ,\n                      [ 0.0050, 0.4200, 0.3200, 0.0335, -0.0335 ] ,\n                      [ 0.0150, 0.4500, 0.2900, 0.0652, -0.0652 ] ,\n                      [ 0.0500, 0.5000, 0.2400, 0.1200, -0.1200 ] ,\n                      [ 0.1000, 0.5500, 0.1900, 0.1750, -0.1750 ] ,\n                      [ 0.1800, 0.6000, 0.1400, 0.2400, -0.2400 ] ,\n                      [ 0.2773, 0.6450, 0.1000, 0.3000, -0.3000 ] ,\n                      [ 0.4191, 0.7000, 0.0500, 0.3700, -0.3700 ] ,\n                      [ 0.5610, 0.7550, 0.0250, 0.4300, -0.4300 ] ,\n                      [ 0.6200, 0.7800, 0.0180, 0.4500, -0.4500 ] ,\n                      [ 0.7700, 0.9700, 0.0090, 0.4850, -0.4850 ] ,\n                      [ 0.8100, 0.9900, 0.0060, 0.4900, -0.4900 ] ,\n                      [ 0.9100, 0.9970, 0.0030, 0.4976, -0.4976 ] ,\n                      [ 1.0000, 1.0000, 0.0000, 0.5000, -0.5000 ]]),\n\n    \"cone1\":np.array([[ 0.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ] ,\n                      [ 0.0213 , 1.0000 , 0.0082 , 0.5000 , -0.5000 ] ,\n                      [ 0.0638 , 1.0000 , 0.0230 , 0.4956 , -0.4956 ] ,\n                      [ 0.1064 , 1.0000 , 0.0393 , 0.4875 , -0.4875 ] ,\n                      [ 0.1489 , 1.0000 , 0.0556 , 0.4794 , -0.4794 ] ,\n                      [ 0.1915 , 1.0000 , 0.0786 , 0.4720 , -0.4720 ] ,\n                      [ 0.2766 , 1.0000 , 0.1334 , 0.4566 , -0.4566 ] ,\n                      [ 0.3617 , 1.0000 , 0.1964 , 0.4330 , -0.4330 ] ,\n                      [ 0.4894 , 1.0000 , 0.3024 , 0.3822 , -0.3822 ] ,\n                      [ 0.6170 , 1.0000 , 0.4159 , 0.3240 , -0.3240 ] ,\n                      [ 0.7447 , 1.0000 , 0.5374 , 0.2577 , -0.2577 ] ,\n                      [ 0.8723 , 1.0000 , 0.6627 , 0.1834 , -0.1834 ] ,\n                      [ 0.8936 , 0.9963 , 0.6901 , 0.1679 , -0.1679 ] ,\n                      [ 0.9149 , 0.9881 , 0.7139 , 0.1524 , -0.1524 ] ,\n                      [ 0.9362 , 0.9800 , 0.7413 , 0.1333 , -0.1333 ] ,\n                      [ 0.9574 , 0.9652 , 0.7687 , 0.1097 , -0.1097 ] ,\n                      [ 0.9787 , 0.9533 , 0.8043 , 0.0788 , -0.0788 ] ,\n                      [ 0.9894 , 0.9377 , 0.8280 , 0.0589 , -0.0589 ] ,\n                      [ 1.0000 , 0.9103 , 0.8784 , 0.0162 , -0.0162 ]]),\n\n    \"cone2\":np.array([[ 0.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ] ,\n                      [ 0.0213 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ] ,\n                      [ 0.0638 , 0.9956 , 0.0044 , 0.4956 , -0.4956 ] ,\n                      [ 0.1064 , 0.9875 , 0.0125 , 0.4875 , -0.4875 ] ,\n                      [ 0.1489 , 0.9794 , 0.0206 , 0.4794 , -0.4794 ] ,\n                      [ 0.1915 , 0.9720 , 0.0280 , 0.4720 , -0.4720 ] ,\n                      [ 0.2766 , 0.9566 , 0.0434 , 0.4566 , -0.4566 ] ,\n                      [ 0.3617 , 0.9330 , 0.0670 , 0.4330 , -0.4330 ] ,\n                      [ 0.4894 , 0.8822 , 0.1178 , 0.3822 , -0.3822 ] ,\n                      [ 0.6170 , 0.8240 , 0.1760 , 0.3240 , -0.3240 ] ,\n                      [ 0.7447 , 0.7577 , 0.2423 , 0.2577 , -0.2577 ] ,\n                      [ 0.8723 , 0.6834 , 0.3166 , 0.1834 , -0.1834 ] ,\n                      [ 0.8936 , 0.6679 , 0.3321 , 0.1679 , -0.1679 ] ,\n                      [ 0.9149 , 0.6524 , 0.3476 , 0.1524 , -0.1524 ] ,\n                      [ 0.9362 , 0.6333 , 0.3667 , 0.1333 , -0.1333 ] ,\n                      [ 0.9574 , 0.6097 , 0.3903 , 0.1097 , -0.1097 ] ,\n                      [ 0.9787 , 0.5788 , 0.4212 , 0.0788 , -0.0788 ] ,\n                      [ 0.9894 , 0.5589 , 0.4411 , 0.0589 , -0.0589 ] ,\n                      [ 1.0000 , 0.5162 , 0.4838 , 0.0162 , -0.0162 ]]),\n\n    \"sec1\":np.array([[  0.5000000 , 0.0000000 ,  0.0000000 ] ,\n                     [  0.4903926 , 0.0975452 , -0.0975452 ] ,\n                     [  0.4619398 , 0.1913417 , -0.1913417 ] ,\n                     [  0.4157348 , 0.2777851 , -0.2777851 ] ,\n                     [  0.3535534 , 0.3535534 , -0.3535534 ] ,\n                     [  0.2777851 , 0.4157348 , -0.4157348 ] ,\n                     [  0.1913417 , 0.4619398 , -0.4619398 ] ,\n                     [  0.0975452 , 0.4903926 , -0.4903926 ] ,\n                     [  0.0000000 , 0.5000000 , -0.5000000 ] ,\n                     [- 0.0975452 , 0.4903926 , -0.4903926 ] ,\n                     [- 0.1913417 , 0.4619398 , -0.4619398 ] ,\n                     [- 0.2777851 , 0.4157348 , -0.4157348 ] ,\n                     [- 0.3535534 , 0.3535534 , -0.3535534 ] ,\n                     [- 0.4157348 , 0.2777851 , -0.2777851 ] ,\n                     [- 0.4619398 , 0.1913417 , -0.1913417 ] ,\n                     [- 0.4903926 , 0.0975452 , -0.0975452 ] ,\n                     [- 0.5000000 , 0.0000000 ,  0.0000000 ]]),\n\n    \"sec2\":np.array([[ 0.5000000 , 0.0000000 ,  0.0000000] ,\n                     [ 0.4951963 , 0.0975452 , -0.0975452] ,\n                     [ 0.4809699 , 0.1913417 , -0.1913417] ,\n                     [ 0.4578674 , 0.2777851 , -0.2777851] ,\n                     [ 0.4267767 , 0.3535534 , -0.3535534] ,\n                     [ 0.3888926 , 0.4157348 , -0.4157348] ,\n                     [ 0.3456709 , 0.4619398 , -0.4619398] ,\n                     [ 0.2987726 , 0.4903926 , -0.4903926] ,\n                     [ 0.2500000 , 0.5000000 , -0.5000000] ,\n                     [ 0.0000000 , 0.5000000 , -0.5000000] ,\n                     [-0.2500000 , 0.5000000 , -0.5000000] ,\n                     [-0.2987726 , 0.4903926 , -0.4903926] ,\n                     [-0.3456709 , 0.4619398 , -0.4619398] ,\n                     [-0.3888926 , 0.4157348 , -0.4157348] ,\n                     [-0.4267767 , 0.3535534 , -0.3535534] ,\n                     [-0.4578674 , 0.2777851 , -0.2777851] ,\n                     [-0.4809699 , 0.1913417 , -0.1913417] ,\n                     [-0.4951963 , 0.0975452 , -0.0975452] ,\n                     [-0.5000000 , 0.0000000 ,  0.0000000]])}\n\n    return [curve[n] for n in name]\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.VtpTtail","title":"VtpTtail","text":"<pre><code>VtpTtail(aircraft)\n</code></pre> <p>               Bases: <code>Vstab</code></p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def __init__(self, aircraft):\n    super(VtpTtail, self).__init__(aircraft)\n\n    wing_area = aircraft.airframe.wing.area\n\n    self.area = 0.20*wing_area  # Design variable for hq_optim\n    self.height = None\n    self.aspect_ratio = aircraft.get_init(self,\"aspect_ratio\")\n    self.taper_ratio = aircraft.get_init(self,\"taper_ratio\")\n    self.toc = aircraft.get_init(self,\"toc\")\n    self.sweep25 = aircraft.get_init(self,\"sweep25\", val=self.__sweep25())\n    self.thrust_volume_factor = aircraft.get_init(self,\"thrust_volume_factor\")\n    self.wing_volume_factor = aircraft.get_init(self,\"wing_volume_factor\")\n    self.anchor_ratio = aircraft.get_init(self,\"anchor_ratio\")\n    self.lever_arm = None\n\n    self.root_loc = np.full(3,None)     # Position of root chord leading edge\n    self.root_c = None                  # root chord length\n\n    self.tip_loc = np.full(3,None)      # Position of tip chord leading edge\n    self.tip_c = None                   # tip chord length\n\n    self.mac_loc = np.full(3,None)      # Position of MAC chord leading edge\n    self.mac = None\n\n    self.mass_correction_factor = aircraft.get_init(self,\"mass_correction_factor\")\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.VtpTtail-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.VtpTtail.eval_aero_data","title":"eval_aero_data","text":"<pre><code>eval_aero_data()\n</code></pre> <p>WARNING : output values are in Wing reference area</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def eval_aero_data(self):\n    \"\"\"WARNING : output values are in Wing reference area\n    \"\"\"\n    wing_area = self.aircraft.airframe.wing.area\n    # Helmbold formula corrected with endplate effect\n    cyb_vtp =  1.2*(np.pi*self.aspect_ratio)/(1+np.sqrt(1+(self.aspect_ratio/2)**2))*(self.area/wing_area)\n    xlc_vtp = self.mac_loc[0] + 0.25*self.mac   # Position of VTP center of lift\n    aoa_max_vtp = unit.rad_deg(35.)             # Maximum angle of attack allowed for VTP\n    ki_vtp = 1.1/(np.pi*self.aspect_ratio)      # VTP induced drag coefficient\n    return cyb_vtp, xlc_vtp, aoa_max_vtp, ki_vtp\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.VtpTtail.eval_geometry","title":"eval_geometry","text":"<pre><code>eval_geometry()\n</code></pre> <p>Estimates the geometry of the component from the aircraft requirements and statistical design laws.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def eval_geometry(self):\n    body_length = self.aircraft.airframe.body.length\n    body_height = self.aircraft.airframe.body.height\n    tail_cone_length = self.aircraft.airframe.body.tail_cone_length\n    wing_mac_loc = self.aircraft.airframe.wing.mac_loc\n    wing_mac = self.aircraft.airframe.wing.mac\n\n    self.height = np.sqrt(self.aspect_ratio*self.area)\n    self.root_c = 2*self.area/(self.height*(1+self.taper_ratio))\n    self.tip_c = self.taper_ratio*self.root_c\n\n    x_root = body_length*(1-tail_cone_length/body_length*(1-self.anchor_ratio)) - self.root_c\n    x_tip = x_root + 0.25*(self.root_c-self.tip_c) + self.height*np.tan(self.sweep25)\n\n    y_root = 0.\n    y_tip = 0.\n\n    z_root = body_height\n    z_tip = z_root + self.height\n\n    self.mac = self.height*(self.root_c**2+self.tip_c**2+self.root_c*self.tip_c)/(3*self.area)\n    x_mac = x_root+(x_tip-x_root)*self.height*(2*self.tip_c+self.root_c)/(6*self.area)\n    y_mac = 0.\n    z_mac = z_tip**2*(2*self.tip_c+self.root_c)/(6*self.area)\n\n    self.lever_arm = (x_mac + 0.25*self.mac) - (wing_mac_loc[0] + 0.25*wing_mac)\n\n    self.root_loc = np.array([x_root, y_root, z_root])\n    self.tip_loc = np.array([x_tip, y_tip, z_tip])\n    self.mac_loc = np.array([x_mac, y_mac, z_mac])\n\n    self.frame_origin = [x_root, 0., z_root]\n\n    self.gross_wet_area = 2.01*self.area\n    self.net_wet_area = self.gross_wet_area\n\n    self.aero_length = self.mac\n    self.form_factor = 1.40\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.VtpTtail.eval_mass","title":"eval_mass","text":"<pre><code>eval_mass()\n</code></pre> <p>Estimates the geometry of the component from the aircraft requirements and statistical design laws.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def eval_mass(self):\n    self.mass = self.mass_correction_factor * 28. * self.area\n    self.cg = self.mac_loc + 0.20*np.array([self.mac, 0., 0.])\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.VtpTtail.get_aero_length","title":"get_aero_length","text":"<pre><code>get_aero_length()\n</code></pre> <p>The characteristic aerodynamic length of the component (used for Reynolds number estimations for example).</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_aero_length(self):\n    \"\"\"The characteristic aerodynamic length of the component (used for Reynolds number estimations for example).\"\"\"\n    return self.aero_length\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.VtpTtail.get_cg_mwe","title":"get_cg_mwe","text":"<pre><code>get_cg_mwe()\n</code></pre> <p>Returns the position of the center of gravity of the manufacturer empty aircraft</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_cg_mwe(self):\n    \"\"\"Returns the position of the center of gravity of the manufacturer empty aircraft\"\"\"\n    return self.cg\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.VtpTtail.get_cg_owe","title":"get_cg_owe","text":"<pre><code>get_cg_owe()\n</code></pre> <p>Returns the position of the center of gravity of the operational empty aircraft</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_cg_owe(self):\n    \"\"\"Returns the position of the center of gravity of the operational empty aircraft\"\"\"\n    return self.cg\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.VtpTtail.get_form_factor","title":"get_form_factor","text":"<pre><code>get_form_factor()\n</code></pre> <p>Form factor used to estimate form drag.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_form_factor(self):\n    \"\"\"Form factor used to estimate form drag.\"\"\"\n    return self.form_factor\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.VtpTtail.get_inertia_tensor","title":"get_inertia_tensor","text":"<pre><code>get_inertia_tensor()\n</code></pre> <p>returns the inertia matrix of the component, if implemented.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_inertia_tensor(self):\n    \"\"\"returns the inertia matrix of the component, if implemented.\"\"\"\n    return self.inertia_tensor\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.VtpTtail.get_mass_mwe","title":"get_mass_mwe","text":"<pre><code>get_mass_mwe()\n</code></pre> <p>Returns the Manufacturer's Weight Empty, the mass (kg) of the component</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_mass_mwe(self):\n    \"\"\"Returns the *Manufacturer's Weight Empty*, the mass (kg) of the component\"\"\"\n    return self.mass\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.VtpTtail.get_mass_owe","title":"get_mass_owe","text":"<pre><code>get_mass_owe()\n</code></pre> <p>Returns the Operating Weight Empty, the mass (kg) of the component. Can differ from MWE for some components</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_mass_owe(self):\n    \"\"\"Returns the *Operating Weight Empty*, the mass (kg) of the component. Can differ from MWE for some components\"\"\"\n    return self.mass\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.VtpTtail.get_net_wet_area","title":"get_net_wet_area","text":"<pre><code>get_net_wet_area()\n</code></pre> <p>The net wet area of the component in contact with outer airflow, 0 if the component has no aerodynamic surface.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_net_wet_area(self):\n    \"\"\"The net wet area of the component in contact with outer airflow, 0 if the component has no aerodynamic surface.\"\"\"\n    return self.net_wet_area\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.VtpTtail.get_this_shape","title":"get_this_shape","text":"<pre><code>get_this_shape(name)\n</code></pre> <p>Contour curves for 3 view drawing nose1 : modern nose (A220, A350, 787) nose3 : classical Airbus nose nose2 : symetrical nose cone1 : classical tail cone cone2 : symetrical cone section : circle</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_this_shape(self, name): # TODO: is the docstring up to date ?\n    \"\"\"Contour curves for 3 view drawing\n    nose1 : modern nose (A220, A350, 787)\n    nose3 : classical Airbus nose\n    nose2 : symetrical nose\n    cone1 : classical tail cone\n    cone2 : symetrical cone\n    section : circle\n    \"\"\"\n    curve = {\n    \"nose1\":np.array([[ 0.0000 , 0.3339 , 0.3339 , 0.0000 ,  0.0000 ] ,\n                      [ 0.0050 , 0.3848 , 0.3084 , 0.0335 , -0.0335 ] ,\n                      [ 0.0150 , 0.4253 , 0.2881 , 0.0652 , -0.0652 ] ,\n                      [ 0.0500 , 0.5033 , 0.2490 , 0.1101 , -0.1101 ] ,\n                      [ 0.1000 , 0.5811 , 0.2100 , 0.1585 , -0.1585 ] ,\n                      [ 0.1800 , 0.6808 , 0.1600 , 0.2215 , -0.2215 ] ,\n                      [ 0.2773 , 0.7704 , 0.1151 , 0.2859 , -0.2859 ] ,\n                      [ 0.4191 , 0.8562 , 0.0721 , 0.3624 , -0.3624 ] ,\n                      [ 0.5610 , 0.9198 , 0.0402 , 0.4211 , -0.4211 ] ,\n                      [ 0.7738 , 0.9816 , 0.0092 , 0.4761 , -0.4761 ] ,\n                      [ 0.9156 , 0.9962 , 0.0019 , 0.4976 , -0.4976 ] ,\n                      [ 1.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ]]),\n\n    \"nose2\":np.array([[ 0.0000 , 0.5000 ,  0.5000 , 0.0000 ,  0.0000 ] ,\n                      [ 0.0050 , 0.5335 ,  0.4665 , 0.0335 , -0.0335 ] ,\n                      [ 0.0191 , 0.5646 ,  0.4354 , 0.0646 , -0.0646 ] ,\n                      [ 0.0624 , 0.6196 ,  0.3804 , 0.1196 , -0.1196 ] ,\n                      [ 0.1355 , 0.6878 ,  0.3122 , 0.1878 , -0.1878 ] ,\n                      [ 0.1922 , 0.7297 ,  0.2703 , 0.2297 , -0.2297 ] ,\n                      [ 0.2773 , 0.7859 ,  0.2141 , 0.2859 , -0.2859 ] ,\n                      [ 0.4191 , 0.8624 ,  0.1376 , 0.3624 , -0.3624 ] ,\n                      [ 0.5610 , 0.9211 ,  0.0789 , 0.4211 , -0.4211 ] ,\n                      [ 0.7738 , 0.9761 ,  0.0239 , 0.4761 , -0.4761 ] ,\n                      [ 0.9156 , 0.9976 ,  0.0024 , 0.4976 , -0.4976 ] ,\n                      [ 1.0000 , 1.0000 ,  0.0000 , 0.5000 , -0.5000 ]]),\n\n    \"nose3\":np.array([[ 0.0000 , 0.4453 , 0.4453 , 0.0000 ,  0.0000 ] ,\n                      [ 0.0050 , 0.4733 , 0.4112 , 0.0335 , -0.0335 ] ,\n                      [ 0.0191 , 0.5098 , 0.3833 , 0.0646 , -0.0646 ] ,\n                      [ 0.0624 , 0.5718 , 0.3188 , 0.1196 , -0.1196 ] ,\n                      [ 0.1355 , 0.6278 , 0.2531 , 0.1878 , -0.1878 ] ,\n                      [ 0.1922 , 0.7263 , 0.2142 , 0.2297 , -0.2297 ] ,\n                      [ 0.2773 , 0.8127 , 0.1631 , 0.2859 , -0.2859 ] ,\n                      [ 0.4191 , 0.8906 , 0.0962 , 0.3624 , -0.3624 ] ,\n                      [ 0.5610 , 0.9392 , 0.0536 , 0.4211 , -0.4211 ] ,\n                      [ 0.7738 , 0.9818 , 0.0122 , 0.4761 , -0.4761 ] ,\n                      [ 0.9156 , 0.9976 , 0.0025 , 0.4976 , -0.4976 ] ,\n                      [ 1.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ]]),\n\n    \"nose4\":np.array([[ 0.0000, 0.3700, 0.3700, 0.0000,  0.0000 ] ,\n                      [ 0.0050, 0.4200, 0.3200, 0.0335, -0.0335 ] ,\n                      [ 0.0150, 0.4500, 0.2900, 0.0652, -0.0652 ] ,\n                      [ 0.0500, 0.5000, 0.2400, 0.1200, -0.1200 ] ,\n                      [ 0.1000, 0.5500, 0.1900, 0.1750, -0.1750 ] ,\n                      [ 0.1800, 0.6000, 0.1400, 0.2400, -0.2400 ] ,\n                      [ 0.2773, 0.6450, 0.1000, 0.3000, -0.3000 ] ,\n                      [ 0.4191, 0.7000, 0.0500, 0.3700, -0.3700 ] ,\n                      [ 0.5610, 0.7550, 0.0250, 0.4300, -0.4300 ] ,\n                      [ 0.6200, 0.7800, 0.0180, 0.4500, -0.4500 ] ,\n                      [ 0.7700, 0.9700, 0.0090, 0.4850, -0.4850 ] ,\n                      [ 0.8100, 0.9900, 0.0060, 0.4900, -0.4900 ] ,\n                      [ 0.9100, 0.9970, 0.0030, 0.4976, -0.4976 ] ,\n                      [ 1.0000, 1.0000, 0.0000, 0.5000, -0.5000 ]]),\n\n    \"cone1\":np.array([[ 0.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ] ,\n                      [ 0.0213 , 1.0000 , 0.0082 , 0.5000 , -0.5000 ] ,\n                      [ 0.0638 , 1.0000 , 0.0230 , 0.4956 , -0.4956 ] ,\n                      [ 0.1064 , 1.0000 , 0.0393 , 0.4875 , -0.4875 ] ,\n                      [ 0.1489 , 1.0000 , 0.0556 , 0.4794 , -0.4794 ] ,\n                      [ 0.1915 , 1.0000 , 0.0786 , 0.4720 , -0.4720 ] ,\n                      [ 0.2766 , 1.0000 , 0.1334 , 0.4566 , -0.4566 ] ,\n                      [ 0.3617 , 1.0000 , 0.1964 , 0.4330 , -0.4330 ] ,\n                      [ 0.4894 , 1.0000 , 0.3024 , 0.3822 , -0.3822 ] ,\n                      [ 0.6170 , 1.0000 , 0.4159 , 0.3240 , -0.3240 ] ,\n                      [ 0.7447 , 1.0000 , 0.5374 , 0.2577 , -0.2577 ] ,\n                      [ 0.8723 , 1.0000 , 0.6627 , 0.1834 , -0.1834 ] ,\n                      [ 0.8936 , 0.9963 , 0.6901 , 0.1679 , -0.1679 ] ,\n                      [ 0.9149 , 0.9881 , 0.7139 , 0.1524 , -0.1524 ] ,\n                      [ 0.9362 , 0.9800 , 0.7413 , 0.1333 , -0.1333 ] ,\n                      [ 0.9574 , 0.9652 , 0.7687 , 0.1097 , -0.1097 ] ,\n                      [ 0.9787 , 0.9533 , 0.8043 , 0.0788 , -0.0788 ] ,\n                      [ 0.9894 , 0.9377 , 0.8280 , 0.0589 , -0.0589 ] ,\n                      [ 1.0000 , 0.9103 , 0.8784 , 0.0162 , -0.0162 ]]),\n\n    \"cone2\":np.array([[ 0.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ] ,\n                      [ 0.0213 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ] ,\n                      [ 0.0638 , 0.9956 , 0.0044 , 0.4956 , -0.4956 ] ,\n                      [ 0.1064 , 0.9875 , 0.0125 , 0.4875 , -0.4875 ] ,\n                      [ 0.1489 , 0.9794 , 0.0206 , 0.4794 , -0.4794 ] ,\n                      [ 0.1915 , 0.9720 , 0.0280 , 0.4720 , -0.4720 ] ,\n                      [ 0.2766 , 0.9566 , 0.0434 , 0.4566 , -0.4566 ] ,\n                      [ 0.3617 , 0.9330 , 0.0670 , 0.4330 , -0.4330 ] ,\n                      [ 0.4894 , 0.8822 , 0.1178 , 0.3822 , -0.3822 ] ,\n                      [ 0.6170 , 0.8240 , 0.1760 , 0.3240 , -0.3240 ] ,\n                      [ 0.7447 , 0.7577 , 0.2423 , 0.2577 , -0.2577 ] ,\n                      [ 0.8723 , 0.6834 , 0.3166 , 0.1834 , -0.1834 ] ,\n                      [ 0.8936 , 0.6679 , 0.3321 , 0.1679 , -0.1679 ] ,\n                      [ 0.9149 , 0.6524 , 0.3476 , 0.1524 , -0.1524 ] ,\n                      [ 0.9362 , 0.6333 , 0.3667 , 0.1333 , -0.1333 ] ,\n                      [ 0.9574 , 0.6097 , 0.3903 , 0.1097 , -0.1097 ] ,\n                      [ 0.9787 , 0.5788 , 0.4212 , 0.0788 , -0.0788 ] ,\n                      [ 0.9894 , 0.5589 , 0.4411 , 0.0589 , -0.0589 ] ,\n                      [ 1.0000 , 0.5162 , 0.4838 , 0.0162 , -0.0162 ]]),\n\n    \"sec1\":np.array([[  0.5000000 , 0.0000000 ,  0.0000000 ] ,\n                     [  0.4903926 , 0.0975452 , -0.0975452 ] ,\n                     [  0.4619398 , 0.1913417 , -0.1913417 ] ,\n                     [  0.4157348 , 0.2777851 , -0.2777851 ] ,\n                     [  0.3535534 , 0.3535534 , -0.3535534 ] ,\n                     [  0.2777851 , 0.4157348 , -0.4157348 ] ,\n                     [  0.1913417 , 0.4619398 , -0.4619398 ] ,\n                     [  0.0975452 , 0.4903926 , -0.4903926 ] ,\n                     [  0.0000000 , 0.5000000 , -0.5000000 ] ,\n                     [- 0.0975452 , 0.4903926 , -0.4903926 ] ,\n                     [- 0.1913417 , 0.4619398 , -0.4619398 ] ,\n                     [- 0.2777851 , 0.4157348 , -0.4157348 ] ,\n                     [- 0.3535534 , 0.3535534 , -0.3535534 ] ,\n                     [- 0.4157348 , 0.2777851 , -0.2777851 ] ,\n                     [- 0.4619398 , 0.1913417 , -0.1913417 ] ,\n                     [- 0.4903926 , 0.0975452 , -0.0975452 ] ,\n                     [- 0.5000000 , 0.0000000 ,  0.0000000 ]]),\n\n    \"sec2\":np.array([[ 0.5000000 , 0.0000000 ,  0.0000000] ,\n                     [ 0.4951963 , 0.0975452 , -0.0975452] ,\n                     [ 0.4809699 , 0.1913417 , -0.1913417] ,\n                     [ 0.4578674 , 0.2777851 , -0.2777851] ,\n                     [ 0.4267767 , 0.3535534 , -0.3535534] ,\n                     [ 0.3888926 , 0.4157348 , -0.4157348] ,\n                     [ 0.3456709 , 0.4619398 , -0.4619398] ,\n                     [ 0.2987726 , 0.4903926 , -0.4903926] ,\n                     [ 0.2500000 , 0.5000000 , -0.5000000] ,\n                     [ 0.0000000 , 0.5000000 , -0.5000000] ,\n                     [-0.2500000 , 0.5000000 , -0.5000000] ,\n                     [-0.2987726 , 0.4903926 , -0.4903926] ,\n                     [-0.3456709 , 0.4619398 , -0.4619398] ,\n                     [-0.3888926 , 0.4157348 , -0.4157348] ,\n                     [-0.4267767 , 0.3535534 , -0.3535534] ,\n                     [-0.4578674 , 0.2777851 , -0.2777851] ,\n                     [-0.4809699 , 0.1913417 , -0.1913417] ,\n                     [-0.4951963 , 0.0975452 , -0.0975452] ,\n                     [-0.5000000 , 0.0000000 ,  0.0000000]])}\n\n    return [curve[n] for n in name]\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.Wing","title":"Wing","text":"<pre><code>Wing(aircraft)\n</code></pre> <p>               Bases: <code>Component</code></p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def __init__(self, aircraft):\n    super(Wing, self).__init__(aircraft)\n\n    design_range = self.aircraft.requirement.design_range\n    n_pax_ref = self.aircraft.requirement.n_pax_ref\n\n    n_pax_front = self.aircraft.airframe.cabin.n_pax_front\n    n_aisle = self.aircraft.airframe.cabin.n_aisle\n\n    self.wing_morphing = aircraft.get_init(self,\"wing_morphing\")   # \"aspect_ratio_driven\" or \"span_driven\"\n    self.area = 60. + 88.*n_pax_ref*design_range*1.e-9\n    self.span = None\n    self.aspect_ratio = aircraft.get_init(self,\"aspect_ratio\", val=self.aspect_ratio())\n    self.taper_ratio = aircraft.get_init(self,\"taper_ratio\", val=self.taper_ratio())\n    self.dihedral = aircraft.get_init(self,\"dihedral\")\n    self.sweep0 = None\n    self.sweep25 = aircraft.get_init(self,\"sweep25\", val=self.sweep25())\n    self.sweep100 = None\n    self.setting = None\n    self.hld_type = aircraft.get_init(self,\"hld_type\", val=self.high_lift_type())\n    self.front_spar_ratio = aircraft.get_init(self,\"front_spar_ratio\")\n    self.rear_spar_ratio = aircraft.get_init(self,\"rear_spar_ratio\")\n\n    self.x_rout = None      # Design variable for hq_optim\n\n    self.root_loc = np.full(3,None)     # Position of root chord leading edge\n    self.root_toc = None                # thickness over chord ratio of root chord\n    self.root_c = None                  # root chord length\n\n    self.kink_loc =  np.full(3,None)    # Position of kink chord leading edge\n    self.kink_toc = None                # thickness over chord ratio of kink chord\n    self.kink_c = None                  # kink chord length\n\n    self.tip_loc = np.full(3,None)      # Position of tip chord leading edge\n    self.tip_toc = None                 # thickness over chord ratio of tip chord\n    self.tip_c = None                   # tip chord length\n\n    self.mac_loc = np.full(3,None)      # Position of MAC chord leading edge\n    self.mac = None\n\n    self.mass_correction_factor = aircraft.get_init(self,\"mass_correction_factor\")\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.Wing-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.Wing.downwash_angle","title":"downwash_angle","text":"<pre><code>downwash_angle(ki_wing, cz)\n</code></pre> <p>Estimate downwash angle due to the wing</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def downwash_angle(self, ki_wing, cz):\n    \"\"\"Estimate downwash angle due to the wing\n    \"\"\"\n    return cz * ki_wing\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.Wing.eval_aero_data","title":"eval_aero_data","text":"<pre><code>eval_aero_data(hld_conf, mach)\n</code></pre> <p>Estimate wing aerodynamic characteristics</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def eval_aero_data(self, hld_conf, mach):\n    \"\"\"Estimate wing aerodynamic characteristics\n    \"\"\"\n    body_width = self.aircraft.airframe.body.width\n    wing_span = self.aircraft.airframe.wing.span\n    wing_ar = self.aircraft.airframe.wing.aspect_ratio\n    sweep25 = self.aircraft.airframe.wing.sweep25\n    wing_c_mac = self.aircraft.airframe.wing.mac\n    wing_mac_loc = self.aircraft.airframe.wing.mac_loc[0]\n\n    # Polhamus formula, lift gradiant without HTP\n    cza_wo_htp =  (np.pi*wing_ar*(1.07*(1+body_width/wing_span)**2)*(1.-body_width/wing_span)) \\\n                / (1+np.sqrt(1.+0.25*wing_ar**2*(1+np.tan(sweep25)**2-mach**2)))\n\n    xlc_wo_htp = wing_mac_loc + (0.25+0.10*hld_conf)*wing_c_mac # Neutral point\n\n    ki_wing = (1.05 + (body_width / self.span)**2)  / (np.pi * self.aspect_ratio)\n\n    return cza_wo_htp, xlc_wo_htp, ki_wing\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.Wing.eval_geometry","title":"eval_geometry","text":"<pre><code>eval_geometry(hq_optim=False)\n</code></pre> <p>Estimates the geometry of the component from the aircraft requirements and statistical design laws.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def eval_geometry(self, hq_optim=False):\n    wing_attachment = self.aircraft.arrangement.wing_attachment\n    cruise_mach = self.aircraft.requirement.cruise_mach\n    body_width = self.aircraft.airframe.body.width\n    body_length = self.aircraft.airframe.body.length\n    body_height = self.aircraft.airframe.body.height\n\n    self.tip_toc = 0.10\n    self.kink_toc = self.tip_toc + 0.01\n    self.root_toc = self.kink_toc + 0.03\n\n    if(self.wing_morphing==\"aspect_ratio_driven\"):   # Aspect ratio is driving parameter\n        self.span = np.sqrt(self.aspect_ratio*self.area)\n    elif(self.wing_morphing==\"span_driven\"): # Span is driving parameter\n        self.aspect_ratio = self.span**2/self.area\n    else:\n        print(\"geometry_predesign_, wing_wing_morphing index is unkown\")\n\n    y_root = 0.5*body_width\n    y_kink = 1.5*body_width\n    y_tip = 0.5*self.span\n\n    if(15&lt; unit.deg_rad(self.sweep25)):  # With kink\n      Phi100intTE = max(0., 2. * (self.sweep25 - unit.rad_deg(32.)))\n      tan_phi100 = np.tan(Phi100intTE)\n      A = ((1-0.25*self.taper_ratio)*y_kink+0.25*self.taper_ratio*y_root-y_tip) / (0.75*y_kink+0.25*y_root-y_tip)\n      B = (np.tan(self.sweep25)-tan_phi100) * ((y_tip-y_kink)*(y_kink-y_root)) / (0.25*y_root+0.75*y_kink-y_tip)\n      self.root_c = (self.area-B*(y_tip-y_root)) / (y_root+y_kink+A*(y_tip-y_root)+self.taper_ratio*(y_tip-y_kink))\n      self.kink_c = A*self.root_c + B\n      self.tip_c = self.taper_ratio*self.root_c\n\n    else:   # Without kink\n      self.root_c = 2.*self.area / (2.*y_root*(1.-self.taper_ratio) + (1.+self.taper_ratio)*np.sqrt(self.aspect_ratio*self.area))\n      self.tip_c = self.taper_ratio*self.root_c\n      self.kink_c = ((y_tip-y_kink)*self.root_c + (y_kink-y_root)*self.tip_c) / (y_tip-y_root)\n\n\n    tan_phi0 = 0.25*(self.kink_c-self.tip_c)/(y_tip-y_kink) + np.tan(self.sweep25)\n\n    self.mac = 2.*( 3.*y_root*self.root_c**2 \\\n                   +(y_kink-y_root)*(self.root_c**2+self.kink_c**2+self.root_c*self.kink_c) \\\n                   +(y_tip-y_kink)*(self.kink_c**2+self.tip_c**2+self.kink_c*self.tip_c) \\\n                  )/(3*self.area)\n\n    y_mac = (  3.*self.root_c*y_root**2 \\\n             +(y_kink-y_root)*(self.kink_c*(y_root+y_kink*2.)+self.root_c*(y_kink+y_root*2.)) \\\n             +(y_tip-y_kink)*(self.tip_c*(y_kink+y_tip*2.)+self.kink_c*(y_tip+y_kink*2.)) \\\n            )/(3.*self.area)\n\n    x_mac_local = ( (y_kink-y_root)*tan_phi0*((y_kink-y_root)*(self.kink_c*2.+self.root_c) \\\n                   +(y_tip-y_kink)*(self.kink_c*2.+self.tip_c))+(y_tip-y_root)*tan_phi0*(y_tip-y_kink)*(self.tip_c*2.+self.kink_c) \\\n                  )/(3*self.area)\n\n    if (not hq_optim):\n         self.x_root = 0.33*body_length**1.1 - (x_mac_local + 0.25*self.mac)\n    x_root = self.x_root\n    x_kink = x_root + (y_kink-y_root)*tan_phi0\n    x_tip = x_root + (y_tip-y_root)*tan_phi0\n\n    x_mac = x_root+( (x_kink-x_root)*((y_kink-y_root)*(self.kink_c*2.+self.root_c) \\\n                        +(y_tip-y_kink)*(self.kink_c*2.+self.tip_c))+(x_tip-x_root)*(y_tip-y_kink)*(self.tip_c*2.+self.kink_c) \\\n                       )/(self.area*3.)\n    if (wing_attachment==\"low\"):\n        z_root = 0.\n    else:\n        z_root = body_height - 0.5*self.root_toc*self.root_c\n\n    z_kink = z_root+(y_kink-y_root)*np.tan(self.dihedral)\n    z_tip = z_root+(y_tip-y_root)*np.tan(self.dihedral)\n\n    self.root_loc = np.array([x_root, y_root, z_root])\n    self.kink_loc = np.array([x_kink, y_kink, z_kink])\n    self.tip_loc = np.array([x_tip, y_tip, z_tip])\n    self.mac_loc = np.array([x_mac, y_mac, None])\n\n    self.frame_origin = [x_root, 0., z_root]\n\n    self.gross_wet_area = 2.00*(self.area - self.root_c*body_width)\n    self.net_wet_area = self.gross_wet_area\n\n    self.aero_length = self.mac\n    self.form_factor = 1.40\n\n    # Wing setting\n    #-----------------------------------------------------------------------------------------------------------\n    g = earth.gravity()\n    r,gam,Cp,Cv = earth.gas_data()\n\n    disa = 0.\n    rca = self.aircraft.requirement.cruise_altp\n    mach = self.aircraft.requirement.cruise_mach\n    mass = 0.95*self.aircraft.weight_cg.mtow\n\n    pamb,tamb,tstd,dtodz = earth.atmosphere(rca, disa)\n\n    hld_conf = 0.\n    cza_wo_htp, xlc_wo_htp, ki_wing = self.eval_aero_data(hld_conf, mach)\n    cza_wing = cza_wo_htp\n\n    # AoA = 2.5\u00b0 at cruise start\n    self.setting = (0.97*mass*g) / (0.5*gam*pamb*mach**2*self.area*cza_wing) - unit.rad_deg(2.5)\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.Wing.eval_mass","title":"eval_mass","text":"<pre><code>eval_mass()\n</code></pre> <p>Estimates the geometry of the component from the aircraft requirements and statistical design laws.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def eval_mass(self):\n    mtow = self.aircraft.weight_cg.mtow\n    mzfw = self.aircraft.weight_cg.mzfw\n    hld_conf_ld = self.aircraft.aerodynamics.hld_conf_ld\n\n    (cz_max_ld,cz0) = self.high_lift(hld_conf_ld)\n\n    A = 32*self.area**1.1\n    B = 4.*self.span**2 * np.sqrt(mtow*mzfw)\n    C = 1.1e-6*(1.+2.*self.aspect_ratio)/(1.+self.aspect_ratio)\n    D = (0.6*self.root_toc+0.3*self.kink_toc+0.1*self.tip_toc) * (self.area/self.span)\n    E = np.cos(self.sweep25)**2\n    F = 1200.*max(0., cz_max_ld - 1.8)**1.5\n\n    self.mass = self.mass_correction_factor * (A + (B*C)/(D*E) + F)   # Shevell formula + high lift device regression\n\n    self.cg =  0.25*(self.root_loc + 0.40*np.array([self.root_c, 0., 0.])) \\\n             + 0.55*(self.kink_loc + 0.40*np.array([self.kink_c, 0., 0.])) \\\n             + 0.20*(self.tip_loc + 0.40*np.array([self.tip_c, 0., 0.]))\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.Wing.get_aero_length","title":"get_aero_length","text":"<pre><code>get_aero_length()\n</code></pre> <p>The characteristic aerodynamic length of the component (used for Reynolds number estimations for example).</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_aero_length(self):\n    \"\"\"The characteristic aerodynamic length of the component (used for Reynolds number estimations for example).\"\"\"\n    return self.aero_length\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.Wing.get_cg_mwe","title":"get_cg_mwe","text":"<pre><code>get_cg_mwe()\n</code></pre> <p>Returns the position of the center of gravity of the manufacturer empty aircraft</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_cg_mwe(self):\n    \"\"\"Returns the position of the center of gravity of the manufacturer empty aircraft\"\"\"\n    return self.cg\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.Wing.get_cg_owe","title":"get_cg_owe","text":"<pre><code>get_cg_owe()\n</code></pre> <p>Returns the position of the center of gravity of the operational empty aircraft</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_cg_owe(self):\n    \"\"\"Returns the position of the center of gravity of the operational empty aircraft\"\"\"\n    return self.cg\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.Wing.get_form_factor","title":"get_form_factor","text":"<pre><code>get_form_factor()\n</code></pre> <p>Form factor used to estimate form drag.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_form_factor(self):\n    \"\"\"Form factor used to estimate form drag.\"\"\"\n    return self.form_factor\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.Wing.get_inertia_tensor","title":"get_inertia_tensor","text":"<pre><code>get_inertia_tensor()\n</code></pre> <p>returns the inertia matrix of the component, if implemented.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_inertia_tensor(self):\n    \"\"\"returns the inertia matrix of the component, if implemented.\"\"\"\n    return self.inertia_tensor\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.Wing.get_mass_mwe","title":"get_mass_mwe","text":"<pre><code>get_mass_mwe()\n</code></pre> <p>Returns the Manufacturer's Weight Empty, the mass (kg) of the component</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_mass_mwe(self):\n    \"\"\"Returns the *Manufacturer's Weight Empty*, the mass (kg) of the component\"\"\"\n    return self.mass\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.Wing.get_mass_owe","title":"get_mass_owe","text":"<pre><code>get_mass_owe()\n</code></pre> <p>Returns the Operating Weight Empty, the mass (kg) of the component. Can differ from MWE for some components</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_mass_owe(self):\n    \"\"\"Returns the *Operating Weight Empty*, the mass (kg) of the component. Can differ from MWE for some components\"\"\"\n    return self.mass\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.Wing.get_net_wet_area","title":"get_net_wet_area","text":"<pre><code>get_net_wet_area()\n</code></pre> <p>The net wet area of the component in contact with outer airflow, 0 if the component has no aerodynamic surface.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_net_wet_area(self):\n    \"\"\"The net wet area of the component in contact with outer airflow, 0 if the component has no aerodynamic surface.\"\"\"\n    return self.net_wet_area\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.Wing.get_this_shape","title":"get_this_shape","text":"<pre><code>get_this_shape(name)\n</code></pre> <p>Contour curves for 3 view drawing nose1 : modern nose (A220, A350, 787) nose3 : classical Airbus nose nose2 : symetrical nose cone1 : classical tail cone cone2 : symetrical cone section : circle</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_this_shape(self, name): # TODO: is the docstring up to date ?\n    \"\"\"Contour curves for 3 view drawing\n    nose1 : modern nose (A220, A350, 787)\n    nose3 : classical Airbus nose\n    nose2 : symetrical nose\n    cone1 : classical tail cone\n    cone2 : symetrical cone\n    section : circle\n    \"\"\"\n    curve = {\n    \"nose1\":np.array([[ 0.0000 , 0.3339 , 0.3339 , 0.0000 ,  0.0000 ] ,\n                      [ 0.0050 , 0.3848 , 0.3084 , 0.0335 , -0.0335 ] ,\n                      [ 0.0150 , 0.4253 , 0.2881 , 0.0652 , -0.0652 ] ,\n                      [ 0.0500 , 0.5033 , 0.2490 , 0.1101 , -0.1101 ] ,\n                      [ 0.1000 , 0.5811 , 0.2100 , 0.1585 , -0.1585 ] ,\n                      [ 0.1800 , 0.6808 , 0.1600 , 0.2215 , -0.2215 ] ,\n                      [ 0.2773 , 0.7704 , 0.1151 , 0.2859 , -0.2859 ] ,\n                      [ 0.4191 , 0.8562 , 0.0721 , 0.3624 , -0.3624 ] ,\n                      [ 0.5610 , 0.9198 , 0.0402 , 0.4211 , -0.4211 ] ,\n                      [ 0.7738 , 0.9816 , 0.0092 , 0.4761 , -0.4761 ] ,\n                      [ 0.9156 , 0.9962 , 0.0019 , 0.4976 , -0.4976 ] ,\n                      [ 1.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ]]),\n\n    \"nose2\":np.array([[ 0.0000 , 0.5000 ,  0.5000 , 0.0000 ,  0.0000 ] ,\n                      [ 0.0050 , 0.5335 ,  0.4665 , 0.0335 , -0.0335 ] ,\n                      [ 0.0191 , 0.5646 ,  0.4354 , 0.0646 , -0.0646 ] ,\n                      [ 0.0624 , 0.6196 ,  0.3804 , 0.1196 , -0.1196 ] ,\n                      [ 0.1355 , 0.6878 ,  0.3122 , 0.1878 , -0.1878 ] ,\n                      [ 0.1922 , 0.7297 ,  0.2703 , 0.2297 , -0.2297 ] ,\n                      [ 0.2773 , 0.7859 ,  0.2141 , 0.2859 , -0.2859 ] ,\n                      [ 0.4191 , 0.8624 ,  0.1376 , 0.3624 , -0.3624 ] ,\n                      [ 0.5610 , 0.9211 ,  0.0789 , 0.4211 , -0.4211 ] ,\n                      [ 0.7738 , 0.9761 ,  0.0239 , 0.4761 , -0.4761 ] ,\n                      [ 0.9156 , 0.9976 ,  0.0024 , 0.4976 , -0.4976 ] ,\n                      [ 1.0000 , 1.0000 ,  0.0000 , 0.5000 , -0.5000 ]]),\n\n    \"nose3\":np.array([[ 0.0000 , 0.4453 , 0.4453 , 0.0000 ,  0.0000 ] ,\n                      [ 0.0050 , 0.4733 , 0.4112 , 0.0335 , -0.0335 ] ,\n                      [ 0.0191 , 0.5098 , 0.3833 , 0.0646 , -0.0646 ] ,\n                      [ 0.0624 , 0.5718 , 0.3188 , 0.1196 , -0.1196 ] ,\n                      [ 0.1355 , 0.6278 , 0.2531 , 0.1878 , -0.1878 ] ,\n                      [ 0.1922 , 0.7263 , 0.2142 , 0.2297 , -0.2297 ] ,\n                      [ 0.2773 , 0.8127 , 0.1631 , 0.2859 , -0.2859 ] ,\n                      [ 0.4191 , 0.8906 , 0.0962 , 0.3624 , -0.3624 ] ,\n                      [ 0.5610 , 0.9392 , 0.0536 , 0.4211 , -0.4211 ] ,\n                      [ 0.7738 , 0.9818 , 0.0122 , 0.4761 , -0.4761 ] ,\n                      [ 0.9156 , 0.9976 , 0.0025 , 0.4976 , -0.4976 ] ,\n                      [ 1.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ]]),\n\n    \"nose4\":np.array([[ 0.0000, 0.3700, 0.3700, 0.0000,  0.0000 ] ,\n                      [ 0.0050, 0.4200, 0.3200, 0.0335, -0.0335 ] ,\n                      [ 0.0150, 0.4500, 0.2900, 0.0652, -0.0652 ] ,\n                      [ 0.0500, 0.5000, 0.2400, 0.1200, -0.1200 ] ,\n                      [ 0.1000, 0.5500, 0.1900, 0.1750, -0.1750 ] ,\n                      [ 0.1800, 0.6000, 0.1400, 0.2400, -0.2400 ] ,\n                      [ 0.2773, 0.6450, 0.1000, 0.3000, -0.3000 ] ,\n                      [ 0.4191, 0.7000, 0.0500, 0.3700, -0.3700 ] ,\n                      [ 0.5610, 0.7550, 0.0250, 0.4300, -0.4300 ] ,\n                      [ 0.6200, 0.7800, 0.0180, 0.4500, -0.4500 ] ,\n                      [ 0.7700, 0.9700, 0.0090, 0.4850, -0.4850 ] ,\n                      [ 0.8100, 0.9900, 0.0060, 0.4900, -0.4900 ] ,\n                      [ 0.9100, 0.9970, 0.0030, 0.4976, -0.4976 ] ,\n                      [ 1.0000, 1.0000, 0.0000, 0.5000, -0.5000 ]]),\n\n    \"cone1\":np.array([[ 0.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ] ,\n                      [ 0.0213 , 1.0000 , 0.0082 , 0.5000 , -0.5000 ] ,\n                      [ 0.0638 , 1.0000 , 0.0230 , 0.4956 , -0.4956 ] ,\n                      [ 0.1064 , 1.0000 , 0.0393 , 0.4875 , -0.4875 ] ,\n                      [ 0.1489 , 1.0000 , 0.0556 , 0.4794 , -0.4794 ] ,\n                      [ 0.1915 , 1.0000 , 0.0786 , 0.4720 , -0.4720 ] ,\n                      [ 0.2766 , 1.0000 , 0.1334 , 0.4566 , -0.4566 ] ,\n                      [ 0.3617 , 1.0000 , 0.1964 , 0.4330 , -0.4330 ] ,\n                      [ 0.4894 , 1.0000 , 0.3024 , 0.3822 , -0.3822 ] ,\n                      [ 0.6170 , 1.0000 , 0.4159 , 0.3240 , -0.3240 ] ,\n                      [ 0.7447 , 1.0000 , 0.5374 , 0.2577 , -0.2577 ] ,\n                      [ 0.8723 , 1.0000 , 0.6627 , 0.1834 , -0.1834 ] ,\n                      [ 0.8936 , 0.9963 , 0.6901 , 0.1679 , -0.1679 ] ,\n                      [ 0.9149 , 0.9881 , 0.7139 , 0.1524 , -0.1524 ] ,\n                      [ 0.9362 , 0.9800 , 0.7413 , 0.1333 , -0.1333 ] ,\n                      [ 0.9574 , 0.9652 , 0.7687 , 0.1097 , -0.1097 ] ,\n                      [ 0.9787 , 0.9533 , 0.8043 , 0.0788 , -0.0788 ] ,\n                      [ 0.9894 , 0.9377 , 0.8280 , 0.0589 , -0.0589 ] ,\n                      [ 1.0000 , 0.9103 , 0.8784 , 0.0162 , -0.0162 ]]),\n\n    \"cone2\":np.array([[ 0.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ] ,\n                      [ 0.0213 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ] ,\n                      [ 0.0638 , 0.9956 , 0.0044 , 0.4956 , -0.4956 ] ,\n                      [ 0.1064 , 0.9875 , 0.0125 , 0.4875 , -0.4875 ] ,\n                      [ 0.1489 , 0.9794 , 0.0206 , 0.4794 , -0.4794 ] ,\n                      [ 0.1915 , 0.9720 , 0.0280 , 0.4720 , -0.4720 ] ,\n                      [ 0.2766 , 0.9566 , 0.0434 , 0.4566 , -0.4566 ] ,\n                      [ 0.3617 , 0.9330 , 0.0670 , 0.4330 , -0.4330 ] ,\n                      [ 0.4894 , 0.8822 , 0.1178 , 0.3822 , -0.3822 ] ,\n                      [ 0.6170 , 0.8240 , 0.1760 , 0.3240 , -0.3240 ] ,\n                      [ 0.7447 , 0.7577 , 0.2423 , 0.2577 , -0.2577 ] ,\n                      [ 0.8723 , 0.6834 , 0.3166 , 0.1834 , -0.1834 ] ,\n                      [ 0.8936 , 0.6679 , 0.3321 , 0.1679 , -0.1679 ] ,\n                      [ 0.9149 , 0.6524 , 0.3476 , 0.1524 , -0.1524 ] ,\n                      [ 0.9362 , 0.6333 , 0.3667 , 0.1333 , -0.1333 ] ,\n                      [ 0.9574 , 0.6097 , 0.3903 , 0.1097 , -0.1097 ] ,\n                      [ 0.9787 , 0.5788 , 0.4212 , 0.0788 , -0.0788 ] ,\n                      [ 0.9894 , 0.5589 , 0.4411 , 0.0589 , -0.0589 ] ,\n                      [ 1.0000 , 0.5162 , 0.4838 , 0.0162 , -0.0162 ]]),\n\n    \"sec1\":np.array([[  0.5000000 , 0.0000000 ,  0.0000000 ] ,\n                     [  0.4903926 , 0.0975452 , -0.0975452 ] ,\n                     [  0.4619398 , 0.1913417 , -0.1913417 ] ,\n                     [  0.4157348 , 0.2777851 , -0.2777851 ] ,\n                     [  0.3535534 , 0.3535534 , -0.3535534 ] ,\n                     [  0.2777851 , 0.4157348 , -0.4157348 ] ,\n                     [  0.1913417 , 0.4619398 , -0.4619398 ] ,\n                     [  0.0975452 , 0.4903926 , -0.4903926 ] ,\n                     [  0.0000000 , 0.5000000 , -0.5000000 ] ,\n                     [- 0.0975452 , 0.4903926 , -0.4903926 ] ,\n                     [- 0.1913417 , 0.4619398 , -0.4619398 ] ,\n                     [- 0.2777851 , 0.4157348 , -0.4157348 ] ,\n                     [- 0.3535534 , 0.3535534 , -0.3535534 ] ,\n                     [- 0.4157348 , 0.2777851 , -0.2777851 ] ,\n                     [- 0.4619398 , 0.1913417 , -0.1913417 ] ,\n                     [- 0.4903926 , 0.0975452 , -0.0975452 ] ,\n                     [- 0.5000000 , 0.0000000 ,  0.0000000 ]]),\n\n    \"sec2\":np.array([[ 0.5000000 , 0.0000000 ,  0.0000000] ,\n                     [ 0.4951963 , 0.0975452 , -0.0975452] ,\n                     [ 0.4809699 , 0.1913417 , -0.1913417] ,\n                     [ 0.4578674 , 0.2777851 , -0.2777851] ,\n                     [ 0.4267767 , 0.3535534 , -0.3535534] ,\n                     [ 0.3888926 , 0.4157348 , -0.4157348] ,\n                     [ 0.3456709 , 0.4619398 , -0.4619398] ,\n                     [ 0.2987726 , 0.4903926 , -0.4903926] ,\n                     [ 0.2500000 , 0.5000000 , -0.5000000] ,\n                     [ 0.0000000 , 0.5000000 , -0.5000000] ,\n                     [-0.2500000 , 0.5000000 , -0.5000000] ,\n                     [-0.2987726 , 0.4903926 , -0.4903926] ,\n                     [-0.3456709 , 0.4619398 , -0.4619398] ,\n                     [-0.3888926 , 0.4157348 , -0.4157348] ,\n                     [-0.4267767 , 0.3535534 , -0.3535534] ,\n                     [-0.4578674 , 0.2777851 , -0.2777851] ,\n                     [-0.4809699 , 0.1913417 , -0.1913417] ,\n                     [-0.4951963 , 0.0975452 , -0.0975452] ,\n                     [-0.5000000 , 0.0000000 ,  0.0000000]])}\n\n    return [curve[n] for n in name]\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/component/#lh2pac.marilib.aircraft.airframe.component.Wing.high_lift","title":"high_lift","text":"<pre><code>high_lift(hld_conf)\n</code></pre> <p>Retrieves max lift and zero aoa lift of a given (flap/slat) deflection (from 0 to 1).     * 0 =&lt; hld_type =&lt; 10 : type of high lift device     * 0 =&lt; hld_conf =&lt; 1  : (slat) flap deflection</p> Typically <ul> <li>hld_conf = 1 gives the :math:<code>C_{z,max}</code> for landind (<code>czmax_ld</code>)</li> <li>hld_conf = 0.1 to 0.5 gives the :math:<code>C_{z,max}</code> for take-off(<code>czmax_to</code>)</li> </ul> <p>.. todo:: check this documentation</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def high_lift(self, hld_conf):\n    \"\"\"Retrieves max lift and zero aoa lift of a given (flap/slat) deflection (from 0 to 1).\n        * 0 =&lt; hld_type =&lt; 10 : type of high lift device\n        * 0 =&lt; hld_conf =&lt; 1  : (slat) flap deflection\n\n    Typically:\n        * hld_conf = 1 gives the :math:`C_{z,max}` for landind (`czmax_ld`)\n        * hld_conf = 0.1 to 0.5 gives the :math:`C_{z,max}` for take-off(`czmax_to`)\n\n    .. todo:: check this documentation\n    \"\"\"\n\n    # Maximum lift coefficients of different airfoils, DUBS 1987\n    czmax_ld = {0 : 1.45 ,  # Clean\n                1 : 2.25 ,  # Flap only, Rotation without slot\n                2 : 2.60 ,  # Flap only, Rotation single slot      (ATR)\n                3 : 2.80 ,  # Flap only, Rotation double slot\n                4 : 2.80 ,  # Fowler Flap\n                5 : 2.00 ,  # Slat only\n                6 : 2.45 ,  # Slat + Flap rotation without slot\n                7 : 2.70 ,  # Slat + Flap rotation single slot\n                8 : 2.90 ,  # Slat + Flap rotation double slot\n                9 : 2.90 ,  # Slat + Fowler                      (A320)\n                10 : 3.20,  # Slat + Fowler + Fowler double slot (A321)\n                }.get(self.hld_type, \"Erreur - high_lift_, HLDtype out of range\")    # 9 is default if x not found\n\n    if (self.hld_type&lt;5):\n        czmax_base = 1.45      # Flap only\n    else:\n        if (hld_conf==0): czmax_base = 1.45 # Clean\n        else: czmax_base = 2.00             # Slat + Flap\n\n    czmax_2d = (1.-hld_conf)*czmax_base + hld_conf*czmax_ld     # Setting effect\n\n    if (hld_conf==0):\n        cz0_2d = 0. # Clean\n    else:\n        cz0_2d = czmax_2d - czmax_base  # Assumed the Lift vs AoA is just translated upward and Cz0 clean equal to zero\n\n    # Source : http://aerodesign.stanford.edu/aircraftdesign/highlift/clmaxest.html\n    czmax = czmax_2d * (1.-0.08*np.cos(self.sweep25)**2) * np.cos(self.sweep25)**0.75\n    cz0 = cz0_2d\n\n    return czmax, cz0\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/","title":"Model","text":""},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model","title":"model","text":"<p>Created on Thu Jan 20 20:20:20 2020</p> <p>@author: Conceptual Airplane Design &amp; Operations (CADO team)          Nicolas PETEILH, Pascal ROCHES, Nicolas MONROLIN, Thierry DRUOT          Aircraft &amp; Systems, Air Transport Departement, ENAC</p>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model-classes","title":"Classes","text":""},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Aerodynamics","title":"Aerodynamics","text":"<pre><code>Aerodynamics(aircraft)\n</code></pre> <p>               Bases: <code>object</code></p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/model.py</code> <pre><code>def __init__(self, aircraft):\n    self.aircraft = aircraft\n\n    self.kcx_correction = aircraft.get_init(self,\"kcx_correction\")  # Drag FACTOR on cx coefficient\n    self.dcx_correction = aircraft.get_init(self,\"dcx_correction\")  # Drag SHIFT on cx coefficient\n    self.cruise_lodmax = aircraft.get_init(self,\"cruise_lodmax\")  # Assumption on L/D max for some initializations\n    self.cz_cruise_lodmax = None\n\n    self.hld_conf_clean = aircraft.get_init(self,\"hld_conf_clean\")\n    self.czmax_conf_clean = None\n\n    self.hld_conf_to = aircraft.get_init(self,\"hld_conf_to\")\n    self.czmax_conf_to = None\n\n    self.hld_conf_ld = aircraft.get_init(self,\"hld_conf_ld\")\n    self.czmax_conf_ld = None\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Aerodynamics-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Aerodynamics.drag","title":"drag","text":"<pre><code>drag(pamb, tamb, mach, cz)\n</code></pre> <p>Retrieves airplane drag and L/D in current flying conditions</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/model.py</code> <pre><code>def drag(self,pamb,tamb,mach,cz):\n    \"\"\"Retrieves airplane drag and L/D in current flying conditions\n    \"\"\"\n    # Form &amp; friction drag\n    #-----------------------------------------------------------------------------------------------------------\n    re = earth.reynolds_number(pamb, tamb, mach)\n\n    fac = ( 1. + 0.126*mach**2 )\n\n    ac_nwa = 0.\n    cxf = 0.\n    for comp in self.aircraft.airframe:\n        nwa = comp.get_net_wet_area()\n        ael = comp.get_aero_length()\n        frm = comp.get_form_factor()\n        if ael&gt;0.:\n            # Drag model is based on flat plane friction drag\n            cxf += frm * ((0.455/fac)*(np.log(10)/np.log(re*ael))**2.58 ) \\\n                       * (nwa/self.aircraft.airframe.wing.area)\n        else:\n            # Drag model is based on drag area, in that case nwa is frontal area\n            cxf += frm * (nwa/self.aircraft.airframe.wing.area)\n        ac_nwa += nwa\n\n    # Parasitic drag (seals, antennas, sensors, ...)\n    #-----------------------------------------------------------------------------------------------------------\n    knwa = ac_nwa/1000.\n\n    kp = (0.0247*knwa - 0.11)*knwa + 0.166       # Parasitic drag factor\n\n    cx_par = cxf*kp\n\n    # Additional drag\n    #-----------------------------------------------------------------------------------------------------------\n    X = np.array([1.0, 1.5, 2.4, 3.3, 4.0, 5.0])\n    Y = np.array([0.036, 0.020, 0.0075, 0.0025, 0., 0.])\n\n    param = self.aircraft.airframe.body.tail_cone_length/self.aircraft.airframe.body.width\n\n    cx_tap_base = lin_interp_1d(param,X,Y)     # Tapered fuselage drag (tail cone)\n\n    cx_tap = cx_tap_base*self.aircraft.power_system.tail_cone_drag_factor()     # Effect of tail cone fan\n\n    # Total zero lift drag\n    #-----------------------------------------------------------------------------------------------------------\n    cx0 = (cxf + cx_par + cx_tap) * self.kcx_correction + self.dcx_correction\n\n    # Induced drag\n    #-----------------------------------------------------------------------------------------------------------\n    cza_wo_htp, xlc_wo_htp, ki_wing = self.aircraft.airframe.wing.eval_aero_data(self.hld_conf_clean, mach)\n    cxi = ki_wing*cz**2  # Induced drag\n\n    # Compressibility drag\n    #-----------------------------------------------------------------------------------------------------------\n    # Freely inspired from Korn equation\n    cz_design = 0.5\n    mach_div = self.aircraft.requirement.cruise_mach + (0.03 + 0.1*(cz_design-cz))\n\n    if 0.55 &lt; mach:\n        cxc = 0.0025 * np.exp(40.*(mach - mach_div) )\n    else:\n        cxc = 0.\n\n    # Sum up\n    #-----------------------------------------------------------------------------------------------------------\n    cx = cx0 + cxi + cxc\n    lod = cz/cx\n\n    return cx,lod\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Aerodynamics.lod_max","title":"lod_max","text":"<pre><code>lod_max(pamb, tamb, mach)\n</code></pre> <p>Maximum lift to drag ratio</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/model.py</code> <pre><code>def lod_max(self,pamb,tamb,mach):\n    \"\"\"Maximum lift to drag ratio\n    \"\"\"\n    def fct(cz):\n        cx,lod = self.drag(pamb,tamb,mach,cz)\n        return lod\n\n    cz_ini = 0.5\n    dcz = 0.05\n    cz_lodmax,lodmax,rc = maximize_1d(cz_ini,dcz,[fct])\n\n    return lodmax,cz_lodmax\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Aerodynamics.specific_air_flow","title":"specific_air_flow","text":"<pre><code>specific_air_flow(r, d, y)\n</code></pre> <p>Specific air flows and speeds at rear end of a cylinder of radius r mouving at Vair in the direction of its axes,    y is the elevation upon the surface of the cylinder : 0 &lt; y &lt; inf Qs = Q/(rho*Vair) Vs = V/Vair WARNING : even if all mass flows are positive, Q0 and Q1 are going backward in fuselage frame, Q2 is going forward in ground frame</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/model.py</code> <pre><code>def specific_air_flow(self,r,d,y):\n    \"\"\"Specific air flows and speeds at rear end of a cylinder of radius r mouving at Vair in the direction of its axes,\n       y is the elevation upon the surface of the cylinder : 0 &lt; y &lt; inf\n    Qs = Q/(rho*Vair)\n    Vs = V/Vair\n    WARNING : even if all mass flows are positive,\n    Q0 and Q1 are going backward in fuselage frame, Q2 is going forward in ground frame\n    \"\"\"\n    n = 1/7     # exponent in the formula of the speed profile inside a turbulent BL of thickness d : Vy/Vair = (y/d)^(1/7)\n    q0s = (2.*np.pi)*( r*y + 0.5*y**2 )     # Cumulated specific air flow at y, without BL, AIRPLANE FRAME\n    ym = min(y,d)\n    q1s = (2.*np.pi)*d*( (r/(n+1))*(ym/d)**(n+1) + (d/(n+2))*(ym/d)**(n+2) )    # Cumulated specific air flow at y inside of the BL, AIRPLANE FRAME\n    if y&gt;d: q1s = q1s + q0s - (2.*np.pi)*( r*d + 0.5*d**2 )                     # Add to Q1 the specific air flow outside of the BL, AIRPLANE FRAME\n    q2s = q0s - q1s     # Cumulated specific air flow at y, inside the BL, GROUND FRAME (going speed wise)\n    v1s = (q1s/q0s)     # Averaged specific speed of Q1 air flow at y\n    dVs = (1. - v1s)    # Averaged specific air flow speed variation at y\n    return q0s,q1s,q2s,v1s,dVs\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Aerodynamics.tail_cone_boundary_layer","title":"tail_cone_boundary_layer","text":"<pre><code>tail_cone_boundary_layer(body_width, hub_width)\n</code></pre> <p>Compute the increase of BL thickness due to the fuselage tail cone tapering Compute the relation between d0 and d1 d0 : boundary layer thickness around a tube of constant diameter d1 : boundary layer thickness around the tapered part of the tube, the nacelle hub in fact</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/model.py</code> <pre><code>def tail_cone_boundary_layer(self,body_width,hub_width):\n    \"\"\"Compute the increase of BL thickness due to the fuselage tail cone tapering\n    Compute the relation between d0 and d1\n    d0 : boundary layer thickness around a tube of constant diameter\n    d1 : boundary layer thickness around the tapered part of the tube, the nacelle hub in fact\n    \"\"\"\n    r0 = 0.5 * body_width   # Radius of the fuselage, supposed constant\n    r1 = 0.5 * hub_width    # Radius of the hub of the efan nacelle\n\n    def fct(d1,r1,d0,r0):\n        q0s0,q1s0,q2s0,v1s0,dvs0 = self.specific_air_flow(r0,d0,d0)\n        q0s1,q1s1,q2s1,v1s1,dvs1 = self.specific_air_flow(r1,d1,d1)\n        y = q2s0 - q2s1\n        return y\n\n    n = 25\n    yVein = np.linspace(0.001,1.50,n)\n    body_bnd_layer = np.zeros((n,2))\n\n    for j in range (0, n-1):\n        fct1s = (r1,yVein[j],r0)\n        # computation of d1 theoretical thickness of the boundary layer that passes the same air flow around the hub\n        body_bnd_layer[j,0] = yVein[j]\n        body_bnd_layer[j,1] = fsolve(fct,yVein[j],fct1s)\n\n    return body_bnd_layer\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Electrofan","title":"Electrofan","text":"<pre><code>Electrofan(aircraft)\n</code></pre> <p>               Bases: <code>PowerSystem</code>, <code>Flight</code></p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/model.py</code> <pre><code>def __init__(self, aircraft):\n    super(Electrofan, self).__init__(aircraft)\n\n    self.n_engine = number_of_engine(aircraft)\n    self.reference_power = 2.*init_power(aircraft)\n\n    if (self.aircraft.arrangement.power_source == \"fuel_cell\"):\n        self.sfc_type = \"thrust\"\n\n    self.data = {\"MTO\":ThrustDataEf(aircraft, nei=1),\n                 \"MCN\":ThrustDataEf(aircraft, nei=1),\n                 \"MCL\":ThrustDataEf(aircraft, nei=0),\n                 \"MCR\":ThrustDataEf(aircraft, nei=0)}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Electrofan-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Electrofan.acceleration","title":"acceleration","text":"<pre><code>acceleration(\n    nei,\n    altp,\n    disa,\n    speed_mode,\n    speed,\n    mass,\n    rating,\n    throttle,\n    full_output=False,\n)\n</code></pre> <p>Aircraft acceleration on level flight</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def acceleration(self,nei,altp,disa,speed_mode,speed,mass,rating,throttle, full_output=False):\n    \"\"\"Aircraft acceleration on level flight\n    \"\"\"\n    r,gam,Cp,Cv = earth.gas_data()\n\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    mach = self.get_mach(pamb,speed_mode,speed)\n\n    dict = self.aircraft.power_system.thrust(pamb,tamb,mach,rating,throttle=throttle,nei=nei)\n    fn = dict[\"fn\"]\n    ff = dict[\"ff\"]\n\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    if(nei&gt;0):\n        dcx = self.aircraft.power_system.oei_drag(pamb,mach)\n        cx = cx + dcx*nei\n\n    acc = (fn - 0.5*gam*pamb*mach**2*self.aircraft.airframe.wing.area*cx) / mass\n\n    if full_output:\n        return acc,fn,ff,cz,cx,pamb,tamb\n    else:\n        return acc\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Electrofan.air_path","title":"air_path","text":"<pre><code>air_path(\n    nei,\n    altp,\n    disa,\n    speed_mode,\n    speed,\n    mass,\n    rating,\n    kfn,\n    full_output=False,\n)\n</code></pre> <p>Retrieve air path in various conditions</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def air_path(self,nei,altp,disa,speed_mode,speed,mass,rating,kfn, full_output=False):\n    \"\"\"Retrieve air path in various conditions\n    \"\"\"\n    g = earth.gravity()\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    mach = self.get_mach(pamb,speed_mode,speed)\n\n    dict = self.aircraft.power_system.thrust(pamb,tamb,mach,rating,nei=nei)\n    fn = dict[\"fn\"]*kfn\n    ff = dict[\"ff\"]*kfn\n    if kfn!=1. and full_output:\n        print(\"WARNING, air_path method, kfn is different from 1, fuel flow may not be accurate\")\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    if(nei&gt;0):\n        dcx = self.aircraft.power_system.oei_drag(pamb,mach)\n        cx = cx + dcx*nei\n        lod = cz/cx\n\n    acc_factor = earth.climb_mode(speed_mode, mach, dtodz, tstd, disa)\n    slope = ( fn/(mass*g) - 1./lod ) / acc_factor\n    vz = slope * mach * earth.sound_speed(tamb)\n    acc = (acc_factor-1.)*g*slope\n    if full_output:\n        return slope,vz,fn,ff,acc,cz,cx,pamb,tamb\n    else:\n        return slope,vz\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Electrofan.arrival_ground_legs","title":"arrival_ground_legs","text":"<pre><code>arrival_ground_legs(ldw)\n</code></pre> <p>Compute fuel and time allowances for arrival ground phases</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def arrival_ground_legs(self,ldw):\n    \"\"\"Compute fuel and time allowances for arrival ground phases\n    \"\"\"\n    n_engine = self.aircraft.power_system.n_engine\n    reference_thrust = self.aircraft.power_system.get_reference_thrust()\n    fuel_type = self.aircraft.arrangement.fuel_type\n\n    time_landing = 180.\n    time_taxi_in = 420.\n\n    if fuel_type!=\"battery\":\n        engine_bpr = self.aircraft.airframe.nacelle.engine_bpr\n        fuel_mass_factor = earth.fuel_heat(\"kerosene\") / earth.fuel_heat(fuel_type)\n        fuel_landing = fuel_mass_factor*1e-4*(0.5+2.3/engine_bpr)*ldw\n        fuel_taxi_in = fuel_mass_factor*(26. + 1.8e-4*reference_thrust)*n_engine\n        return {\"fuel\":{\"landing\":fuel_landing,\"taxi_in\":fuel_taxi_in},\n                \"time\":{\"landing\":time_landing,\"taxi_in\":time_taxi_in}}\n    else:\n        enrg_landing = (0.25*43.1e6)*0.75e-4*ldw\n        enrg_taxi_in = (0.25*43.1e6)*(26. + 1.8e-4*reference_thrust)*n_engine\n        return {\"enrg\":{\"landing\":enrg_landing,\"taxi_in\":enrg_taxi_in},\n                \"time\":{\"landing\":time_landing,\"taxi_in\":time_taxi_in}}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Electrofan.breguet_range","title":"breguet_range","text":"<pre><code>breguet_range(range, tow, ktow, altp, mach, disa)\n</code></pre> <p>Breguet range equation is dependant from power architecture</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def breguet_range(self,range,tow,ktow,altp,mach,disa):\n    \"\"\"Breguet range equation is dependant from power architecture\n    \"\"\"\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    tas = mach * earth.sound_speed(tamb)\n    time = 1.09*(range/tas)\n\n    dict = self.level_flight(pamb,tamb,mach,tow*ktow)\n    val = self.aircraft.power_system.specific_breguet_range(tow,range,tas,dict)\n    return val,time\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Electrofan.departure_ground_legs","title":"departure_ground_legs","text":"<pre><code>departure_ground_legs(tow)\n</code></pre> <p>Compute fuel and time allowances for departure ground phases</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def departure_ground_legs(self,tow):\n    \"\"\"Compute fuel and time allowances for departure ground phases\n    \"\"\"\n    n_engine = self.aircraft.power_system.n_engine\n    reference_thrust = self.aircraft.power_system.get_reference_thrust()\n    fuel_type = self.aircraft.arrangement.fuel_type\n\n    time_taxi_out = 540.\n    time_take_off = 220.*tow/(reference_thrust*n_engine)\n\n    if fuel_type!=\"battery\":\n        engine_bpr = self.aircraft.airframe.nacelle.engine_bpr\n        fuel_mass_factor = earth.fuel_heat(\"kerosene\") / earth.fuel_heat(fuel_type)\n        fuel_taxi_out = fuel_mass_factor*(34. + 2.3e-4*reference_thrust)*n_engine\n        fuel_take_off = fuel_mass_factor*1e-4*(2.8+2.3/engine_bpr)*tow\n        return {\"fuel\":{\"taxi_out\":fuel_taxi_out,\"take_off\":fuel_take_off},\n                \"time\":{\"taxi_out\":time_taxi_out,\"take_off\":time_take_off}}\n    else:\n        enrg_taxi_out = (0.25*43.1e6)*(34. + 2.3e-4*reference_thrust)*n_engine\n        enrg_take_off = (0.25*43.1e6)*3.e-4*tow\n        return {\"enrg\":{\"taxi_out\":enrg_taxi_out,\"take_off\":enrg_take_off},\n                \"time\":{\"taxi_out\":time_taxi_out,\"take_off\":time_take_off}}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Electrofan.descent","title":"descent","text":"<pre><code>descent(nei, altp, disa, speed_mode, speed, vz, mass)\n</code></pre> <p>Retrieve air path and flight characteristics in various conditions</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def descent(self,nei,altp,disa,speed_mode,speed,vz,mass):\n    \"\"\"Retrieve air path and flight characteristics in various conditions\n    \"\"\"\n    g = earth.gravity()\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    mach = self.get_mach(pamb,speed_mode,speed)\n\n    slope = vz / (mach * earth.sound_speed(tamb))\n    acc_factor = earth.climb_mode(speed_mode, mach, dtodz, tstd, disa)\n\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    fn = (slope * acc_factor + 1./lod) * (mass*g)\n    dict = self.aircraft.power_system.sc(self,pamb,tamb,mach,\"FID\", fn, nei)\n    ff = dict[\"sfc\"]*fn\n    thtl = dict[\"thtl\"]\n\n    return slope,thtl,fn,ff,cz,cx,pamb,tamb\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Electrofan.eval_sar","title":"eval_sar","text":"<pre><code>eval_sar(altp, mass, mach, disa)\n</code></pre> <p>Evaluate Specific Air Range</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def eval_sar(self,altp,mass,mach,disa):\n    \"\"\"Evaluate Specific Air Range\n    \"\"\"\n    g = earth.gravity()\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    tas = mach * earth.sound_speed(tamb)\n\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    nei = 0\n    thrust = mass*g / lod\n    dict = self.aircraft.power_system.sc(pamb,tamb,mach,\"MCR\",thrust,nei)\n    dict[\"fn\"] = thrust\n    dict[\"cz\"] = cz\n    dict[\"cx\"] = cx\n    dict[\"lod\"] = lod\n    dict[\"sar\"] = self.aircraft.power_system.specific_air_range(mass,tas,dict)\n    return dict\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Electrofan.get_mach","title":"get_mach","text":"<pre><code>get_mach(pamb, speed_mode, speed)\n</code></pre> <p>Retrieve Mach from CAS or mach depending on speed_mode</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def get_mach(self,pamb,speed_mode,speed):\n    \"\"\"Retrieve Mach from CAS or mach depending on speed_mode\n    \"\"\"\n    mach = {\"cas\" : earth.mach_from_vcas(pamb, speed),  # Input is CAS\n            \"mach\" : speed  # Input is mach\n            }.get(speed_mode, \"Erreur: select speed_mode equal to cas or mach\")\n    return mach\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Electrofan.get_speed","title":"get_speed","text":"<pre><code>get_speed(pamb, speed_mode, mach)\n</code></pre> <p>retrieve CAS or Mach from mach depending on speed_mode</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def get_speed(self,pamb,speed_mode,mach):\n    \"\"\"retrieve CAS or Mach from mach depending on speed_mode\n    \"\"\"\n    speed = {\"cas\" : earth.vcas_from_mach(pamb, mach),  # CAS required\n             \"mach\" : mach  # mach required\n             }.get(speed_mode, \"Erreur: select speed_mode equal to cas or mach\")\n    return speed\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Electrofan.get_vcas","title":"get_vcas","text":"<pre><code>get_vcas(pamb, speed_mode, speed)\n</code></pre> <p>Retrieve CAS from Mach or CAS depending on speed_mode</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def get_vcas(self,pamb,speed_mode,speed):\n    \"\"\"Retrieve CAS from Mach or CAS depending on speed_mode\n    \"\"\"\n    cas = {\"mach\" : earth.vcas_from_mach(pamb, speed),  # Input is CAS\n            \"cas\" : speed  # Input is mach\n            }.get(speed_mode, \"Erreur: select speed_mode equal to cas or mach\")\n    return cas\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Electrofan.holding","title":"holding","text":"<pre><code>holding(time, mass, altp, mach, disa)\n</code></pre> <p>Holding equation is dependant from power architecture</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def holding(self,time,mass,altp,mach,disa):\n    \"\"\"Holding equation is dependant from power architecture\n    \"\"\"\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    tas = mach * earth.sound_speed(tamb)\n    dict = self.level_flight(pamb,tamb,mach,mass)\n    return self.aircraft.power_system.specific_holding(mass,time,tas,dict)\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Electrofan.level_flight","title":"level_flight","text":"<pre><code>level_flight(pamb, tamb, mach, mass)\n</code></pre> <p>Level flight equilibrium</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def level_flight(self,pamb,tamb,mach,mass):\n    \"\"\"Level flight equilibrium\n    \"\"\"\n    g = earth.gravity()\n    r,gam,Cp,Cv = earth.gas_data()\n    tas = mach * earth.sound_speed(tamb)\n\n    cz = (2.*mass*g)/(gam*pamb*mach**2*self.aircraft.airframe.wing.area)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    thrust = (gam/2.)*pamb*mach**2*self.aircraft.airframe.wing.area*cx\n    dict = self.aircraft.power_system.sc(pamb,tamb,mach,\"MCR\",thrust)\n    dict[\"fn\"] = thrust\n    dict[\"cx\"] = cx\n    dict[\"cz\"] = cz\n    dict[\"lod\"] = lod\n    dict[\"sar\"] = self.aircraft.power_system.specific_air_range(mass,tas,dict)\n    return dict\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Electrofan.lift_from_speed","title":"lift_from_speed","text":"<pre><code>lift_from_speed(pamb, tamb, mach, mass)\n</code></pre> <p>Retrieve cz from mach using simplified lift equation</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def lift_from_speed(self,pamb,tamb,mach,mass):\n    \"\"\"Retrieve cz from mach using simplified lift equation\n    \"\"\"\n    g = earth.gravity()\n    r,gam,Cp,Cv = earth.gas_data()\n    cz = (2.*mass*g)/(gam*pamb*mach**2*self.aircraft.airframe.wing.area)\n    return cz\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Electrofan.max_air_path","title":"max_air_path","text":"<pre><code>max_air_path(\n    nei,\n    altp,\n    disa,\n    speed_mode,\n    mass,\n    rating,\n    kfn,\n    full_output=False,\n)\n</code></pre> <p>Optimize the speed of the aircraft to maximize the air path</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def max_air_path(self,nei,altp,disa,speed_mode,mass,rating,kfn, full_output=False):\n    \"\"\"Optimize the speed of the aircraft to maximize the air path\n    \"\"\"\n    def fct(cz):\n        pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n        mach = self.speed_from_lift(pamb,tamb,cz,mass)\n        speed = self.get_speed(pamb,speed_mode,mach)\n        slope,vz = self.air_path(nei,altp,disa,speed_mode,speed,mass,rating,kfn)\n        if isformax: return slope\n        else: return slope,vz,mach\n\n    cz_ini = 0.5\n    dcz = 0.05\n\n    isformax = True\n    cz,slope,rc = maximize_1d(cz_ini,dcz,[fct])\n    isformax = False\n\n    slope,vz,mach = fct(cz)\n    return slope,vz,mach,cz\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Electrofan.oei_drag","title":"oei_drag","text":"<pre><code>oei_drag(pamb, tamb)\n</code></pre> <p>Inoperative engine drag coefficient</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/model.py</code> <pre><code>def oei_drag(self,pamb,tamb):\n    \"\"\"Inoperative engine drag coefficient\n    \"\"\"\n    wing_area = self.aircraft.airframe.wing.area\n    nacelle_width = self.aircraft.airframe.nacelle.width\n\n    dCx = 0.12*nacelle_width**2 / wing_area\n\n    return dCx\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Electrofan.propulsion_ceiling","title":"propulsion_ceiling","text":"<pre><code>propulsion_ceiling(\n    altp_ini,\n    nei,\n    vzreq,\n    disa,\n    speed_mode,\n    speed,\n    mass,\n    rating,\n    throttle,\n)\n</code></pre> <p>Optimize the speed of the aircraft to maximize the air path</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def propulsion_ceiling(self,altp_ini,nei,vzreq,disa,speed_mode,speed,mass,rating,throttle):\n    \"\"\"Optimize the speed of the aircraft to maximize the air path\n    \"\"\"\n    def fct_prop_ceiling(altp,nei,vzreq,disa,speed_mode,speed,mass,rating):\n        slope,vz = self.air_path(nei,altp,disa,speed_mode,speed,mass,rating,throttle)\n        delta_vz = vz - vzreq\n        return delta_vz\n\n    fct_arg = (nei,vzreq,disa,speed_mode,speed,mass,rating)\n\n    output_dict = fsolve(fct_prop_ceiling, x0 = altp_ini, args=fct_arg, full_output = True)\n\n    altp = output_dict[0][0]\n    rei = output_dict[2]\n    if(rei!=1): altp = np.NaN\n\n    return altp, rei\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Electrofan.sc","title":"sc","text":"<pre><code>sc(pamb, tamb, mach, rating, thrust, nei=0)\n</code></pre> <p>Total thrust of a pure turbofan engine</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/model.py</code> <pre><code>def sc(self,pamb,tamb,mach,rating, thrust, nei=0):\n    \"\"\"Total thrust of a pure turbofan engine\n    \"\"\"\n    n_engine = self.aircraft.power_system.n_engine\n    fuel_type = self.aircraft.arrangement.fuel_type\n    fn = thrust/(n_engine - nei)\n\n    dict = self.aircraft.airframe.nacelle.unitary_sc(pamb,tamb,mach,rating,fn)\n    dict[\"sec\"] = dict[\"sec\"] / self.aircraft.airframe.system.wiring_efficiency\n\n    pw_net  = dict[\"sec\"] * thrust\n\n    if (self.aircraft.arrangement.power_source == \"fuel_cell\"):\n        fc_dict = self.aircraft.airframe.system.eval_fuel_cell_power(pw_net,pamb,tamb)\n        dict[\"sfc\"] = fc_dict[\"fuel_flow\"] / thrust     # TSFC here\n        dict[\"ff\"] = fc_dict[\"fuel_flow\"]\n    elif (self.aircraft.arrangement.power_source == \"battery\"):\n        dict[\"sfc\"] = 0.\n        dict[\"ff\"] = 0.\n\n    return dict\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Electrofan.speed_from_lift","title":"speed_from_lift","text":"<pre><code>speed_from_lift(pamb, tamb, cz, mass)\n</code></pre> <p>Retrieve mach from cz using simplified lift equation</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def speed_from_lift(self,pamb,tamb,cz,mass):\n    \"\"\"Retrieve mach from cz using simplified lift equation\n    \"\"\"\n    g = earth.gravity()\n    r,gam,Cp,Cv = earth.gas_data()\n    mach = np.sqrt((mass*g)/(0.5*gam*pamb*self.aircraft.airframe.wing.area*cz))\n    return mach\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Electrofan.thrust","title":"thrust","text":"<pre><code>thrust(pamb, tamb, mach, rating, throttle=1.0, nei=0)\n</code></pre> <p>Total thrust of a pure turbofan engine</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/model.py</code> <pre><code>def thrust(self,pamb,tamb,mach,rating, throttle=1., nei=0):\n    \"\"\"Total thrust of a pure turbofan engine\n    \"\"\"\n    n_engine = self.aircraft.power_system.n_engine\n    fuel_type = self.aircraft.arrangement.fuel_type\n\n    dict = self.aircraft.airframe.nacelle.unitary_thrust(pamb,tamb,mach,rating,throttle=throttle)\n\n    fn = dict[\"fn\"]*(n_engine-nei)\n    pw = dict[\"pw\"]*(n_engine-nei)\n    pw_net = pw / self.aircraft.airframe.system.wiring_efficiency\n    sec = pw_net / fn\n\n    dict = {\"fn\":fn, \"pw\":pw_net, \"sec\":sec, \"fn1\":fn}\n\n    if (self.aircraft.arrangement.power_source == \"fuel_cell\"):\n        fc_dict = self.aircraft.airframe.system.eval_fuel_cell_power(pw_net,pamb,tamb)\n        dict[\"sfc\"] = fc_dict[\"fuel_flow\"] / fn     # TSFC here\n        dict[\"ff\"] = fc_dict[\"fuel_flow\"]\n    elif (self.aircraft.arrangement.power_source == \"battery\"):\n        dict[\"sfc\"] = 0.\n        dict[\"ff\"] = 0.\n\n    return dict\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Electroprop","title":"Electroprop","text":"<pre><code>Electroprop(aircraft)\n</code></pre> <p>               Bases: <code>PowerSystem</code>, <code>Flight</code></p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/model.py</code> <pre><code>def __init__(self, aircraft):\n    super(Electroprop, self).__init__(aircraft)\n\n    self.n_engine = number_of_engine(aircraft)\n    self.reference_power = init_power(aircraft)\n\n    if (self.aircraft.arrangement.power_source == \"fuel_cell\"):\n        self.sfc_type = \"power\"\n\n    self.data = {\"MTO\":ThrustDataEp(aircraft, nei=1),\n                 \"MCN\":ThrustDataEp(aircraft, nei=1),\n                 \"MCL\":ThrustDataEp(aircraft, nei=0),\n                 \"MCR\":ThrustDataEp(aircraft, nei=0)}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Electroprop-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Electroprop.acceleration","title":"acceleration","text":"<pre><code>acceleration(\n    nei,\n    altp,\n    disa,\n    speed_mode,\n    speed,\n    mass,\n    rating,\n    throttle,\n    full_output=False,\n)\n</code></pre> <p>Aircraft acceleration on level flight</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def acceleration(self,nei,altp,disa,speed_mode,speed,mass,rating,throttle, full_output=False):\n    \"\"\"Aircraft acceleration on level flight\n    \"\"\"\n    r,gam,Cp,Cv = earth.gas_data()\n\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    mach = self.get_mach(pamb,speed_mode,speed)\n\n    dict = self.aircraft.power_system.thrust(pamb,tamb,mach,rating,throttle=throttle,nei=nei)\n    fn = dict[\"fn\"]\n    ff = dict[\"ff\"]\n\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    if(nei&gt;0):\n        dcx = self.aircraft.power_system.oei_drag(pamb,mach)\n        cx = cx + dcx*nei\n\n    acc = (fn - 0.5*gam*pamb*mach**2*self.aircraft.airframe.wing.area*cx) / mass\n\n    if full_output:\n        return acc,fn,ff,cz,cx,pamb,tamb\n    else:\n        return acc\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Electroprop.air_path","title":"air_path","text":"<pre><code>air_path(\n    nei,\n    altp,\n    disa,\n    speed_mode,\n    speed,\n    mass,\n    rating,\n    kfn,\n    full_output=False,\n)\n</code></pre> <p>Retrieve air path in various conditions</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def air_path(self,nei,altp,disa,speed_mode,speed,mass,rating,kfn, full_output=False):\n    \"\"\"Retrieve air path in various conditions\n    \"\"\"\n    g = earth.gravity()\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    mach = self.get_mach(pamb,speed_mode,speed)\n\n    dict = self.aircraft.power_system.thrust(pamb,tamb,mach,rating,nei=nei)\n    fn = dict[\"fn\"]*kfn\n    ff = dict[\"ff\"]*kfn\n    if kfn!=1. and full_output:\n        print(\"WARNING, air_path method, kfn is different from 1, fuel flow may not be accurate\")\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    if(nei&gt;0):\n        dcx = self.aircraft.power_system.oei_drag(pamb,mach)\n        cx = cx + dcx*nei\n        lod = cz/cx\n\n    acc_factor = earth.climb_mode(speed_mode, mach, dtodz, tstd, disa)\n    slope = ( fn/(mass*g) - 1./lod ) / acc_factor\n    vz = slope * mach * earth.sound_speed(tamb)\n    acc = (acc_factor-1.)*g*slope\n    if full_output:\n        return slope,vz,fn,ff,acc,cz,cx,pamb,tamb\n    else:\n        return slope,vz\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Electroprop.arrival_ground_legs","title":"arrival_ground_legs","text":"<pre><code>arrival_ground_legs(ldw)\n</code></pre> <p>Compute fuel and time allowances for arrival ground phases</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def arrival_ground_legs(self,ldw):\n    \"\"\"Compute fuel and time allowances for arrival ground phases\n    \"\"\"\n    n_engine = self.aircraft.power_system.n_engine\n    reference_thrust = self.aircraft.power_system.get_reference_thrust()\n    fuel_type = self.aircraft.arrangement.fuel_type\n\n    time_landing = 180.\n    time_taxi_in = 420.\n\n    if fuel_type!=\"battery\":\n        engine_bpr = self.aircraft.airframe.nacelle.engine_bpr\n        fuel_mass_factor = earth.fuel_heat(\"kerosene\") / earth.fuel_heat(fuel_type)\n        fuel_landing = fuel_mass_factor*1e-4*(0.5+2.3/engine_bpr)*ldw\n        fuel_taxi_in = fuel_mass_factor*(26. + 1.8e-4*reference_thrust)*n_engine\n        return {\"fuel\":{\"landing\":fuel_landing,\"taxi_in\":fuel_taxi_in},\n                \"time\":{\"landing\":time_landing,\"taxi_in\":time_taxi_in}}\n    else:\n        enrg_landing = (0.25*43.1e6)*0.75e-4*ldw\n        enrg_taxi_in = (0.25*43.1e6)*(26. + 1.8e-4*reference_thrust)*n_engine\n        return {\"enrg\":{\"landing\":enrg_landing,\"taxi_in\":enrg_taxi_in},\n                \"time\":{\"landing\":time_landing,\"taxi_in\":time_taxi_in}}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Electroprop.breguet_range","title":"breguet_range","text":"<pre><code>breguet_range(range, tow, ktow, altp, mach, disa)\n</code></pre> <p>Breguet range equation is dependant from power architecture</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def breguet_range(self,range,tow,ktow,altp,mach,disa):\n    \"\"\"Breguet range equation is dependant from power architecture\n    \"\"\"\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    tas = mach * earth.sound_speed(tamb)\n    time = 1.09*(range/tas)\n\n    dict = self.level_flight(pamb,tamb,mach,tow*ktow)\n    val = self.aircraft.power_system.specific_breguet_range(tow,range,tas,dict)\n    return val,time\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Electroprop.departure_ground_legs","title":"departure_ground_legs","text":"<pre><code>departure_ground_legs(tow)\n</code></pre> <p>Compute fuel and time allowances for departure ground phases</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def departure_ground_legs(self,tow):\n    \"\"\"Compute fuel and time allowances for departure ground phases\n    \"\"\"\n    n_engine = self.aircraft.power_system.n_engine\n    reference_thrust = self.aircraft.power_system.get_reference_thrust()\n    fuel_type = self.aircraft.arrangement.fuel_type\n\n    time_taxi_out = 540.\n    time_take_off = 220.*tow/(reference_thrust*n_engine)\n\n    if fuel_type!=\"battery\":\n        engine_bpr = self.aircraft.airframe.nacelle.engine_bpr\n        fuel_mass_factor = earth.fuel_heat(\"kerosene\") / earth.fuel_heat(fuel_type)\n        fuel_taxi_out = fuel_mass_factor*(34. + 2.3e-4*reference_thrust)*n_engine\n        fuel_take_off = fuel_mass_factor*1e-4*(2.8+2.3/engine_bpr)*tow\n        return {\"fuel\":{\"taxi_out\":fuel_taxi_out,\"take_off\":fuel_take_off},\n                \"time\":{\"taxi_out\":time_taxi_out,\"take_off\":time_take_off}}\n    else:\n        enrg_taxi_out = (0.25*43.1e6)*(34. + 2.3e-4*reference_thrust)*n_engine\n        enrg_take_off = (0.25*43.1e6)*3.e-4*tow\n        return {\"enrg\":{\"taxi_out\":enrg_taxi_out,\"take_off\":enrg_take_off},\n                \"time\":{\"taxi_out\":time_taxi_out,\"take_off\":time_take_off}}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Electroprop.descent","title":"descent","text":"<pre><code>descent(nei, altp, disa, speed_mode, speed, vz, mass)\n</code></pre> <p>Retrieve air path and flight characteristics in various conditions</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def descent(self,nei,altp,disa,speed_mode,speed,vz,mass):\n    \"\"\"Retrieve air path and flight characteristics in various conditions\n    \"\"\"\n    g = earth.gravity()\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    mach = self.get_mach(pamb,speed_mode,speed)\n\n    slope = vz / (mach * earth.sound_speed(tamb))\n    acc_factor = earth.climb_mode(speed_mode, mach, dtodz, tstd, disa)\n\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    fn = (slope * acc_factor + 1./lod) * (mass*g)\n    dict = self.aircraft.power_system.sc(self,pamb,tamb,mach,\"FID\", fn, nei)\n    ff = dict[\"sfc\"]*fn\n    thtl = dict[\"thtl\"]\n\n    return slope,thtl,fn,ff,cz,cx,pamb,tamb\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Electroprop.eval_sar","title":"eval_sar","text":"<pre><code>eval_sar(altp, mass, mach, disa)\n</code></pre> <p>Evaluate Specific Air Range</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def eval_sar(self,altp,mass,mach,disa):\n    \"\"\"Evaluate Specific Air Range\n    \"\"\"\n    g = earth.gravity()\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    tas = mach * earth.sound_speed(tamb)\n\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    nei = 0\n    thrust = mass*g / lod\n    dict = self.aircraft.power_system.sc(pamb,tamb,mach,\"MCR\",thrust,nei)\n    dict[\"fn\"] = thrust\n    dict[\"cz\"] = cz\n    dict[\"cx\"] = cx\n    dict[\"lod\"] = lod\n    dict[\"sar\"] = self.aircraft.power_system.specific_air_range(mass,tas,dict)\n    return dict\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Electroprop.get_mach","title":"get_mach","text":"<pre><code>get_mach(pamb, speed_mode, speed)\n</code></pre> <p>Retrieve Mach from CAS or mach depending on speed_mode</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def get_mach(self,pamb,speed_mode,speed):\n    \"\"\"Retrieve Mach from CAS or mach depending on speed_mode\n    \"\"\"\n    mach = {\"cas\" : earth.mach_from_vcas(pamb, speed),  # Input is CAS\n            \"mach\" : speed  # Input is mach\n            }.get(speed_mode, \"Erreur: select speed_mode equal to cas or mach\")\n    return mach\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Electroprop.get_speed","title":"get_speed","text":"<pre><code>get_speed(pamb, speed_mode, mach)\n</code></pre> <p>retrieve CAS or Mach from mach depending on speed_mode</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def get_speed(self,pamb,speed_mode,mach):\n    \"\"\"retrieve CAS or Mach from mach depending on speed_mode\n    \"\"\"\n    speed = {\"cas\" : earth.vcas_from_mach(pamb, mach),  # CAS required\n             \"mach\" : mach  # mach required\n             }.get(speed_mode, \"Erreur: select speed_mode equal to cas or mach\")\n    return speed\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Electroprop.get_vcas","title":"get_vcas","text":"<pre><code>get_vcas(pamb, speed_mode, speed)\n</code></pre> <p>Retrieve CAS from Mach or CAS depending on speed_mode</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def get_vcas(self,pamb,speed_mode,speed):\n    \"\"\"Retrieve CAS from Mach or CAS depending on speed_mode\n    \"\"\"\n    cas = {\"mach\" : earth.vcas_from_mach(pamb, speed),  # Input is CAS\n            \"cas\" : speed  # Input is mach\n            }.get(speed_mode, \"Erreur: select speed_mode equal to cas or mach\")\n    return cas\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Electroprop.holding","title":"holding","text":"<pre><code>holding(time, mass, altp, mach, disa)\n</code></pre> <p>Holding equation is dependant from power architecture</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def holding(self,time,mass,altp,mach,disa):\n    \"\"\"Holding equation is dependant from power architecture\n    \"\"\"\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    tas = mach * earth.sound_speed(tamb)\n    dict = self.level_flight(pamb,tamb,mach,mass)\n    return self.aircraft.power_system.specific_holding(mass,time,tas,dict)\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Electroprop.level_flight","title":"level_flight","text":"<pre><code>level_flight(pamb, tamb, mach, mass)\n</code></pre> <p>Level flight equilibrium</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def level_flight(self,pamb,tamb,mach,mass):\n    \"\"\"Level flight equilibrium\n    \"\"\"\n    g = earth.gravity()\n    r,gam,Cp,Cv = earth.gas_data()\n    tas = mach * earth.sound_speed(tamb)\n\n    cz = (2.*mass*g)/(gam*pamb*mach**2*self.aircraft.airframe.wing.area)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    thrust = (gam/2.)*pamb*mach**2*self.aircraft.airframe.wing.area*cx\n    dict = self.aircraft.power_system.sc(pamb,tamb,mach,\"MCR\",thrust)\n    dict[\"fn\"] = thrust\n    dict[\"cx\"] = cx\n    dict[\"cz\"] = cz\n    dict[\"lod\"] = lod\n    dict[\"sar\"] = self.aircraft.power_system.specific_air_range(mass,tas,dict)\n    return dict\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Electroprop.lift_from_speed","title":"lift_from_speed","text":"<pre><code>lift_from_speed(pamb, tamb, mach, mass)\n</code></pre> <p>Retrieve cz from mach using simplified lift equation</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def lift_from_speed(self,pamb,tamb,mach,mass):\n    \"\"\"Retrieve cz from mach using simplified lift equation\n    \"\"\"\n    g = earth.gravity()\n    r,gam,Cp,Cv = earth.gas_data()\n    cz = (2.*mass*g)/(gam*pamb*mach**2*self.aircraft.airframe.wing.area)\n    return cz\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Electroprop.max_air_path","title":"max_air_path","text":"<pre><code>max_air_path(\n    nei,\n    altp,\n    disa,\n    speed_mode,\n    mass,\n    rating,\n    kfn,\n    full_output=False,\n)\n</code></pre> <p>Optimize the speed of the aircraft to maximize the air path</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def max_air_path(self,nei,altp,disa,speed_mode,mass,rating,kfn, full_output=False):\n    \"\"\"Optimize the speed of the aircraft to maximize the air path\n    \"\"\"\n    def fct(cz):\n        pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n        mach = self.speed_from_lift(pamb,tamb,cz,mass)\n        speed = self.get_speed(pamb,speed_mode,mach)\n        slope,vz = self.air_path(nei,altp,disa,speed_mode,speed,mass,rating,kfn)\n        if isformax: return slope\n        else: return slope,vz,mach\n\n    cz_ini = 0.5\n    dcz = 0.05\n\n    isformax = True\n    cz,slope,rc = maximize_1d(cz_ini,dcz,[fct])\n    isformax = False\n\n    slope,vz,mach = fct(cz)\n    return slope,vz,mach,cz\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Electroprop.oei_drag","title":"oei_drag","text":"<pre><code>oei_drag(pamb, tamb)\n</code></pre> <p>Inoperative engine drag coefficient</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/model.py</code> <pre><code>def oei_drag(self,pamb,tamb):\n    \"\"\"Inoperative engine drag coefficient\n    \"\"\"\n    wing_area = self.aircraft.airframe.wing.area\n    nacelle_width = self.aircraft.airframe.nacelle.width\n\n    dCx = 1.15*nacelle_width**2 / wing_area\n\n    return dCx\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Electroprop.propulsion_ceiling","title":"propulsion_ceiling","text":"<pre><code>propulsion_ceiling(\n    altp_ini,\n    nei,\n    vzreq,\n    disa,\n    speed_mode,\n    speed,\n    mass,\n    rating,\n    throttle,\n)\n</code></pre> <p>Optimize the speed of the aircraft to maximize the air path</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def propulsion_ceiling(self,altp_ini,nei,vzreq,disa,speed_mode,speed,mass,rating,throttle):\n    \"\"\"Optimize the speed of the aircraft to maximize the air path\n    \"\"\"\n    def fct_prop_ceiling(altp,nei,vzreq,disa,speed_mode,speed,mass,rating):\n        slope,vz = self.air_path(nei,altp,disa,speed_mode,speed,mass,rating,throttle)\n        delta_vz = vz - vzreq\n        return delta_vz\n\n    fct_arg = (nei,vzreq,disa,speed_mode,speed,mass,rating)\n\n    output_dict = fsolve(fct_prop_ceiling, x0 = altp_ini, args=fct_arg, full_output = True)\n\n    altp = output_dict[0][0]\n    rei = output_dict[2]\n    if(rei!=1): altp = np.NaN\n\n    return altp, rei\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Electroprop.sc","title":"sc","text":"<pre><code>sc(pamb, tamb, mach, rating, thrust, nei=0)\n</code></pre> <p>Total thrust of a pure turbofan engine</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/model.py</code> <pre><code>def sc(self,pamb,tamb,mach,rating, thrust, nei=0):\n    \"\"\"Total thrust of a pure turbofan engine\n    \"\"\"\n    n_engine = self.aircraft.power_system.n_engine\n    fuel_type = self.aircraft.arrangement.fuel_type\n    fn = thrust/(n_engine - nei)\n\n    dict = self.aircraft.airframe.nacelle.unitary_sc(pamb,tamb,mach,rating,fn)\n    dict[\"sec\"] = dict[\"sec\"] / self.aircraft.airframe.system.wiring_efficiency\n\n    pw_net  = dict[\"sec\"] * thrust\n\n    if (self.aircraft.arrangement.power_source == \"fuel_cell\"):\n        fc_dict = self.aircraft.airframe.system.eval_fuel_cell_power(pw_net,pamb,tamb)\n        dict[\"sfc\"] = fc_dict[\"fuel_flow\"] / pw_net     # WARNING : PSFC here\n        dict[\"ff\"] = fc_dict[\"fuel_flow\"]\n    elif (self.aircraft.arrangement.power_source == \"battery\"):\n        dict[\"sfc\"] = 0.\n        dict[\"ff\"] = 0.\n\n    return dict\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Electroprop.speed_from_lift","title":"speed_from_lift","text":"<pre><code>speed_from_lift(pamb, tamb, cz, mass)\n</code></pre> <p>Retrieve mach from cz using simplified lift equation</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def speed_from_lift(self,pamb,tamb,cz,mass):\n    \"\"\"Retrieve mach from cz using simplified lift equation\n    \"\"\"\n    g = earth.gravity()\n    r,gam,Cp,Cv = earth.gas_data()\n    mach = np.sqrt((mass*g)/(0.5*gam*pamb*self.aircraft.airframe.wing.area*cz))\n    return mach\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Electroprop.thrust","title":"thrust","text":"<pre><code>thrust(pamb, tamb, mach, rating, throttle=1.0, nei=0)\n</code></pre> <p>Total thrust of a pure turbofan engine</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/model.py</code> <pre><code>def thrust(self,pamb,tamb,mach,rating, throttle=1., nei=0):\n    \"\"\"Total thrust of a pure turbofan engine\n    \"\"\"\n    n_engine = self.aircraft.power_system.n_engine\n    fuel_type = self.aircraft.arrangement.fuel_type\n\n    dict = self.aircraft.airframe.nacelle.unitary_thrust(pamb,tamb,mach,rating,throttle=throttle)\n\n    fn = dict[\"fn\"]*(n_engine-nei)\n    pw = dict[\"pw\"]*(n_engine-nei)\n    pw_net = pw / self.aircraft.airframe.system.wiring_efficiency\n    sec = pw_net / fn\n\n    dict = {\"fn\":fn, \"pw\":pw_net, \"sec\":sec, \"fn1\":fn}\n\n    if (self.aircraft.arrangement.power_source == \"fuel_cell\"):\n        fc_dict = self.aircraft.airframe.system.eval_fuel_cell_power(pw_net,pamb,tamb)\n        dict[\"sfc\"] = fc_dict[\"fuel_flow\"] / pw_net     # WARNING : PSFC here\n        dict[\"ff\"] = fc_dict[\"fuel_flow\"]\n    elif (self.aircraft.arrangement.power_source == \"battery\"):\n        dict[\"sfc\"] = 0.\n        dict[\"ff\"] = 0.\n\n    return dict\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.PartialTurboElectric","title":"PartialTurboElectric","text":"<pre><code>PartialTurboElectric(aircraft)\n</code></pre> <p>               Bases: <code>PowerSystem</code>, <code>Flight</code></p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/model.py</code> <pre><code>def __init__(self, aircraft):\n    super(PartialTurboElectric, self).__init__(aircraft)\n\n    class_name = \"PowerSystem\"\n\n    self.sfc_correction = aircraft.get_init(class_name,\"sfc_correction\")  # FACTOR on specific fuel consumption\n\n    self.n_engine = number_of_engine(aircraft)\n    self.reference_thrust = init_thrust(aircraft)\n    self.sfc_type = \"thrust\"\n    self.data = {\"MTO\":ThrustDataTf(nei=1),\n                 \"MCN\":ThrustDataTf(nei=1),\n                 \"MCL\":ThrustDataTf(nei=0),\n                 \"MCR\":ThrustDataTf(nei=0)}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.PartialTurboElectric-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.PartialTurboElectric.acceleration","title":"acceleration","text":"<pre><code>acceleration(\n    nei,\n    altp,\n    disa,\n    speed_mode,\n    speed,\n    mass,\n    rating,\n    throttle,\n    full_output=False,\n)\n</code></pre> <p>Aircraft acceleration on level flight</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def acceleration(self,nei,altp,disa,speed_mode,speed,mass,rating,throttle, full_output=False):\n    \"\"\"Aircraft acceleration on level flight\n    \"\"\"\n    r,gam,Cp,Cv = earth.gas_data()\n\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    mach = self.get_mach(pamb,speed_mode,speed)\n\n    dict = self.aircraft.power_system.thrust(pamb,tamb,mach,rating,throttle=throttle,nei=nei)\n    fn = dict[\"fn\"]\n    ff = dict[\"ff\"]\n\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    if(nei&gt;0):\n        dcx = self.aircraft.power_system.oei_drag(pamb,mach)\n        cx = cx + dcx*nei\n\n    acc = (fn - 0.5*gam*pamb*mach**2*self.aircraft.airframe.wing.area*cx) / mass\n\n    if full_output:\n        return acc,fn,ff,cz,cx,pamb,tamb\n    else:\n        return acc\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.PartialTurboElectric.air_path","title":"air_path","text":"<pre><code>air_path(\n    nei,\n    altp,\n    disa,\n    speed_mode,\n    speed,\n    mass,\n    rating,\n    kfn,\n    full_output=False,\n)\n</code></pre> <p>Retrieve air path in various conditions</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def air_path(self,nei,altp,disa,speed_mode,speed,mass,rating,kfn, full_output=False):\n    \"\"\"Retrieve air path in various conditions\n    \"\"\"\n    g = earth.gravity()\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    mach = self.get_mach(pamb,speed_mode,speed)\n\n    dict = self.aircraft.power_system.thrust(pamb,tamb,mach,rating,nei=nei)\n    fn = dict[\"fn\"]*kfn\n    ff = dict[\"ff\"]*kfn\n    if kfn!=1. and full_output:\n        print(\"WARNING, air_path method, kfn is different from 1, fuel flow may not be accurate\")\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    if(nei&gt;0):\n        dcx = self.aircraft.power_system.oei_drag(pamb,mach)\n        cx = cx + dcx*nei\n        lod = cz/cx\n\n    acc_factor = earth.climb_mode(speed_mode, mach, dtodz, tstd, disa)\n    slope = ( fn/(mass*g) - 1./lod ) / acc_factor\n    vz = slope * mach * earth.sound_speed(tamb)\n    acc = (acc_factor-1.)*g*slope\n    if full_output:\n        return slope,vz,fn,ff,acc,cz,cx,pamb,tamb\n    else:\n        return slope,vz\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.PartialTurboElectric.arrival_ground_legs","title":"arrival_ground_legs","text":"<pre><code>arrival_ground_legs(ldw)\n</code></pre> <p>Compute fuel and time allowances for arrival ground phases</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def arrival_ground_legs(self,ldw):\n    \"\"\"Compute fuel and time allowances for arrival ground phases\n    \"\"\"\n    n_engine = self.aircraft.power_system.n_engine\n    reference_thrust = self.aircraft.power_system.get_reference_thrust()\n    fuel_type = self.aircraft.arrangement.fuel_type\n\n    time_landing = 180.\n    time_taxi_in = 420.\n\n    if fuel_type!=\"battery\":\n        engine_bpr = self.aircraft.airframe.nacelle.engine_bpr\n        fuel_mass_factor = earth.fuel_heat(\"kerosene\") / earth.fuel_heat(fuel_type)\n        fuel_landing = fuel_mass_factor*1e-4*(0.5+2.3/engine_bpr)*ldw\n        fuel_taxi_in = fuel_mass_factor*(26. + 1.8e-4*reference_thrust)*n_engine\n        return {\"fuel\":{\"landing\":fuel_landing,\"taxi_in\":fuel_taxi_in},\n                \"time\":{\"landing\":time_landing,\"taxi_in\":time_taxi_in}}\n    else:\n        enrg_landing = (0.25*43.1e6)*0.75e-4*ldw\n        enrg_taxi_in = (0.25*43.1e6)*(26. + 1.8e-4*reference_thrust)*n_engine\n        return {\"enrg\":{\"landing\":enrg_landing,\"taxi_in\":enrg_taxi_in},\n                \"time\":{\"landing\":time_landing,\"taxi_in\":time_taxi_in}}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.PartialTurboElectric.breguet_range","title":"breguet_range","text":"<pre><code>breguet_range(range, tow, ktow, altp, mach, disa)\n</code></pre> <p>Breguet range equation is dependant from power architecture</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def breguet_range(self,range,tow,ktow,altp,mach,disa):\n    \"\"\"Breguet range equation is dependant from power architecture\n    \"\"\"\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    tas = mach * earth.sound_speed(tamb)\n    time = 1.09*(range/tas)\n\n    dict = self.level_flight(pamb,tamb,mach,tow*ktow)\n    val = self.aircraft.power_system.specific_breguet_range(tow,range,tas,dict)\n    return val,time\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.PartialTurboElectric.departure_ground_legs","title":"departure_ground_legs","text":"<pre><code>departure_ground_legs(tow)\n</code></pre> <p>Compute fuel and time allowances for departure ground phases</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def departure_ground_legs(self,tow):\n    \"\"\"Compute fuel and time allowances for departure ground phases\n    \"\"\"\n    n_engine = self.aircraft.power_system.n_engine\n    reference_thrust = self.aircraft.power_system.get_reference_thrust()\n    fuel_type = self.aircraft.arrangement.fuel_type\n\n    time_taxi_out = 540.\n    time_take_off = 220.*tow/(reference_thrust*n_engine)\n\n    if fuel_type!=\"battery\":\n        engine_bpr = self.aircraft.airframe.nacelle.engine_bpr\n        fuel_mass_factor = earth.fuel_heat(\"kerosene\") / earth.fuel_heat(fuel_type)\n        fuel_taxi_out = fuel_mass_factor*(34. + 2.3e-4*reference_thrust)*n_engine\n        fuel_take_off = fuel_mass_factor*1e-4*(2.8+2.3/engine_bpr)*tow\n        return {\"fuel\":{\"taxi_out\":fuel_taxi_out,\"take_off\":fuel_take_off},\n                \"time\":{\"taxi_out\":time_taxi_out,\"take_off\":time_take_off}}\n    else:\n        enrg_taxi_out = (0.25*43.1e6)*(34. + 2.3e-4*reference_thrust)*n_engine\n        enrg_take_off = (0.25*43.1e6)*3.e-4*tow\n        return {\"enrg\":{\"taxi_out\":enrg_taxi_out,\"take_off\":enrg_take_off},\n                \"time\":{\"taxi_out\":time_taxi_out,\"take_off\":time_take_off}}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.PartialTurboElectric.descent","title":"descent","text":"<pre><code>descent(nei, altp, disa, speed_mode, speed, vz, mass)\n</code></pre> <p>Retrieve air path and flight characteristics in various conditions</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def descent(self,nei,altp,disa,speed_mode,speed,vz,mass):\n    \"\"\"Retrieve air path and flight characteristics in various conditions\n    \"\"\"\n    g = earth.gravity()\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    mach = self.get_mach(pamb,speed_mode,speed)\n\n    slope = vz / (mach * earth.sound_speed(tamb))\n    acc_factor = earth.climb_mode(speed_mode, mach, dtodz, tstd, disa)\n\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    fn = (slope * acc_factor + 1./lod) * (mass*g)\n    dict = self.aircraft.power_system.sc(self,pamb,tamb,mach,\"FID\", fn, nei)\n    ff = dict[\"sfc\"]*fn\n    thtl = dict[\"thtl\"]\n\n    return slope,thtl,fn,ff,cz,cx,pamb,tamb\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.PartialTurboElectric.eval_sar","title":"eval_sar","text":"<pre><code>eval_sar(altp, mass, mach, disa)\n</code></pre> <p>Evaluate Specific Air Range</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def eval_sar(self,altp,mass,mach,disa):\n    \"\"\"Evaluate Specific Air Range\n    \"\"\"\n    g = earth.gravity()\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    tas = mach * earth.sound_speed(tamb)\n\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    nei = 0\n    thrust = mass*g / lod\n    dict = self.aircraft.power_system.sc(pamb,tamb,mach,\"MCR\",thrust,nei)\n    dict[\"fn\"] = thrust\n    dict[\"cz\"] = cz\n    dict[\"cx\"] = cx\n    dict[\"lod\"] = lod\n    dict[\"sar\"] = self.aircraft.power_system.specific_air_range(mass,tas,dict)\n    return dict\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.PartialTurboElectric.get_mach","title":"get_mach","text":"<pre><code>get_mach(pamb, speed_mode, speed)\n</code></pre> <p>Retrieve Mach from CAS or mach depending on speed_mode</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def get_mach(self,pamb,speed_mode,speed):\n    \"\"\"Retrieve Mach from CAS or mach depending on speed_mode\n    \"\"\"\n    mach = {\"cas\" : earth.mach_from_vcas(pamb, speed),  # Input is CAS\n            \"mach\" : speed  # Input is mach\n            }.get(speed_mode, \"Erreur: select speed_mode equal to cas or mach\")\n    return mach\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.PartialTurboElectric.get_speed","title":"get_speed","text":"<pre><code>get_speed(pamb, speed_mode, mach)\n</code></pre> <p>retrieve CAS or Mach from mach depending on speed_mode</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def get_speed(self,pamb,speed_mode,mach):\n    \"\"\"retrieve CAS or Mach from mach depending on speed_mode\n    \"\"\"\n    speed = {\"cas\" : earth.vcas_from_mach(pamb, mach),  # CAS required\n             \"mach\" : mach  # mach required\n             }.get(speed_mode, \"Erreur: select speed_mode equal to cas or mach\")\n    return speed\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.PartialTurboElectric.get_vcas","title":"get_vcas","text":"<pre><code>get_vcas(pamb, speed_mode, speed)\n</code></pre> <p>Retrieve CAS from Mach or CAS depending on speed_mode</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def get_vcas(self,pamb,speed_mode,speed):\n    \"\"\"Retrieve CAS from Mach or CAS depending on speed_mode\n    \"\"\"\n    cas = {\"mach\" : earth.vcas_from_mach(pamb, speed),  # Input is CAS\n            \"cas\" : speed  # Input is mach\n            }.get(speed_mode, \"Erreur: select speed_mode equal to cas or mach\")\n    return cas\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.PartialTurboElectric.holding","title":"holding","text":"<pre><code>holding(time, mass, altp, mach, disa)\n</code></pre> <p>Holding equation is dependant from power architecture</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def holding(self,time,mass,altp,mach,disa):\n    \"\"\"Holding equation is dependant from power architecture\n    \"\"\"\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    tas = mach * earth.sound_speed(tamb)\n    dict = self.level_flight(pamb,tamb,mach,mass)\n    return self.aircraft.power_system.specific_holding(mass,time,tas,dict)\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.PartialTurboElectric.level_flight","title":"level_flight","text":"<pre><code>level_flight(pamb, tamb, mach, mass)\n</code></pre> <p>Level flight equilibrium</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def level_flight(self,pamb,tamb,mach,mass):\n    \"\"\"Level flight equilibrium\n    \"\"\"\n    g = earth.gravity()\n    r,gam,Cp,Cv = earth.gas_data()\n    tas = mach * earth.sound_speed(tamb)\n\n    cz = (2.*mass*g)/(gam*pamb*mach**2*self.aircraft.airframe.wing.area)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    thrust = (gam/2.)*pamb*mach**2*self.aircraft.airframe.wing.area*cx\n    dict = self.aircraft.power_system.sc(pamb,tamb,mach,\"MCR\",thrust)\n    dict[\"fn\"] = thrust\n    dict[\"cx\"] = cx\n    dict[\"cz\"] = cz\n    dict[\"lod\"] = lod\n    dict[\"sar\"] = self.aircraft.power_system.specific_air_range(mass,tas,dict)\n    return dict\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.PartialTurboElectric.lift_from_speed","title":"lift_from_speed","text":"<pre><code>lift_from_speed(pamb, tamb, mach, mass)\n</code></pre> <p>Retrieve cz from mach using simplified lift equation</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def lift_from_speed(self,pamb,tamb,mach,mass):\n    \"\"\"Retrieve cz from mach using simplified lift equation\n    \"\"\"\n    g = earth.gravity()\n    r,gam,Cp,Cv = earth.gas_data()\n    cz = (2.*mass*g)/(gam*pamb*mach**2*self.aircraft.airframe.wing.area)\n    return cz\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.PartialTurboElectric.max_air_path","title":"max_air_path","text":"<pre><code>max_air_path(\n    nei,\n    altp,\n    disa,\n    speed_mode,\n    mass,\n    rating,\n    kfn,\n    full_output=False,\n)\n</code></pre> <p>Optimize the speed of the aircraft to maximize the air path</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def max_air_path(self,nei,altp,disa,speed_mode,mass,rating,kfn, full_output=False):\n    \"\"\"Optimize the speed of the aircraft to maximize the air path\n    \"\"\"\n    def fct(cz):\n        pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n        mach = self.speed_from_lift(pamb,tamb,cz,mass)\n        speed = self.get_speed(pamb,speed_mode,mach)\n        slope,vz = self.air_path(nei,altp,disa,speed_mode,speed,mass,rating,kfn)\n        if isformax: return slope\n        else: return slope,vz,mach\n\n    cz_ini = 0.5\n    dcz = 0.05\n\n    isformax = True\n    cz,slope,rc = maximize_1d(cz_ini,dcz,[fct])\n    isformax = False\n\n    slope,vz,mach = fct(cz)\n    return slope,vz,mach,cz\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.PartialTurboElectric.oei_drag","title":"oei_drag","text":"<pre><code>oei_drag(pamb, tamb)\n</code></pre> <p>Inoperative engine drag coefficient</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/model.py</code> <pre><code>def oei_drag(self,pamb,tamb):\n    \"\"\"Inoperative engine drag coefficient\n    \"\"\"\n    wing_area = self.aircraft.airframe.wing.area\n    nacelle_width = self.aircraft.airframe.nacelle.width\n\n    dCx = 0.12*nacelle_width**2 / wing_area\n\n    return dCx\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.PartialTurboElectric.propulsion_ceiling","title":"propulsion_ceiling","text":"<pre><code>propulsion_ceiling(\n    altp_ini,\n    nei,\n    vzreq,\n    disa,\n    speed_mode,\n    speed,\n    mass,\n    rating,\n    throttle,\n)\n</code></pre> <p>Optimize the speed of the aircraft to maximize the air path</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def propulsion_ceiling(self,altp_ini,nei,vzreq,disa,speed_mode,speed,mass,rating,throttle):\n    \"\"\"Optimize the speed of the aircraft to maximize the air path\n    \"\"\"\n    def fct_prop_ceiling(altp,nei,vzreq,disa,speed_mode,speed,mass,rating):\n        slope,vz = self.air_path(nei,altp,disa,speed_mode,speed,mass,rating,throttle)\n        delta_vz = vz - vzreq\n        return delta_vz\n\n    fct_arg = (nei,vzreq,disa,speed_mode,speed,mass,rating)\n\n    output_dict = fsolve(fct_prop_ceiling, x0 = altp_ini, args=fct_arg, full_output = True)\n\n    altp = output_dict[0][0]\n    rei = output_dict[2]\n    if(rei!=1): altp = np.NaN\n\n    return altp, rei\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.PartialTurboElectric.sc","title":"sc","text":"<pre><code>sc(pamb, tamb, mach, rating, thrust, nei=0)\n</code></pre> <p>Total thrust of a pure turbofan engine</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/model.py</code> <pre><code>def sc(self,pamb,tamb,mach,rating, thrust, nei=0):\n    \"\"\"Total thrust of a pure turbofan engine\n    \"\"\"\n    n_engine = self.aircraft.power_system.n_engine\n    fn = thrust/(n_engine - nei)\n\n    def fct(thtl):\n        dict = self.thrust(pamb,tamb,mach,rating, throttle=thtl, nei=nei)\n        return thrust-dict[\"fn\"]\n\n    thtl_ini = 0.9\n    output_dict = fsolve(fct, x0=thtl_ini, args=(), full_output=True)\n    if (output_dict[2]!=1): raise Exception(\"Convergence problem\")\n\n    throttle = output_dict[0][0]\n\n    dict = self.thrust(pamb,tamb,mach,rating, throttle=throttle, nei=nei)\n    sfc = dict[\"sfc\"]\n    t41 = dict[\"t4\"]\n    efn = dict[\"efn\"]\n    epw = dict[\"epw\"]\n\n    return {\"sfc\":sfc, \"thtl\":throttle, \"t4\":t41, \"efn\":efn, \"epw\":epw, \"sec\":epw/efn}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.PartialTurboElectric.speed_from_lift","title":"speed_from_lift","text":"<pre><code>speed_from_lift(pamb, tamb, cz, mass)\n</code></pre> <p>Retrieve mach from cz using simplified lift equation</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def speed_from_lift(self,pamb,tamb,cz,mass):\n    \"\"\"Retrieve mach from cz using simplified lift equation\n    \"\"\"\n    g = earth.gravity()\n    r,gam,Cp,Cv = earth.gas_data()\n    mach = np.sqrt((mass*g)/(0.5*gam*pamb*self.aircraft.airframe.wing.area*cz))\n    return mach\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.PartialTurboElectric.thrust","title":"thrust","text":"<pre><code>thrust(pamb, tamb, mach, rating, throttle=1.0, nei=0)\n</code></pre> <p>Total thrust of a series architecture of turbofan engine and electrofan</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/model.py</code> <pre><code>def thrust(self,pamb,tamb,mach,rating, throttle=1., nei=0):\n    \"\"\"Total thrust of a series architecture of turbofan engine and electrofan\n    \"\"\"\n    n_engine = self.aircraft.power_system.n_engine\n    fuel_type = self.aircraft.arrangement.fuel_type\n    fuel_heat = earth.fuel_heat(fuel_type)\n\n    # Compute power required by electrofan\n    dict_ef = self.aircraft.airframe.tail_nacelle.unitary_thrust(pamb,tamb,mach,rating)\n\n    pw_elec = dict_ef[\"pw\"]\n\n    # Power offtake for one single engine\n    pw_offtake =    pw_elec \\\n                 / self.aircraft.airframe.system.wiring_efficiency \\\n                 / self.aircraft.airframe.system.rectifier_efficiency \\\n                 / self.aircraft.airframe.system.generator_efficiency \\\n                 / (n_engine - nei)\n\n    # Then, compute turbofan thrust according to required power offtake\n    dict_tf = self.aircraft.airframe.nacelle.unitary_thrust(pamb,tamb,mach,rating,throttle=throttle,pw_offtake=pw_offtake)\n\n    fn1 = dict_tf[\"fn\"]*(n_engine-nei)  # All turbofan thrust\n    fn = fn1 + dict_ef[\"fn\"]            # Total thrust\n    ff = dict_tf[\"ff\"]*(n_engine-nei) * earth.fuel_heat(\"kerosene\") / fuel_heat\n    sfc = ff / fn                       # Global SFC\n    t41 = dict_tf[\"t4\"]\n    efn = dict_ef[\"fn\"]\n    epw = dict_ef[\"pw\"]\n\n    return {\"fn\":fn, \"ff\":ff, \"sfc\":sfc, \"t4\":t41, \"fn1\":fn1, \"efn\":efn, \"epw\":epw, \"sec\":epw/efn}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.PartialTurboElectricPiggyBack","title":"PartialTurboElectricPiggyBack","text":"<pre><code>PartialTurboElectricPiggyBack(aircraft)\n</code></pre> <p>               Bases: <code>PartialTurboElectric</code></p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/model.py</code> <pre><code>def __init__(self, aircraft):\n    super(PartialTurboElectricPiggyBack, self).__init__(aircraft)\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.PartialTurboElectricPiggyBack-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.PartialTurboElectricPiggyBack.acceleration","title":"acceleration","text":"<pre><code>acceleration(\n    nei,\n    altp,\n    disa,\n    speed_mode,\n    speed,\n    mass,\n    rating,\n    throttle,\n    full_output=False,\n)\n</code></pre> <p>Aircraft acceleration on level flight</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def acceleration(self,nei,altp,disa,speed_mode,speed,mass,rating,throttle, full_output=False):\n    \"\"\"Aircraft acceleration on level flight\n    \"\"\"\n    r,gam,Cp,Cv = earth.gas_data()\n\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    mach = self.get_mach(pamb,speed_mode,speed)\n\n    dict = self.aircraft.power_system.thrust(pamb,tamb,mach,rating,throttle=throttle,nei=nei)\n    fn = dict[\"fn\"]\n    ff = dict[\"ff\"]\n\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    if(nei&gt;0):\n        dcx = self.aircraft.power_system.oei_drag(pamb,mach)\n        cx = cx + dcx*nei\n\n    acc = (fn - 0.5*gam*pamb*mach**2*self.aircraft.airframe.wing.area*cx) / mass\n\n    if full_output:\n        return acc,fn,ff,cz,cx,pamb,tamb\n    else:\n        return acc\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.PartialTurboElectricPiggyBack.air_path","title":"air_path","text":"<pre><code>air_path(\n    nei,\n    altp,\n    disa,\n    speed_mode,\n    speed,\n    mass,\n    rating,\n    kfn,\n    full_output=False,\n)\n</code></pre> <p>Retrieve air path in various conditions</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def air_path(self,nei,altp,disa,speed_mode,speed,mass,rating,kfn, full_output=False):\n    \"\"\"Retrieve air path in various conditions\n    \"\"\"\n    g = earth.gravity()\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    mach = self.get_mach(pamb,speed_mode,speed)\n\n    dict = self.aircraft.power_system.thrust(pamb,tamb,mach,rating,nei=nei)\n    fn = dict[\"fn\"]*kfn\n    ff = dict[\"ff\"]*kfn\n    if kfn!=1. and full_output:\n        print(\"WARNING, air_path method, kfn is different from 1, fuel flow may not be accurate\")\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    if(nei&gt;0):\n        dcx = self.aircraft.power_system.oei_drag(pamb,mach)\n        cx = cx + dcx*nei\n        lod = cz/cx\n\n    acc_factor = earth.climb_mode(speed_mode, mach, dtodz, tstd, disa)\n    slope = ( fn/(mass*g) - 1./lod ) / acc_factor\n    vz = slope * mach * earth.sound_speed(tamb)\n    acc = (acc_factor-1.)*g*slope\n    if full_output:\n        return slope,vz,fn,ff,acc,cz,cx,pamb,tamb\n    else:\n        return slope,vz\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.PartialTurboElectricPiggyBack.arrival_ground_legs","title":"arrival_ground_legs","text":"<pre><code>arrival_ground_legs(ldw)\n</code></pre> <p>Compute fuel and time allowances for arrival ground phases</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def arrival_ground_legs(self,ldw):\n    \"\"\"Compute fuel and time allowances for arrival ground phases\n    \"\"\"\n    n_engine = self.aircraft.power_system.n_engine\n    reference_thrust = self.aircraft.power_system.get_reference_thrust()\n    fuel_type = self.aircraft.arrangement.fuel_type\n\n    time_landing = 180.\n    time_taxi_in = 420.\n\n    if fuel_type!=\"battery\":\n        engine_bpr = self.aircraft.airframe.nacelle.engine_bpr\n        fuel_mass_factor = earth.fuel_heat(\"kerosene\") / earth.fuel_heat(fuel_type)\n        fuel_landing = fuel_mass_factor*1e-4*(0.5+2.3/engine_bpr)*ldw\n        fuel_taxi_in = fuel_mass_factor*(26. + 1.8e-4*reference_thrust)*n_engine\n        return {\"fuel\":{\"landing\":fuel_landing,\"taxi_in\":fuel_taxi_in},\n                \"time\":{\"landing\":time_landing,\"taxi_in\":time_taxi_in}}\n    else:\n        enrg_landing = (0.25*43.1e6)*0.75e-4*ldw\n        enrg_taxi_in = (0.25*43.1e6)*(26. + 1.8e-4*reference_thrust)*n_engine\n        return {\"enrg\":{\"landing\":enrg_landing,\"taxi_in\":enrg_taxi_in},\n                \"time\":{\"landing\":time_landing,\"taxi_in\":time_taxi_in}}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.PartialTurboElectricPiggyBack.breguet_range","title":"breguet_range","text":"<pre><code>breguet_range(range, tow, ktow, altp, mach, disa)\n</code></pre> <p>Breguet range equation is dependant from power architecture</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def breguet_range(self,range,tow,ktow,altp,mach,disa):\n    \"\"\"Breguet range equation is dependant from power architecture\n    \"\"\"\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    tas = mach * earth.sound_speed(tamb)\n    time = 1.09*(range/tas)\n\n    dict = self.level_flight(pamb,tamb,mach,tow*ktow)\n    val = self.aircraft.power_system.specific_breguet_range(tow,range,tas,dict)\n    return val,time\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.PartialTurboElectricPiggyBack.departure_ground_legs","title":"departure_ground_legs","text":"<pre><code>departure_ground_legs(tow)\n</code></pre> <p>Compute fuel and time allowances for departure ground phases</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def departure_ground_legs(self,tow):\n    \"\"\"Compute fuel and time allowances for departure ground phases\n    \"\"\"\n    n_engine = self.aircraft.power_system.n_engine\n    reference_thrust = self.aircraft.power_system.get_reference_thrust()\n    fuel_type = self.aircraft.arrangement.fuel_type\n\n    time_taxi_out = 540.\n    time_take_off = 220.*tow/(reference_thrust*n_engine)\n\n    if fuel_type!=\"battery\":\n        engine_bpr = self.aircraft.airframe.nacelle.engine_bpr\n        fuel_mass_factor = earth.fuel_heat(\"kerosene\") / earth.fuel_heat(fuel_type)\n        fuel_taxi_out = fuel_mass_factor*(34. + 2.3e-4*reference_thrust)*n_engine\n        fuel_take_off = fuel_mass_factor*1e-4*(2.8+2.3/engine_bpr)*tow\n        return {\"fuel\":{\"taxi_out\":fuel_taxi_out,\"take_off\":fuel_take_off},\n                \"time\":{\"taxi_out\":time_taxi_out,\"take_off\":time_take_off}}\n    else:\n        enrg_taxi_out = (0.25*43.1e6)*(34. + 2.3e-4*reference_thrust)*n_engine\n        enrg_take_off = (0.25*43.1e6)*3.e-4*tow\n        return {\"enrg\":{\"taxi_out\":enrg_taxi_out,\"take_off\":enrg_take_off},\n                \"time\":{\"taxi_out\":time_taxi_out,\"take_off\":time_take_off}}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.PartialTurboElectricPiggyBack.descent","title":"descent","text":"<pre><code>descent(nei, altp, disa, speed_mode, speed, vz, mass)\n</code></pre> <p>Retrieve air path and flight characteristics in various conditions</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def descent(self,nei,altp,disa,speed_mode,speed,vz,mass):\n    \"\"\"Retrieve air path and flight characteristics in various conditions\n    \"\"\"\n    g = earth.gravity()\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    mach = self.get_mach(pamb,speed_mode,speed)\n\n    slope = vz / (mach * earth.sound_speed(tamb))\n    acc_factor = earth.climb_mode(speed_mode, mach, dtodz, tstd, disa)\n\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    fn = (slope * acc_factor + 1./lod) * (mass*g)\n    dict = self.aircraft.power_system.sc(self,pamb,tamb,mach,\"FID\", fn, nei)\n    ff = dict[\"sfc\"]*fn\n    thtl = dict[\"thtl\"]\n\n    return slope,thtl,fn,ff,cz,cx,pamb,tamb\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.PartialTurboElectricPiggyBack.eval_sar","title":"eval_sar","text":"<pre><code>eval_sar(altp, mass, mach, disa)\n</code></pre> <p>Evaluate Specific Air Range</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def eval_sar(self,altp,mass,mach,disa):\n    \"\"\"Evaluate Specific Air Range\n    \"\"\"\n    g = earth.gravity()\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    tas = mach * earth.sound_speed(tamb)\n\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    nei = 0\n    thrust = mass*g / lod\n    dict = self.aircraft.power_system.sc(pamb,tamb,mach,\"MCR\",thrust,nei)\n    dict[\"fn\"] = thrust\n    dict[\"cz\"] = cz\n    dict[\"cx\"] = cx\n    dict[\"lod\"] = lod\n    dict[\"sar\"] = self.aircraft.power_system.specific_air_range(mass,tas,dict)\n    return dict\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.PartialTurboElectricPiggyBack.get_mach","title":"get_mach","text":"<pre><code>get_mach(pamb, speed_mode, speed)\n</code></pre> <p>Retrieve Mach from CAS or mach depending on speed_mode</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def get_mach(self,pamb,speed_mode,speed):\n    \"\"\"Retrieve Mach from CAS or mach depending on speed_mode\n    \"\"\"\n    mach = {\"cas\" : earth.mach_from_vcas(pamb, speed),  # Input is CAS\n            \"mach\" : speed  # Input is mach\n            }.get(speed_mode, \"Erreur: select speed_mode equal to cas or mach\")\n    return mach\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.PartialTurboElectricPiggyBack.get_speed","title":"get_speed","text":"<pre><code>get_speed(pamb, speed_mode, mach)\n</code></pre> <p>retrieve CAS or Mach from mach depending on speed_mode</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def get_speed(self,pamb,speed_mode,mach):\n    \"\"\"retrieve CAS or Mach from mach depending on speed_mode\n    \"\"\"\n    speed = {\"cas\" : earth.vcas_from_mach(pamb, mach),  # CAS required\n             \"mach\" : mach  # mach required\n             }.get(speed_mode, \"Erreur: select speed_mode equal to cas or mach\")\n    return speed\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.PartialTurboElectricPiggyBack.get_vcas","title":"get_vcas","text":"<pre><code>get_vcas(pamb, speed_mode, speed)\n</code></pre> <p>Retrieve CAS from Mach or CAS depending on speed_mode</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def get_vcas(self,pamb,speed_mode,speed):\n    \"\"\"Retrieve CAS from Mach or CAS depending on speed_mode\n    \"\"\"\n    cas = {\"mach\" : earth.vcas_from_mach(pamb, speed),  # Input is CAS\n            \"cas\" : speed  # Input is mach\n            }.get(speed_mode, \"Erreur: select speed_mode equal to cas or mach\")\n    return cas\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.PartialTurboElectricPiggyBack.holding","title":"holding","text":"<pre><code>holding(time, mass, altp, mach, disa)\n</code></pre> <p>Holding equation is dependant from power architecture</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def holding(self,time,mass,altp,mach,disa):\n    \"\"\"Holding equation is dependant from power architecture\n    \"\"\"\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    tas = mach * earth.sound_speed(tamb)\n    dict = self.level_flight(pamb,tamb,mach,mass)\n    return self.aircraft.power_system.specific_holding(mass,time,tas,dict)\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.PartialTurboElectricPiggyBack.level_flight","title":"level_flight","text":"<pre><code>level_flight(pamb, tamb, mach, mass)\n</code></pre> <p>Level flight equilibrium</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def level_flight(self,pamb,tamb,mach,mass):\n    \"\"\"Level flight equilibrium\n    \"\"\"\n    g = earth.gravity()\n    r,gam,Cp,Cv = earth.gas_data()\n    tas = mach * earth.sound_speed(tamb)\n\n    cz = (2.*mass*g)/(gam*pamb*mach**2*self.aircraft.airframe.wing.area)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    thrust = (gam/2.)*pamb*mach**2*self.aircraft.airframe.wing.area*cx\n    dict = self.aircraft.power_system.sc(pamb,tamb,mach,\"MCR\",thrust)\n    dict[\"fn\"] = thrust\n    dict[\"cx\"] = cx\n    dict[\"cz\"] = cz\n    dict[\"lod\"] = lod\n    dict[\"sar\"] = self.aircraft.power_system.specific_air_range(mass,tas,dict)\n    return dict\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.PartialTurboElectricPiggyBack.lift_from_speed","title":"lift_from_speed","text":"<pre><code>lift_from_speed(pamb, tamb, mach, mass)\n</code></pre> <p>Retrieve cz from mach using simplified lift equation</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def lift_from_speed(self,pamb,tamb,mach,mass):\n    \"\"\"Retrieve cz from mach using simplified lift equation\n    \"\"\"\n    g = earth.gravity()\n    r,gam,Cp,Cv = earth.gas_data()\n    cz = (2.*mass*g)/(gam*pamb*mach**2*self.aircraft.airframe.wing.area)\n    return cz\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.PartialTurboElectricPiggyBack.max_air_path","title":"max_air_path","text":"<pre><code>max_air_path(\n    nei,\n    altp,\n    disa,\n    speed_mode,\n    mass,\n    rating,\n    kfn,\n    full_output=False,\n)\n</code></pre> <p>Optimize the speed of the aircraft to maximize the air path</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def max_air_path(self,nei,altp,disa,speed_mode,mass,rating,kfn, full_output=False):\n    \"\"\"Optimize the speed of the aircraft to maximize the air path\n    \"\"\"\n    def fct(cz):\n        pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n        mach = self.speed_from_lift(pamb,tamb,cz,mass)\n        speed = self.get_speed(pamb,speed_mode,mach)\n        slope,vz = self.air_path(nei,altp,disa,speed_mode,speed,mass,rating,kfn)\n        if isformax: return slope\n        else: return slope,vz,mach\n\n    cz_ini = 0.5\n    dcz = 0.05\n\n    isformax = True\n    cz,slope,rc = maximize_1d(cz_ini,dcz,[fct])\n    isformax = False\n\n    slope,vz,mach = fct(cz)\n    return slope,vz,mach,cz\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.PartialTurboElectricPiggyBack.oei_drag","title":"oei_drag","text":"<pre><code>oei_drag(pamb, tamb)\n</code></pre> <p>Inoperative engine drag coefficient</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/model.py</code> <pre><code>def oei_drag(self,pamb,tamb):\n    \"\"\"Inoperative engine drag coefficient\n    \"\"\"\n    wing_area = self.aircraft.airframe.wing.area\n    nacelle_width = self.aircraft.airframe.nacelle.width\n\n    dCx = 0.12*nacelle_width**2 / wing_area\n\n    return dCx\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.PartialTurboElectricPiggyBack.propulsion_ceiling","title":"propulsion_ceiling","text":"<pre><code>propulsion_ceiling(\n    altp_ini,\n    nei,\n    vzreq,\n    disa,\n    speed_mode,\n    speed,\n    mass,\n    rating,\n    throttle,\n)\n</code></pre> <p>Optimize the speed of the aircraft to maximize the air path</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def propulsion_ceiling(self,altp_ini,nei,vzreq,disa,speed_mode,speed,mass,rating,throttle):\n    \"\"\"Optimize the speed of the aircraft to maximize the air path\n    \"\"\"\n    def fct_prop_ceiling(altp,nei,vzreq,disa,speed_mode,speed,mass,rating):\n        slope,vz = self.air_path(nei,altp,disa,speed_mode,speed,mass,rating,throttle)\n        delta_vz = vz - vzreq\n        return delta_vz\n\n    fct_arg = (nei,vzreq,disa,speed_mode,speed,mass,rating)\n\n    output_dict = fsolve(fct_prop_ceiling, x0 = altp_ini, args=fct_arg, full_output = True)\n\n    altp = output_dict[0][0]\n    rei = output_dict[2]\n    if(rei!=1): altp = np.NaN\n\n    return altp, rei\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.PartialTurboElectricPiggyBack.sc","title":"sc","text":"<pre><code>sc(pamb, tamb, mach, rating, thrust, nei=0)\n</code></pre> <p>Total thrust of a pure turbofan engine</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/model.py</code> <pre><code>def sc(self,pamb,tamb,mach,rating, thrust, nei=0):\n    \"\"\"Total thrust of a pure turbofan engine\n    \"\"\"\n    n_engine = self.aircraft.power_system.n_engine\n    fn = thrust/(n_engine - nei)\n\n    def fct(thtl):\n        dict = self.thrust(pamb,tamb,mach,rating, throttle=thtl, nei=nei)\n        return thrust-dict[\"fn\"]\n\n    thtl_ini = 0.9\n    output_dict = fsolve(fct, x0=thtl_ini, args=(), full_output=True)\n    if (output_dict[2]!=1): raise Exception(\"Convergence problem\")\n\n    throttle = output_dict[0][0]\n\n    dict = self.thrust(pamb,tamb,mach,rating, throttle=throttle, nei=nei)\n    sfc = dict[\"sfc\"]\n    t41 = dict[\"t4\"]\n    efn = dict[\"efn\"]\n    epw = dict[\"epw\"]\n\n    return {\"sfc\":sfc, \"thtl\":throttle, \"t4\":t41, \"efn\":efn, \"epw\":epw, \"sec\":epw/efn}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.PartialTurboElectricPiggyBack.speed_from_lift","title":"speed_from_lift","text":"<pre><code>speed_from_lift(pamb, tamb, cz, mass)\n</code></pre> <p>Retrieve mach from cz using simplified lift equation</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def speed_from_lift(self,pamb,tamb,cz,mass):\n    \"\"\"Retrieve mach from cz using simplified lift equation\n    \"\"\"\n    g = earth.gravity()\n    r,gam,Cp,Cv = earth.gas_data()\n    mach = np.sqrt((mass*g)/(0.5*gam*pamb*self.aircraft.airframe.wing.area*cz))\n    return mach\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.PartialTurboElectricPiggyBack.thrust","title":"thrust","text":"<pre><code>thrust(pamb, tamb, mach, rating, throttle=1.0, nei=0)\n</code></pre> <p>Total thrust of a series architecture of turbofan engine and electrofan</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/model.py</code> <pre><code>def thrust(self,pamb,tamb,mach,rating, throttle=1., nei=0):\n    \"\"\"Total thrust of a series architecture of turbofan engine and electrofan\n    \"\"\"\n    n_engine = self.aircraft.power_system.n_engine\n    fuel_type = self.aircraft.arrangement.fuel_type\n    fuel_heat = earth.fuel_heat(fuel_type)\n\n    # Compute power required by body tail electrofan\n    dict_ef1 = self.aircraft.airframe.tail_nacelle.unitary_thrust(pamb,tamb,mach,rating)\n\n    # Compute power required by piggyback tail electrofan\n    dict_ef2 = self.aircraft.airframe.other_tail_nacelle.unitary_thrust(pamb,tamb,mach,rating)\n\n    pw_elec = dict_ef1[\"pw\"] + dict_ef2[\"pw\"]\n\n    # Power offtake for one single engine\n    pw_offtake =    pw_elec \\\n                 / self.aircraft.airframe.system.wiring_efficiency \\\n                 / self.aircraft.airframe.system.rectifier_efficiency \\\n                 / self.aircraft.airframe.system.generator_efficiency \\\n                 / (n_engine - nei)\n\n    # Then, compute turbofan thrust according to required power offtake\n    dict_tf = self.aircraft.airframe.nacelle.unitary_thrust(pamb,tamb,mach,rating,throttle=throttle,pw_offtake=pw_offtake)\n\n    fn1 = dict_tf[\"fn\"]*(n_engine-nei)          # All turbofan thrust\n    fn = fn1 + dict_ef1[\"fn\"] + dict_ef2[\"fn\"]  # Total thrust\n    ff = dict_tf[\"ff\"]*self.sfc_correction * (n_engine-nei) * earth.fuel_heat(\"kerosene\") / fuel_heat\n    sfc = ff / fn                       # Global SFC\n    t41 = dict_tf[\"t4\"]\n    efn = dict_ef1[\"fn\"] + dict_ef2[\"fn\"]\n    epw = dict_ef1[\"pw\"] + dict_ef2[\"pw\"]\n\n    return {\"fn\":fn, \"ff\":ff, \"sfc\":sfc, \"t4\":t41, \"fn1\":fn1, \"efn\":efn, \"epw\":epw, \"sec\":epw/efn}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.PartialTurboElectricPods","title":"PartialTurboElectricPods","text":"<pre><code>PartialTurboElectricPods(aircraft)\n</code></pre> <p>               Bases: <code>PartialTurboElectric</code></p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/model.py</code> <pre><code>def __init__(self, aircraft):\n    super(PartialTurboElectricPods, self).__init__(aircraft)\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.PartialTurboElectricPods-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.PartialTurboElectricPods.acceleration","title":"acceleration","text":"<pre><code>acceleration(\n    nei,\n    altp,\n    disa,\n    speed_mode,\n    speed,\n    mass,\n    rating,\n    throttle,\n    full_output=False,\n)\n</code></pre> <p>Aircraft acceleration on level flight</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def acceleration(self,nei,altp,disa,speed_mode,speed,mass,rating,throttle, full_output=False):\n    \"\"\"Aircraft acceleration on level flight\n    \"\"\"\n    r,gam,Cp,Cv = earth.gas_data()\n\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    mach = self.get_mach(pamb,speed_mode,speed)\n\n    dict = self.aircraft.power_system.thrust(pamb,tamb,mach,rating,throttle=throttle,nei=nei)\n    fn = dict[\"fn\"]\n    ff = dict[\"ff\"]\n\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    if(nei&gt;0):\n        dcx = self.aircraft.power_system.oei_drag(pamb,mach)\n        cx = cx + dcx*nei\n\n    acc = (fn - 0.5*gam*pamb*mach**2*self.aircraft.airframe.wing.area*cx) / mass\n\n    if full_output:\n        return acc,fn,ff,cz,cx,pamb,tamb\n    else:\n        return acc\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.PartialTurboElectricPods.air_path","title":"air_path","text":"<pre><code>air_path(\n    nei,\n    altp,\n    disa,\n    speed_mode,\n    speed,\n    mass,\n    rating,\n    kfn,\n    full_output=False,\n)\n</code></pre> <p>Retrieve air path in various conditions</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def air_path(self,nei,altp,disa,speed_mode,speed,mass,rating,kfn, full_output=False):\n    \"\"\"Retrieve air path in various conditions\n    \"\"\"\n    g = earth.gravity()\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    mach = self.get_mach(pamb,speed_mode,speed)\n\n    dict = self.aircraft.power_system.thrust(pamb,tamb,mach,rating,nei=nei)\n    fn = dict[\"fn\"]*kfn\n    ff = dict[\"ff\"]*kfn\n    if kfn!=1. and full_output:\n        print(\"WARNING, air_path method, kfn is different from 1, fuel flow may not be accurate\")\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    if(nei&gt;0):\n        dcx = self.aircraft.power_system.oei_drag(pamb,mach)\n        cx = cx + dcx*nei\n        lod = cz/cx\n\n    acc_factor = earth.climb_mode(speed_mode, mach, dtodz, tstd, disa)\n    slope = ( fn/(mass*g) - 1./lod ) / acc_factor\n    vz = slope * mach * earth.sound_speed(tamb)\n    acc = (acc_factor-1.)*g*slope\n    if full_output:\n        return slope,vz,fn,ff,acc,cz,cx,pamb,tamb\n    else:\n        return slope,vz\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.PartialTurboElectricPods.arrival_ground_legs","title":"arrival_ground_legs","text":"<pre><code>arrival_ground_legs(ldw)\n</code></pre> <p>Compute fuel and time allowances for arrival ground phases</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def arrival_ground_legs(self,ldw):\n    \"\"\"Compute fuel and time allowances for arrival ground phases\n    \"\"\"\n    n_engine = self.aircraft.power_system.n_engine\n    reference_thrust = self.aircraft.power_system.get_reference_thrust()\n    fuel_type = self.aircraft.arrangement.fuel_type\n\n    time_landing = 180.\n    time_taxi_in = 420.\n\n    if fuel_type!=\"battery\":\n        engine_bpr = self.aircraft.airframe.nacelle.engine_bpr\n        fuel_mass_factor = earth.fuel_heat(\"kerosene\") / earth.fuel_heat(fuel_type)\n        fuel_landing = fuel_mass_factor*1e-4*(0.5+2.3/engine_bpr)*ldw\n        fuel_taxi_in = fuel_mass_factor*(26. + 1.8e-4*reference_thrust)*n_engine\n        return {\"fuel\":{\"landing\":fuel_landing,\"taxi_in\":fuel_taxi_in},\n                \"time\":{\"landing\":time_landing,\"taxi_in\":time_taxi_in}}\n    else:\n        enrg_landing = (0.25*43.1e6)*0.75e-4*ldw\n        enrg_taxi_in = (0.25*43.1e6)*(26. + 1.8e-4*reference_thrust)*n_engine\n        return {\"enrg\":{\"landing\":enrg_landing,\"taxi_in\":enrg_taxi_in},\n                \"time\":{\"landing\":time_landing,\"taxi_in\":time_taxi_in}}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.PartialTurboElectricPods.breguet_range","title":"breguet_range","text":"<pre><code>breguet_range(range, tow, ktow, altp, mach, disa)\n</code></pre> <p>Breguet range equation is dependant from power architecture</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def breguet_range(self,range,tow,ktow,altp,mach,disa):\n    \"\"\"Breguet range equation is dependant from power architecture\n    \"\"\"\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    tas = mach * earth.sound_speed(tamb)\n    time = 1.09*(range/tas)\n\n    dict = self.level_flight(pamb,tamb,mach,tow*ktow)\n    val = self.aircraft.power_system.specific_breguet_range(tow,range,tas,dict)\n    return val,time\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.PartialTurboElectricPods.departure_ground_legs","title":"departure_ground_legs","text":"<pre><code>departure_ground_legs(tow)\n</code></pre> <p>Compute fuel and time allowances for departure ground phases</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def departure_ground_legs(self,tow):\n    \"\"\"Compute fuel and time allowances for departure ground phases\n    \"\"\"\n    n_engine = self.aircraft.power_system.n_engine\n    reference_thrust = self.aircraft.power_system.get_reference_thrust()\n    fuel_type = self.aircraft.arrangement.fuel_type\n\n    time_taxi_out = 540.\n    time_take_off = 220.*tow/(reference_thrust*n_engine)\n\n    if fuel_type!=\"battery\":\n        engine_bpr = self.aircraft.airframe.nacelle.engine_bpr\n        fuel_mass_factor = earth.fuel_heat(\"kerosene\") / earth.fuel_heat(fuel_type)\n        fuel_taxi_out = fuel_mass_factor*(34. + 2.3e-4*reference_thrust)*n_engine\n        fuel_take_off = fuel_mass_factor*1e-4*(2.8+2.3/engine_bpr)*tow\n        return {\"fuel\":{\"taxi_out\":fuel_taxi_out,\"take_off\":fuel_take_off},\n                \"time\":{\"taxi_out\":time_taxi_out,\"take_off\":time_take_off}}\n    else:\n        enrg_taxi_out = (0.25*43.1e6)*(34. + 2.3e-4*reference_thrust)*n_engine\n        enrg_take_off = (0.25*43.1e6)*3.e-4*tow\n        return {\"enrg\":{\"taxi_out\":enrg_taxi_out,\"take_off\":enrg_take_off},\n                \"time\":{\"taxi_out\":time_taxi_out,\"take_off\":time_take_off}}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.PartialTurboElectricPods.descent","title":"descent","text":"<pre><code>descent(nei, altp, disa, speed_mode, speed, vz, mass)\n</code></pre> <p>Retrieve air path and flight characteristics in various conditions</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def descent(self,nei,altp,disa,speed_mode,speed,vz,mass):\n    \"\"\"Retrieve air path and flight characteristics in various conditions\n    \"\"\"\n    g = earth.gravity()\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    mach = self.get_mach(pamb,speed_mode,speed)\n\n    slope = vz / (mach * earth.sound_speed(tamb))\n    acc_factor = earth.climb_mode(speed_mode, mach, dtodz, tstd, disa)\n\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    fn = (slope * acc_factor + 1./lod) * (mass*g)\n    dict = self.aircraft.power_system.sc(self,pamb,tamb,mach,\"FID\", fn, nei)\n    ff = dict[\"sfc\"]*fn\n    thtl = dict[\"thtl\"]\n\n    return slope,thtl,fn,ff,cz,cx,pamb,tamb\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.PartialTurboElectricPods.eval_sar","title":"eval_sar","text":"<pre><code>eval_sar(altp, mass, mach, disa)\n</code></pre> <p>Evaluate Specific Air Range</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def eval_sar(self,altp,mass,mach,disa):\n    \"\"\"Evaluate Specific Air Range\n    \"\"\"\n    g = earth.gravity()\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    tas = mach * earth.sound_speed(tamb)\n\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    nei = 0\n    thrust = mass*g / lod\n    dict = self.aircraft.power_system.sc(pamb,tamb,mach,\"MCR\",thrust,nei)\n    dict[\"fn\"] = thrust\n    dict[\"cz\"] = cz\n    dict[\"cx\"] = cx\n    dict[\"lod\"] = lod\n    dict[\"sar\"] = self.aircraft.power_system.specific_air_range(mass,tas,dict)\n    return dict\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.PartialTurboElectricPods.get_mach","title":"get_mach","text":"<pre><code>get_mach(pamb, speed_mode, speed)\n</code></pre> <p>Retrieve Mach from CAS or mach depending on speed_mode</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def get_mach(self,pamb,speed_mode,speed):\n    \"\"\"Retrieve Mach from CAS or mach depending on speed_mode\n    \"\"\"\n    mach = {\"cas\" : earth.mach_from_vcas(pamb, speed),  # Input is CAS\n            \"mach\" : speed  # Input is mach\n            }.get(speed_mode, \"Erreur: select speed_mode equal to cas or mach\")\n    return mach\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.PartialTurboElectricPods.get_speed","title":"get_speed","text":"<pre><code>get_speed(pamb, speed_mode, mach)\n</code></pre> <p>retrieve CAS or Mach from mach depending on speed_mode</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def get_speed(self,pamb,speed_mode,mach):\n    \"\"\"retrieve CAS or Mach from mach depending on speed_mode\n    \"\"\"\n    speed = {\"cas\" : earth.vcas_from_mach(pamb, mach),  # CAS required\n             \"mach\" : mach  # mach required\n             }.get(speed_mode, \"Erreur: select speed_mode equal to cas or mach\")\n    return speed\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.PartialTurboElectricPods.get_vcas","title":"get_vcas","text":"<pre><code>get_vcas(pamb, speed_mode, speed)\n</code></pre> <p>Retrieve CAS from Mach or CAS depending on speed_mode</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def get_vcas(self,pamb,speed_mode,speed):\n    \"\"\"Retrieve CAS from Mach or CAS depending on speed_mode\n    \"\"\"\n    cas = {\"mach\" : earth.vcas_from_mach(pamb, speed),  # Input is CAS\n            \"cas\" : speed  # Input is mach\n            }.get(speed_mode, \"Erreur: select speed_mode equal to cas or mach\")\n    return cas\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.PartialTurboElectricPods.holding","title":"holding","text":"<pre><code>holding(time, mass, altp, mach, disa)\n</code></pre> <p>Holding equation is dependant from power architecture</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def holding(self,time,mass,altp,mach,disa):\n    \"\"\"Holding equation is dependant from power architecture\n    \"\"\"\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    tas = mach * earth.sound_speed(tamb)\n    dict = self.level_flight(pamb,tamb,mach,mass)\n    return self.aircraft.power_system.specific_holding(mass,time,tas,dict)\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.PartialTurboElectricPods.level_flight","title":"level_flight","text":"<pre><code>level_flight(pamb, tamb, mach, mass)\n</code></pre> <p>Level flight equilibrium</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def level_flight(self,pamb,tamb,mach,mass):\n    \"\"\"Level flight equilibrium\n    \"\"\"\n    g = earth.gravity()\n    r,gam,Cp,Cv = earth.gas_data()\n    tas = mach * earth.sound_speed(tamb)\n\n    cz = (2.*mass*g)/(gam*pamb*mach**2*self.aircraft.airframe.wing.area)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    thrust = (gam/2.)*pamb*mach**2*self.aircraft.airframe.wing.area*cx\n    dict = self.aircraft.power_system.sc(pamb,tamb,mach,\"MCR\",thrust)\n    dict[\"fn\"] = thrust\n    dict[\"cx\"] = cx\n    dict[\"cz\"] = cz\n    dict[\"lod\"] = lod\n    dict[\"sar\"] = self.aircraft.power_system.specific_air_range(mass,tas,dict)\n    return dict\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.PartialTurboElectricPods.lift_from_speed","title":"lift_from_speed","text":"<pre><code>lift_from_speed(pamb, tamb, mach, mass)\n</code></pre> <p>Retrieve cz from mach using simplified lift equation</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def lift_from_speed(self,pamb,tamb,mach,mass):\n    \"\"\"Retrieve cz from mach using simplified lift equation\n    \"\"\"\n    g = earth.gravity()\n    r,gam,Cp,Cv = earth.gas_data()\n    cz = (2.*mass*g)/(gam*pamb*mach**2*self.aircraft.airframe.wing.area)\n    return cz\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.PartialTurboElectricPods.max_air_path","title":"max_air_path","text":"<pre><code>max_air_path(\n    nei,\n    altp,\n    disa,\n    speed_mode,\n    mass,\n    rating,\n    kfn,\n    full_output=False,\n)\n</code></pre> <p>Optimize the speed of the aircraft to maximize the air path</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def max_air_path(self,nei,altp,disa,speed_mode,mass,rating,kfn, full_output=False):\n    \"\"\"Optimize the speed of the aircraft to maximize the air path\n    \"\"\"\n    def fct(cz):\n        pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n        mach = self.speed_from_lift(pamb,tamb,cz,mass)\n        speed = self.get_speed(pamb,speed_mode,mach)\n        slope,vz = self.air_path(nei,altp,disa,speed_mode,speed,mass,rating,kfn)\n        if isformax: return slope\n        else: return slope,vz,mach\n\n    cz_ini = 0.5\n    dcz = 0.05\n\n    isformax = True\n    cz,slope,rc = maximize_1d(cz_ini,dcz,[fct])\n    isformax = False\n\n    slope,vz,mach = fct(cz)\n    return slope,vz,mach,cz\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.PartialTurboElectricPods.oei_drag","title":"oei_drag","text":"<pre><code>oei_drag(pamb, tamb)\n</code></pre> <p>Inoperative engine drag coefficient</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/model.py</code> <pre><code>def oei_drag(self,pamb,tamb):\n    \"\"\"Inoperative engine drag coefficient\n    \"\"\"\n    wing_area = self.aircraft.airframe.wing.area\n    nacelle_width = self.aircraft.airframe.nacelle.width\n\n    dCx = 0.12*nacelle_width**2 / wing_area\n\n    return dCx\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.PartialTurboElectricPods.propulsion_ceiling","title":"propulsion_ceiling","text":"<pre><code>propulsion_ceiling(\n    altp_ini,\n    nei,\n    vzreq,\n    disa,\n    speed_mode,\n    speed,\n    mass,\n    rating,\n    throttle,\n)\n</code></pre> <p>Optimize the speed of the aircraft to maximize the air path</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def propulsion_ceiling(self,altp_ini,nei,vzreq,disa,speed_mode,speed,mass,rating,throttle):\n    \"\"\"Optimize the speed of the aircraft to maximize the air path\n    \"\"\"\n    def fct_prop_ceiling(altp,nei,vzreq,disa,speed_mode,speed,mass,rating):\n        slope,vz = self.air_path(nei,altp,disa,speed_mode,speed,mass,rating,throttle)\n        delta_vz = vz - vzreq\n        return delta_vz\n\n    fct_arg = (nei,vzreq,disa,speed_mode,speed,mass,rating)\n\n    output_dict = fsolve(fct_prop_ceiling, x0 = altp_ini, args=fct_arg, full_output = True)\n\n    altp = output_dict[0][0]\n    rei = output_dict[2]\n    if(rei!=1): altp = np.NaN\n\n    return altp, rei\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.PartialTurboElectricPods.sc","title":"sc","text":"<pre><code>sc(pamb, tamb, mach, rating, thrust, nei=0)\n</code></pre> <p>Total thrust of a pure turbofan engine</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/model.py</code> <pre><code>def sc(self,pamb,tamb,mach,rating, thrust, nei=0):\n    \"\"\"Total thrust of a pure turbofan engine\n    \"\"\"\n    n_engine = self.aircraft.power_system.n_engine\n    fn = thrust/(n_engine - nei)\n\n    def fct(thtl):\n        dict = self.thrust(pamb,tamb,mach,rating, throttle=thtl, nei=nei)\n        return thrust-dict[\"fn\"]\n\n    thtl_ini = 0.9\n    output_dict = fsolve(fct, x0=thtl_ini, args=(), full_output=True)\n    if (output_dict[2]!=1): raise Exception(\"Convergence problem\")\n\n    throttle = output_dict[0][0]\n\n    dict = self.thrust(pamb,tamb,mach,rating, throttle=throttle, nei=nei)\n    sfc = dict[\"sfc\"]\n    t41 = dict[\"t4\"]\n    efn = dict[\"efn\"]\n    epw = dict[\"epw\"]\n\n    return {\"sfc\":sfc, \"thtl\":throttle, \"t4\":t41, \"efn\":efn, \"epw\":epw, \"sec\":epw/efn}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.PartialTurboElectricPods.speed_from_lift","title":"speed_from_lift","text":"<pre><code>speed_from_lift(pamb, tamb, cz, mass)\n</code></pre> <p>Retrieve mach from cz using simplified lift equation</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def speed_from_lift(self,pamb,tamb,cz,mass):\n    \"\"\"Retrieve mach from cz using simplified lift equation\n    \"\"\"\n    g = earth.gravity()\n    r,gam,Cp,Cv = earth.gas_data()\n    mach = np.sqrt((mass*g)/(0.5*gam*pamb*self.aircraft.airframe.wing.area*cz))\n    return mach\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.PartialTurboElectricPods.thrust","title":"thrust","text":"<pre><code>thrust(pamb, tamb, mach, rating, throttle=1.0, nei=0)\n</code></pre> <p>Total thrust of a series architecture of turbofan engine and electrofan</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/model.py</code> <pre><code>def thrust(self,pamb,tamb,mach,rating, throttle=1., nei=0):\n    \"\"\"Total thrust of a series architecture of turbofan engine and electrofan\n    \"\"\"\n    n_engine = self.aircraft.power_system.n_engine\n    fuel_type = self.aircraft.arrangement.fuel_type\n    fuel_heat = earth.fuel_heat(fuel_type)\n\n    # Compute power required by body tail electrofan\n    dict_ef1 = self.aircraft.airframe.tail_nacelle.unitary_thrust(pamb,tamb,mach,rating)\n\n    # Compute power required by tank pod tail electrofan\n    dict_ef2 = self.aircraft.airframe.pod_tail_nacelle.unitary_thrust(pamb,tamb,mach,rating)\n\n    pw_elec = dict_ef1[\"pw\"] + 2.*dict_ef2[\"pw\"]\n\n    # Power offtake for one single engine\n    pw_offtake =    pw_elec \\\n                 / self.aircraft.airframe.system.wiring_efficiency \\\n                 / self.aircraft.airframe.system.rectifier_efficiency \\\n                 / self.aircraft.airframe.system.generator_efficiency \\\n                 / (n_engine - nei)\n\n    # Then, compute turbofan thrust according to required power offtake\n    dict_tf = self.aircraft.airframe.nacelle.unitary_thrust(pamb,tamb,mach,rating,throttle=throttle,pw_offtake=pw_offtake)\n\n    fn1 = dict_tf[\"fn\"]*(n_engine-nei)              # All turbofan thrust\n    fn = fn1 + dict_ef1[\"fn\"] + 2.*dict_ef2[\"fn\"]   # Total thrust\n    ff = dict_tf[\"ff\"]*self.sfc_correction * (n_engine-nei) * earth.fuel_heat(\"kerosene\") / fuel_heat\n    sfc = ff / fn                       # Global SFC\n    t41 = dict_tf[\"t4\"]\n    efn = dict_ef1[\"fn\"] + 2.*dict_ef2[\"fn\"]\n    epw = dict_ef1[\"pw\"] + 2.*dict_ef2[\"pw\"]\n\n    return {\"fn\":fn, \"ff\":ff, \"sfc\":sfc, \"t4\":t41, \"fn1\":fn1, \"efn\":efn, \"epw\":epw, \"sec\":epw/efn}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.PowerSystem","title":"PowerSystem","text":"<pre><code>PowerSystem(aircraft)\n</code></pre> <p>               Bases: <code>object</code></p> <p>A generic class that describes a power system.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/model.py</code> <pre><code>def __init__(self, aircraft):\n    self.aircraft = aircraft\n\n    self.data = {\"MTO\":ThrustData(nei=1),\n                 \"MCN\":ThrustData(nei=1),\n                 \"MCL\":ThrustData(nei=0),\n                 \"MCR\":ThrustData(nei=0)}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Turbofan","title":"Turbofan","text":"<pre><code>Turbofan(aircraft)\n</code></pre> <p>               Bases: <code>PowerSystem</code>, <code>Flight</code></p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/model.py</code> <pre><code>def __init__(self, aircraft):\n    super(Turbofan, self).__init__(aircraft)\n\n    class_name = \"PowerSystem\"\n\n    self.sfc_correction = aircraft.get_init(class_name,\"sfc_correction\")  # FACTOR on specific fuel consumption\n\n    self.n_engine = number_of_engine(aircraft)\n    self.reference_thrust = init_thrust(aircraft)\n    self.sfc_type = \"thrust\"\n    self.data = {\"MTO\":ThrustDataTf(nei=1),\n                 \"MCN\":ThrustDataTf(nei=1),\n                 \"MCL\":ThrustDataTf(nei=0),\n                 \"MCR\":ThrustDataTf(nei=0)}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Turbofan-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Turbofan.acceleration","title":"acceleration","text":"<pre><code>acceleration(\n    nei,\n    altp,\n    disa,\n    speed_mode,\n    speed,\n    mass,\n    rating,\n    throttle,\n    full_output=False,\n)\n</code></pre> <p>Aircraft acceleration on level flight</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def acceleration(self,nei,altp,disa,speed_mode,speed,mass,rating,throttle, full_output=False):\n    \"\"\"Aircraft acceleration on level flight\n    \"\"\"\n    r,gam,Cp,Cv = earth.gas_data()\n\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    mach = self.get_mach(pamb,speed_mode,speed)\n\n    dict = self.aircraft.power_system.thrust(pamb,tamb,mach,rating,throttle=throttle,nei=nei)\n    fn = dict[\"fn\"]\n    ff = dict[\"ff\"]\n\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    if(nei&gt;0):\n        dcx = self.aircraft.power_system.oei_drag(pamb,mach)\n        cx = cx + dcx*nei\n\n    acc = (fn - 0.5*gam*pamb*mach**2*self.aircraft.airframe.wing.area*cx) / mass\n\n    if full_output:\n        return acc,fn,ff,cz,cx,pamb,tamb\n    else:\n        return acc\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Turbofan.air_path","title":"air_path","text":"<pre><code>air_path(\n    nei,\n    altp,\n    disa,\n    speed_mode,\n    speed,\n    mass,\n    rating,\n    kfn,\n    full_output=False,\n)\n</code></pre> <p>Retrieve air path in various conditions</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def air_path(self,nei,altp,disa,speed_mode,speed,mass,rating,kfn, full_output=False):\n    \"\"\"Retrieve air path in various conditions\n    \"\"\"\n    g = earth.gravity()\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    mach = self.get_mach(pamb,speed_mode,speed)\n\n    dict = self.aircraft.power_system.thrust(pamb,tamb,mach,rating,nei=nei)\n    fn = dict[\"fn\"]*kfn\n    ff = dict[\"ff\"]*kfn\n    if kfn!=1. and full_output:\n        print(\"WARNING, air_path method, kfn is different from 1, fuel flow may not be accurate\")\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    if(nei&gt;0):\n        dcx = self.aircraft.power_system.oei_drag(pamb,mach)\n        cx = cx + dcx*nei\n        lod = cz/cx\n\n    acc_factor = earth.climb_mode(speed_mode, mach, dtodz, tstd, disa)\n    slope = ( fn/(mass*g) - 1./lod ) / acc_factor\n    vz = slope * mach * earth.sound_speed(tamb)\n    acc = (acc_factor-1.)*g*slope\n    if full_output:\n        return slope,vz,fn,ff,acc,cz,cx,pamb,tamb\n    else:\n        return slope,vz\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Turbofan.arrival_ground_legs","title":"arrival_ground_legs","text":"<pre><code>arrival_ground_legs(ldw)\n</code></pre> <p>Compute fuel and time allowances for arrival ground phases</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def arrival_ground_legs(self,ldw):\n    \"\"\"Compute fuel and time allowances for arrival ground phases\n    \"\"\"\n    n_engine = self.aircraft.power_system.n_engine\n    reference_thrust = self.aircraft.power_system.get_reference_thrust()\n    fuel_type = self.aircraft.arrangement.fuel_type\n\n    time_landing = 180.\n    time_taxi_in = 420.\n\n    if fuel_type!=\"battery\":\n        engine_bpr = self.aircraft.airframe.nacelle.engine_bpr\n        fuel_mass_factor = earth.fuel_heat(\"kerosene\") / earth.fuel_heat(fuel_type)\n        fuel_landing = fuel_mass_factor*1e-4*(0.5+2.3/engine_bpr)*ldw\n        fuel_taxi_in = fuel_mass_factor*(26. + 1.8e-4*reference_thrust)*n_engine\n        return {\"fuel\":{\"landing\":fuel_landing,\"taxi_in\":fuel_taxi_in},\n                \"time\":{\"landing\":time_landing,\"taxi_in\":time_taxi_in}}\n    else:\n        enrg_landing = (0.25*43.1e6)*0.75e-4*ldw\n        enrg_taxi_in = (0.25*43.1e6)*(26. + 1.8e-4*reference_thrust)*n_engine\n        return {\"enrg\":{\"landing\":enrg_landing,\"taxi_in\":enrg_taxi_in},\n                \"time\":{\"landing\":time_landing,\"taxi_in\":time_taxi_in}}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Turbofan.breguet_range","title":"breguet_range","text":"<pre><code>breguet_range(range, tow, ktow, altp, mach, disa)\n</code></pre> <p>Breguet range equation is dependant from power architecture</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def breguet_range(self,range,tow,ktow,altp,mach,disa):\n    \"\"\"Breguet range equation is dependant from power architecture\n    \"\"\"\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    tas = mach * earth.sound_speed(tamb)\n    time = 1.09*(range/tas)\n\n    dict = self.level_flight(pamb,tamb,mach,tow*ktow)\n    val = self.aircraft.power_system.specific_breguet_range(tow,range,tas,dict)\n    return val,time\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Turbofan.departure_ground_legs","title":"departure_ground_legs","text":"<pre><code>departure_ground_legs(tow)\n</code></pre> <p>Compute fuel and time allowances for departure ground phases</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def departure_ground_legs(self,tow):\n    \"\"\"Compute fuel and time allowances for departure ground phases\n    \"\"\"\n    n_engine = self.aircraft.power_system.n_engine\n    reference_thrust = self.aircraft.power_system.get_reference_thrust()\n    fuel_type = self.aircraft.arrangement.fuel_type\n\n    time_taxi_out = 540.\n    time_take_off = 220.*tow/(reference_thrust*n_engine)\n\n    if fuel_type!=\"battery\":\n        engine_bpr = self.aircraft.airframe.nacelle.engine_bpr\n        fuel_mass_factor = earth.fuel_heat(\"kerosene\") / earth.fuel_heat(fuel_type)\n        fuel_taxi_out = fuel_mass_factor*(34. + 2.3e-4*reference_thrust)*n_engine\n        fuel_take_off = fuel_mass_factor*1e-4*(2.8+2.3/engine_bpr)*tow\n        return {\"fuel\":{\"taxi_out\":fuel_taxi_out,\"take_off\":fuel_take_off},\n                \"time\":{\"taxi_out\":time_taxi_out,\"take_off\":time_take_off}}\n    else:\n        enrg_taxi_out = (0.25*43.1e6)*(34. + 2.3e-4*reference_thrust)*n_engine\n        enrg_take_off = (0.25*43.1e6)*3.e-4*tow\n        return {\"enrg\":{\"taxi_out\":enrg_taxi_out,\"take_off\":enrg_take_off},\n                \"time\":{\"taxi_out\":time_taxi_out,\"take_off\":time_take_off}}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Turbofan.descent","title":"descent","text":"<pre><code>descent(nei, altp, disa, speed_mode, speed, vz, mass)\n</code></pre> <p>Retrieve air path and flight characteristics in various conditions</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def descent(self,nei,altp,disa,speed_mode,speed,vz,mass):\n    \"\"\"Retrieve air path and flight characteristics in various conditions\n    \"\"\"\n    g = earth.gravity()\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    mach = self.get_mach(pamb,speed_mode,speed)\n\n    slope = vz / (mach * earth.sound_speed(tamb))\n    acc_factor = earth.climb_mode(speed_mode, mach, dtodz, tstd, disa)\n\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    fn = (slope * acc_factor + 1./lod) * (mass*g)\n    dict = self.aircraft.power_system.sc(self,pamb,tamb,mach,\"FID\", fn, nei)\n    ff = dict[\"sfc\"]*fn\n    thtl = dict[\"thtl\"]\n\n    return slope,thtl,fn,ff,cz,cx,pamb,tamb\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Turbofan.eval_sar","title":"eval_sar","text":"<pre><code>eval_sar(altp, mass, mach, disa)\n</code></pre> <p>Evaluate Specific Air Range</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def eval_sar(self,altp,mass,mach,disa):\n    \"\"\"Evaluate Specific Air Range\n    \"\"\"\n    g = earth.gravity()\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    tas = mach * earth.sound_speed(tamb)\n\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    nei = 0\n    thrust = mass*g / lod\n    dict = self.aircraft.power_system.sc(pamb,tamb,mach,\"MCR\",thrust,nei)\n    dict[\"fn\"] = thrust\n    dict[\"cz\"] = cz\n    dict[\"cx\"] = cx\n    dict[\"lod\"] = lod\n    dict[\"sar\"] = self.aircraft.power_system.specific_air_range(mass,tas,dict)\n    return dict\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Turbofan.get_mach","title":"get_mach","text":"<pre><code>get_mach(pamb, speed_mode, speed)\n</code></pre> <p>Retrieve Mach from CAS or mach depending on speed_mode</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def get_mach(self,pamb,speed_mode,speed):\n    \"\"\"Retrieve Mach from CAS or mach depending on speed_mode\n    \"\"\"\n    mach = {\"cas\" : earth.mach_from_vcas(pamb, speed),  # Input is CAS\n            \"mach\" : speed  # Input is mach\n            }.get(speed_mode, \"Erreur: select speed_mode equal to cas or mach\")\n    return mach\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Turbofan.get_speed","title":"get_speed","text":"<pre><code>get_speed(pamb, speed_mode, mach)\n</code></pre> <p>retrieve CAS or Mach from mach depending on speed_mode</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def get_speed(self,pamb,speed_mode,mach):\n    \"\"\"retrieve CAS or Mach from mach depending on speed_mode\n    \"\"\"\n    speed = {\"cas\" : earth.vcas_from_mach(pamb, mach),  # CAS required\n             \"mach\" : mach  # mach required\n             }.get(speed_mode, \"Erreur: select speed_mode equal to cas or mach\")\n    return speed\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Turbofan.get_vcas","title":"get_vcas","text":"<pre><code>get_vcas(pamb, speed_mode, speed)\n</code></pre> <p>Retrieve CAS from Mach or CAS depending on speed_mode</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def get_vcas(self,pamb,speed_mode,speed):\n    \"\"\"Retrieve CAS from Mach or CAS depending on speed_mode\n    \"\"\"\n    cas = {\"mach\" : earth.vcas_from_mach(pamb, speed),  # Input is CAS\n            \"cas\" : speed  # Input is mach\n            }.get(speed_mode, \"Erreur: select speed_mode equal to cas or mach\")\n    return cas\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Turbofan.holding","title":"holding","text":"<pre><code>holding(time, mass, altp, mach, disa)\n</code></pre> <p>Holding equation is dependant from power architecture</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def holding(self,time,mass,altp,mach,disa):\n    \"\"\"Holding equation is dependant from power architecture\n    \"\"\"\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    tas = mach * earth.sound_speed(tamb)\n    dict = self.level_flight(pamb,tamb,mach,mass)\n    return self.aircraft.power_system.specific_holding(mass,time,tas,dict)\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Turbofan.level_flight","title":"level_flight","text":"<pre><code>level_flight(pamb, tamb, mach, mass)\n</code></pre> <p>Level flight equilibrium</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def level_flight(self,pamb,tamb,mach,mass):\n    \"\"\"Level flight equilibrium\n    \"\"\"\n    g = earth.gravity()\n    r,gam,Cp,Cv = earth.gas_data()\n    tas = mach * earth.sound_speed(tamb)\n\n    cz = (2.*mass*g)/(gam*pamb*mach**2*self.aircraft.airframe.wing.area)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    thrust = (gam/2.)*pamb*mach**2*self.aircraft.airframe.wing.area*cx\n    dict = self.aircraft.power_system.sc(pamb,tamb,mach,\"MCR\",thrust)\n    dict[\"fn\"] = thrust\n    dict[\"cx\"] = cx\n    dict[\"cz\"] = cz\n    dict[\"lod\"] = lod\n    dict[\"sar\"] = self.aircraft.power_system.specific_air_range(mass,tas,dict)\n    return dict\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Turbofan.lift_from_speed","title":"lift_from_speed","text":"<pre><code>lift_from_speed(pamb, tamb, mach, mass)\n</code></pre> <p>Retrieve cz from mach using simplified lift equation</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def lift_from_speed(self,pamb,tamb,mach,mass):\n    \"\"\"Retrieve cz from mach using simplified lift equation\n    \"\"\"\n    g = earth.gravity()\n    r,gam,Cp,Cv = earth.gas_data()\n    cz = (2.*mass*g)/(gam*pamb*mach**2*self.aircraft.airframe.wing.area)\n    return cz\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Turbofan.max_air_path","title":"max_air_path","text":"<pre><code>max_air_path(\n    nei,\n    altp,\n    disa,\n    speed_mode,\n    mass,\n    rating,\n    kfn,\n    full_output=False,\n)\n</code></pre> <p>Optimize the speed of the aircraft to maximize the air path</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def max_air_path(self,nei,altp,disa,speed_mode,mass,rating,kfn, full_output=False):\n    \"\"\"Optimize the speed of the aircraft to maximize the air path\n    \"\"\"\n    def fct(cz):\n        pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n        mach = self.speed_from_lift(pamb,tamb,cz,mass)\n        speed = self.get_speed(pamb,speed_mode,mach)\n        slope,vz = self.air_path(nei,altp,disa,speed_mode,speed,mass,rating,kfn)\n        if isformax: return slope\n        else: return slope,vz,mach\n\n    cz_ini = 0.5\n    dcz = 0.05\n\n    isformax = True\n    cz,slope,rc = maximize_1d(cz_ini,dcz,[fct])\n    isformax = False\n\n    slope,vz,mach = fct(cz)\n    return slope,vz,mach,cz\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Turbofan.oei_drag","title":"oei_drag","text":"<pre><code>oei_drag(pamb, tamb)\n</code></pre> <p>Inoperative engine drag coefficient</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/model.py</code> <pre><code>def oei_drag(self,pamb,tamb):\n    \"\"\"Inoperative engine drag coefficient\n    \"\"\"\n    wing_area = self.aircraft.airframe.wing.area\n    nacelle_width = self.aircraft.airframe.nacelle.width\n\n    dCx = 0.12*nacelle_width**2 / wing_area\n\n    return dCx\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Turbofan.propulsion_ceiling","title":"propulsion_ceiling","text":"<pre><code>propulsion_ceiling(\n    altp_ini,\n    nei,\n    vzreq,\n    disa,\n    speed_mode,\n    speed,\n    mass,\n    rating,\n    throttle,\n)\n</code></pre> <p>Optimize the speed of the aircraft to maximize the air path</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def propulsion_ceiling(self,altp_ini,nei,vzreq,disa,speed_mode,speed,mass,rating,throttle):\n    \"\"\"Optimize the speed of the aircraft to maximize the air path\n    \"\"\"\n    def fct_prop_ceiling(altp,nei,vzreq,disa,speed_mode,speed,mass,rating):\n        slope,vz = self.air_path(nei,altp,disa,speed_mode,speed,mass,rating,throttle)\n        delta_vz = vz - vzreq\n        return delta_vz\n\n    fct_arg = (nei,vzreq,disa,speed_mode,speed,mass,rating)\n\n    output_dict = fsolve(fct_prop_ceiling, x0 = altp_ini, args=fct_arg, full_output = True)\n\n    altp = output_dict[0][0]\n    rei = output_dict[2]\n    if(rei!=1): altp = np.NaN\n\n    return altp, rei\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Turbofan.sc","title":"sc","text":"<pre><code>sc(pamb, tamb, mach, rating, thrust, nei=0)\n</code></pre> <p>Total thrust of a pure turbofan engine</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/model.py</code> <pre><code>def sc(self,pamb,tamb,mach,rating, thrust, nei=0):\n    \"\"\"Total thrust of a pure turbofan engine\n    \"\"\"\n    n_engine = self.aircraft.power_system.n_engine\n    fuel_type = self.aircraft.arrangement.fuel_type\n    fuel_heat = earth.fuel_heat(fuel_type)\n\n    fn = thrust/(n_engine - nei)\n\n    dict = self.aircraft.airframe.nacelle.unitary_sc(pamb,tamb,mach,rating,fn)\n    dict[\"sfc\"] = dict[\"sfc\"]*self.sfc_correction * earth.fuel_heat(\"kerosene\") / fuel_heat\n\n    return dict\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Turbofan.speed_from_lift","title":"speed_from_lift","text":"<pre><code>speed_from_lift(pamb, tamb, cz, mass)\n</code></pre> <p>Retrieve mach from cz using simplified lift equation</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def speed_from_lift(self,pamb,tamb,cz,mass):\n    \"\"\"Retrieve mach from cz using simplified lift equation\n    \"\"\"\n    g = earth.gravity()\n    r,gam,Cp,Cv = earth.gas_data()\n    mach = np.sqrt((mass*g)/(0.5*gam*pamb*self.aircraft.airframe.wing.area*cz))\n    return mach\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Turbofan.thrust","title":"thrust","text":"<pre><code>thrust(pamb, tamb, mach, rating, throttle=1.0, nei=0)\n</code></pre> <p>Total thrust of a pure turbofan engine</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/model.py</code> <pre><code>def  thrust(self,pamb,tamb,mach,rating, throttle=1., nei=0):\n    \"\"\"Total thrust of a pure turbofan engine\n    \"\"\"\n    n_engine = self.aircraft.power_system.n_engine\n    fuel_type = self.aircraft.arrangement.fuel_type\n    fuel_heat = earth.fuel_heat(fuel_type)\n\n    dict = self.aircraft.airframe.nacelle.unitary_thrust(pamb,tamb,mach,rating,throttle=throttle)\n\n    fn = dict[\"fn\"]*(n_engine-nei)\n    ff = dict[\"ff\"]*self.sfc_correction * (n_engine-nei) * earth.fuel_heat(\"kerosene\") / fuel_heat\n    sfc = ff / fn\n    t41 = dict[\"t4\"]\n\n    return {\"fn\":fn, \"ff\":ff, \"sfc\":sfc, \"t4\":t41, \"fn1\":fn}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Turboprop","title":"Turboprop","text":"<pre><code>Turboprop(aircraft)\n</code></pre> <p>               Bases: <code>PowerSystem</code>, <code>Flight</code></p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/model.py</code> <pre><code>def __init__(self, aircraft):\n    super(Turboprop, self).__init__(aircraft)\n\n    class_name = \"PowerSystem\"\n\n    self.sfc_correction = aircraft.get_init(class_name,\"sfc_correction\")  # FACTOR on specific fuel consumption\n\n    self.n_engine = number_of_engine(aircraft)\n    self.reference_power = init_power(aircraft)\n    self.sfc_type = \"power\"\n    self.data = {\"MTO\":ThrustDataTp(nei=1),\n                 \"MCN\":ThrustDataTp(nei=1),\n                 \"MCL\":ThrustDataTp(nei=0),\n                 \"MCR\":ThrustDataTp(nei=0)}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Turboprop-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Turboprop.acceleration","title":"acceleration","text":"<pre><code>acceleration(\n    nei,\n    altp,\n    disa,\n    speed_mode,\n    speed,\n    mass,\n    rating,\n    throttle,\n    full_output=False,\n)\n</code></pre> <p>Aircraft acceleration on level flight</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def acceleration(self,nei,altp,disa,speed_mode,speed,mass,rating,throttle, full_output=False):\n    \"\"\"Aircraft acceleration on level flight\n    \"\"\"\n    r,gam,Cp,Cv = earth.gas_data()\n\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    mach = self.get_mach(pamb,speed_mode,speed)\n\n    dict = self.aircraft.power_system.thrust(pamb,tamb,mach,rating,throttle=throttle,nei=nei)\n    fn = dict[\"fn\"]\n    ff = dict[\"ff\"]\n\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    if(nei&gt;0):\n        dcx = self.aircraft.power_system.oei_drag(pamb,mach)\n        cx = cx + dcx*nei\n\n    acc = (fn - 0.5*gam*pamb*mach**2*self.aircraft.airframe.wing.area*cx) / mass\n\n    if full_output:\n        return acc,fn,ff,cz,cx,pamb,tamb\n    else:\n        return acc\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Turboprop.air_path","title":"air_path","text":"<pre><code>air_path(\n    nei,\n    altp,\n    disa,\n    speed_mode,\n    speed,\n    mass,\n    rating,\n    kfn,\n    full_output=False,\n)\n</code></pre> <p>Retrieve air path in various conditions</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def air_path(self,nei,altp,disa,speed_mode,speed,mass,rating,kfn, full_output=False):\n    \"\"\"Retrieve air path in various conditions\n    \"\"\"\n    g = earth.gravity()\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    mach = self.get_mach(pamb,speed_mode,speed)\n\n    dict = self.aircraft.power_system.thrust(pamb,tamb,mach,rating,nei=nei)\n    fn = dict[\"fn\"]*kfn\n    ff = dict[\"ff\"]*kfn\n    if kfn!=1. and full_output:\n        print(\"WARNING, air_path method, kfn is different from 1, fuel flow may not be accurate\")\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    if(nei&gt;0):\n        dcx = self.aircraft.power_system.oei_drag(pamb,mach)\n        cx = cx + dcx*nei\n        lod = cz/cx\n\n    acc_factor = earth.climb_mode(speed_mode, mach, dtodz, tstd, disa)\n    slope = ( fn/(mass*g) - 1./lod ) / acc_factor\n    vz = slope * mach * earth.sound_speed(tamb)\n    acc = (acc_factor-1.)*g*slope\n    if full_output:\n        return slope,vz,fn,ff,acc,cz,cx,pamb,tamb\n    else:\n        return slope,vz\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Turboprop.arrival_ground_legs","title":"arrival_ground_legs","text":"<pre><code>arrival_ground_legs(ldw)\n</code></pre> <p>Compute fuel and time allowances for arrival ground phases</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def arrival_ground_legs(self,ldw):\n    \"\"\"Compute fuel and time allowances for arrival ground phases\n    \"\"\"\n    n_engine = self.aircraft.power_system.n_engine\n    reference_thrust = self.aircraft.power_system.get_reference_thrust()\n    fuel_type = self.aircraft.arrangement.fuel_type\n\n    time_landing = 180.\n    time_taxi_in = 420.\n\n    if fuel_type!=\"battery\":\n        engine_bpr = self.aircraft.airframe.nacelle.engine_bpr\n        fuel_mass_factor = earth.fuel_heat(\"kerosene\") / earth.fuel_heat(fuel_type)\n        fuel_landing = fuel_mass_factor*1e-4*(0.5+2.3/engine_bpr)*ldw\n        fuel_taxi_in = fuel_mass_factor*(26. + 1.8e-4*reference_thrust)*n_engine\n        return {\"fuel\":{\"landing\":fuel_landing,\"taxi_in\":fuel_taxi_in},\n                \"time\":{\"landing\":time_landing,\"taxi_in\":time_taxi_in}}\n    else:\n        enrg_landing = (0.25*43.1e6)*0.75e-4*ldw\n        enrg_taxi_in = (0.25*43.1e6)*(26. + 1.8e-4*reference_thrust)*n_engine\n        return {\"enrg\":{\"landing\":enrg_landing,\"taxi_in\":enrg_taxi_in},\n                \"time\":{\"landing\":time_landing,\"taxi_in\":time_taxi_in}}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Turboprop.breguet_range","title":"breguet_range","text":"<pre><code>breguet_range(range, tow, ktow, altp, mach, disa)\n</code></pre> <p>Breguet range equation is dependant from power architecture</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def breguet_range(self,range,tow,ktow,altp,mach,disa):\n    \"\"\"Breguet range equation is dependant from power architecture\n    \"\"\"\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    tas = mach * earth.sound_speed(tamb)\n    time = 1.09*(range/tas)\n\n    dict = self.level_flight(pamb,tamb,mach,tow*ktow)\n    val = self.aircraft.power_system.specific_breguet_range(tow,range,tas,dict)\n    return val,time\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Turboprop.departure_ground_legs","title":"departure_ground_legs","text":"<pre><code>departure_ground_legs(tow)\n</code></pre> <p>Compute fuel and time allowances for departure ground phases</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def departure_ground_legs(self,tow):\n    \"\"\"Compute fuel and time allowances for departure ground phases\n    \"\"\"\n    n_engine = self.aircraft.power_system.n_engine\n    reference_thrust = self.aircraft.power_system.get_reference_thrust()\n    fuel_type = self.aircraft.arrangement.fuel_type\n\n    time_taxi_out = 540.\n    time_take_off = 220.*tow/(reference_thrust*n_engine)\n\n    if fuel_type!=\"battery\":\n        engine_bpr = self.aircraft.airframe.nacelle.engine_bpr\n        fuel_mass_factor = earth.fuel_heat(\"kerosene\") / earth.fuel_heat(fuel_type)\n        fuel_taxi_out = fuel_mass_factor*(34. + 2.3e-4*reference_thrust)*n_engine\n        fuel_take_off = fuel_mass_factor*1e-4*(2.8+2.3/engine_bpr)*tow\n        return {\"fuel\":{\"taxi_out\":fuel_taxi_out,\"take_off\":fuel_take_off},\n                \"time\":{\"taxi_out\":time_taxi_out,\"take_off\":time_take_off}}\n    else:\n        enrg_taxi_out = (0.25*43.1e6)*(34. + 2.3e-4*reference_thrust)*n_engine\n        enrg_take_off = (0.25*43.1e6)*3.e-4*tow\n        return {\"enrg\":{\"taxi_out\":enrg_taxi_out,\"take_off\":enrg_take_off},\n                \"time\":{\"taxi_out\":time_taxi_out,\"take_off\":time_take_off}}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Turboprop.descent","title":"descent","text":"<pre><code>descent(nei, altp, disa, speed_mode, speed, vz, mass)\n</code></pre> <p>Retrieve air path and flight characteristics in various conditions</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def descent(self,nei,altp,disa,speed_mode,speed,vz,mass):\n    \"\"\"Retrieve air path and flight characteristics in various conditions\n    \"\"\"\n    g = earth.gravity()\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    mach = self.get_mach(pamb,speed_mode,speed)\n\n    slope = vz / (mach * earth.sound_speed(tamb))\n    acc_factor = earth.climb_mode(speed_mode, mach, dtodz, tstd, disa)\n\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    fn = (slope * acc_factor + 1./lod) * (mass*g)\n    dict = self.aircraft.power_system.sc(self,pamb,tamb,mach,\"FID\", fn, nei)\n    ff = dict[\"sfc\"]*fn\n    thtl = dict[\"thtl\"]\n\n    return slope,thtl,fn,ff,cz,cx,pamb,tamb\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Turboprop.eval_sar","title":"eval_sar","text":"<pre><code>eval_sar(altp, mass, mach, disa)\n</code></pre> <p>Evaluate Specific Air Range</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def eval_sar(self,altp,mass,mach,disa):\n    \"\"\"Evaluate Specific Air Range\n    \"\"\"\n    g = earth.gravity()\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    tas = mach * earth.sound_speed(tamb)\n\n    cz = self.lift_from_speed(pamb,tamb,mach,mass)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    nei = 0\n    thrust = mass*g / lod\n    dict = self.aircraft.power_system.sc(pamb,tamb,mach,\"MCR\",thrust,nei)\n    dict[\"fn\"] = thrust\n    dict[\"cz\"] = cz\n    dict[\"cx\"] = cx\n    dict[\"lod\"] = lod\n    dict[\"sar\"] = self.aircraft.power_system.specific_air_range(mass,tas,dict)\n    return dict\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Turboprop.get_mach","title":"get_mach","text":"<pre><code>get_mach(pamb, speed_mode, speed)\n</code></pre> <p>Retrieve Mach from CAS or mach depending on speed_mode</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def get_mach(self,pamb,speed_mode,speed):\n    \"\"\"Retrieve Mach from CAS or mach depending on speed_mode\n    \"\"\"\n    mach = {\"cas\" : earth.mach_from_vcas(pamb, speed),  # Input is CAS\n            \"mach\" : speed  # Input is mach\n            }.get(speed_mode, \"Erreur: select speed_mode equal to cas or mach\")\n    return mach\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Turboprop.get_speed","title":"get_speed","text":"<pre><code>get_speed(pamb, speed_mode, mach)\n</code></pre> <p>retrieve CAS or Mach from mach depending on speed_mode</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def get_speed(self,pamb,speed_mode,mach):\n    \"\"\"retrieve CAS or Mach from mach depending on speed_mode\n    \"\"\"\n    speed = {\"cas\" : earth.vcas_from_mach(pamb, mach),  # CAS required\n             \"mach\" : mach  # mach required\n             }.get(speed_mode, \"Erreur: select speed_mode equal to cas or mach\")\n    return speed\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Turboprop.get_vcas","title":"get_vcas","text":"<pre><code>get_vcas(pamb, speed_mode, speed)\n</code></pre> <p>Retrieve CAS from Mach or CAS depending on speed_mode</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def get_vcas(self,pamb,speed_mode,speed):\n    \"\"\"Retrieve CAS from Mach or CAS depending on speed_mode\n    \"\"\"\n    cas = {\"mach\" : earth.vcas_from_mach(pamb, speed),  # Input is CAS\n            \"cas\" : speed  # Input is mach\n            }.get(speed_mode, \"Erreur: select speed_mode equal to cas or mach\")\n    return cas\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Turboprop.holding","title":"holding","text":"<pre><code>holding(time, mass, altp, mach, disa)\n</code></pre> <p>Holding equation is dependant from power architecture</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def holding(self,time,mass,altp,mach,disa):\n    \"\"\"Holding equation is dependant from power architecture\n    \"\"\"\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n    tas = mach * earth.sound_speed(tamb)\n    dict = self.level_flight(pamb,tamb,mach,mass)\n    return self.aircraft.power_system.specific_holding(mass,time,tas,dict)\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Turboprop.level_flight","title":"level_flight","text":"<pre><code>level_flight(pamb, tamb, mach, mass)\n</code></pre> <p>Level flight equilibrium</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def level_flight(self,pamb,tamb,mach,mass):\n    \"\"\"Level flight equilibrium\n    \"\"\"\n    g = earth.gravity()\n    r,gam,Cp,Cv = earth.gas_data()\n    tas = mach * earth.sound_speed(tamb)\n\n    cz = (2.*mass*g)/(gam*pamb*mach**2*self.aircraft.airframe.wing.area)\n    cx,lod = self.aircraft.aerodynamics.drag(pamb,tamb,mach,cz)\n\n    thrust = (gam/2.)*pamb*mach**2*self.aircraft.airframe.wing.area*cx\n    dict = self.aircraft.power_system.sc(pamb,tamb,mach,\"MCR\",thrust)\n    dict[\"fn\"] = thrust\n    dict[\"cx\"] = cx\n    dict[\"cz\"] = cz\n    dict[\"lod\"] = lod\n    dict[\"sar\"] = self.aircraft.power_system.specific_air_range(mass,tas,dict)\n    return dict\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Turboprop.lift_from_speed","title":"lift_from_speed","text":"<pre><code>lift_from_speed(pamb, tamb, mach, mass)\n</code></pre> <p>Retrieve cz from mach using simplified lift equation</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def lift_from_speed(self,pamb,tamb,mach,mass):\n    \"\"\"Retrieve cz from mach using simplified lift equation\n    \"\"\"\n    g = earth.gravity()\n    r,gam,Cp,Cv = earth.gas_data()\n    cz = (2.*mass*g)/(gam*pamb*mach**2*self.aircraft.airframe.wing.area)\n    return cz\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Turboprop.max_air_path","title":"max_air_path","text":"<pre><code>max_air_path(\n    nei,\n    altp,\n    disa,\n    speed_mode,\n    mass,\n    rating,\n    kfn,\n    full_output=False,\n)\n</code></pre> <p>Optimize the speed of the aircraft to maximize the air path</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def max_air_path(self,nei,altp,disa,speed_mode,mass,rating,kfn, full_output=False):\n    \"\"\"Optimize the speed of the aircraft to maximize the air path\n    \"\"\"\n    def fct(cz):\n        pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n        mach = self.speed_from_lift(pamb,tamb,cz,mass)\n        speed = self.get_speed(pamb,speed_mode,mach)\n        slope,vz = self.air_path(nei,altp,disa,speed_mode,speed,mass,rating,kfn)\n        if isformax: return slope\n        else: return slope,vz,mach\n\n    cz_ini = 0.5\n    dcz = 0.05\n\n    isformax = True\n    cz,slope,rc = maximize_1d(cz_ini,dcz,[fct])\n    isformax = False\n\n    slope,vz,mach = fct(cz)\n    return slope,vz,mach,cz\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Turboprop.oei_drag","title":"oei_drag","text":"<pre><code>oei_drag(pamb, tamb)\n</code></pre> <p>Inoperative engine drag coefficient</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/model.py</code> <pre><code>def oei_drag(self,pamb,tamb):\n    \"\"\"Inoperative engine drag coefficient\n    \"\"\"\n    wing_area = self.aircraft.airframe.wing.area\n    nacelle_width = self.aircraft.airframe.nacelle.width\n\n    dCx = 1.15*nacelle_width**2 / wing_area\n\n    return dCx\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Turboprop.propulsion_ceiling","title":"propulsion_ceiling","text":"<pre><code>propulsion_ceiling(\n    altp_ini,\n    nei,\n    vzreq,\n    disa,\n    speed_mode,\n    speed,\n    mass,\n    rating,\n    throttle,\n)\n</code></pre> <p>Optimize the speed of the aircraft to maximize the air path</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def propulsion_ceiling(self,altp_ini,nei,vzreq,disa,speed_mode,speed,mass,rating,throttle):\n    \"\"\"Optimize the speed of the aircraft to maximize the air path\n    \"\"\"\n    def fct_prop_ceiling(altp,nei,vzreq,disa,speed_mode,speed,mass,rating):\n        slope,vz = self.air_path(nei,altp,disa,speed_mode,speed,mass,rating,throttle)\n        delta_vz = vz - vzreq\n        return delta_vz\n\n    fct_arg = (nei,vzreq,disa,speed_mode,speed,mass,rating)\n\n    output_dict = fsolve(fct_prop_ceiling, x0 = altp_ini, args=fct_arg, full_output = True)\n\n    altp = output_dict[0][0]\n    rei = output_dict[2]\n    if(rei!=1): altp = np.NaN\n\n    return altp, rei\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Turboprop.sc","title":"sc","text":"<pre><code>sc(pamb, tamb, mach, rating, thrust, nei=0)\n</code></pre> <p>Total thrust of a pure turbofan engine</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/model.py</code> <pre><code>def sc(self,pamb,tamb,mach,rating, thrust, nei=0):\n    \"\"\"Total thrust of a pure turbofan engine\n    \"\"\"\n    n_engine = self.aircraft.power_system.n_engine\n    fuel_type = self.aircraft.arrangement.fuel_type\n    fuel_heat = earth.fuel_heat(fuel_type)\n\n    fn = thrust/(n_engine - nei)\n\n    dict = self.aircraft.airframe.nacelle.unitary_sc(pamb,tamb,mach,rating,fn)\n    dict[\"sfc\"] = dict[\"sfc\"]*self.sfc_correction * earth.fuel_heat(\"kerosene\") / fuel_heat\n\n    return dict\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Turboprop.speed_from_lift","title":"speed_from_lift","text":"<pre><code>speed_from_lift(pamb, tamb, cz, mass)\n</code></pre> <p>Retrieve mach from cz using simplified lift equation</p> Source code in <code>src/lh2pac/marilib/aircraft/performance.py</code> <pre><code>def speed_from_lift(self,pamb,tamb,cz,mass):\n    \"\"\"Retrieve mach from cz using simplified lift equation\n    \"\"\"\n    g = earth.gravity()\n    r,gam,Cp,Cv = earth.gas_data()\n    mach = np.sqrt((mass*g)/(0.5*gam*pamb*self.aircraft.airframe.wing.area*cz))\n    return mach\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.Turboprop.thrust","title":"thrust","text":"<pre><code>thrust(pamb, tamb, mach, rating, throttle=1.0, nei=0)\n</code></pre> <p>Total thrust of a pure turbofan engine</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/model.py</code> <pre><code>def thrust(self,pamb,tamb,mach,rating, throttle=1., nei=0):\n    \"\"\"Total thrust of a pure turbofan engine\n    \"\"\"\n    n_engine = self.aircraft.power_system.n_engine\n    fuel_type = self.aircraft.arrangement.fuel_type\n    fuel_heat = earth.fuel_heat(fuel_type)\n\n    dict = self.aircraft.airframe.nacelle.unitary_thrust(pamb,tamb,mach,rating,throttle=throttle)\n\n    fn = dict[\"fn\"]*(n_engine-nei)\n    ff = dict[\"ff\"]*self.sfc_correction * (n_engine-nei) * earth.fuel_heat(\"kerosene\") / fuel_heat\n    pw = dict[\"pw\"]*(n_engine-nei)\n    sfc = ff / pw\n    t41 = dict[\"t4\"]\n\n    return {\"fn\":fn, \"ff\":ff, \"pw\":pw, \"sfc\":sfc, \"t4\":t41, \"fn1\":fn}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.WeightCg","title":"WeightCg","text":"<pre><code>WeightCg(aircraft)\n</code></pre> <p>               Bases: <code>object</code></p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/model.py</code> <pre><code>def __init__(self, aircraft):\n    self.aircraft = aircraft\n\n    self.mtow = self.__mtow_init__()\n    self.mzfw = self.__mzfw_init__()\n    self.mlw = self.__mlw_init__()\n    self.owe = None\n    self.mwe = None\n    self.mfw = None\n\n    self.breakdown = OweBreakdown(aircraft)\n\n    self.owe_cg = None\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.WeightCg-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.WeightCg.mass_analysis","title":"mass_analysis","text":"<pre><code>mass_analysis()\n</code></pre> <p>Update all component mass</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/model.py</code> <pre><code>def mass_analysis(self):\n    \"\"\"Update all component mass\n    \"\"\"\n    for comp in self.aircraft.airframe.mass_iter():\n        comp.eval_mass()\n\n    # sum all MWE &amp; OWE contributions\n    mwe = 0.\n    owe = 0.\n    for comp in self.aircraft.airframe.mass_iter():\n        mwe += comp.get_mass_mwe()\n        owe += comp.get_mass_owe()\n    self.mwe = mwe\n    self.owe = owe\n\n    # sum all CG OWE contributions\n    owe_cg = 0.\n    for comp in self.aircraft.airframe.mass_iter():\n        owe_cg += (comp.get_cg_owe() * comp.get_mass_owe()) / self.owe\n    self.owe_cg = owe_cg\n\n    self.breakdown.owe = self.owe\n    self.breakdown.op_item_mass = self.aircraft.airframe.cabin.m_op_item\n    self.breakdown.container_pallet_mass = self.aircraft.airframe.cargo.mass\n    self.breakdown.mwe = self.mwe\n    self.breakdown.furnishing_mass = self.aircraft.airframe.cabin.m_furnishing\n    self.breakdown.wing_mass = self.aircraft.airframe.wing.mass\n    self.breakdown.body_mass = self.aircraft.airframe.body.mass\n    self.breakdown.htp_mass = self.aircraft.airframe.horizontal_stab.mass\n    self.breakdown.vtp_mass = self.aircraft.airframe.vertical_stab.mass\n    self.breakdown.tank_mass = self.aircraft.airframe.tank.mass\n    self.breakdown.ldg_mass = self.aircraft.airframe.landing_gear.mass\n    self.breakdown.system_mass = self.aircraft.airframe.system.mass\n    self.breakdown.propeller_mass = self.aircraft.airframe.nacelle.propeller_mass\n    self.breakdown.engine_mass = self.aircraft.airframe.nacelle.engine_mass * self.aircraft.power_system.n_engine\n    self.breakdown.pylon_mass = self.aircraft.airframe.nacelle.pylon_mass * self.aircraft.power_system.n_engine\n\n    if (self.aircraft.arrangement.power_source==\"battery\"):\n        self.mzfw = self.mtow\n    else:\n        self.mzfw = self.owe + self.aircraft.airframe.cabin.maximum_payload\n\n    if (self.aircraft.arrangement.power_source==\"battery\"):\n        self.mlw = self.mtow\n    elif (self.aircraft.arrangement.fuel_type in [\"liquid_h2\", \"compressed_h2\"]):\n        self.mlw = min(self.mtow , (1.02*self.mzfw))    # Because energy density of hydrogen is higher than kerosene\n    else:\n        self.mlw = min(self.mtow , (1.07*self.mzfw))\n\n    # WARNING : for battery powered architecture, MFW corresponds to max battery weight\n    mfw = 0.\n    for comp in self.aircraft.airframe:\n        if issubclass(type(comp),Tank) or issubclass(type(comp),Pod):\n            mfw += comp.get_mfw()\n    self.mfw = min(mfw, self.mtow - self.owe)\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model.WeightCg.mass_pre_design","title":"mass_pre_design","text":"<pre><code>mass_pre_design()\n</code></pre> <p>Solve the coupling through MZFW &amp; MLW for a given mtow</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/model.py</code> <pre><code>def mass_pre_design(self):\n    \"\"\"Solve the coupling through MZFW &amp; MLW for a given mtow\n    \"\"\"\n    def fct(x_in):\n        self.aircraft.weight_cg.mzfw = x_in[0]\n        self.aircraft.weight_cg.mlw = x_in[1]\n\n        self.mass_analysis()\n\n        y_out = np.array([x_in[0] - self.aircraft.weight_cg.mzfw,\n                          x_in[1] - self.aircraft.weight_cg.mlw])\n        return y_out\n\n    x_ini = np.array([self.aircraft.weight_cg.mzfw,\n                      self.aircraft.weight_cg.mlw])\n\n    output_dict = fsolve(fct, x0=x_ini, args=(), full_output=True)\n    if (output_dict[2]!=1): raise Exception(\"Convergence problem\")\n\n    self.aircraft.weight_cg.mzfw = output_dict[0][0]        # Coupling variable\n    self.aircraft.weight_cg.mlw = output_dict[0][1]         # Coupling variable\n\n    self.mass_analysis()\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/model/#lh2pac.marilib.aircraft.airframe.model-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/aircraft/airframe/propulsion/","title":"Propulsion","text":""},{"location":"reference/lh2pac/marilib/aircraft/airframe/propulsion/#lh2pac.marilib.aircraft.airframe.propulsion","title":"propulsion","text":"<p>@author: Conceptual Airplane Design &amp; Operations (CADO team)          Nicolas PETEILH, Pascal ROCHES, Nicolas MONROLIN, Thierry DRUOT          Aircraft &amp; Systems, Air Transport Departement, ENAC</p> <p>.. note:: All physical parameters are given in SI units.</p>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/propulsion/#lh2pac.marilib.aircraft.airframe.propulsion-classes","title":"Classes","text":""},{"location":"reference/lh2pac/marilib/aircraft/airframe/propulsion/#lh2pac.marilib.aircraft.airframe.propulsion.SemiEmpiricEfBliNacelle","title":"SemiEmpiricEfBliNacelle","text":"<pre><code>SemiEmpiricEfBliNacelle(aircraft)\n</code></pre> <p>               Bases: <code>SemiEmpiricEfNacelle</code></p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/propulsion.py</code> <pre><code>def __init__(self, aircraft):\n    super(SemiEmpiricEfBliNacelle, self).__init__(aircraft)\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/propulsion/#lh2pac.marilib.aircraft.airframe.propulsion.SemiEmpiricEfBliNacelle-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/aircraft/airframe/propulsion/#lh2pac.marilib.aircraft.airframe.propulsion.SemiEmpiricEfBliNacelle.air_flow","title":"air_flow","text":"<pre><code>air_flow(rho, vair, r, d, y)\n</code></pre> <p>Air flows and averaged speed at rear end of a cylinder of radius r mouving at vair in the direction of its axes, y is the elevation upon the surface of the cylinder : 0 &lt; y &lt; inf</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/propulsion.py</code> <pre><code>def air_flow(self,rho,vair,r,d,y):\n    \"\"\"Air flows and averaged speed at rear end of a cylinder of radius r mouving at vair in the direction of its axes,\n       y is the elevation upon the surface of the cylinder : 0 &lt; y &lt; inf\n    \"\"\"\n    n = 1./7.   # exponent in the formula of the speed profile inside a turbulent BL of thickness bly : Vy/Vair = (y/d)**(1/7)\n    q0 = (2.*np.pi)*(rho*vair)*(r*y + 0.5*y**2)     # Cumulated air flow at y_elev, without BL\n    ym = min(y,d)\n    q1 = (2.*np.pi)*(rho*vair)*d*( (r/(n+1))*(ym/d)**(n+1) + (d/(n+2))*(ym/d)**(n+2) )      # Cumulated air flow at ym, with BL\n    if (y&gt;d): q1 = q1 + q0 - (2.*np.pi)*(rho*vair)*( r*d + 0.5*d**2 )                       # Add to Q1 the air flow outside the BL\n    q2 = q1 - q0        # Cumulated air flow at y_elev, inside the BL (going speed wise)\n    v1 = vair*(q1/q0)   # Mean speed of q1 air flow at y_elev\n    dv = vair - v1      # Mean air flow speed variation at y_elev\n    return q0,q1,q2,v1,dv\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/propulsion/#lh2pac.marilib.aircraft.airframe.propulsion.SemiEmpiricEfBliNacelle.boundary_layer","title":"boundary_layer","text":"<pre><code>boundary_layer(re, x_length)\n</code></pre> <p>Thickness of a turbulent boundary layer which developped turbulently from its starting point</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/propulsion.py</code> <pre><code>def boundary_layer(self,re,x_length):\n    \"\"\"Thickness of a turbulent boundary layer which developped turbulently from its starting point\n    \"\"\"\n    return (0.385*x_length)/(re*x_length)**(1./5.)\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/propulsion/#lh2pac.marilib.aircraft.airframe.propulsion.SemiEmpiricEfBliNacelle.corrected_air_flow","title":"corrected_air_flow","text":"<pre><code>corrected_air_flow(Ptot, Ttot, Mach)\n</code></pre> <p>Computes the corrected air flow per square meter</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/propulsion.py</code> <pre><code>def corrected_air_flow(self,Ptot,Ttot,Mach):\n    \"\"\"Computes the corrected air flow per square meter\n    \"\"\"\n    r,gam,Cp,Cv = earth.gas_data()\n    f_m = Mach*(1. + 0.5*(gam-1)*Mach**2)**(-(gam+1.)/(2.*(gam-1.)))\n    cqoa = (np.sqrt(gam/r)*Ptot/np.sqrt(Ttot))*f_m\n    return cqoa\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/propulsion/#lh2pac.marilib.aircraft.airframe.propulsion.SemiEmpiricEfBliNacelle.efan_nacelle_design","title":"efan_nacelle_design","text":"<pre><code>efan_nacelle_design(Pamb, Tamb, Mach, shaft_power)\n</code></pre> <p>Electrofan nacelle design</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/propulsion.py</code> <pre><code>def efan_nacelle_design(self,Pamb,Tamb,Mach,shaft_power):\n    \"\"\"Electrofan nacelle design\n    \"\"\"\n    r,gam,Cp,Cv = earth.gas_data()\n\n    MachInlet = Mach     # The inlet is in free stream\n    Ptot = earth.total_pressure(Pamb, MachInlet)        # Stagnation pressure at inlet position\n    Ttot = earth.total_temperature(Tamb, MachInlet)     # Stagnation temperature at inlet position\n\n    PtotJet = Ptot * self.engine_fpr\n    TtotJet = Ttot*((self.engine_fpr**((gam-1.)/gam) - 1.)/self.fan_efficiency + 1.)\n    m_dot_design = shaft_power/(Cp*(TtotJet - Ttot))\n    MachJet = np.sqrt(((PtotJet/Pamb)**((gam-1.)/gam) - 1.) * (2./(gam-1.)))\n\n    self.nozzle_area = m_dot_design / self.corrected_air_flow(PtotJet,TtotJet,MachJet)\n\n    MachFan = min(0.55, self.aircraft.requirement.cruise_mach)     # required Mach number at fan position\n    fan_area = m_dot_design / self.corrected_air_flow(Ptot,Ttot,MachFan)        # Corrected air flow per area at fan position\n    self.fan_width = 2.*np.sqrt(fan_area/np.pi)        # Fan diameter\n    self.nozzle_width = np.sqrt(self.hub_width**2 + 4.*self.nozzle_area/np.pi)        # Nozzle diameter\n\n    self.width = self.fan_width + 0.30      # Surrounding structure\n    self.length = 1.50*self.width\n\n    self.gross_wet_area = np.pi*self.width*self.length\n    self.net_wet_area = self.gross_wet_area\n    self.aero_length = self.length\n    self.form_factor = 1.15\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/propulsion/#lh2pac.marilib.aircraft.airframe.propulsion.SemiEmpiricEfBliNacelle.unitary_sc_bli","title":"unitary_sc_bli","text":"<pre><code>unitary_sc_bli(\n    pamb, tamb, mach, rating, thrust, pw_offtake=0.0\n)\n</code></pre> <p>Unitary power required of an electrofan engine delivering a given thrust (semi-empirical model)</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/propulsion.py</code> <pre><code>def unitary_sc_bli(self,pamb,tamb,mach,rating,thrust,pw_offtake=0.):\n    \"\"\"Unitary power required of an electrofan engine delivering a given thrust (semi-empirical model)\n    \"\"\"\n    r,gam,Cp,Cv = earth.gas_data()\n\n    def fct(x_in,thrust,pamb,tamb,rho,Vair,r1,d1):\n        y = x_in[0]\n        pw_shaft = x_in[1]\n        q0,q1,q2,Vinlet,dVbli = self.air_flow(rho,Vair,r1,d1,y)\n        mach_inlet = Vinlet / earth.sound_speed(tamb)\n        Ttot = earth.total_temperature(tamb,mach_inlet)     # Total temperature at inlet position\n        Ptot = earth.total_pressure(pamb, mach_inlet)        # Total pressure at inlet position\n        TtotJet = Ttot + pw_shaft/(q1*Cp)\n        PtotJet = Ptot * (1. + self.fan_efficiency*(TtotJet/Ttot-1.))**(gam/(gam-1.))\n        MachJet = np.sqrt(((PtotJet/pamb)**((gam-1.)/gam) - 1.) * (2./(gam-1.)))\n        TstaJet = TtotJet / (1.+0.5*(gam-1.)*MachJet**2)\n        Vjet = MachJet * np.sqrt(gam*r*TstaJet)\n        qf = self.nozzle_area * self.corrected_air_flow(PtotJet,TtotJet,MachJet)\n        fan_thrust = qf*(Vjet - Vinlet)\n        return [q1-qf, thrust-fan_thrust]\n\n    reference_power = self.aircraft.power_system.get_reference_power()\n\n    Re = earth.reynolds_number(pamb,tamb,mach)\n    rho,sig = earth.air_density(pamb,tamb)\n    Vair = mach * earth.sound_speed(tamb)\n\n    d0 = self.boundary_layer(Re,self.body_length)   # theorical thickness of the boundary layer without taking account of fuselage tapering\n    r1 = 0.5*self.hub_width                         # Radius of the hub of the eFan nacelle\n    d1 = math.lin_interp_1d(d0,self.bnd_layer[:,0],self.bnd_layer[:,1])     # Using the precomputed relation\n\n    fct_arg = (thrust,pamb,tamb,rho,Vair,r1,d1)\n\n    PWinit = reference_power*getattr(self.rating_factor,rating) - pw_offtake\n    x_init = [0.5, PWinit]\n\n    # Computation of both air flow and shaft power\n    output_dict = fsolve(fct, x0=x_init, args=fct_arg, full_output=True)\n    if (output_dict[2]!=1): raise Exception(\"Convergence problem\")\n\n    y1 = output_dict[0][0]\n    pw_shaft = output_dict[0][1]\n\n    q0,q1,q2,Vinlet,dVbli = self.air_flow(rho,Vair,r1,d1,y1)\n    mach_inlet = Vinlet / earth.sound_speed(tamb)\n    Ttot = earth.total_temperature(tamb,mach_inlet)     # Total temperature at inlet position\n    Ptot = earth.total_pressure(pamb, mach_inlet)        # Total pressure at inlet position\n    TtotJet = Ttot + pw_shaft/(q1*Cp)\n    PtotJet = Ptot * (1. + self.fan_efficiency*(TtotJet/Ttot-1.))**(gam/(gam-1.))\n    MachJet = np.sqrt(((PtotJet/pamb)**((gam-1.)/gam) - 1.) * (2./(gam-1.)))\n    TstaJet = TtotJet / (1.+0.5*(gam-1.)*MachJet**2)\n    Vjet = MachJet * np.sqrt(gam*r*TstaJet)\n    fan_thrust = q1*(Vjet - Vinlet)\n\n    throttle = (pw_shaft + pw_offtake)/(self.reference_power*getattr(self.rating_factor,rating))\n    pw_elec = pw_shaft / (self.controller_efficiency*self.motor_efficiency)\n    sec = pw_elec/fan_thrust\n\n    return {\"sec\":sec, \"thtl\":throttle}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/propulsion/#lh2pac.marilib.aircraft.airframe.propulsion.SemiEmpiricEfBliNacelle.unitary_sc_free_stream","title":"unitary_sc_free_stream","text":"<pre><code>unitary_sc_free_stream(\n    pamb, tamb, mach, rating, thrust, pw_offtake=0.0\n)\n</code></pre> <p>Unitary power required of an electrofan engine delivering a given thrust (semi-empirical model)</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/propulsion.py</code> <pre><code>def unitary_sc_free_stream(self,pamb,tamb,mach,rating,thrust,pw_offtake=0.):\n    \"\"\"Unitary power required of an electrofan engine delivering a given thrust (semi-empirical model)\n    \"\"\"\n    reference_power = self.aircraft.power_system.reference_power\n\n    r,gam,Cp,Cv = earth.gas_data()\n\n    def fct(x_in,thrust,pamb,Ttot,Vair):\n        q = x_in[0]\n        pw_shaft = x_in[1]\n        TtotJet = Ttot + pw_shaft/(q*Cp)\n        PtotJet = Ptot * (1. + self.fan_efficiency*(TtotJet/Ttot-1.))**(gam/(gam-1.))\n        MachJet = np.sqrt(((PtotJet/pamb)**((gam-1.)/gam) - 1.) * (2./(gam-1.)))\n        TstaJet = TtotJet / (1.+0.5*(gam-1.)*MachJet**2)\n        Vjet = MachJet * np.sqrt(gam*r*TstaJet)\n        qf = self.nozzle_area * self.corrected_air_flow(PtotJet,TtotJet,MachJet)\n        fan_thrust = qf*(Vjet - Vair)\n        return [qf-q, thrust-fan_thrust]\n\n    Ptot = earth.total_pressure(pamb, mach)        # Total pressure at inlet position\n    Ttot = earth.total_temperature(tamb, mach)     # Total temperature at inlet position\n    Vair = mach * earth.sound_speed(tamb)\n\n    fct_arg = (thrust,pamb,Ttot,Vair)\n\n    CQoA0 = self.corrected_air_flow(Ptot,Ttot,mach)       # Corrected air flow per area at fan position\n    q0init = CQoA0*(0.25*np.pi*self.fan_width**2)\n    PWinit = reference_power*getattr(self.rating_factor,rating) - pw_offtake\n    x_init = [q0init,PWinit]\n\n    # Computation of both air flow and shaft power\n    output_dict = fsolve(fct, x0=x_init, args=fct_arg, full_output=True)\n    if (output_dict[2]!=1): raise Exception(\"Convergence problem\")\n\n    q0 = output_dict[0][0]\n    pw_shaft = output_dict[0][1]\n\n    TtotJet = Ttot + pw_shaft/(q0*Cp)\n    PtotJet = Ptot * (1. + self.fan_efficiency*(TtotJet/Ttot-1.))**(gam/(gam-1.))\n    MachJet = np.sqrt(((PtotJet/pamb)**((gam-1.)/gam) - 1.) * (2./(gam-1.)))\n    TstaJet = TtotJet / (1.+0.5*(gam-1.)*MachJet**2)\n    Vjet = MachJet * np.sqrt(gam*r*TstaJet)\n    eFn = q0*(Vjet - Vair)\n\n    throttle = (pw_shaft+pw_offtake)/(reference_power*getattr(self.rating_factor,rating))\n    pw_elec = pw_shaft / (self.controller_efficiency*self.motor_efficiency)\n    sec = pw_elec/eFn\n\n    return {\"sec\":sec, \"thtl\":throttle}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/propulsion/#lh2pac.marilib.aircraft.airframe.propulsion.SemiEmpiricEfBliNacelle.unitary_thrust_bli","title":"unitary_thrust_bli","text":"<pre><code>unitary_thrust_bli(\n    pamb, tamb, mach, rating, throttle=1.0, pw_offtake=0.0\n)\n</code></pre> <p>Unitary thrust of an electrofan engine (semi-empirical model)</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/propulsion.py</code> <pre><code>def unitary_thrust_bli(self,pamb,tamb,mach,rating,throttle=1.,pw_offtake=0.):\n    \"\"\"Unitary thrust of an electrofan engine (semi-empirical model)\n    \"\"\"\n    r,gam,Cp,Cv = earth.gas_data()\n\n    def fct(y,pw_shaft,pamb,tamb,rho,Vair,r1,d1):\n        q0,q1,q2,Vinlet,dVbli = self.air_flow(rho,Vair,r1,d1,y)\n        mach_inlet = Vinlet / earth.sound_speed(tamb)\n        Ttot = earth.total_temperature(tamb,mach_inlet)     # Total temperature at inlet position\n        Ptot = earth.total_pressure(pamb, mach_inlet)        # Total pressure at inlet position\n        TtotJet = Ttot + pw_shaft/(q1*Cp)\n        PtotJet = Ptot * (1. + self.fan_efficiency*(TtotJet/Ttot-1.))**(gam/(gam-1.))\n        MachJet = np.sqrt(((PtotJet/pamb)**((gam-1.)/gam) - 1.) * (2./(gam-1.)))\n        qf = self.nozzle_area * self.corrected_air_flow(PtotJet,TtotJet,MachJet)\n        return qf - q1\n\n    reference_power = self.aircraft.power_system.get_reference_power(self.get_component_type())\n    pw_shaft = reference_power*getattr(self.rating_factor,rating)*throttle - pw_offtake\n    pw_elec = pw_shaft / (self.controller_efficiency*self.motor_efficiency)\n\n    Re = earth.reynolds_number(pamb,tamb,mach)\n    rho,sig = earth.air_density(pamb,tamb)\n    Vair = mach * earth.sound_speed(tamb)\n\n    d0 = self.boundary_layer(Re,self.body_length)      # theorical thickness of the boundary layer without taking account of fuselage tapering\n    r1 = 0.5*self.hub_width      # Radius of the hub of the eFan nacelle\n    d1 = math.lin_interp_1d(d0,self.bnd_layer[:,0],self.bnd_layer[:,1])     # Using the precomputed relation\n\n    fct_arg = (pw_shaft,pamb,tamb,rho,Vair,r1,d1)\n\n    # Computation of y1 : thikness of the vein swallowed by the inlet\n    output_dict = fsolve(fct, x0=0.5, args=fct_arg, full_output=True)\n    if (output_dict[2]!=1): raise Exception(\"Convergence problem\")\n\n    y1 = output_dict[0][0]\n\n    q0,q1,q2,Vinlet,dVbli = self.air_flow(rho,Vair,r1,d1,y1)\n    mach_inlet = Vinlet / earth.sound_speed(tamb)\n    Ttot = earth.total_temperature(tamb,mach_inlet)     # Total temperature at inlet position\n    Ptot = earth.total_pressure(pamb, mach_inlet)        # Total pressure at inlet position\n    TtotJet = Ttot + pw_shaft/(q1*Cp)\n    PtotJet = Ptot * (1. + self.fan_efficiency*(TtotJet/Ttot-1.))**(gam/(gam-1.))\n    MachJet = np.sqrt(((PtotJet/pamb)**((gam-1.)/gam) - 1.) * (2./(gam-1.)))\n    TstaJet = TtotJet / (1.+0.5*(gam-1.)*MachJet**2)\n    Vjet = MachJet * np.sqrt(gam*r*TstaJet)\n    fan_thrust = q1*(Vjet - Vinlet)\n    sec = pw_elec/fan_thrust\n\n    return {\"fn\":fan_thrust, \"pw\":pw_elec, \"sec\":sec, \"dv_bli\":dVbli}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/propulsion/#lh2pac.marilib.aircraft.airframe.propulsion.SemiEmpiricEfBliNacelle.unitary_thrust_free_stream","title":"unitary_thrust_free_stream","text":"<pre><code>unitary_thrust_free_stream(\n    pamb, tamb, mach, rating, throttle=1.0, pw_offtake=0.0\n)\n</code></pre> <p>Unitary thrust of an electrofan engine (semi-empirical model)</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/propulsion.py</code> <pre><code>def unitary_thrust_free_stream(self,pamb,tamb,mach,rating,throttle=1.,pw_offtake=0.):\n    \"\"\"Unitary thrust of an electrofan engine (semi-empirical model)\n    \"\"\"\n    reference_power = self.aircraft.power_system.get_reference_power(self.get_component_type())\n\n    r,gam,Cp,Cv = earth.gas_data()\n\n    def fct(q,pw_shaft,pamb,Ptot,Ttot,Vair):\n        TtotJet = Ttot + pw_shaft/(q*Cp)\n        PtotJet = Ptot * (1. + self.fan_efficiency*(TtotJet/Ttot-1.))**(gam/(gam-1.))\n        MachJet = np.sqrt(((PtotJet/pamb)**((gam-1.)/gam) - 1.) * (2./(gam-1.)))\n        qf = self.nozzle_area * self.corrected_air_flow(PtotJet,TtotJet,MachJet)\n        return qf - q\n\n    pw_shaft = reference_power*getattr(self.rating_factor,rating)*throttle - pw_offtake\n    pw_elec = pw_shaft / (self.controller_efficiency*self.motor_efficiency)\n\n    Ptot = earth.total_pressure(pamb, mach)        # Total pressure at inlet position\n    Ttot = earth.total_temperature(tamb, mach)     # Total temperature at inlet position\n    Vair = mach * earth.sound_speed(tamb)\n\n    fct_arg = (pw_shaft,pamb,Ptot,Ttot,Vair)\n\n    CQoA0 = self.corrected_air_flow(Ptot,Ttot,mach)       # Corrected air flow per area at fan position\n    q0init = CQoA0*(0.25*np.pi*self.fan_width**2)\n\n    # Computation of the air flow swallowed by the inlet\n    output_dict = fsolve(fct, x0=q0init, args=fct_arg, full_output=True)\n    if (output_dict[2]!=1): raise Exception(\"Convergence problem\")\n\n    q0 = output_dict[0][0]\n    TtotJet = Ttot + pw_shaft/(q0*Cp)\n    PtotJet = Ptot * (1. + self.fan_efficiency*(TtotJet/Ttot-1.))**(gam/(gam-1.))\n    MachJet = np.sqrt(((PtotJet/pamb)**((gam-1.)/gam) - 1.) * (2./(gam-1.)))\n    TstaJet = TtotJet / (1.+0.5*(gam-1.)*MachJet**2)\n    Vjet = MachJet * np.sqrt(gam*r*TstaJet)\n    fan_thrust = q0*(Vjet - Vair)\n    sec = pw_elec/fan_thrust\n\n    return {\"fn\":fan_thrust, \"pw\":pw_elec, \"sec\":sec}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/propulsion/#lh2pac.marilib.aircraft.airframe.propulsion.SemiEmpiricEfNacelle","title":"SemiEmpiricEfNacelle","text":"<pre><code>SemiEmpiricEfNacelle(aircraft)\n</code></pre> <p>               Bases: <code>object</code></p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/propulsion.py</code> <pre><code>def __init__(self, aircraft):\n    super(SemiEmpiricEfNacelle, self).__init__(aircraft)\n\n    class_name = \"SemiEmpiricEfNacelle\"\n\n    self.eis_date = 2020\n    self.rating_factor = RatingFactor(MTO=1.00, MCN=0.90, MCL=0.90, MCR=0.90, FID=0.05)\n    self.propeller_efficiency = aircraft.get_init(class_name,\"propeller_efficiency\")\n    self.fan_efficiency = aircraft.get_init(class_name,\"fan_efficiency\")\n    self.engine_fpr = aircraft.get_init(class_name,\"engine_fpr\")\n\n    self.controller_efficiency = aircraft.get_init(class_name,\"controller_efficiency\")\n    self.controller_pw_density = aircraft.get_init(class_name,\"controller_pw_density\")\n\n    self.motor_efficiency = aircraft.get_init(class_name,\"motor_efficiency\")\n    self.motor_pw_density = aircraft.get_init(class_name,\"motor_pw_density\")\n    self.nacelle_pw_density = aircraft.get_init(class_name,\"nacelle_pw_density\")\n\n    self.lateral_margin = aircraft.get_init(class_name,\"lateral_margin\")\n    self.vertical_margin = aircraft.get_init(class_name,\"vertical_margin\")\n    self.hub_width = aircraft.get_init(class_name,\"hub_width\")\n\n    self.fan_width = None\n    self.nozzle_area = None\n    self.width = None\n    self.length = None\n\n    self.propeller_mass = 0.\n    self.engine_mass = 0.\n    self.pylon_mass = 0.\n\n    self.frame_origin = np.full(3,None)\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/propulsion/#lh2pac.marilib.aircraft.airframe.propulsion.SemiEmpiricEfNacelle-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/aircraft/airframe/propulsion/#lh2pac.marilib.aircraft.airframe.propulsion.SemiEmpiricEfNacelle.corrected_air_flow","title":"corrected_air_flow","text":"<pre><code>corrected_air_flow(Ptot, Ttot, Mach)\n</code></pre> <p>Computes the corrected air flow per square meter</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/propulsion.py</code> <pre><code>def corrected_air_flow(self,Ptot,Ttot,Mach):\n    \"\"\"Computes the corrected air flow per square meter\n    \"\"\"\n    r,gam,Cp,Cv = earth.gas_data()\n    f_m = Mach*(1. + 0.5*(gam-1)*Mach**2)**(-(gam+1.)/(2.*(gam-1.)))\n    cqoa = (np.sqrt(gam/r)*Ptot/np.sqrt(Ttot))*f_m\n    return cqoa\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/propulsion/#lh2pac.marilib.aircraft.airframe.propulsion.SemiEmpiricEfNacelle.efan_nacelle_design","title":"efan_nacelle_design","text":"<pre><code>efan_nacelle_design(Pamb, Tamb, Mach, shaft_power)\n</code></pre> <p>Electrofan nacelle design</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/propulsion.py</code> <pre><code>def efan_nacelle_design(self,Pamb,Tamb,Mach,shaft_power):\n    \"\"\"Electrofan nacelle design\n    \"\"\"\n    r,gam,Cp,Cv = earth.gas_data()\n\n    MachInlet = Mach     # The inlet is in free stream\n    Ptot = earth.total_pressure(Pamb, MachInlet)        # Stagnation pressure at inlet position\n    Ttot = earth.total_temperature(Tamb, MachInlet)     # Stagnation temperature at inlet position\n\n    PtotJet = Ptot * self.engine_fpr\n    TtotJet = Ttot*((self.engine_fpr**((gam-1.)/gam) - 1.)/self.fan_efficiency + 1.)\n    m_dot_design = shaft_power/(Cp*(TtotJet - Ttot))\n    MachJet = np.sqrt(((PtotJet/Pamb)**((gam-1.)/gam) - 1.) * (2./(gam-1.)))\n\n    self.nozzle_area = m_dot_design / self.corrected_air_flow(PtotJet,TtotJet,MachJet)\n\n    MachFan = min(0.55, self.aircraft.requirement.cruise_mach)     # required Mach number at fan position\n    fan_area = m_dot_design / self.corrected_air_flow(Ptot,Ttot,MachFan)        # Corrected air flow per area at fan position\n    self.fan_width = 2.*np.sqrt(fan_area/np.pi)        # Fan diameter\n    self.nozzle_width = np.sqrt(self.hub_width**2 + 4.*self.nozzle_area/np.pi)        # Nozzle diameter\n\n    self.width = self.fan_width + 0.30      # Surrounding structure\n    self.length = 1.50*self.width\n\n    self.gross_wet_area = np.pi*self.width*self.length\n    self.net_wet_area = self.gross_wet_area\n    self.aero_length = self.length\n    self.form_factor = 1.15\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/propulsion/#lh2pac.marilib.aircraft.airframe.propulsion.SemiEmpiricEfNacelle.unitary_sc_free_stream","title":"unitary_sc_free_stream","text":"<pre><code>unitary_sc_free_stream(\n    pamb, tamb, mach, rating, thrust, pw_offtake=0.0\n)\n</code></pre> <p>Unitary power required of an electrofan engine delivering a given thrust (semi-empirical model)</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/propulsion.py</code> <pre><code>def unitary_sc_free_stream(self,pamb,tamb,mach,rating,thrust,pw_offtake=0.):\n    \"\"\"Unitary power required of an electrofan engine delivering a given thrust (semi-empirical model)\n    \"\"\"\n    reference_power = self.aircraft.power_system.reference_power\n\n    r,gam,Cp,Cv = earth.gas_data()\n\n    def fct(x_in,thrust,pamb,Ttot,Vair):\n        q = x_in[0]\n        pw_shaft = x_in[1]\n        TtotJet = Ttot + pw_shaft/(q*Cp)\n        PtotJet = Ptot * (1. + self.fan_efficiency*(TtotJet/Ttot-1.))**(gam/(gam-1.))\n        MachJet = np.sqrt(((PtotJet/pamb)**((gam-1.)/gam) - 1.) * (2./(gam-1.)))\n        TstaJet = TtotJet / (1.+0.5*(gam-1.)*MachJet**2)\n        Vjet = MachJet * np.sqrt(gam*r*TstaJet)\n        qf = self.nozzle_area * self.corrected_air_flow(PtotJet,TtotJet,MachJet)\n        fan_thrust = qf*(Vjet - Vair)\n        return [qf-q, thrust-fan_thrust]\n\n    Ptot = earth.total_pressure(pamb, mach)        # Total pressure at inlet position\n    Ttot = earth.total_temperature(tamb, mach)     # Total temperature at inlet position\n    Vair = mach * earth.sound_speed(tamb)\n\n    fct_arg = (thrust,pamb,Ttot,Vair)\n\n    CQoA0 = self.corrected_air_flow(Ptot,Ttot,mach)       # Corrected air flow per area at fan position\n    q0init = CQoA0*(0.25*np.pi*self.fan_width**2)\n    PWinit = reference_power*getattr(self.rating_factor,rating) - pw_offtake\n    x_init = [q0init,PWinit]\n\n    # Computation of both air flow and shaft power\n    output_dict = fsolve(fct, x0=x_init, args=fct_arg, full_output=True)\n    if (output_dict[2]!=1): raise Exception(\"Convergence problem\")\n\n    q0 = output_dict[0][0]\n    pw_shaft = output_dict[0][1]\n\n    TtotJet = Ttot + pw_shaft/(q0*Cp)\n    PtotJet = Ptot * (1. + self.fan_efficiency*(TtotJet/Ttot-1.))**(gam/(gam-1.))\n    MachJet = np.sqrt(((PtotJet/pamb)**((gam-1.)/gam) - 1.) * (2./(gam-1.)))\n    TstaJet = TtotJet / (1.+0.5*(gam-1.)*MachJet**2)\n    Vjet = MachJet * np.sqrt(gam*r*TstaJet)\n    eFn = q0*(Vjet - Vair)\n\n    throttle = (pw_shaft+pw_offtake)/(reference_power*getattr(self.rating_factor,rating))\n    pw_elec = pw_shaft / (self.controller_efficiency*self.motor_efficiency)\n    sec = pw_elec/eFn\n\n    return {\"sec\":sec, \"thtl\":throttle}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/propulsion/#lh2pac.marilib.aircraft.airframe.propulsion.SemiEmpiricEfNacelle.unitary_thrust_free_stream","title":"unitary_thrust_free_stream","text":"<pre><code>unitary_thrust_free_stream(\n    pamb, tamb, mach, rating, throttle=1.0, pw_offtake=0.0\n)\n</code></pre> <p>Unitary thrust of an electrofan engine (semi-empirical model)</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/propulsion.py</code> <pre><code>def unitary_thrust_free_stream(self,pamb,tamb,mach,rating,throttle=1.,pw_offtake=0.):\n    \"\"\"Unitary thrust of an electrofan engine (semi-empirical model)\n    \"\"\"\n    reference_power = self.aircraft.power_system.get_reference_power(self.get_component_type())\n\n    r,gam,Cp,Cv = earth.gas_data()\n\n    def fct(q,pw_shaft,pamb,Ptot,Ttot,Vair):\n        TtotJet = Ttot + pw_shaft/(q*Cp)\n        PtotJet = Ptot * (1. + self.fan_efficiency*(TtotJet/Ttot-1.))**(gam/(gam-1.))\n        MachJet = np.sqrt(((PtotJet/pamb)**((gam-1.)/gam) - 1.) * (2./(gam-1.)))\n        qf = self.nozzle_area * self.corrected_air_flow(PtotJet,TtotJet,MachJet)\n        return qf - q\n\n    pw_shaft = reference_power*getattr(self.rating_factor,rating)*throttle - pw_offtake\n    pw_elec = pw_shaft / (self.controller_efficiency*self.motor_efficiency)\n\n    Ptot = earth.total_pressure(pamb, mach)        # Total pressure at inlet position\n    Ttot = earth.total_temperature(tamb, mach)     # Total temperature at inlet position\n    Vair = mach * earth.sound_speed(tamb)\n\n    fct_arg = (pw_shaft,pamb,Ptot,Ttot,Vair)\n\n    CQoA0 = self.corrected_air_flow(Ptot,Ttot,mach)       # Corrected air flow per area at fan position\n    q0init = CQoA0*(0.25*np.pi*self.fan_width**2)\n\n    # Computation of the air flow swallowed by the inlet\n    output_dict = fsolve(fct, x0=q0init, args=fct_arg, full_output=True)\n    if (output_dict[2]!=1): raise Exception(\"Convergence problem\")\n\n    q0 = output_dict[0][0]\n    TtotJet = Ttot + pw_shaft/(q0*Cp)\n    PtotJet = Ptot * (1. + self.fan_efficiency*(TtotJet/Ttot-1.))**(gam/(gam-1.))\n    MachJet = np.sqrt(((PtotJet/pamb)**((gam-1.)/gam) - 1.) * (2./(gam-1.)))\n    TstaJet = TtotJet / (1.+0.5*(gam-1.)*MachJet**2)\n    Vjet = MachJet * np.sqrt(gam*r*TstaJet)\n    fan_thrust = q0*(Vjet - Vair)\n    sec = pw_elec/fan_thrust\n\n    return {\"fn\":fan_thrust, \"pw\":pw_elec, \"sec\":sec}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/propulsion/#lh2pac.marilib.aircraft.airframe.propulsion.SemiEmpiricEpNacelle","title":"SemiEmpiricEpNacelle","text":"<pre><code>SemiEmpiricEpNacelle(aircraft)\n</code></pre> <p>               Bases: <code>object</code></p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/propulsion.py</code> <pre><code>def __init__(self, aircraft):\n    super(SemiEmpiricEpNacelle, self).__init__(aircraft)\n\n    class_name = \"SemiEmpiricEpNacelle\"\n\n    self.eis_date = 2020\n    self.rating_factor = RatingFactor(MTO=1.00, MCN=0.90, MCL=0.90, MCR=0.90, FID=0.05)\n    self.propeller_efficiency = aircraft.get_init(class_name,\"propeller_efficiency\")\n    self.propeller_disk_load = aircraft.get_init(class_name,\"propeller_disk_load\")\n    self.motor_efficiency = aircraft.get_init(class_name,\"motor_efficiency\")\n    self.controller_efficiency = aircraft.get_init(class_name,\"controller_efficiency\")\n    self.controller_pw_density = aircraft.get_init(class_name,\"controller_pw_density\")\n    self.nacelle_pw_density = aircraft.get_init(class_name,\"nacelle_pw_density\")\n    self.motor_pw_density = aircraft.get_init(class_name,\"motor_pw_density\")\n    self.lateral_margin = aircraft.get_init(class_name,\"lateral_margin\")\n    self.hub_width = aircraft.get_init(class_name,\"hub_width\")\n    self.engine_bpr = 100.\n\n    self.propeller_width = None\n    self.width = None\n    self.length = None\n\n    self.propeller_mass = 0.\n    self.engine_mass = 0.\n    self.pylon_mass = 0.\n\n    self.frame_origin = np.full(3,None)\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/propulsion/#lh2pac.marilib.aircraft.airframe.propulsion.SemiEmpiricEpNacelle-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/aircraft/airframe/propulsion/#lh2pac.marilib.aircraft.airframe.propulsion.SemiEmpiricEpNacelle.unitary_sc","title":"unitary_sc","text":"<pre><code>unitary_sc(\n    pamb, tamb, mach, rating, thrust, pw_offtake=0.0\n)\n</code></pre> <p>Unitary thrust of a pure turbofan engine (semi-empirical model)</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/propulsion.py</code> <pre><code>def unitary_sc(self,pamb,tamb,mach,rating,thrust,pw_offtake=0.):\n    \"\"\"Unitary thrust of a pure turbofan engine (semi-empirical model)\n    \"\"\"\n    dict = self.unitary_thrust(pamb,tamb,mach,rating,pw_offtake=pw_offtake)\n    fn = dict[\"fn\"]\n    pw = dict[\"pw\"]\n    throttle = thrust/fn\n    sec = pw/fn     # Specific Energy Consumption\n    return {\"sec\":sec, \"thtl\":throttle}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/propulsion/#lh2pac.marilib.aircraft.airframe.propulsion.SemiEmpiricEpNacelle.unitary_thrust","title":"unitary_thrust","text":"<pre><code>unitary_thrust(\n    pamb, tamb, mach, rating, throttle=1.0, pw_offtake=0.0\n)\n</code></pre> <p>Unitary thrust of a pure turboprop engine (semi-empirical model)</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/propulsion.py</code> <pre><code>def unitary_thrust(self,pamb,tamb,mach,rating,throttle=1.,pw_offtake=0.):\n    \"\"\"Unitary thrust of a pure turboprop engine (semi-empirical model)\n    \"\"\"\n    reference_power = self.aircraft.power_system.reference_power\n    Vsnd = earth.sound_speed(tamb)\n    Vair = Vsnd*mach\n    pw_shaft = reference_power*getattr(self.rating_factor,rating)*throttle - pw_offtake\n    pw_elec = pw_shaft / (self.motor_efficiency*self.controller_efficiency)\n    fn = self.propeller_efficiency*pw_shaft/Vair\n    return {\"fn\":fn, \"pw\":pw_elec, \"sec\":pw_elec/fn}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/propulsion/#lh2pac.marilib.aircraft.airframe.propulsion.SemiEmpiricTf0Nacelle","title":"SemiEmpiricTf0Nacelle","text":"<pre><code>SemiEmpiricTf0Nacelle(aircraft)\n</code></pre> <p>               Bases: <code>object</code></p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/propulsion.py</code> <pre><code>def __init__(self, aircraft):\n    super(SemiEmpiricTf0Nacelle, self).__init__(aircraft)\n\n    class_name = \"SemiEmpiricTf0Nacelle\"\n\n    ne = self.aircraft.arrangement.number_of_engine\n    n_pax_ref = self.aircraft.requirement.n_pax_ref\n    design_range = self.aircraft.requirement.design_range\n\n    self.eis_date = aircraft.get_init(class_name,\"eis_date\")\n    self.rating_factor = RatingFactor(MTO=1.00, MCN=0.86, MCL=0.78, MCR=0.70, FID=0.05)\n    self.reference_offtake = 0.\n    self.engine_bpr = aircraft.get_init(class_name,\"engine_bpr\", val=self.__turbofan_bpr())\n    self.engine_opr = aircraft.get_init(class_name,\"engine_opr\", val=self.__turbofan_opr())\n    self.core_thrust_ratio = aircraft.get_init(class_name,\"core_thrust_ratio\")\n    self.propeller_efficiency = aircraft.get_init(class_name,\"propeller_efficiency\")\n    self.lateral_margin = aircraft.get_init(class_name,\"lateral_margin\")\n    self.vertical_margin = aircraft.get_init(class_name,\"vertical_margin\")\n\n    self.thrust_factor = None\n    self.width = None\n    self.length = None\n\n    self.propeller_mass = 0.\n    self.engine_mass = 0.\n    self.pylon_mass = 0.\n\n    self.frame_origin = np.full(3,None)\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/propulsion/#lh2pac.marilib.aircraft.airframe.propulsion.SemiEmpiricTf0Nacelle-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/aircraft/airframe/propulsion/#lh2pac.marilib.aircraft.airframe.propulsion.SemiEmpiricTf0Nacelle.unitary_sc","title":"unitary_sc","text":"<pre><code>unitary_sc(\n    pamb, tamb, mach, rating, thrust, pw_offtake=0.0\n)\n</code></pre> <p>Unitary thrust of a pure turbofan engine (semi-empirical model)</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/propulsion.py</code> <pre><code>def unitary_sc(self,pamb,tamb,mach,rating,thrust,pw_offtake=0.):\n    \"\"\"Unitary thrust of a pure turbofan engine (semi-empirical model)\n    \"\"\"\n    dict = self.unitary_thrust(pamb,tamb,mach,rating,pw_offtake=pw_offtake)\n    throttle = thrust/dict[\"fn\"]\n    sfc = dict[\"ff\"]/dict[\"fn\"]\n    t41 = dict[\"t4\"]\n    return {\"sfc\":sfc, \"thtl\":throttle, \"t4\":t41}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/propulsion/#lh2pac.marilib.aircraft.airframe.propulsion.SemiEmpiricTf0Nacelle.unitary_thrust","title":"unitary_thrust","text":"<pre><code>unitary_thrust(\n    pamb, tamb, mach, rating, throttle=1.0, pw_offtake=0.0\n)\n</code></pre> <p>Unitary thrust of a pure turbofan engine (semi-empirical model)</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/propulsion.py</code> <pre><code>def unitary_thrust(self,pamb,tamb,mach,rating,throttle=1.,pw_offtake=0.):\n    \"\"\"Unitary thrust of a pure turbofan engine (semi-empirical model)\n    \"\"\"\n    reference_thrust = self.aircraft.power_system.reference_thrust\n\n    kth =  0.475*mach**2 + 0.091*(self.engine_bpr/10.)**2 \\\n         - 0.283*mach*self.engine_bpr/10. \\\n         - 0.633*mach - 0.081*self.engine_bpr/10. + 1.192\n\n    rho,sig = earth.air_density(pamb, tamb)\n    vair = mach * earth.sound_speed(tamb)\n\n    total_thrust0 =   reference_thrust \\\n                    * kth \\\n                    * getattr(self.rating_factor,rating) \\\n                    * throttle \\\n                    * sig**0.75\n    core_thrust0 = total_thrust0 * self.core_thrust_ratio        # Core thrust\n    fan_thrust0 = total_thrust0 * (1.-self.core_thrust_ratio)    # Fan thrust\n    fan_power0 = fan_thrust0*vair/self.propeller_efficiency   # Available total shaft power for one engine\n\n    fan_power = fan_power0 - pw_offtake\n    fan_thrust = (fan_power/vair)*self.propeller_efficiency\n    total_thrust = fan_thrust + core_thrust0\n\n    sfc_ref = ( 0.4 + 1./self.engine_bpr**0.895 )/36000.\n    fuel_flow = sfc_ref * total_thrust0\n\n    return {\"fn\":total_thrust, \"ff\":fuel_flow, \"t4\":None}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/propulsion/#lh2pac.marilib.aircraft.airframe.propulsion.SemiEmpiricTfBliNacelle","title":"SemiEmpiricTfBliNacelle","text":"<pre><code>SemiEmpiricTfBliNacelle(aircraft)\n</code></pre> <p>               Bases: <code>SemiEmpiricTfNacelle</code></p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/propulsion.py</code> <pre><code>def __init__(self, aircraft):\n    super(SemiEmpiricTfBliNacelle, self).__init__(aircraft)\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/propulsion/#lh2pac.marilib.aircraft.airframe.propulsion.SemiEmpiricTfBliNacelle-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/aircraft/airframe/propulsion/#lh2pac.marilib.aircraft.airframe.propulsion.SemiEmpiricTfBliNacelle.air_flow","title":"air_flow","text":"<pre><code>air_flow(rho, vair, r, d, y)\n</code></pre> <p>Air flows and averaged speed at rear end of a cylinder of radius r mouving at vair in the direction of its axes, y is the elevation upon the surface of the cylinder : 0 &lt; y &lt; inf</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/propulsion.py</code> <pre><code>def air_flow(self,rho,vair,r,d,y):\n    \"\"\"Air flows and averaged speed at rear end of a cylinder of radius r mouving at vair in the direction of its axes,\n       y is the elevation upon the surface of the cylinder : 0 &lt; y &lt; inf\n    \"\"\"\n    n = 1./7.   # exponent in the formula of the speed profile inside a turbulent BL of thickness bly : Vy/Vair = (y/d)**(1/7)\n    q0 = (2.*np.pi)*(rho*vair)*(r*y + 0.5*y**2)     # Cumulated air flow at y_elev, without BL\n    ym = min(y,d)\n    q1 = (2.*np.pi)*(rho*vair)*d*( (r/(n+1))*(ym/d)**(n+1) + (d/(n+2))*(ym/d)**(n+2) )      # Cumulated air flow at ym, with BL\n    if (y&gt;d): q1 = q1 + q0 - (2.*np.pi)*(rho*vair)*( r*d + 0.5*d**2 )                       # Add to Q1 the air flow outside the BL\n    q2 = q1 - q0        # Cumulated air flow at y_elev, inside the BL (going speed wise)\n    v1 = vair*(q1/q0)   # Mean speed of q1 air flow at y_elev\n    dv = vair - v1      # Mean air flow speed variation at y_elev\n    return q0,q1,q2,v1,dv\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/propulsion/#lh2pac.marilib.aircraft.airframe.propulsion.SemiEmpiricTfBliNacelle.boundary_layer","title":"boundary_layer","text":"<pre><code>boundary_layer(re, x_length)\n</code></pre> <p>Thickness of a turbulent boundary layer which developped turbulently from its starting point</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/propulsion.py</code> <pre><code>def boundary_layer(self,re,x_length):\n    \"\"\"Thickness of a turbulent boundary layer which developped turbulently from its starting point\n    \"\"\"\n    return (0.385*x_length)/(re*x_length)**(1./5.)\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/propulsion/#lh2pac.marilib.aircraft.airframe.propulsion.SemiEmpiricTfBliNacelle.corrected_air_flow","title":"corrected_air_flow","text":"<pre><code>corrected_air_flow(Ptot, Ttot, Mach)\n</code></pre> <p>Computes the corrected air flow per square meter</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/propulsion.py</code> <pre><code>def corrected_air_flow(self,Ptot,Ttot,Mach):\n    \"\"\"Computes the corrected air flow per square meter\n    \"\"\"\n    r,gam,Cp,Cv = earth.gas_data()\n    f_m = Mach*(1. + 0.5*(gam-1)*Mach**2)**(-(gam+1.)/(2.*(gam-1.)))\n    cqoa = (np.sqrt(gam/r)*Ptot/np.sqrt(Ttot))*f_m\n    return cqoa\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/propulsion/#lh2pac.marilib.aircraft.airframe.propulsion.SemiEmpiricTfBliNacelle.fan_shaft_power","title":"fan_shaft_power","text":"<pre><code>fan_shaft_power(\n    pamb, tamb, mach, rating, throttle=1.0, pw_offtake=0.0\n)\n</code></pre> <p>Fan shaft power of a pure turbofan engine (semi-empirical model)</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/propulsion.py</code> <pre><code>def fan_shaft_power(self,pamb,tamb,mach,rating,throttle=1.,pw_offtake=0.):\n    \"\"\"Fan shaft power of a pure turbofan engine (semi-empirical model)\n    \"\"\"\n    sfc_ref = ( 0.4 + 1./self.engine_bpr**0.895 )/36000.\n\n    reference_thrust = self.aircraft.power_system.reference_thrust\n    kth =  0.475*mach**2 + 0.091*(self.engine_bpr/10.)**2 \\\n         - 0.283*mach*self.engine_bpr/10. \\\n         - 0.633*mach - 0.081*self.engine_bpr/10. + 1.192\n\n    rho,sig = earth.air_density(pamb, tamb)\n    vair = mach * earth.sound_speed(tamb)\n\n    # Factor 1.25 on kth is to synchronise the order of magnitude of reference thrust\n    # with the effective SLST computed as Thrust(mach=0.25, disa=15) / 0.8\n    total_thrust0 =   reference_thrust \\\n                    * kth * 1.25 \\\n                    * getattr(self.rating_factor,rating) \\\n                    * throttle \\\n                    * sig**0.75\n    fuel_flow = sfc_ref * total_thrust0                         # Fuel flow\n    core_thrust0 = total_thrust0 * self.core_thrust_ratio       # Core thrust\n    fan_thrust0 = total_thrust0 * (1.-self.core_thrust_ratio)   # Fan thrust\n    fan_power0 = fan_thrust0*vair/self.propeller_efficiency     # Available total shaft power for one engine\n\n    return fan_power0-pw_offtake, core_thrust0, fuel_flow\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/propulsion/#lh2pac.marilib.aircraft.airframe.propulsion.SemiEmpiricTfBliNacelle.turbofan_nacelle_design","title":"turbofan_nacelle_design","text":"<pre><code>turbofan_nacelle_design(Pamb, Tamb, Mach, shaft_power)\n</code></pre> <p>Electrofan nacelle design</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/propulsion.py</code> <pre><code>def turbofan_nacelle_design(self,Pamb,Tamb,Mach,shaft_power):\n    \"\"\"Electrofan nacelle design\n    \"\"\"\n    r,gam,Cp,Cv = earth.gas_data()\n\n    MachInlet = Mach     # The inlet is in free stream\n    Ptot = earth.total_pressure(Pamb, MachInlet)        # Stagnation pressure at inlet position\n    Ttot = earth.total_temperature(Tamb, MachInlet)     # Stagnation temperature at inlet position\n\n    PtotJet = Ptot * self.engine_fpr\n    TtotJet = Ttot*((self.engine_fpr**((gam-1.)/gam) - 1.)/self.fan_efficiency + 1.)\n    MachJet = np.sqrt(((PtotJet/Pamb)**((gam-1.)/gam) - 1.) * (2./(gam-1.)))\n    m_dot_design = shaft_power/(Cp*(TtotJet - Ttot))\n\n    self.nozzle_area = m_dot_design / self.corrected_air_flow(PtotJet,TtotJet,MachJet)\n    self.nozzle_width = np.sqrt(self.hub_width**2 + 4.*self.nozzle_area/np.pi)        # Nozzle diameter\n\n    MachFan = min(0.55, self.aircraft.requirement.cruise_mach)     # required Mach number at fan position\n    fan_area = m_dot_design / self.corrected_air_flow(Ptot,Ttot,MachFan)        # Corrected air flow per area at fan position\n    self.fan_width = 2.*np.sqrt(fan_area/np.pi)        # Fan diameter\n\n    self.width = self.fan_width + 0.30      # Surrounding structure\n    self.length = 1.50*self.width\n\n    self.gross_wet_area = np.pi*self.width*self.length\n    self.net_wet_area = self.gross_wet_area\n    self.aero_length = self.length\n    self.form_factor = 1.15\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/propulsion/#lh2pac.marilib.aircraft.airframe.propulsion.SemiEmpiricTfBliNacelle.unitary_sc_bli","title":"unitary_sc_bli","text":"<pre><code>unitary_sc_bli(\n    pamb, tamb, mach, rating, thrust, pw_offtake=0.0\n)\n</code></pre> <p>Unitary specific consumption of a turbofan with bli</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/propulsion.py</code> <pre><code>def unitary_sc_bli(self,pamb,tamb,mach,rating,thrust,pw_offtake=0.):\n    \"\"\"Unitary specific consumption of a turbofan with bli\n    \"\"\"\n    r,gam,Cp,Cv = earth.gas_data()\n\n    def fct(x_in,thrust,pamb,tamb,rho,Vair,r1,d1):\n        y = x_in[0]\n        throttle = x_in[1]\n        q0,q1,q2,Vinlet,dVbli = self.air_flow(rho,Vair,r1,d1,y)\n        mach_inlet = Vinlet / earth.sound_speed(tamb)\n        pw_shaft,core_thrust,fuel_flow = self.fan_shaft_power(pamb,tamb,mach_inlet,rating,throttle=throttle,pw_offtake=pw_offtake)\n        Ttot = earth.total_temperature(tamb,mach_inlet)     # Total temperature at inlet position\n        Ptot = earth.total_pressure(pamb,mach_inlet)        # Total pressure at inlet position\n        TtotJet = Ttot + pw_shaft/(q1*Cp)\n        PtotJet = Ptot * (1. + self.fan_efficiency*(TtotJet/Ttot-1.))**(gam/(gam-1.))\n        MachJet = np.sqrt(((PtotJet/pamb)**((gam-1.)/gam) - 1.) * (2./(gam-1.)))\n        TstaJet = TtotJet / (1.+0.5*(gam-1.)*MachJet**2)\n        Vjet = MachJet * np.sqrt(gam*r*TstaJet)\n        qf = self.nozzle_area * self.corrected_air_flow(PtotJet,TtotJet,MachJet)\n        fan_thrust = qf*(Vjet - Vinlet)\n        qc = qf / self.engine_bpr\n        return [qf+qc-q1, thrust-(fan_thrust+core_thrust)]\n\n    Re = earth.reynolds_number(pamb,tamb,mach)\n    rho,sig = earth.air_density(pamb,tamb)\n    Vair = mach * earth.sound_speed(tamb)\n\n    d0 = self.boundary_layer(Re,self.body_length)      # theorical thickness of the boundary layer without taking account of fuselage tapering\n    r1 = 0.5*self.hub_width      # Radius of the hub of the eFan nacelle\n    d1 = math.lin_interp_1d(d0,self.bnd_layer[:,0],self.bnd_layer[:,1])     # Using the precomputed relation\n\n    fct_arg = (thrust,pamb,tamb,rho,Vair,r1,d1)\n\n    x_init = [0.75,0.75]\n\n    # Computation of both air flow and shaft power\n    output_dict = fsolve(fct, x0=x_init, args=fct_arg, full_output=True)\n    if (output_dict[2]!=1): raise Exception(\"Convergence problem\")\n\n    y1 = output_dict[0][0]\n    throttle = output_dict[0][1]\n\n    q0,q1,q2,Vinlet,dVbli = self.air_flow(rho,Vair,r1,d1,y1)\n    mach_inlet = Vinlet / earth.sound_speed(tamb)\n    pw_shaft,core_thrust,fuel_flow = self.fan_shaft_power(pamb,tamb,mach_inlet,rating,throttle=throttle,pw_offtake=pw_offtake)\n\n    sfc = fuel_flow / thrust\n\n    return {\"sfc\":sfc, \"thtl\":throttle, \"t4\":None}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/propulsion/#lh2pac.marilib.aircraft.airframe.propulsion.SemiEmpiricTfBliNacelle.unitary_sc_free_stream","title":"unitary_sc_free_stream","text":"<pre><code>unitary_sc_free_stream(\n    pamb, tamb, mach, rating, thrust, pw_offtake=0.0\n)\n</code></pre> <p>Unitary power required of a turbofan engine delivering a given thrust (semi-empirical model)</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/propulsion.py</code> <pre><code>def unitary_sc_free_stream(self,pamb,tamb,mach,rating,thrust,pw_offtake=0.):\n    \"\"\"Unitary power required of a turbofan engine delivering a given thrust (semi-empirical model)\n    \"\"\"\n    r,gam,Cp,Cv = earth.gas_data()\n\n    def fct(x_in,thrust,pamb,Ptot,Ttot,Vair):\n        q = x_in[0]\n        throttle = x_in[1]\n        pw_shaft,core_thrust,fuel_flow = self.fan_shaft_power(pamb,tamb,mach,rating,throttle=throttle,pw_offtake=pw_offtake)\n        TtotJet = Ttot + pw_shaft/(q*Cp)\n        PtotJet = Ptot * (1. + self.fan_efficiency*(TtotJet/Ttot-1.))**(gam/(gam-1.))\n        MachJet = np.sqrt(((PtotJet/pamb)**((gam-1.)/gam) - 1.) * (2./(gam-1.)))\n        TstaJet = TtotJet / (1.+0.5*(gam-1.)*MachJet**2)\n        Vjet = MachJet * np.sqrt(gam*r*TstaJet)\n        qf = self.nozzle_area * self.corrected_air_flow(PtotJet,TtotJet,MachJet)\n        fan_thrust = qf*(Vjet - Vair)\n        qc = qf / self.engine_bpr\n        return [qf+qc-q, thrust-(fan_thrust+core_thrust)]\n\n    Ptot = earth.total_pressure(pamb, mach)        # Total pressure at inlet position\n    Ttot = earth.total_temperature(tamb, mach)     # Total temperature at inlet position\n    Vair = mach * earth.sound_speed(tamb)\n\n    fct_arg = (thrust,pamb,Ptot,Ttot,Vair)\n\n    CQoA0 = self.corrected_air_flow(Ptot,Ttot,mach)       # Corrected air flow per area at fan position\n    q0init = CQoA0*(0.25*np.pi*self.fan_width**2)\n\n    x_init = [q0init,0.75]\n\n    # Computation of both air flow and shaft power\n    output_dict = fsolve(fct, x0=x_init, args=fct_arg, full_output=True)\n    if (output_dict[2]!=1): raise Exception(\"Convergence problem\")\n\n    throttle = output_dict[0][1]\n\n    pw_shaft,core_thrust,fuel_flow = self.fan_shaft_power(pamb,tamb,mach,rating,throttle=throttle,pw_offtake=pw_offtake)\n\n    sfc = fuel_flow / thrust\n\n    return {\"sfc\":sfc, \"thtl\":throttle, \"t4\":None}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/propulsion/#lh2pac.marilib.aircraft.airframe.propulsion.SemiEmpiricTfBliNacelle.unitary_thrust_bli","title":"unitary_thrust_bli","text":"<pre><code>unitary_thrust_bli(\n    pamb, tamb, mach, rating, throttle=1.0, pw_offtake=0.0\n)\n</code></pre> <p>Unitary thrust of an electrofan engine (semi-empirical model)</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/propulsion.py</code> <pre><code>def unitary_thrust_bli(self,pamb,tamb,mach,rating,throttle=1.,pw_offtake=0.):\n    \"\"\"Unitary thrust of an electrofan engine (semi-empirical model)\n    \"\"\"\n    r,gam,Cp,Cv = earth.gas_data()\n\n    def fct(y,pw_shaft,pamb,tamb,rho,Vair,r1,d1):\n        q0,q1,q2,Vinlet,dVbli = self.air_flow(rho,Vair,r1,d1,y)\n        mach_inlet = Vinlet / earth.sound_speed(tamb)\n        Ttot = earth.total_temperature(tamb,mach_inlet)     # Total temperature at inlet position\n        Ptot = earth.total_pressure(pamb,mach_inlet)        # Total pressure at inlet position\n        TtotJet = Ttot + pw_shaft/(q1*Cp)\n        PtotJet = Ptot * (1. + self.fan_efficiency*(TtotJet/Ttot-1.))**(gam/(gam-1.))\n        MachJet = np.sqrt(((PtotJet/pamb)**((gam-1.)/gam) - 1.) * (2./(gam-1.)))\n        qf = self.nozzle_area * self.corrected_air_flow(PtotJet,TtotJet,MachJet)\n        qc = qf / self.engine_bpr\n        return qf+qc - q1\n\n    pw_shaft,core_thrust,fuel_flow = self.fan_shaft_power(pamb,tamb,mach,rating,throttle=throttle,pw_offtake=pw_offtake)\n\n    Re = earth.reynolds_number(pamb,tamb,mach)\n    rho,sig = earth.air_density(pamb,tamb)\n    Vair = mach * earth.sound_speed(tamb)\n\n    d0 = self.boundary_layer(Re,self.body_length)      # theorical thickness of the boundary layer without taking account of fuselage tapering\n    r1 = 0.5*self.hub_width      # Radius of the hub of the eFan nacelle\n    d1 = math.lin_interp_1d(d0,self.bnd_layer[:,0],self.bnd_layer[:,1])     # Using the precomputed relation\n\n    fct_arg = (pw_shaft,pamb,tamb,rho,Vair,r1,d1)\n\n    # Computation of y1 : thikness of the vein swallowed by the inlet\n    output_dict = fsolve(fct, x0=0.5, args=fct_arg, full_output=True)\n    if (output_dict[2]!=1): raise Exception(\"Convergence problem\")\n\n    y1 = output_dict[0][0]\n\n    q0,q1,q2,Vinlet,dVbli = self.air_flow(rho,Vair,r1,d1,y1)\n\n    mach_inlet = Vinlet / earth.sound_speed(tamb)\n    Ttot = earth.total_temperature(tamb,mach_inlet)     # Total temperature at inlet position\n    Ptot = earth.total_pressure(pamb,mach_inlet)        # Total pressure at inlet position\n    TtotJet = Ttot + pw_shaft/(q1*Cp)\n    PtotJet = Ptot * (1. + self.fan_efficiency*(TtotJet/Ttot-1.))**(gam/(gam-1.))\n    MachJet = np.sqrt(((PtotJet/pamb)**((gam-1.)/gam) - 1.) * (2./(gam-1.)))\n    TstaJet = TtotJet / (1.+0.5*(gam-1.)*MachJet**2)\n    Vjet = MachJet * np.sqrt(gam*r*TstaJet)\n    qf = self.nozzle_area * self.corrected_air_flow(PtotJet,TtotJet,MachJet)\n    fan_thrust = qf*(Vjet - Vinlet)\n\n    total_thrust = fan_thrust + core_thrust\n    sfc = fuel_flow / total_thrust\n\n    return {\"fn\":total_thrust, \"ff\":fuel_flow, \"sfc\":sfc, \"t4\":None}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/propulsion/#lh2pac.marilib.aircraft.airframe.propulsion.SemiEmpiricTfBliNacelle.unitary_thrust_free_stream","title":"unitary_thrust_free_stream","text":"<pre><code>unitary_thrust_free_stream(\n    pamb, tamb, mach, rating, throttle=1.0, pw_offtake=0.0\n)\n</code></pre> <p>Unitary thrust of an electrofan engine (semi-empirical model)</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/propulsion.py</code> <pre><code>def unitary_thrust_free_stream(self,pamb,tamb,mach,rating,throttle=1.,pw_offtake=0.):\n    \"\"\"Unitary thrust of an electrofan engine (semi-empirical model)\n    \"\"\"\n    r,gam,Cp,Cv = earth.gas_data()\n\n    def fct(q,pw_shaft,pamb,Ptot,Ttot,Vair):\n        TtotJet = Ttot + pw_shaft/(q*Cp)\n        PtotJet = Ptot * (1. + self.fan_efficiency*(TtotJet/Ttot-1.))**(gam/(gam-1.))\n        MachJet = np.sqrt(((PtotJet/pamb)**((gam-1.)/gam) - 1.) * (2./(gam-1.)))\n        qf = self.nozzle_area * self.corrected_air_flow(PtotJet,TtotJet,MachJet)\n        qc = qf / self.engine_bpr\n        return qf+qc - q\n\n    pw_shaft,core_thrust,fuel_flow = self.fan_shaft_power(pamb,tamb,mach,rating,throttle=throttle,pw_offtake=pw_offtake)\n\n    Ptot = earth.total_pressure(pamb, mach)        # Total pressure at inlet position\n    Ttot = earth.total_temperature(tamb, mach)     # Total temperature at inlet position\n    Vair = mach * earth.sound_speed(tamb)\n\n    fct_arg = (pw_shaft,pamb,Ptot,Ttot,Vair)\n\n    CQoA0 = self.corrected_air_flow(Ptot,Ttot,mach)       # Corrected air flow per area at fan position\n    q0init = CQoA0*(0.25*np.pi*self.fan_width**2)\n\n    # Computation of the air flow swallowed by the inlet\n    output_dict = fsolve(fct, x0=q0init, args=fct_arg, full_output=True)\n    if (output_dict[2]!=1): raise Exception(\"Convergence problem\")\n\n    q0 = output_dict[0][0]\n    TtotJet = Ttot + pw_shaft/(q0*Cp)\n    PtotJet = Ptot * (1. + self.fan_efficiency*(TtotJet/Ttot-1.))**(gam/(gam-1.))\n    MachJet = np.sqrt(((PtotJet/pamb)**((gam-1.)/gam) - 1.) * (2./(gam-1.)))\n    TstaJet = TtotJet / (1.+0.5*(gam-1.)*MachJet**2)\n    Vjet = MachJet * np.sqrt(gam*r*TstaJet)\n    qf = self.nozzle_area * self.corrected_air_flow(PtotJet,TtotJet,MachJet)\n    fan_thrust = qf*(Vjet - Vair)\n\n    total_thrust = fan_thrust + core_thrust\n    sfc = fuel_flow / total_thrust\n\n    return {\"fn\":total_thrust, \"ff\":fuel_flow, \"sfc\":sfc, \"t4\":None}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/propulsion/#lh2pac.marilib.aircraft.airframe.propulsion.SemiEmpiricTfNacelle","title":"SemiEmpiricTfNacelle","text":"<pre><code>SemiEmpiricTfNacelle(aircraft)\n</code></pre> <p>               Bases: <code>object</code></p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/propulsion.py</code> <pre><code>def __init__(self, aircraft):\n    super(SemiEmpiricTfNacelle, self).__init__(aircraft)\n\n    class_name = \"SemiEmpiricTfNacelle\"\n\n    self.eis_date = aircraft.get_init(class_name,\"eis_date\")\n    # self.rating_factor = RatingFactor(MTO=1.00, MCN=0.86, MCL=0.78, MCR=0.70, FID=0.05)\n    self.rating_factor = RatingFactor(MTO=1.00, MCN=0.90, MCL=0.85, MCR=0.57, FID=0.05)\n    self.reference_offtake = 0.\n\n    self.engine_bpr = aircraft.get_init(class_name,\"engine_bpr\", val=self.__turbofan_bpr())\n    self.engine_opr = aircraft.get_init(class_name,\"engine_opr\", val=self.__turbofan_opr())\n    self.engine_fpr = aircraft.get_init(class_name,\"engine_fpr\", val=self.__turbofan_fpr())\n    self.core_thrust_ratio = aircraft.get_init(class_name,\"core_thrust_ratio\")\n    self.propeller_efficiency = aircraft.get_init(class_name,\"propeller_efficiency\")\n    self.fan_efficiency = aircraft.get_init(class_name,\"fan_efficiency\")\n    self.delta_air_speed = None\n\n    self.lateral_margin = aircraft.get_init(class_name,\"lateral_margin\")\n    self.vertical_margin = aircraft.get_init(class_name,\"vertical_margin\")\n    self.hub_width = aircraft.get_init(class_name,\"hub_width\")\n\n    self.fan_width = None\n    self.nozzle_width = None\n    self.nozzle_area = None\n    self.sea_level_static_thrust = None\n\n    self.width = None\n    self.length = None\n\n    self.propeller_mass = 0.\n    self.engine_mass = 0.\n    self.pylon_mass = 0.\n\n    self.frame_origin = np.full(3,None)\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/propulsion/#lh2pac.marilib.aircraft.airframe.propulsion.SemiEmpiricTfNacelle-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/aircraft/airframe/propulsion/#lh2pac.marilib.aircraft.airframe.propulsion.SemiEmpiricTfNacelle.corrected_air_flow","title":"corrected_air_flow","text":"<pre><code>corrected_air_flow(Ptot, Ttot, Mach)\n</code></pre> <p>Computes the corrected air flow per square meter</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/propulsion.py</code> <pre><code>def corrected_air_flow(self,Ptot,Ttot,Mach):\n    \"\"\"Computes the corrected air flow per square meter\n    \"\"\"\n    r,gam,Cp,Cv = earth.gas_data()\n    f_m = Mach*(1. + 0.5*(gam-1)*Mach**2)**(-(gam+1.)/(2.*(gam-1.)))\n    cqoa = (np.sqrt(gam/r)*Ptot/np.sqrt(Ttot))*f_m\n    return cqoa\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/propulsion/#lh2pac.marilib.aircraft.airframe.propulsion.SemiEmpiricTfNacelle.fan_shaft_power","title":"fan_shaft_power","text":"<pre><code>fan_shaft_power(\n    pamb, tamb, mach, rating, throttle=1.0, pw_offtake=0.0\n)\n</code></pre> <p>Fan shaft power of a pure turbofan engine (semi-empirical model)</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/propulsion.py</code> <pre><code>def fan_shaft_power(self,pamb,tamb,mach,rating,throttle=1.,pw_offtake=0.):\n    \"\"\"Fan shaft power of a pure turbofan engine (semi-empirical model)\n    \"\"\"\n    sfc_ref = ( 0.4 + 1./self.engine_bpr**0.895 )/36000.\n\n    reference_thrust = self.aircraft.power_system.reference_thrust\n    kth =  0.475*mach**2 + 0.091*(self.engine_bpr/10.)**2 \\\n         - 0.283*mach*self.engine_bpr/10. \\\n         - 0.633*mach - 0.081*self.engine_bpr/10. + 1.192\n\n    rho,sig = earth.air_density(pamb, tamb)\n    vair = mach * earth.sound_speed(tamb)\n\n    # Factor 1.25 on kth is to synchronise the order of magnitude of reference thrust\n    # with the effective SLST computed as Thrust(mach=0.25, disa=15) / 0.8\n    total_thrust0 =   reference_thrust \\\n                    * kth * 1.25 \\\n                    * getattr(self.rating_factor,rating) \\\n                    * throttle \\\n                    * sig**0.75\n    fuel_flow = sfc_ref * total_thrust0                         # Fuel flow\n    core_thrust0 = total_thrust0 * self.core_thrust_ratio       # Core thrust\n    fan_thrust0 = total_thrust0 * (1.-self.core_thrust_ratio)   # Fan thrust\n    fan_power0 = fan_thrust0*vair/self.propeller_efficiency     # Available total shaft power for one engine\n\n    return fan_power0-pw_offtake, core_thrust0, fuel_flow\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/propulsion/#lh2pac.marilib.aircraft.airframe.propulsion.SemiEmpiricTfNacelle.turbofan_nacelle_design","title":"turbofan_nacelle_design","text":"<pre><code>turbofan_nacelle_design(Pamb, Tamb, Mach, shaft_power)\n</code></pre> <p>Electrofan nacelle design</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/propulsion.py</code> <pre><code>def turbofan_nacelle_design(self,Pamb,Tamb,Mach,shaft_power):\n    \"\"\"Electrofan nacelle design\n    \"\"\"\n    r,gam,Cp,Cv = earth.gas_data()\n\n    MachInlet = Mach     # The inlet is in free stream\n    Ptot = earth.total_pressure(Pamb, MachInlet)        # Stagnation pressure at inlet position\n    Ttot = earth.total_temperature(Tamb, MachInlet)     # Stagnation temperature at inlet position\n\n    PtotJet = Ptot * self.engine_fpr\n    TtotJet = Ttot*((self.engine_fpr**((gam-1.)/gam) - 1.)/self.fan_efficiency + 1.)\n    MachJet = np.sqrt(((PtotJet/Pamb)**((gam-1.)/gam) - 1.) * (2./(gam-1.)))\n    m_dot_design = shaft_power/(Cp*(TtotJet - Ttot))\n\n    self.nozzle_area = m_dot_design / self.corrected_air_flow(PtotJet,TtotJet,MachJet)\n    self.nozzle_width = np.sqrt(self.hub_width**2 + 4.*self.nozzle_area/np.pi)        # Nozzle diameter\n\n    MachFan = min(0.55, self.aircraft.requirement.cruise_mach)     # required Mach number at fan position\n    fan_area = m_dot_design / self.corrected_air_flow(Ptot,Ttot,MachFan)        # Corrected air flow per area at fan position\n    self.fan_width = 2.*np.sqrt(fan_area/np.pi)        # Fan diameter\n\n    self.width = self.fan_width + 0.30      # Surrounding structure\n    self.length = 1.50*self.width\n\n    self.gross_wet_area = np.pi*self.width*self.length\n    self.net_wet_area = self.gross_wet_area\n    self.aero_length = self.length\n    self.form_factor = 1.15\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/propulsion/#lh2pac.marilib.aircraft.airframe.propulsion.SemiEmpiricTfNacelle.unitary_sc_free_stream","title":"unitary_sc_free_stream","text":"<pre><code>unitary_sc_free_stream(\n    pamb, tamb, mach, rating, thrust, pw_offtake=0.0\n)\n</code></pre> <p>Unitary power required of a turbofan engine delivering a given thrust (semi-empirical model)</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/propulsion.py</code> <pre><code>def unitary_sc_free_stream(self,pamb,tamb,mach,rating,thrust,pw_offtake=0.):\n    \"\"\"Unitary power required of a turbofan engine delivering a given thrust (semi-empirical model)\n    \"\"\"\n    r,gam,Cp,Cv = earth.gas_data()\n\n    def fct(x_in,thrust,pamb,Ptot,Ttot,Vair):\n        q = x_in[0]\n        throttle = x_in[1]\n        pw_shaft,core_thrust,fuel_flow = self.fan_shaft_power(pamb,tamb,mach,rating,throttle=throttle,pw_offtake=pw_offtake)\n        TtotJet = Ttot + pw_shaft/(q*Cp)\n        PtotJet = Ptot * (1. + self.fan_efficiency*(TtotJet/Ttot-1.))**(gam/(gam-1.))\n        MachJet = np.sqrt(((PtotJet/pamb)**((gam-1.)/gam) - 1.) * (2./(gam-1.)))\n        TstaJet = TtotJet / (1.+0.5*(gam-1.)*MachJet**2)\n        Vjet = MachJet * np.sqrt(gam*r*TstaJet)\n        qf = self.nozzle_area * self.corrected_air_flow(PtotJet,TtotJet,MachJet)\n        fan_thrust = qf*(Vjet - Vair)\n        qc = qf / self.engine_bpr\n        return [qf+qc-q, thrust-(fan_thrust+core_thrust)]\n\n    Ptot = earth.total_pressure(pamb, mach)        # Total pressure at inlet position\n    Ttot = earth.total_temperature(tamb, mach)     # Total temperature at inlet position\n    Vair = mach * earth.sound_speed(tamb)\n\n    fct_arg = (thrust,pamb,Ptot,Ttot,Vair)\n\n    CQoA0 = self.corrected_air_flow(Ptot,Ttot,mach)       # Corrected air flow per area at fan position\n    q0init = CQoA0*(0.25*np.pi*self.fan_width**2)\n\n    x_init = [q0init,0.75]\n\n    # Computation of both air flow and shaft power\n    output_dict = fsolve(fct, x0=x_init, args=fct_arg, full_output=True)\n    if (output_dict[2]!=1): raise Exception(\"Convergence problem\")\n\n    throttle = output_dict[0][1]\n\n    pw_shaft,core_thrust,fuel_flow = self.fan_shaft_power(pamb,tamb,mach,rating,throttle=throttle,pw_offtake=pw_offtake)\n\n    sfc = fuel_flow / thrust\n\n    return {\"sfc\":sfc, \"thtl\":throttle, \"t4\":None}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/propulsion/#lh2pac.marilib.aircraft.airframe.propulsion.SemiEmpiricTfNacelle.unitary_thrust_free_stream","title":"unitary_thrust_free_stream","text":"<pre><code>unitary_thrust_free_stream(\n    pamb, tamb, mach, rating, throttle=1.0, pw_offtake=0.0\n)\n</code></pre> <p>Unitary thrust of an electrofan engine (semi-empirical model)</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/propulsion.py</code> <pre><code>def unitary_thrust_free_stream(self,pamb,tamb,mach,rating,throttle=1.,pw_offtake=0.):\n    \"\"\"Unitary thrust of an electrofan engine (semi-empirical model)\n    \"\"\"\n    r,gam,Cp,Cv = earth.gas_data()\n\n    def fct(q,pw_shaft,pamb,Ptot,Ttot,Vair):\n        TtotJet = Ttot + pw_shaft/(q*Cp)\n        PtotJet = Ptot * (1. + self.fan_efficiency*(TtotJet/Ttot-1.))**(gam/(gam-1.))\n        MachJet = np.sqrt(((PtotJet/pamb)**((gam-1.)/gam) - 1.) * (2./(gam-1.)))\n        qf = self.nozzle_area * self.corrected_air_flow(PtotJet,TtotJet,MachJet)\n        qc = qf / self.engine_bpr\n        return qf+qc - q\n\n    pw_shaft,core_thrust,fuel_flow = self.fan_shaft_power(pamb,tamb,mach,rating,throttle=throttle,pw_offtake=pw_offtake)\n\n    Ptot = earth.total_pressure(pamb, mach)        # Total pressure at inlet position\n    Ttot = earth.total_temperature(tamb, mach)     # Total temperature at inlet position\n    Vair = mach * earth.sound_speed(tamb)\n\n    fct_arg = (pw_shaft,pamb,Ptot,Ttot,Vair)\n\n    CQoA0 = self.corrected_air_flow(Ptot,Ttot,mach)       # Corrected air flow per area at fan position\n    q0init = CQoA0*(0.25*np.pi*self.fan_width**2)\n\n    # Computation of the air flow swallowed by the inlet\n    output_dict = fsolve(fct, x0=q0init, args=fct_arg, full_output=True)\n    if (output_dict[2]!=1): raise Exception(\"Convergence problem\")\n\n    q0 = output_dict[0][0]\n    TtotJet = Ttot + pw_shaft/(q0*Cp)\n    PtotJet = Ptot * (1. + self.fan_efficiency*(TtotJet/Ttot-1.))**(gam/(gam-1.))\n    MachJet = np.sqrt(((PtotJet/pamb)**((gam-1.)/gam) - 1.) * (2./(gam-1.)))\n    TstaJet = TtotJet / (1.+0.5*(gam-1.)*MachJet**2)\n    Vjet = MachJet * np.sqrt(gam*r*TstaJet)\n    qf = self.nozzle_area * self.corrected_air_flow(PtotJet,TtotJet,MachJet)\n    fan_thrust = qf*(Vjet - Vair)\n\n    total_thrust = fan_thrust + core_thrust\n    sfc = fuel_flow / total_thrust\n\n    return {\"fn\":total_thrust, \"ff\":fuel_flow, \"sfc\":sfc, \"t4\":None}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/propulsion/#lh2pac.marilib.aircraft.airframe.propulsion.SemiEmpiricTpNacelle","title":"SemiEmpiricTpNacelle","text":"<pre><code>SemiEmpiricTpNacelle(aircraft)\n</code></pre> <p>               Bases: <code>object</code></p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/propulsion.py</code> <pre><code>def __init__(self, aircraft):\n    super(SemiEmpiricTpNacelle, self).__init__(aircraft)\n\n    class_name = \"SemiEmpiricTpNacelle\"\n\n    self.eis_date = 2020\n    self.rating_factor = RatingFactor(MTO=1.00, MCN=0.95, MCL=0.90, MCR=0.70, FID=0.05)\n    self.propeller_efficiency = aircraft.get_init(class_name,\"propeller_efficiency\")\n    self.propeller_disk_load = aircraft.get_init(class_name,\"propeller_disk_load\")\n    self.lateral_margin = aircraft.get_init(class_name,\"lateral_margin\")\n    self.hub_width = aircraft.get_init(class_name,\"hub_width\")\n    self.engine_bpr = 100.\n    self.psfc_reference = aircraft.get_init(class_name,\"psfc_reference\")\n\n    self.propeller_width = None\n    self.width = None\n    self.length = None\n    self.propeller_mass = None\n\n    self.propeller_mass = 0.\n    self.engine_mass = 0.\n    self.pylon_mass = 0.\n\n    self.frame_origin = np.full(3,None)\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/propulsion/#lh2pac.marilib.aircraft.airframe.propulsion.SemiEmpiricTpNacelle-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/aircraft/airframe/propulsion/#lh2pac.marilib.aircraft.airframe.propulsion.SemiEmpiricTpNacelle.unitary_sc","title":"unitary_sc","text":"<pre><code>unitary_sc(\n    pamb, tamb, mach, rating, thrust, pw_offtake=0.0\n)\n</code></pre> <p>Unitary thrust of a pure turbofan engine (semi-empirical model)</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/propulsion.py</code> <pre><code>def unitary_sc(self,pamb,tamb,mach,rating,thrust,pw_offtake=0.):\n    \"\"\"Unitary thrust of a pure turbofan engine (semi-empirical model)\n    \"\"\"\n    dict = self.unitary_thrust(pamb,tamb,mach,rating,pw_offtake=pw_offtake)\n    throttle = thrust/dict[\"fn\"]\n    sfc = dict[\"ff\"]/dict[\"pw\"]     # Power SFC\n    t41 = dict[\"t4\"]\n    return {\"sfc\":sfc, \"thtl\":throttle, \"t4\":t41}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/propulsion/#lh2pac.marilib.aircraft.airframe.propulsion.SemiEmpiricTpNacelle.unitary_thrust","title":"unitary_thrust","text":"<pre><code>unitary_thrust(\n    pamb, tamb, mach, rating, throttle=1.0, pw_offtake=0.0\n)\n</code></pre> <p>Unitary thrust of a pure turboprop engine (semi-empirical model)</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/propulsion.py</code> <pre><code>def unitary_thrust(self,pamb,tamb,mach,rating,throttle=1.,pw_offtake=0.):\n    \"\"\"Unitary thrust of a pure turboprop engine (semi-empirical model)\n    \"\"\"\n    reference_power = self.aircraft.power_system.reference_power\n\n    factor = self.rating_factor\n    eta_prop = self.propeller_efficiency\n\n    rho,sig = earth.air_density(pamb,tamb)\n    Vair = mach*earth.sound_speed(tamb)\n\n    shaft_power = throttle*getattr(factor,rating)*reference_power*sig**0.5 - pw_offtake\n\n    fn = eta_prop*shaft_power/Vair\n    ff = self.psfc_reference*(shaft_power + pw_offtake)\n\n    return {\"fn\":fn, \"ff\":ff, \"pw\":shaft_power, \"t4\":None}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/","title":"System","text":""},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system","title":"system","text":"<p>Created on Thu Jan 20 20:20:20 2020</p> <p>@author: Conceptual Airplane Design &amp; Operations (CADO team)          Nicolas PETEILH, Pascal ROCHES, Nicolas MONROLIN, Thierry DRUOT          Aircraft &amp; Systems, Air Transport Departement, ENAC</p> <p>.. note:: All physical parameters are given in SI units.</p>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system-classes","title":"Classes","text":""},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.System","title":"System","text":"<pre><code>System(aircraft)\n</code></pre> <p>               Bases: <code>Component</code></p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/system.py</code> <pre><code>def __init__(self, aircraft):\n    super(System, self).__init__(aircraft)\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.System-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.System.eval_geometry","title":"eval_geometry","text":"<pre><code>eval_geometry()\n</code></pre> <p>Estimates the geometry of the component from the aircraft requirements and statistical design laws.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/system.py</code> <pre><code>def eval_geometry(self):\n    self.frame_origin = [0., 0., 0.]\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.System.eval_mass","title":"eval_mass","text":"<pre><code>eval_mass()\n</code></pre> <p>Estimates the geometry of the component from the aircraft requirements and statistical design laws.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/system.py</code> <pre><code>def eval_mass(self):\n    mtow = self.aircraft.weight_cg.mtow\n    body_cg = self.aircraft.airframe.body.cg\n    wing_cg = self.aircraft.airframe.wing.cg\n    horizontal_stab_cg = self.aircraft.airframe.horizontal_stab.cg\n    vertical_stab_cg = self.aircraft.airframe.vertical_stab.cg\n    nacelle_cg = self.aircraft.airframe.nacelle.cg\n    landing_gear_cg = self.aircraft.airframe.landing_gear.cg\n\n    self.mass = 0.545*mtow**0.8    # global mass of all systems\n\n    self.cg =   0.50*body_cg \\\n              + 0.20*wing_cg \\\n              + 0.10*landing_gear_cg \\\n              + 0.05*horizontal_stab_cg \\\n              + 0.05*vertical_stab_cg \\\n              + 0.10*nacelle_cg\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.System.get_aero_length","title":"get_aero_length","text":"<pre><code>get_aero_length()\n</code></pre> <p>The characteristic aerodynamic length of the component (used for Reynolds number estimations for example).</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_aero_length(self):\n    \"\"\"The characteristic aerodynamic length of the component (used for Reynolds number estimations for example).\"\"\"\n    return self.aero_length\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.System.get_cg_mwe","title":"get_cg_mwe","text":"<pre><code>get_cg_mwe()\n</code></pre> <p>Returns the position of the center of gravity of the manufacturer empty aircraft</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_cg_mwe(self):\n    \"\"\"Returns the position of the center of gravity of the manufacturer empty aircraft\"\"\"\n    return self.cg\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.System.get_cg_owe","title":"get_cg_owe","text":"<pre><code>get_cg_owe()\n</code></pre> <p>Returns the position of the center of gravity of the operational empty aircraft</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_cg_owe(self):\n    \"\"\"Returns the position of the center of gravity of the operational empty aircraft\"\"\"\n    return self.cg\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.System.get_form_factor","title":"get_form_factor","text":"<pre><code>get_form_factor()\n</code></pre> <p>Form factor used to estimate form drag.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_form_factor(self):\n    \"\"\"Form factor used to estimate form drag.\"\"\"\n    return self.form_factor\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.System.get_inertia_tensor","title":"get_inertia_tensor","text":"<pre><code>get_inertia_tensor()\n</code></pre> <p>returns the inertia matrix of the component, if implemented.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_inertia_tensor(self):\n    \"\"\"returns the inertia matrix of the component, if implemented.\"\"\"\n    return self.inertia_tensor\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.System.get_mass_mwe","title":"get_mass_mwe","text":"<pre><code>get_mass_mwe()\n</code></pre> <p>Returns the Manufacturer's Weight Empty, the mass (kg) of the component</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_mass_mwe(self):\n    \"\"\"Returns the *Manufacturer's Weight Empty*, the mass (kg) of the component\"\"\"\n    return self.mass\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.System.get_mass_owe","title":"get_mass_owe","text":"<pre><code>get_mass_owe()\n</code></pre> <p>Returns the Operating Weight Empty, the mass (kg) of the component. Can differ from MWE for some components</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_mass_owe(self):\n    \"\"\"Returns the *Operating Weight Empty*, the mass (kg) of the component. Can differ from MWE for some components\"\"\"\n    return self.mass\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.System.get_net_wet_area","title":"get_net_wet_area","text":"<pre><code>get_net_wet_area()\n</code></pre> <p>The net wet area of the component in contact with outer airflow, 0 if the component has no aerodynamic surface.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_net_wet_area(self):\n    \"\"\"The net wet area of the component in contact with outer airflow, 0 if the component has no aerodynamic surface.\"\"\"\n    return self.net_wet_area\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.System.get_this_shape","title":"get_this_shape","text":"<pre><code>get_this_shape(name)\n</code></pre> <p>Contour curves for 3 view drawing nose1 : modern nose (A220, A350, 787) nose3 : classical Airbus nose nose2 : symetrical nose cone1 : classical tail cone cone2 : symetrical cone section : circle</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_this_shape(self, name): # TODO: is the docstring up to date ?\n    \"\"\"Contour curves for 3 view drawing\n    nose1 : modern nose (A220, A350, 787)\n    nose3 : classical Airbus nose\n    nose2 : symetrical nose\n    cone1 : classical tail cone\n    cone2 : symetrical cone\n    section : circle\n    \"\"\"\n    curve = {\n    \"nose1\":np.array([[ 0.0000 , 0.3339 , 0.3339 , 0.0000 ,  0.0000 ] ,\n                      [ 0.0050 , 0.3848 , 0.3084 , 0.0335 , -0.0335 ] ,\n                      [ 0.0150 , 0.4253 , 0.2881 , 0.0652 , -0.0652 ] ,\n                      [ 0.0500 , 0.5033 , 0.2490 , 0.1101 , -0.1101 ] ,\n                      [ 0.1000 , 0.5811 , 0.2100 , 0.1585 , -0.1585 ] ,\n                      [ 0.1800 , 0.6808 , 0.1600 , 0.2215 , -0.2215 ] ,\n                      [ 0.2773 , 0.7704 , 0.1151 , 0.2859 , -0.2859 ] ,\n                      [ 0.4191 , 0.8562 , 0.0721 , 0.3624 , -0.3624 ] ,\n                      [ 0.5610 , 0.9198 , 0.0402 , 0.4211 , -0.4211 ] ,\n                      [ 0.7738 , 0.9816 , 0.0092 , 0.4761 , -0.4761 ] ,\n                      [ 0.9156 , 0.9962 , 0.0019 , 0.4976 , -0.4976 ] ,\n                      [ 1.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ]]),\n\n    \"nose2\":np.array([[ 0.0000 , 0.5000 ,  0.5000 , 0.0000 ,  0.0000 ] ,\n                      [ 0.0050 , 0.5335 ,  0.4665 , 0.0335 , -0.0335 ] ,\n                      [ 0.0191 , 0.5646 ,  0.4354 , 0.0646 , -0.0646 ] ,\n                      [ 0.0624 , 0.6196 ,  0.3804 , 0.1196 , -0.1196 ] ,\n                      [ 0.1355 , 0.6878 ,  0.3122 , 0.1878 , -0.1878 ] ,\n                      [ 0.1922 , 0.7297 ,  0.2703 , 0.2297 , -0.2297 ] ,\n                      [ 0.2773 , 0.7859 ,  0.2141 , 0.2859 , -0.2859 ] ,\n                      [ 0.4191 , 0.8624 ,  0.1376 , 0.3624 , -0.3624 ] ,\n                      [ 0.5610 , 0.9211 ,  0.0789 , 0.4211 , -0.4211 ] ,\n                      [ 0.7738 , 0.9761 ,  0.0239 , 0.4761 , -0.4761 ] ,\n                      [ 0.9156 , 0.9976 ,  0.0024 , 0.4976 , -0.4976 ] ,\n                      [ 1.0000 , 1.0000 ,  0.0000 , 0.5000 , -0.5000 ]]),\n\n    \"nose3\":np.array([[ 0.0000 , 0.4453 , 0.4453 , 0.0000 ,  0.0000 ] ,\n                      [ 0.0050 , 0.4733 , 0.4112 , 0.0335 , -0.0335 ] ,\n                      [ 0.0191 , 0.5098 , 0.3833 , 0.0646 , -0.0646 ] ,\n                      [ 0.0624 , 0.5718 , 0.3188 , 0.1196 , -0.1196 ] ,\n                      [ 0.1355 , 0.6278 , 0.2531 , 0.1878 , -0.1878 ] ,\n                      [ 0.1922 , 0.7263 , 0.2142 , 0.2297 , -0.2297 ] ,\n                      [ 0.2773 , 0.8127 , 0.1631 , 0.2859 , -0.2859 ] ,\n                      [ 0.4191 , 0.8906 , 0.0962 , 0.3624 , -0.3624 ] ,\n                      [ 0.5610 , 0.9392 , 0.0536 , 0.4211 , -0.4211 ] ,\n                      [ 0.7738 , 0.9818 , 0.0122 , 0.4761 , -0.4761 ] ,\n                      [ 0.9156 , 0.9976 , 0.0025 , 0.4976 , -0.4976 ] ,\n                      [ 1.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ]]),\n\n    \"nose4\":np.array([[ 0.0000, 0.3700, 0.3700, 0.0000,  0.0000 ] ,\n                      [ 0.0050, 0.4200, 0.3200, 0.0335, -0.0335 ] ,\n                      [ 0.0150, 0.4500, 0.2900, 0.0652, -0.0652 ] ,\n                      [ 0.0500, 0.5000, 0.2400, 0.1200, -0.1200 ] ,\n                      [ 0.1000, 0.5500, 0.1900, 0.1750, -0.1750 ] ,\n                      [ 0.1800, 0.6000, 0.1400, 0.2400, -0.2400 ] ,\n                      [ 0.2773, 0.6450, 0.1000, 0.3000, -0.3000 ] ,\n                      [ 0.4191, 0.7000, 0.0500, 0.3700, -0.3700 ] ,\n                      [ 0.5610, 0.7550, 0.0250, 0.4300, -0.4300 ] ,\n                      [ 0.6200, 0.7800, 0.0180, 0.4500, -0.4500 ] ,\n                      [ 0.7700, 0.9700, 0.0090, 0.4850, -0.4850 ] ,\n                      [ 0.8100, 0.9900, 0.0060, 0.4900, -0.4900 ] ,\n                      [ 0.9100, 0.9970, 0.0030, 0.4976, -0.4976 ] ,\n                      [ 1.0000, 1.0000, 0.0000, 0.5000, -0.5000 ]]),\n\n    \"cone1\":np.array([[ 0.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ] ,\n                      [ 0.0213 , 1.0000 , 0.0082 , 0.5000 , -0.5000 ] ,\n                      [ 0.0638 , 1.0000 , 0.0230 , 0.4956 , -0.4956 ] ,\n                      [ 0.1064 , 1.0000 , 0.0393 , 0.4875 , -0.4875 ] ,\n                      [ 0.1489 , 1.0000 , 0.0556 , 0.4794 , -0.4794 ] ,\n                      [ 0.1915 , 1.0000 , 0.0786 , 0.4720 , -0.4720 ] ,\n                      [ 0.2766 , 1.0000 , 0.1334 , 0.4566 , -0.4566 ] ,\n                      [ 0.3617 , 1.0000 , 0.1964 , 0.4330 , -0.4330 ] ,\n                      [ 0.4894 , 1.0000 , 0.3024 , 0.3822 , -0.3822 ] ,\n                      [ 0.6170 , 1.0000 , 0.4159 , 0.3240 , -0.3240 ] ,\n                      [ 0.7447 , 1.0000 , 0.5374 , 0.2577 , -0.2577 ] ,\n                      [ 0.8723 , 1.0000 , 0.6627 , 0.1834 , -0.1834 ] ,\n                      [ 0.8936 , 0.9963 , 0.6901 , 0.1679 , -0.1679 ] ,\n                      [ 0.9149 , 0.9881 , 0.7139 , 0.1524 , -0.1524 ] ,\n                      [ 0.9362 , 0.9800 , 0.7413 , 0.1333 , -0.1333 ] ,\n                      [ 0.9574 , 0.9652 , 0.7687 , 0.1097 , -0.1097 ] ,\n                      [ 0.9787 , 0.9533 , 0.8043 , 0.0788 , -0.0788 ] ,\n                      [ 0.9894 , 0.9377 , 0.8280 , 0.0589 , -0.0589 ] ,\n                      [ 1.0000 , 0.9103 , 0.8784 , 0.0162 , -0.0162 ]]),\n\n    \"cone2\":np.array([[ 0.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ] ,\n                      [ 0.0213 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ] ,\n                      [ 0.0638 , 0.9956 , 0.0044 , 0.4956 , -0.4956 ] ,\n                      [ 0.1064 , 0.9875 , 0.0125 , 0.4875 , -0.4875 ] ,\n                      [ 0.1489 , 0.9794 , 0.0206 , 0.4794 , -0.4794 ] ,\n                      [ 0.1915 , 0.9720 , 0.0280 , 0.4720 , -0.4720 ] ,\n                      [ 0.2766 , 0.9566 , 0.0434 , 0.4566 , -0.4566 ] ,\n                      [ 0.3617 , 0.9330 , 0.0670 , 0.4330 , -0.4330 ] ,\n                      [ 0.4894 , 0.8822 , 0.1178 , 0.3822 , -0.3822 ] ,\n                      [ 0.6170 , 0.8240 , 0.1760 , 0.3240 , -0.3240 ] ,\n                      [ 0.7447 , 0.7577 , 0.2423 , 0.2577 , -0.2577 ] ,\n                      [ 0.8723 , 0.6834 , 0.3166 , 0.1834 , -0.1834 ] ,\n                      [ 0.8936 , 0.6679 , 0.3321 , 0.1679 , -0.1679 ] ,\n                      [ 0.9149 , 0.6524 , 0.3476 , 0.1524 , -0.1524 ] ,\n                      [ 0.9362 , 0.6333 , 0.3667 , 0.1333 , -0.1333 ] ,\n                      [ 0.9574 , 0.6097 , 0.3903 , 0.1097 , -0.1097 ] ,\n                      [ 0.9787 , 0.5788 , 0.4212 , 0.0788 , -0.0788 ] ,\n                      [ 0.9894 , 0.5589 , 0.4411 , 0.0589 , -0.0589 ] ,\n                      [ 1.0000 , 0.5162 , 0.4838 , 0.0162 , -0.0162 ]]),\n\n    \"sec1\":np.array([[  0.5000000 , 0.0000000 ,  0.0000000 ] ,\n                     [  0.4903926 , 0.0975452 , -0.0975452 ] ,\n                     [  0.4619398 , 0.1913417 , -0.1913417 ] ,\n                     [  0.4157348 , 0.2777851 , -0.2777851 ] ,\n                     [  0.3535534 , 0.3535534 , -0.3535534 ] ,\n                     [  0.2777851 , 0.4157348 , -0.4157348 ] ,\n                     [  0.1913417 , 0.4619398 , -0.4619398 ] ,\n                     [  0.0975452 , 0.4903926 , -0.4903926 ] ,\n                     [  0.0000000 , 0.5000000 , -0.5000000 ] ,\n                     [- 0.0975452 , 0.4903926 , -0.4903926 ] ,\n                     [- 0.1913417 , 0.4619398 , -0.4619398 ] ,\n                     [- 0.2777851 , 0.4157348 , -0.4157348 ] ,\n                     [- 0.3535534 , 0.3535534 , -0.3535534 ] ,\n                     [- 0.4157348 , 0.2777851 , -0.2777851 ] ,\n                     [- 0.4619398 , 0.1913417 , -0.1913417 ] ,\n                     [- 0.4903926 , 0.0975452 , -0.0975452 ] ,\n                     [- 0.5000000 , 0.0000000 ,  0.0000000 ]]),\n\n    \"sec2\":np.array([[ 0.5000000 , 0.0000000 ,  0.0000000] ,\n                     [ 0.4951963 , 0.0975452 , -0.0975452] ,\n                     [ 0.4809699 , 0.1913417 , -0.1913417] ,\n                     [ 0.4578674 , 0.2777851 , -0.2777851] ,\n                     [ 0.4267767 , 0.3535534 , -0.3535534] ,\n                     [ 0.3888926 , 0.4157348 , -0.4157348] ,\n                     [ 0.3456709 , 0.4619398 , -0.4619398] ,\n                     [ 0.2987726 , 0.4903926 , -0.4903926] ,\n                     [ 0.2500000 , 0.5000000 , -0.5000000] ,\n                     [ 0.0000000 , 0.5000000 , -0.5000000] ,\n                     [-0.2500000 , 0.5000000 , -0.5000000] ,\n                     [-0.2987726 , 0.4903926 , -0.4903926] ,\n                     [-0.3456709 , 0.4619398 , -0.4619398] ,\n                     [-0.3888926 , 0.4157348 , -0.4157348] ,\n                     [-0.4267767 , 0.3535534 , -0.3535534] ,\n                     [-0.4578674 , 0.2777851 , -0.2777851] ,\n                     [-0.4809699 , 0.1913417 , -0.1913417] ,\n                     [-0.4951963 , 0.0975452 , -0.0975452] ,\n                     [-0.5000000 , 0.0000000 ,  0.0000000]])}\n\n    return [curve[n] for n in name]\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.SystemPartialTurboElectric","title":"SystemPartialTurboElectric","text":"<pre><code>SystemPartialTurboElectric(aircraft)\n</code></pre> <p>               Bases: <code>Component</code></p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/system.py</code> <pre><code>def __init__(self, aircraft):\n    super(SystemPartialTurboElectric, self).__init__(aircraft)\n\n    class_name = \"SystemPartialTurboElectric\"\n\n    self.chain_power = aircraft.get_init(class_name,\"chain_power\", val=0.2*init_power(aircraft))\n\n    self.battery = aircraft.get_init(class_name,\"battery\")\n    self.battery_density = aircraft.get_init(class_name,\"battery_density\")\n    self.battery_energy_density = aircraft.get_init(class_name,\"battery_energy_density\")\n    self.lto_power = aircraft.get_init(class_name,\"lto_power\")\n    self.lto_time = aircraft.get_init(class_name,\"lto_time\")\n    self.cruise_energy = aircraft.get_init(class_name,\"cruise_energy\")\n\n    self.generator_efficiency = aircraft.get_init(class_name,\"generator_efficiency\")\n    self.generator_pw_density = aircraft.get_init(class_name,\"generator_pw_density\")\n\n    self.rectifier_efficiency = aircraft.get_init(class_name,\"rectifier_efficiency\")\n    self.rectifier_pw_density = aircraft.get_init(class_name,\"rectifier_pw_density\")\n\n    self.wiring_efficiency = aircraft.get_init(class_name,\"wiring_efficiency\")\n    self.wiring_pw_density = aircraft.get_init(class_name,\"wiring_pw_density\")\n\n    self.cooling_efficiency = aircraft.get_init(class_name,\"cooling_efficiency\")\n    self.cooling_pw_density = aircraft.get_init(class_name,\"cooling_pw_density\")\n\n    self.power_chain_efficiency = None\n\n    self.battery_mass = None\n    self.power_chain_mass = None\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.SystemPartialTurboElectric-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.SystemPartialTurboElectric.eval_geometry","title":"eval_geometry","text":"<pre><code>eval_geometry()\n</code></pre> <p>Estimates the geometry of the component from the aircraft requirements and statistical design laws.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/system.py</code> <pre><code>def eval_geometry(self):\n    self.frame_origin = [0., 0., 0.]\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.SystemPartialTurboElectric.eval_mass","title":"eval_mass","text":"<pre><code>eval_mass()\n</code></pre> <p>Estimates the geometry of the component from the aircraft requirements and statistical design laws.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/system.py</code> <pre><code>def eval_mass(self):\n    mtow = self.aircraft.weight_cg.mtow\n    body_cg = self.aircraft.airframe.body.cg\n    wing_cg = self.aircraft.airframe.wing.cg\n    horizontal_stab_cg = self.aircraft.airframe.horizontal_stab.cg\n    vertical_stab_cg = self.aircraft.airframe.vertical_stab.cg\n    nacelle_cg = self.aircraft.airframe.nacelle.cg\n    landing_gear_cg = self.aircraft.airframe.landing_gear.cg\n    n_engine = self.aircraft.power_system.n_engine\n\n    elec_power_max = self.chain_power / self.get_power_chain_efficiency()\n\n    self.power_chain_mass = (  1./self.generator_pw_density\n                             + 1./self.rectifier_pw_density\n                             + 1./self.wiring_pw_density\n                             + 1./self.cooling_pw_density) * elec_power_max\n\n    if self.battery==\"yes\":\n        self.battery_mass = (self.lto_power * self.lto_time + self.cruise_energy) / self.battery_energy_density\n        self.power_chain_mass += self.battery_mass\n    else:\n        self.battery_mass = 0.\n\n    power_elec_cg = 0.70*nacelle_cg + 0.30*body_cg\n\n    self.mass = 0.545*mtow**0.8  + self.power_chain_mass  # global mass of all systems\n\n    self.cg =   0.40*body_cg \\\n              + 0.20*wing_cg \\\n              + 0.10*landing_gear_cg \\\n              + 0.05*horizontal_stab_cg \\\n              + 0.05*vertical_stab_cg \\\n              + 0.10*nacelle_cg \\\n              + 0.10*power_elec_cg\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.SystemPartialTurboElectric.get_aero_length","title":"get_aero_length","text":"<pre><code>get_aero_length()\n</code></pre> <p>The characteristic aerodynamic length of the component (used for Reynolds number estimations for example).</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_aero_length(self):\n    \"\"\"The characteristic aerodynamic length of the component (used for Reynolds number estimations for example).\"\"\"\n    return self.aero_length\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.SystemPartialTurboElectric.get_cg_mwe","title":"get_cg_mwe","text":"<pre><code>get_cg_mwe()\n</code></pre> <p>Returns the position of the center of gravity of the manufacturer empty aircraft</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_cg_mwe(self):\n    \"\"\"Returns the position of the center of gravity of the manufacturer empty aircraft\"\"\"\n    return self.cg\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.SystemPartialTurboElectric.get_cg_owe","title":"get_cg_owe","text":"<pre><code>get_cg_owe()\n</code></pre> <p>Returns the position of the center of gravity of the operational empty aircraft</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_cg_owe(self):\n    \"\"\"Returns the position of the center of gravity of the operational empty aircraft\"\"\"\n    return self.cg\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.SystemPartialTurboElectric.get_form_factor","title":"get_form_factor","text":"<pre><code>get_form_factor()\n</code></pre> <p>Form factor used to estimate form drag.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_form_factor(self):\n    \"\"\"Form factor used to estimate form drag.\"\"\"\n    return self.form_factor\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.SystemPartialTurboElectric.get_inertia_tensor","title":"get_inertia_tensor","text":"<pre><code>get_inertia_tensor()\n</code></pre> <p>returns the inertia matrix of the component, if implemented.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_inertia_tensor(self):\n    \"\"\"returns the inertia matrix of the component, if implemented.\"\"\"\n    return self.inertia_tensor\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.SystemPartialTurboElectric.get_mass_mwe","title":"get_mass_mwe","text":"<pre><code>get_mass_mwe()\n</code></pre> <p>Returns the Manufacturer's Weight Empty, the mass (kg) of the component</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_mass_mwe(self):\n    \"\"\"Returns the *Manufacturer's Weight Empty*, the mass (kg) of the component\"\"\"\n    return self.mass\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.SystemPartialTurboElectric.get_mass_owe","title":"get_mass_owe","text":"<pre><code>get_mass_owe()\n</code></pre> <p>Returns the Operating Weight Empty, the mass (kg) of the component. Can differ from MWE for some components</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_mass_owe(self):\n    \"\"\"Returns the *Operating Weight Empty*, the mass (kg) of the component. Can differ from MWE for some components\"\"\"\n    return self.mass\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.SystemPartialTurboElectric.get_net_wet_area","title":"get_net_wet_area","text":"<pre><code>get_net_wet_area()\n</code></pre> <p>The net wet area of the component in contact with outer airflow, 0 if the component has no aerodynamic surface.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_net_wet_area(self):\n    \"\"\"The net wet area of the component in contact with outer airflow, 0 if the component has no aerodynamic surface.\"\"\"\n    return self.net_wet_area\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.SystemPartialTurboElectric.get_this_shape","title":"get_this_shape","text":"<pre><code>get_this_shape(name)\n</code></pre> <p>Contour curves for 3 view drawing nose1 : modern nose (A220, A350, 787) nose3 : classical Airbus nose nose2 : symetrical nose cone1 : classical tail cone cone2 : symetrical cone section : circle</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_this_shape(self, name): # TODO: is the docstring up to date ?\n    \"\"\"Contour curves for 3 view drawing\n    nose1 : modern nose (A220, A350, 787)\n    nose3 : classical Airbus nose\n    nose2 : symetrical nose\n    cone1 : classical tail cone\n    cone2 : symetrical cone\n    section : circle\n    \"\"\"\n    curve = {\n    \"nose1\":np.array([[ 0.0000 , 0.3339 , 0.3339 , 0.0000 ,  0.0000 ] ,\n                      [ 0.0050 , 0.3848 , 0.3084 , 0.0335 , -0.0335 ] ,\n                      [ 0.0150 , 0.4253 , 0.2881 , 0.0652 , -0.0652 ] ,\n                      [ 0.0500 , 0.5033 , 0.2490 , 0.1101 , -0.1101 ] ,\n                      [ 0.1000 , 0.5811 , 0.2100 , 0.1585 , -0.1585 ] ,\n                      [ 0.1800 , 0.6808 , 0.1600 , 0.2215 , -0.2215 ] ,\n                      [ 0.2773 , 0.7704 , 0.1151 , 0.2859 , -0.2859 ] ,\n                      [ 0.4191 , 0.8562 , 0.0721 , 0.3624 , -0.3624 ] ,\n                      [ 0.5610 , 0.9198 , 0.0402 , 0.4211 , -0.4211 ] ,\n                      [ 0.7738 , 0.9816 , 0.0092 , 0.4761 , -0.4761 ] ,\n                      [ 0.9156 , 0.9962 , 0.0019 , 0.4976 , -0.4976 ] ,\n                      [ 1.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ]]),\n\n    \"nose2\":np.array([[ 0.0000 , 0.5000 ,  0.5000 , 0.0000 ,  0.0000 ] ,\n                      [ 0.0050 , 0.5335 ,  0.4665 , 0.0335 , -0.0335 ] ,\n                      [ 0.0191 , 0.5646 ,  0.4354 , 0.0646 , -0.0646 ] ,\n                      [ 0.0624 , 0.6196 ,  0.3804 , 0.1196 , -0.1196 ] ,\n                      [ 0.1355 , 0.6878 ,  0.3122 , 0.1878 , -0.1878 ] ,\n                      [ 0.1922 , 0.7297 ,  0.2703 , 0.2297 , -0.2297 ] ,\n                      [ 0.2773 , 0.7859 ,  0.2141 , 0.2859 , -0.2859 ] ,\n                      [ 0.4191 , 0.8624 ,  0.1376 , 0.3624 , -0.3624 ] ,\n                      [ 0.5610 , 0.9211 ,  0.0789 , 0.4211 , -0.4211 ] ,\n                      [ 0.7738 , 0.9761 ,  0.0239 , 0.4761 , -0.4761 ] ,\n                      [ 0.9156 , 0.9976 ,  0.0024 , 0.4976 , -0.4976 ] ,\n                      [ 1.0000 , 1.0000 ,  0.0000 , 0.5000 , -0.5000 ]]),\n\n    \"nose3\":np.array([[ 0.0000 , 0.4453 , 0.4453 , 0.0000 ,  0.0000 ] ,\n                      [ 0.0050 , 0.4733 , 0.4112 , 0.0335 , -0.0335 ] ,\n                      [ 0.0191 , 0.5098 , 0.3833 , 0.0646 , -0.0646 ] ,\n                      [ 0.0624 , 0.5718 , 0.3188 , 0.1196 , -0.1196 ] ,\n                      [ 0.1355 , 0.6278 , 0.2531 , 0.1878 , -0.1878 ] ,\n                      [ 0.1922 , 0.7263 , 0.2142 , 0.2297 , -0.2297 ] ,\n                      [ 0.2773 , 0.8127 , 0.1631 , 0.2859 , -0.2859 ] ,\n                      [ 0.4191 , 0.8906 , 0.0962 , 0.3624 , -0.3624 ] ,\n                      [ 0.5610 , 0.9392 , 0.0536 , 0.4211 , -0.4211 ] ,\n                      [ 0.7738 , 0.9818 , 0.0122 , 0.4761 , -0.4761 ] ,\n                      [ 0.9156 , 0.9976 , 0.0025 , 0.4976 , -0.4976 ] ,\n                      [ 1.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ]]),\n\n    \"nose4\":np.array([[ 0.0000, 0.3700, 0.3700, 0.0000,  0.0000 ] ,\n                      [ 0.0050, 0.4200, 0.3200, 0.0335, -0.0335 ] ,\n                      [ 0.0150, 0.4500, 0.2900, 0.0652, -0.0652 ] ,\n                      [ 0.0500, 0.5000, 0.2400, 0.1200, -0.1200 ] ,\n                      [ 0.1000, 0.5500, 0.1900, 0.1750, -0.1750 ] ,\n                      [ 0.1800, 0.6000, 0.1400, 0.2400, -0.2400 ] ,\n                      [ 0.2773, 0.6450, 0.1000, 0.3000, -0.3000 ] ,\n                      [ 0.4191, 0.7000, 0.0500, 0.3700, -0.3700 ] ,\n                      [ 0.5610, 0.7550, 0.0250, 0.4300, -0.4300 ] ,\n                      [ 0.6200, 0.7800, 0.0180, 0.4500, -0.4500 ] ,\n                      [ 0.7700, 0.9700, 0.0090, 0.4850, -0.4850 ] ,\n                      [ 0.8100, 0.9900, 0.0060, 0.4900, -0.4900 ] ,\n                      [ 0.9100, 0.9970, 0.0030, 0.4976, -0.4976 ] ,\n                      [ 1.0000, 1.0000, 0.0000, 0.5000, -0.5000 ]]),\n\n    \"cone1\":np.array([[ 0.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ] ,\n                      [ 0.0213 , 1.0000 , 0.0082 , 0.5000 , -0.5000 ] ,\n                      [ 0.0638 , 1.0000 , 0.0230 , 0.4956 , -0.4956 ] ,\n                      [ 0.1064 , 1.0000 , 0.0393 , 0.4875 , -0.4875 ] ,\n                      [ 0.1489 , 1.0000 , 0.0556 , 0.4794 , -0.4794 ] ,\n                      [ 0.1915 , 1.0000 , 0.0786 , 0.4720 , -0.4720 ] ,\n                      [ 0.2766 , 1.0000 , 0.1334 , 0.4566 , -0.4566 ] ,\n                      [ 0.3617 , 1.0000 , 0.1964 , 0.4330 , -0.4330 ] ,\n                      [ 0.4894 , 1.0000 , 0.3024 , 0.3822 , -0.3822 ] ,\n                      [ 0.6170 , 1.0000 , 0.4159 , 0.3240 , -0.3240 ] ,\n                      [ 0.7447 , 1.0000 , 0.5374 , 0.2577 , -0.2577 ] ,\n                      [ 0.8723 , 1.0000 , 0.6627 , 0.1834 , -0.1834 ] ,\n                      [ 0.8936 , 0.9963 , 0.6901 , 0.1679 , -0.1679 ] ,\n                      [ 0.9149 , 0.9881 , 0.7139 , 0.1524 , -0.1524 ] ,\n                      [ 0.9362 , 0.9800 , 0.7413 , 0.1333 , -0.1333 ] ,\n                      [ 0.9574 , 0.9652 , 0.7687 , 0.1097 , -0.1097 ] ,\n                      [ 0.9787 , 0.9533 , 0.8043 , 0.0788 , -0.0788 ] ,\n                      [ 0.9894 , 0.9377 , 0.8280 , 0.0589 , -0.0589 ] ,\n                      [ 1.0000 , 0.9103 , 0.8784 , 0.0162 , -0.0162 ]]),\n\n    \"cone2\":np.array([[ 0.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ] ,\n                      [ 0.0213 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ] ,\n                      [ 0.0638 , 0.9956 , 0.0044 , 0.4956 , -0.4956 ] ,\n                      [ 0.1064 , 0.9875 , 0.0125 , 0.4875 , -0.4875 ] ,\n                      [ 0.1489 , 0.9794 , 0.0206 , 0.4794 , -0.4794 ] ,\n                      [ 0.1915 , 0.9720 , 0.0280 , 0.4720 , -0.4720 ] ,\n                      [ 0.2766 , 0.9566 , 0.0434 , 0.4566 , -0.4566 ] ,\n                      [ 0.3617 , 0.9330 , 0.0670 , 0.4330 , -0.4330 ] ,\n                      [ 0.4894 , 0.8822 , 0.1178 , 0.3822 , -0.3822 ] ,\n                      [ 0.6170 , 0.8240 , 0.1760 , 0.3240 , -0.3240 ] ,\n                      [ 0.7447 , 0.7577 , 0.2423 , 0.2577 , -0.2577 ] ,\n                      [ 0.8723 , 0.6834 , 0.3166 , 0.1834 , -0.1834 ] ,\n                      [ 0.8936 , 0.6679 , 0.3321 , 0.1679 , -0.1679 ] ,\n                      [ 0.9149 , 0.6524 , 0.3476 , 0.1524 , -0.1524 ] ,\n                      [ 0.9362 , 0.6333 , 0.3667 , 0.1333 , -0.1333 ] ,\n                      [ 0.9574 , 0.6097 , 0.3903 , 0.1097 , -0.1097 ] ,\n                      [ 0.9787 , 0.5788 , 0.4212 , 0.0788 , -0.0788 ] ,\n                      [ 0.9894 , 0.5589 , 0.4411 , 0.0589 , -0.0589 ] ,\n                      [ 1.0000 , 0.5162 , 0.4838 , 0.0162 , -0.0162 ]]),\n\n    \"sec1\":np.array([[  0.5000000 , 0.0000000 ,  0.0000000 ] ,\n                     [  0.4903926 , 0.0975452 , -0.0975452 ] ,\n                     [  0.4619398 , 0.1913417 , -0.1913417 ] ,\n                     [  0.4157348 , 0.2777851 , -0.2777851 ] ,\n                     [  0.3535534 , 0.3535534 , -0.3535534 ] ,\n                     [  0.2777851 , 0.4157348 , -0.4157348 ] ,\n                     [  0.1913417 , 0.4619398 , -0.4619398 ] ,\n                     [  0.0975452 , 0.4903926 , -0.4903926 ] ,\n                     [  0.0000000 , 0.5000000 , -0.5000000 ] ,\n                     [- 0.0975452 , 0.4903926 , -0.4903926 ] ,\n                     [- 0.1913417 , 0.4619398 , -0.4619398 ] ,\n                     [- 0.2777851 , 0.4157348 , -0.4157348 ] ,\n                     [- 0.3535534 , 0.3535534 , -0.3535534 ] ,\n                     [- 0.4157348 , 0.2777851 , -0.2777851 ] ,\n                     [- 0.4619398 , 0.1913417 , -0.1913417 ] ,\n                     [- 0.4903926 , 0.0975452 , -0.0975452 ] ,\n                     [- 0.5000000 , 0.0000000 ,  0.0000000 ]]),\n\n    \"sec2\":np.array([[ 0.5000000 , 0.0000000 ,  0.0000000] ,\n                     [ 0.4951963 , 0.0975452 , -0.0975452] ,\n                     [ 0.4809699 , 0.1913417 , -0.1913417] ,\n                     [ 0.4578674 , 0.2777851 , -0.2777851] ,\n                     [ 0.4267767 , 0.3535534 , -0.3535534] ,\n                     [ 0.3888926 , 0.4157348 , -0.4157348] ,\n                     [ 0.3456709 , 0.4619398 , -0.4619398] ,\n                     [ 0.2987726 , 0.4903926 , -0.4903926] ,\n                     [ 0.2500000 , 0.5000000 , -0.5000000] ,\n                     [ 0.0000000 , 0.5000000 , -0.5000000] ,\n                     [-0.2500000 , 0.5000000 , -0.5000000] ,\n                     [-0.2987726 , 0.4903926 , -0.4903926] ,\n                     [-0.3456709 , 0.4619398 , -0.4619398] ,\n                     [-0.3888926 , 0.4157348 , -0.4157348] ,\n                     [-0.4267767 , 0.3535534 , -0.3535534] ,\n                     [-0.4578674 , 0.2777851 , -0.2777851] ,\n                     [-0.4809699 , 0.1913417 , -0.1913417] ,\n                     [-0.4951963 , 0.0975452 , -0.0975452] ,\n                     [-0.5000000 , 0.0000000 ,  0.0000000]])}\n\n    return [curve[n] for n in name]\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.SystemPartialTurboElectricPiggyBack","title":"SystemPartialTurboElectricPiggyBack","text":"<pre><code>SystemPartialTurboElectricPiggyBack(aircraft)\n</code></pre> <p>               Bases: <code>SystemPartialTurboElectric</code></p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/system.py</code> <pre><code>def __init__(self, aircraft):\n    super(SystemPartialTurboElectricPiggyBack, self).__init__(aircraft)\n\n    class_name = \"SystemPartialTurboElectric\"\n\n    self.chain_power_body = aircraft.get_init(class_name,\"chain_power_body\", val=0.1*init_power(aircraft))\n    self.chain_power_piggyback = aircraft.get_init(class_name,\"chain_power_piggyback\", val=0.1*init_power(aircraft))\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.SystemPartialTurboElectricPiggyBack-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.SystemPartialTurboElectricPiggyBack.eval_geometry","title":"eval_geometry","text":"<pre><code>eval_geometry()\n</code></pre> <p>Estimates the geometry of the component from the aircraft requirements and statistical design laws.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/system.py</code> <pre><code>def eval_geometry(self):\n    self.frame_origin = [0., 0., 0.]\n    self.chain_power = self.chain_power_body + self.chain_power_piggyback\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.SystemPartialTurboElectricPiggyBack.eval_mass","title":"eval_mass","text":"<pre><code>eval_mass()\n</code></pre> <p>Estimates the geometry of the component from the aircraft requirements and statistical design laws.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/system.py</code> <pre><code>def eval_mass(self):\n    mtow = self.aircraft.weight_cg.mtow\n    body_cg = self.aircraft.airframe.body.cg\n    wing_cg = self.aircraft.airframe.wing.cg\n    horizontal_stab_cg = self.aircraft.airframe.horizontal_stab.cg\n    vertical_stab_cg = self.aircraft.airframe.vertical_stab.cg\n    nacelle_cg = self.aircraft.airframe.nacelle.cg\n    landing_gear_cg = self.aircraft.airframe.landing_gear.cg\n    n_engine = self.aircraft.power_system.n_engine\n\n    elec_power_max = self.chain_power / self.get_power_chain_efficiency()\n\n    self.power_chain_mass = (  1./self.generator_pw_density\n                             + 1./self.rectifier_pw_density\n                             + 1./self.wiring_pw_density\n                             + 1./self.cooling_pw_density) * elec_power_max\n\n    if self.battery==\"yes\":\n        self.battery_mass = (self.lto_power * self.lto_time + self.cruise_energy) / self.battery_energy_density\n        self.power_chain_mass += self.battery_mass\n    else:\n        self.battery_mass = 0.\n\n    power_elec_cg = 0.70*nacelle_cg + 0.30*body_cg\n\n    self.mass = 0.545*mtow**0.8  + self.power_chain_mass  # global mass of all systems\n\n    self.cg =   0.40*body_cg \\\n              + 0.20*wing_cg \\\n              + 0.10*landing_gear_cg \\\n              + 0.05*horizontal_stab_cg \\\n              + 0.05*vertical_stab_cg \\\n              + 0.10*nacelle_cg \\\n              + 0.10*power_elec_cg\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.SystemPartialTurboElectricPiggyBack.get_aero_length","title":"get_aero_length","text":"<pre><code>get_aero_length()\n</code></pre> <p>The characteristic aerodynamic length of the component (used for Reynolds number estimations for example).</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_aero_length(self):\n    \"\"\"The characteristic aerodynamic length of the component (used for Reynolds number estimations for example).\"\"\"\n    return self.aero_length\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.SystemPartialTurboElectricPiggyBack.get_cg_mwe","title":"get_cg_mwe","text":"<pre><code>get_cg_mwe()\n</code></pre> <p>Returns the position of the center of gravity of the manufacturer empty aircraft</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_cg_mwe(self):\n    \"\"\"Returns the position of the center of gravity of the manufacturer empty aircraft\"\"\"\n    return self.cg\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.SystemPartialTurboElectricPiggyBack.get_cg_owe","title":"get_cg_owe","text":"<pre><code>get_cg_owe()\n</code></pre> <p>Returns the position of the center of gravity of the operational empty aircraft</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_cg_owe(self):\n    \"\"\"Returns the position of the center of gravity of the operational empty aircraft\"\"\"\n    return self.cg\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.SystemPartialTurboElectricPiggyBack.get_form_factor","title":"get_form_factor","text":"<pre><code>get_form_factor()\n</code></pre> <p>Form factor used to estimate form drag.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_form_factor(self):\n    \"\"\"Form factor used to estimate form drag.\"\"\"\n    return self.form_factor\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.SystemPartialTurboElectricPiggyBack.get_inertia_tensor","title":"get_inertia_tensor","text":"<pre><code>get_inertia_tensor()\n</code></pre> <p>returns the inertia matrix of the component, if implemented.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_inertia_tensor(self):\n    \"\"\"returns the inertia matrix of the component, if implemented.\"\"\"\n    return self.inertia_tensor\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.SystemPartialTurboElectricPiggyBack.get_mass_mwe","title":"get_mass_mwe","text":"<pre><code>get_mass_mwe()\n</code></pre> <p>Returns the Manufacturer's Weight Empty, the mass (kg) of the component</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_mass_mwe(self):\n    \"\"\"Returns the *Manufacturer's Weight Empty*, the mass (kg) of the component\"\"\"\n    return self.mass\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.SystemPartialTurboElectricPiggyBack.get_mass_owe","title":"get_mass_owe","text":"<pre><code>get_mass_owe()\n</code></pre> <p>Returns the Operating Weight Empty, the mass (kg) of the component. Can differ from MWE for some components</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_mass_owe(self):\n    \"\"\"Returns the *Operating Weight Empty*, the mass (kg) of the component. Can differ from MWE for some components\"\"\"\n    return self.mass\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.SystemPartialTurboElectricPiggyBack.get_net_wet_area","title":"get_net_wet_area","text":"<pre><code>get_net_wet_area()\n</code></pre> <p>The net wet area of the component in contact with outer airflow, 0 if the component has no aerodynamic surface.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_net_wet_area(self):\n    \"\"\"The net wet area of the component in contact with outer airflow, 0 if the component has no aerodynamic surface.\"\"\"\n    return self.net_wet_area\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.SystemPartialTurboElectricPiggyBack.get_this_shape","title":"get_this_shape","text":"<pre><code>get_this_shape(name)\n</code></pre> <p>Contour curves for 3 view drawing nose1 : modern nose (A220, A350, 787) nose3 : classical Airbus nose nose2 : symetrical nose cone1 : classical tail cone cone2 : symetrical cone section : circle</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_this_shape(self, name): # TODO: is the docstring up to date ?\n    \"\"\"Contour curves for 3 view drawing\n    nose1 : modern nose (A220, A350, 787)\n    nose3 : classical Airbus nose\n    nose2 : symetrical nose\n    cone1 : classical tail cone\n    cone2 : symetrical cone\n    section : circle\n    \"\"\"\n    curve = {\n    \"nose1\":np.array([[ 0.0000 , 0.3339 , 0.3339 , 0.0000 ,  0.0000 ] ,\n                      [ 0.0050 , 0.3848 , 0.3084 , 0.0335 , -0.0335 ] ,\n                      [ 0.0150 , 0.4253 , 0.2881 , 0.0652 , -0.0652 ] ,\n                      [ 0.0500 , 0.5033 , 0.2490 , 0.1101 , -0.1101 ] ,\n                      [ 0.1000 , 0.5811 , 0.2100 , 0.1585 , -0.1585 ] ,\n                      [ 0.1800 , 0.6808 , 0.1600 , 0.2215 , -0.2215 ] ,\n                      [ 0.2773 , 0.7704 , 0.1151 , 0.2859 , -0.2859 ] ,\n                      [ 0.4191 , 0.8562 , 0.0721 , 0.3624 , -0.3624 ] ,\n                      [ 0.5610 , 0.9198 , 0.0402 , 0.4211 , -0.4211 ] ,\n                      [ 0.7738 , 0.9816 , 0.0092 , 0.4761 , -0.4761 ] ,\n                      [ 0.9156 , 0.9962 , 0.0019 , 0.4976 , -0.4976 ] ,\n                      [ 1.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ]]),\n\n    \"nose2\":np.array([[ 0.0000 , 0.5000 ,  0.5000 , 0.0000 ,  0.0000 ] ,\n                      [ 0.0050 , 0.5335 ,  0.4665 , 0.0335 , -0.0335 ] ,\n                      [ 0.0191 , 0.5646 ,  0.4354 , 0.0646 , -0.0646 ] ,\n                      [ 0.0624 , 0.6196 ,  0.3804 , 0.1196 , -0.1196 ] ,\n                      [ 0.1355 , 0.6878 ,  0.3122 , 0.1878 , -0.1878 ] ,\n                      [ 0.1922 , 0.7297 ,  0.2703 , 0.2297 , -0.2297 ] ,\n                      [ 0.2773 , 0.7859 ,  0.2141 , 0.2859 , -0.2859 ] ,\n                      [ 0.4191 , 0.8624 ,  0.1376 , 0.3624 , -0.3624 ] ,\n                      [ 0.5610 , 0.9211 ,  0.0789 , 0.4211 , -0.4211 ] ,\n                      [ 0.7738 , 0.9761 ,  0.0239 , 0.4761 , -0.4761 ] ,\n                      [ 0.9156 , 0.9976 ,  0.0024 , 0.4976 , -0.4976 ] ,\n                      [ 1.0000 , 1.0000 ,  0.0000 , 0.5000 , -0.5000 ]]),\n\n    \"nose3\":np.array([[ 0.0000 , 0.4453 , 0.4453 , 0.0000 ,  0.0000 ] ,\n                      [ 0.0050 , 0.4733 , 0.4112 , 0.0335 , -0.0335 ] ,\n                      [ 0.0191 , 0.5098 , 0.3833 , 0.0646 , -0.0646 ] ,\n                      [ 0.0624 , 0.5718 , 0.3188 , 0.1196 , -0.1196 ] ,\n                      [ 0.1355 , 0.6278 , 0.2531 , 0.1878 , -0.1878 ] ,\n                      [ 0.1922 , 0.7263 , 0.2142 , 0.2297 , -0.2297 ] ,\n                      [ 0.2773 , 0.8127 , 0.1631 , 0.2859 , -0.2859 ] ,\n                      [ 0.4191 , 0.8906 , 0.0962 , 0.3624 , -0.3624 ] ,\n                      [ 0.5610 , 0.9392 , 0.0536 , 0.4211 , -0.4211 ] ,\n                      [ 0.7738 , 0.9818 , 0.0122 , 0.4761 , -0.4761 ] ,\n                      [ 0.9156 , 0.9976 , 0.0025 , 0.4976 , -0.4976 ] ,\n                      [ 1.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ]]),\n\n    \"nose4\":np.array([[ 0.0000, 0.3700, 0.3700, 0.0000,  0.0000 ] ,\n                      [ 0.0050, 0.4200, 0.3200, 0.0335, -0.0335 ] ,\n                      [ 0.0150, 0.4500, 0.2900, 0.0652, -0.0652 ] ,\n                      [ 0.0500, 0.5000, 0.2400, 0.1200, -0.1200 ] ,\n                      [ 0.1000, 0.5500, 0.1900, 0.1750, -0.1750 ] ,\n                      [ 0.1800, 0.6000, 0.1400, 0.2400, -0.2400 ] ,\n                      [ 0.2773, 0.6450, 0.1000, 0.3000, -0.3000 ] ,\n                      [ 0.4191, 0.7000, 0.0500, 0.3700, -0.3700 ] ,\n                      [ 0.5610, 0.7550, 0.0250, 0.4300, -0.4300 ] ,\n                      [ 0.6200, 0.7800, 0.0180, 0.4500, -0.4500 ] ,\n                      [ 0.7700, 0.9700, 0.0090, 0.4850, -0.4850 ] ,\n                      [ 0.8100, 0.9900, 0.0060, 0.4900, -0.4900 ] ,\n                      [ 0.9100, 0.9970, 0.0030, 0.4976, -0.4976 ] ,\n                      [ 1.0000, 1.0000, 0.0000, 0.5000, -0.5000 ]]),\n\n    \"cone1\":np.array([[ 0.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ] ,\n                      [ 0.0213 , 1.0000 , 0.0082 , 0.5000 , -0.5000 ] ,\n                      [ 0.0638 , 1.0000 , 0.0230 , 0.4956 , -0.4956 ] ,\n                      [ 0.1064 , 1.0000 , 0.0393 , 0.4875 , -0.4875 ] ,\n                      [ 0.1489 , 1.0000 , 0.0556 , 0.4794 , -0.4794 ] ,\n                      [ 0.1915 , 1.0000 , 0.0786 , 0.4720 , -0.4720 ] ,\n                      [ 0.2766 , 1.0000 , 0.1334 , 0.4566 , -0.4566 ] ,\n                      [ 0.3617 , 1.0000 , 0.1964 , 0.4330 , -0.4330 ] ,\n                      [ 0.4894 , 1.0000 , 0.3024 , 0.3822 , -0.3822 ] ,\n                      [ 0.6170 , 1.0000 , 0.4159 , 0.3240 , -0.3240 ] ,\n                      [ 0.7447 , 1.0000 , 0.5374 , 0.2577 , -0.2577 ] ,\n                      [ 0.8723 , 1.0000 , 0.6627 , 0.1834 , -0.1834 ] ,\n                      [ 0.8936 , 0.9963 , 0.6901 , 0.1679 , -0.1679 ] ,\n                      [ 0.9149 , 0.9881 , 0.7139 , 0.1524 , -0.1524 ] ,\n                      [ 0.9362 , 0.9800 , 0.7413 , 0.1333 , -0.1333 ] ,\n                      [ 0.9574 , 0.9652 , 0.7687 , 0.1097 , -0.1097 ] ,\n                      [ 0.9787 , 0.9533 , 0.8043 , 0.0788 , -0.0788 ] ,\n                      [ 0.9894 , 0.9377 , 0.8280 , 0.0589 , -0.0589 ] ,\n                      [ 1.0000 , 0.9103 , 0.8784 , 0.0162 , -0.0162 ]]),\n\n    \"cone2\":np.array([[ 0.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ] ,\n                      [ 0.0213 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ] ,\n                      [ 0.0638 , 0.9956 , 0.0044 , 0.4956 , -0.4956 ] ,\n                      [ 0.1064 , 0.9875 , 0.0125 , 0.4875 , -0.4875 ] ,\n                      [ 0.1489 , 0.9794 , 0.0206 , 0.4794 , -0.4794 ] ,\n                      [ 0.1915 , 0.9720 , 0.0280 , 0.4720 , -0.4720 ] ,\n                      [ 0.2766 , 0.9566 , 0.0434 , 0.4566 , -0.4566 ] ,\n                      [ 0.3617 , 0.9330 , 0.0670 , 0.4330 , -0.4330 ] ,\n                      [ 0.4894 , 0.8822 , 0.1178 , 0.3822 , -0.3822 ] ,\n                      [ 0.6170 , 0.8240 , 0.1760 , 0.3240 , -0.3240 ] ,\n                      [ 0.7447 , 0.7577 , 0.2423 , 0.2577 , -0.2577 ] ,\n                      [ 0.8723 , 0.6834 , 0.3166 , 0.1834 , -0.1834 ] ,\n                      [ 0.8936 , 0.6679 , 0.3321 , 0.1679 , -0.1679 ] ,\n                      [ 0.9149 , 0.6524 , 0.3476 , 0.1524 , -0.1524 ] ,\n                      [ 0.9362 , 0.6333 , 0.3667 , 0.1333 , -0.1333 ] ,\n                      [ 0.9574 , 0.6097 , 0.3903 , 0.1097 , -0.1097 ] ,\n                      [ 0.9787 , 0.5788 , 0.4212 , 0.0788 , -0.0788 ] ,\n                      [ 0.9894 , 0.5589 , 0.4411 , 0.0589 , -0.0589 ] ,\n                      [ 1.0000 , 0.5162 , 0.4838 , 0.0162 , -0.0162 ]]),\n\n    \"sec1\":np.array([[  0.5000000 , 0.0000000 ,  0.0000000 ] ,\n                     [  0.4903926 , 0.0975452 , -0.0975452 ] ,\n                     [  0.4619398 , 0.1913417 , -0.1913417 ] ,\n                     [  0.4157348 , 0.2777851 , -0.2777851 ] ,\n                     [  0.3535534 , 0.3535534 , -0.3535534 ] ,\n                     [  0.2777851 , 0.4157348 , -0.4157348 ] ,\n                     [  0.1913417 , 0.4619398 , -0.4619398 ] ,\n                     [  0.0975452 , 0.4903926 , -0.4903926 ] ,\n                     [  0.0000000 , 0.5000000 , -0.5000000 ] ,\n                     [- 0.0975452 , 0.4903926 , -0.4903926 ] ,\n                     [- 0.1913417 , 0.4619398 , -0.4619398 ] ,\n                     [- 0.2777851 , 0.4157348 , -0.4157348 ] ,\n                     [- 0.3535534 , 0.3535534 , -0.3535534 ] ,\n                     [- 0.4157348 , 0.2777851 , -0.2777851 ] ,\n                     [- 0.4619398 , 0.1913417 , -0.1913417 ] ,\n                     [- 0.4903926 , 0.0975452 , -0.0975452 ] ,\n                     [- 0.5000000 , 0.0000000 ,  0.0000000 ]]),\n\n    \"sec2\":np.array([[ 0.5000000 , 0.0000000 ,  0.0000000] ,\n                     [ 0.4951963 , 0.0975452 , -0.0975452] ,\n                     [ 0.4809699 , 0.1913417 , -0.1913417] ,\n                     [ 0.4578674 , 0.2777851 , -0.2777851] ,\n                     [ 0.4267767 , 0.3535534 , -0.3535534] ,\n                     [ 0.3888926 , 0.4157348 , -0.4157348] ,\n                     [ 0.3456709 , 0.4619398 , -0.4619398] ,\n                     [ 0.2987726 , 0.4903926 , -0.4903926] ,\n                     [ 0.2500000 , 0.5000000 , -0.5000000] ,\n                     [ 0.0000000 , 0.5000000 , -0.5000000] ,\n                     [-0.2500000 , 0.5000000 , -0.5000000] ,\n                     [-0.2987726 , 0.4903926 , -0.4903926] ,\n                     [-0.3456709 , 0.4619398 , -0.4619398] ,\n                     [-0.3888926 , 0.4157348 , -0.4157348] ,\n                     [-0.4267767 , 0.3535534 , -0.3535534] ,\n                     [-0.4578674 , 0.2777851 , -0.2777851] ,\n                     [-0.4809699 , 0.1913417 , -0.1913417] ,\n                     [-0.4951963 , 0.0975452 , -0.0975452] ,\n                     [-0.5000000 , 0.0000000 ,  0.0000000]])}\n\n    return [curve[n] for n in name]\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.SystemPartialTurboElectricPods","title":"SystemPartialTurboElectricPods","text":"<pre><code>SystemPartialTurboElectricPods(aircraft)\n</code></pre> <p>               Bases: <code>SystemPartialTurboElectric</code></p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/system.py</code> <pre><code>def __init__(self, aircraft):\n    super(SystemPartialTurboElectricPods, self).__init__(aircraft)\n\n    class_name = \"SystemPartialTurboElectric\"\n\n    self.chain_power_body = aircraft.get_init(class_name,\"chain_power_body\", val=0.1*init_power(aircraft))\n    self.chain_power_pod = aircraft.get_init(class_name,\"chain_power_pod\", val=0.05*init_power(aircraft))\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.SystemPartialTurboElectricPods-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.SystemPartialTurboElectricPods.eval_geometry","title":"eval_geometry","text":"<pre><code>eval_geometry()\n</code></pre> <p>Estimates the geometry of the component from the aircraft requirements and statistical design laws.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/system.py</code> <pre><code>def eval_geometry(self):\n    self.frame_origin = [0., 0., 0.]\n    self.chain_power = self.chain_power_body + 2.*self.chain_power_pod\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.SystemPartialTurboElectricPods.eval_mass","title":"eval_mass","text":"<pre><code>eval_mass()\n</code></pre> <p>Estimates the geometry of the component from the aircraft requirements and statistical design laws.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/system.py</code> <pre><code>def eval_mass(self):\n    mtow = self.aircraft.weight_cg.mtow\n    body_cg = self.aircraft.airframe.body.cg\n    wing_cg = self.aircraft.airframe.wing.cg\n    horizontal_stab_cg = self.aircraft.airframe.horizontal_stab.cg\n    vertical_stab_cg = self.aircraft.airframe.vertical_stab.cg\n    nacelle_cg = self.aircraft.airframe.nacelle.cg\n    landing_gear_cg = self.aircraft.airframe.landing_gear.cg\n    n_engine = self.aircraft.power_system.n_engine\n\n    elec_power_max = self.chain_power / self.get_power_chain_efficiency()\n\n    self.power_chain_mass = (  1./self.generator_pw_density\n                             + 1./self.rectifier_pw_density\n                             + 1./self.wiring_pw_density\n                             + 1./self.cooling_pw_density) * elec_power_max\n\n    if self.battery==\"yes\":\n        self.battery_mass = (self.lto_power * self.lto_time + self.cruise_energy) / self.battery_energy_density\n        self.power_chain_mass += self.battery_mass\n    else:\n        self.battery_mass = 0.\n\n    power_elec_cg = 0.70*nacelle_cg + 0.30*body_cg\n\n    self.mass = 0.545*mtow**0.8  + self.power_chain_mass  # global mass of all systems\n\n    self.cg =   0.40*body_cg \\\n              + 0.20*wing_cg \\\n              + 0.10*landing_gear_cg \\\n              + 0.05*horizontal_stab_cg \\\n              + 0.05*vertical_stab_cg \\\n              + 0.10*nacelle_cg \\\n              + 0.10*power_elec_cg\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.SystemPartialTurboElectricPods.get_aero_length","title":"get_aero_length","text":"<pre><code>get_aero_length()\n</code></pre> <p>The characteristic aerodynamic length of the component (used for Reynolds number estimations for example).</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_aero_length(self):\n    \"\"\"The characteristic aerodynamic length of the component (used for Reynolds number estimations for example).\"\"\"\n    return self.aero_length\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.SystemPartialTurboElectricPods.get_cg_mwe","title":"get_cg_mwe","text":"<pre><code>get_cg_mwe()\n</code></pre> <p>Returns the position of the center of gravity of the manufacturer empty aircraft</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_cg_mwe(self):\n    \"\"\"Returns the position of the center of gravity of the manufacturer empty aircraft\"\"\"\n    return self.cg\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.SystemPartialTurboElectricPods.get_cg_owe","title":"get_cg_owe","text":"<pre><code>get_cg_owe()\n</code></pre> <p>Returns the position of the center of gravity of the operational empty aircraft</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_cg_owe(self):\n    \"\"\"Returns the position of the center of gravity of the operational empty aircraft\"\"\"\n    return self.cg\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.SystemPartialTurboElectricPods.get_form_factor","title":"get_form_factor","text":"<pre><code>get_form_factor()\n</code></pre> <p>Form factor used to estimate form drag.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_form_factor(self):\n    \"\"\"Form factor used to estimate form drag.\"\"\"\n    return self.form_factor\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.SystemPartialTurboElectricPods.get_inertia_tensor","title":"get_inertia_tensor","text":"<pre><code>get_inertia_tensor()\n</code></pre> <p>returns the inertia matrix of the component, if implemented.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_inertia_tensor(self):\n    \"\"\"returns the inertia matrix of the component, if implemented.\"\"\"\n    return self.inertia_tensor\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.SystemPartialTurboElectricPods.get_mass_mwe","title":"get_mass_mwe","text":"<pre><code>get_mass_mwe()\n</code></pre> <p>Returns the Manufacturer's Weight Empty, the mass (kg) of the component</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_mass_mwe(self):\n    \"\"\"Returns the *Manufacturer's Weight Empty*, the mass (kg) of the component\"\"\"\n    return self.mass\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.SystemPartialTurboElectricPods.get_mass_owe","title":"get_mass_owe","text":"<pre><code>get_mass_owe()\n</code></pre> <p>Returns the Operating Weight Empty, the mass (kg) of the component. Can differ from MWE for some components</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_mass_owe(self):\n    \"\"\"Returns the *Operating Weight Empty*, the mass (kg) of the component. Can differ from MWE for some components\"\"\"\n    return self.mass\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.SystemPartialTurboElectricPods.get_net_wet_area","title":"get_net_wet_area","text":"<pre><code>get_net_wet_area()\n</code></pre> <p>The net wet area of the component in contact with outer airflow, 0 if the component has no aerodynamic surface.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_net_wet_area(self):\n    \"\"\"The net wet area of the component in contact with outer airflow, 0 if the component has no aerodynamic surface.\"\"\"\n    return self.net_wet_area\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.SystemPartialTurboElectricPods.get_this_shape","title":"get_this_shape","text":"<pre><code>get_this_shape(name)\n</code></pre> <p>Contour curves for 3 view drawing nose1 : modern nose (A220, A350, 787) nose3 : classical Airbus nose nose2 : symetrical nose cone1 : classical tail cone cone2 : symetrical cone section : circle</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_this_shape(self, name): # TODO: is the docstring up to date ?\n    \"\"\"Contour curves for 3 view drawing\n    nose1 : modern nose (A220, A350, 787)\n    nose3 : classical Airbus nose\n    nose2 : symetrical nose\n    cone1 : classical tail cone\n    cone2 : symetrical cone\n    section : circle\n    \"\"\"\n    curve = {\n    \"nose1\":np.array([[ 0.0000 , 0.3339 , 0.3339 , 0.0000 ,  0.0000 ] ,\n                      [ 0.0050 , 0.3848 , 0.3084 , 0.0335 , -0.0335 ] ,\n                      [ 0.0150 , 0.4253 , 0.2881 , 0.0652 , -0.0652 ] ,\n                      [ 0.0500 , 0.5033 , 0.2490 , 0.1101 , -0.1101 ] ,\n                      [ 0.1000 , 0.5811 , 0.2100 , 0.1585 , -0.1585 ] ,\n                      [ 0.1800 , 0.6808 , 0.1600 , 0.2215 , -0.2215 ] ,\n                      [ 0.2773 , 0.7704 , 0.1151 , 0.2859 , -0.2859 ] ,\n                      [ 0.4191 , 0.8562 , 0.0721 , 0.3624 , -0.3624 ] ,\n                      [ 0.5610 , 0.9198 , 0.0402 , 0.4211 , -0.4211 ] ,\n                      [ 0.7738 , 0.9816 , 0.0092 , 0.4761 , -0.4761 ] ,\n                      [ 0.9156 , 0.9962 , 0.0019 , 0.4976 , -0.4976 ] ,\n                      [ 1.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ]]),\n\n    \"nose2\":np.array([[ 0.0000 , 0.5000 ,  0.5000 , 0.0000 ,  0.0000 ] ,\n                      [ 0.0050 , 0.5335 ,  0.4665 , 0.0335 , -0.0335 ] ,\n                      [ 0.0191 , 0.5646 ,  0.4354 , 0.0646 , -0.0646 ] ,\n                      [ 0.0624 , 0.6196 ,  0.3804 , 0.1196 , -0.1196 ] ,\n                      [ 0.1355 , 0.6878 ,  0.3122 , 0.1878 , -0.1878 ] ,\n                      [ 0.1922 , 0.7297 ,  0.2703 , 0.2297 , -0.2297 ] ,\n                      [ 0.2773 , 0.7859 ,  0.2141 , 0.2859 , -0.2859 ] ,\n                      [ 0.4191 , 0.8624 ,  0.1376 , 0.3624 , -0.3624 ] ,\n                      [ 0.5610 , 0.9211 ,  0.0789 , 0.4211 , -0.4211 ] ,\n                      [ 0.7738 , 0.9761 ,  0.0239 , 0.4761 , -0.4761 ] ,\n                      [ 0.9156 , 0.9976 ,  0.0024 , 0.4976 , -0.4976 ] ,\n                      [ 1.0000 , 1.0000 ,  0.0000 , 0.5000 , -0.5000 ]]),\n\n    \"nose3\":np.array([[ 0.0000 , 0.4453 , 0.4453 , 0.0000 ,  0.0000 ] ,\n                      [ 0.0050 , 0.4733 , 0.4112 , 0.0335 , -0.0335 ] ,\n                      [ 0.0191 , 0.5098 , 0.3833 , 0.0646 , -0.0646 ] ,\n                      [ 0.0624 , 0.5718 , 0.3188 , 0.1196 , -0.1196 ] ,\n                      [ 0.1355 , 0.6278 , 0.2531 , 0.1878 , -0.1878 ] ,\n                      [ 0.1922 , 0.7263 , 0.2142 , 0.2297 , -0.2297 ] ,\n                      [ 0.2773 , 0.8127 , 0.1631 , 0.2859 , -0.2859 ] ,\n                      [ 0.4191 , 0.8906 , 0.0962 , 0.3624 , -0.3624 ] ,\n                      [ 0.5610 , 0.9392 , 0.0536 , 0.4211 , -0.4211 ] ,\n                      [ 0.7738 , 0.9818 , 0.0122 , 0.4761 , -0.4761 ] ,\n                      [ 0.9156 , 0.9976 , 0.0025 , 0.4976 , -0.4976 ] ,\n                      [ 1.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ]]),\n\n    \"nose4\":np.array([[ 0.0000, 0.3700, 0.3700, 0.0000,  0.0000 ] ,\n                      [ 0.0050, 0.4200, 0.3200, 0.0335, -0.0335 ] ,\n                      [ 0.0150, 0.4500, 0.2900, 0.0652, -0.0652 ] ,\n                      [ 0.0500, 0.5000, 0.2400, 0.1200, -0.1200 ] ,\n                      [ 0.1000, 0.5500, 0.1900, 0.1750, -0.1750 ] ,\n                      [ 0.1800, 0.6000, 0.1400, 0.2400, -0.2400 ] ,\n                      [ 0.2773, 0.6450, 0.1000, 0.3000, -0.3000 ] ,\n                      [ 0.4191, 0.7000, 0.0500, 0.3700, -0.3700 ] ,\n                      [ 0.5610, 0.7550, 0.0250, 0.4300, -0.4300 ] ,\n                      [ 0.6200, 0.7800, 0.0180, 0.4500, -0.4500 ] ,\n                      [ 0.7700, 0.9700, 0.0090, 0.4850, -0.4850 ] ,\n                      [ 0.8100, 0.9900, 0.0060, 0.4900, -0.4900 ] ,\n                      [ 0.9100, 0.9970, 0.0030, 0.4976, -0.4976 ] ,\n                      [ 1.0000, 1.0000, 0.0000, 0.5000, -0.5000 ]]),\n\n    \"cone1\":np.array([[ 0.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ] ,\n                      [ 0.0213 , 1.0000 , 0.0082 , 0.5000 , -0.5000 ] ,\n                      [ 0.0638 , 1.0000 , 0.0230 , 0.4956 , -0.4956 ] ,\n                      [ 0.1064 , 1.0000 , 0.0393 , 0.4875 , -0.4875 ] ,\n                      [ 0.1489 , 1.0000 , 0.0556 , 0.4794 , -0.4794 ] ,\n                      [ 0.1915 , 1.0000 , 0.0786 , 0.4720 , -0.4720 ] ,\n                      [ 0.2766 , 1.0000 , 0.1334 , 0.4566 , -0.4566 ] ,\n                      [ 0.3617 , 1.0000 , 0.1964 , 0.4330 , -0.4330 ] ,\n                      [ 0.4894 , 1.0000 , 0.3024 , 0.3822 , -0.3822 ] ,\n                      [ 0.6170 , 1.0000 , 0.4159 , 0.3240 , -0.3240 ] ,\n                      [ 0.7447 , 1.0000 , 0.5374 , 0.2577 , -0.2577 ] ,\n                      [ 0.8723 , 1.0000 , 0.6627 , 0.1834 , -0.1834 ] ,\n                      [ 0.8936 , 0.9963 , 0.6901 , 0.1679 , -0.1679 ] ,\n                      [ 0.9149 , 0.9881 , 0.7139 , 0.1524 , -0.1524 ] ,\n                      [ 0.9362 , 0.9800 , 0.7413 , 0.1333 , -0.1333 ] ,\n                      [ 0.9574 , 0.9652 , 0.7687 , 0.1097 , -0.1097 ] ,\n                      [ 0.9787 , 0.9533 , 0.8043 , 0.0788 , -0.0788 ] ,\n                      [ 0.9894 , 0.9377 , 0.8280 , 0.0589 , -0.0589 ] ,\n                      [ 1.0000 , 0.9103 , 0.8784 , 0.0162 , -0.0162 ]]),\n\n    \"cone2\":np.array([[ 0.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ] ,\n                      [ 0.0213 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ] ,\n                      [ 0.0638 , 0.9956 , 0.0044 , 0.4956 , -0.4956 ] ,\n                      [ 0.1064 , 0.9875 , 0.0125 , 0.4875 , -0.4875 ] ,\n                      [ 0.1489 , 0.9794 , 0.0206 , 0.4794 , -0.4794 ] ,\n                      [ 0.1915 , 0.9720 , 0.0280 , 0.4720 , -0.4720 ] ,\n                      [ 0.2766 , 0.9566 , 0.0434 , 0.4566 , -0.4566 ] ,\n                      [ 0.3617 , 0.9330 , 0.0670 , 0.4330 , -0.4330 ] ,\n                      [ 0.4894 , 0.8822 , 0.1178 , 0.3822 , -0.3822 ] ,\n                      [ 0.6170 , 0.8240 , 0.1760 , 0.3240 , -0.3240 ] ,\n                      [ 0.7447 , 0.7577 , 0.2423 , 0.2577 , -0.2577 ] ,\n                      [ 0.8723 , 0.6834 , 0.3166 , 0.1834 , -0.1834 ] ,\n                      [ 0.8936 , 0.6679 , 0.3321 , 0.1679 , -0.1679 ] ,\n                      [ 0.9149 , 0.6524 , 0.3476 , 0.1524 , -0.1524 ] ,\n                      [ 0.9362 , 0.6333 , 0.3667 , 0.1333 , -0.1333 ] ,\n                      [ 0.9574 , 0.6097 , 0.3903 , 0.1097 , -0.1097 ] ,\n                      [ 0.9787 , 0.5788 , 0.4212 , 0.0788 , -0.0788 ] ,\n                      [ 0.9894 , 0.5589 , 0.4411 , 0.0589 , -0.0589 ] ,\n                      [ 1.0000 , 0.5162 , 0.4838 , 0.0162 , -0.0162 ]]),\n\n    \"sec1\":np.array([[  0.5000000 , 0.0000000 ,  0.0000000 ] ,\n                     [  0.4903926 , 0.0975452 , -0.0975452 ] ,\n                     [  0.4619398 , 0.1913417 , -0.1913417 ] ,\n                     [  0.4157348 , 0.2777851 , -0.2777851 ] ,\n                     [  0.3535534 , 0.3535534 , -0.3535534 ] ,\n                     [  0.2777851 , 0.4157348 , -0.4157348 ] ,\n                     [  0.1913417 , 0.4619398 , -0.4619398 ] ,\n                     [  0.0975452 , 0.4903926 , -0.4903926 ] ,\n                     [  0.0000000 , 0.5000000 , -0.5000000 ] ,\n                     [- 0.0975452 , 0.4903926 , -0.4903926 ] ,\n                     [- 0.1913417 , 0.4619398 , -0.4619398 ] ,\n                     [- 0.2777851 , 0.4157348 , -0.4157348 ] ,\n                     [- 0.3535534 , 0.3535534 , -0.3535534 ] ,\n                     [- 0.4157348 , 0.2777851 , -0.2777851 ] ,\n                     [- 0.4619398 , 0.1913417 , -0.1913417 ] ,\n                     [- 0.4903926 , 0.0975452 , -0.0975452 ] ,\n                     [- 0.5000000 , 0.0000000 ,  0.0000000 ]]),\n\n    \"sec2\":np.array([[ 0.5000000 , 0.0000000 ,  0.0000000] ,\n                     [ 0.4951963 , 0.0975452 , -0.0975452] ,\n                     [ 0.4809699 , 0.1913417 , -0.1913417] ,\n                     [ 0.4578674 , 0.2777851 , -0.2777851] ,\n                     [ 0.4267767 , 0.3535534 , -0.3535534] ,\n                     [ 0.3888926 , 0.4157348 , -0.4157348] ,\n                     [ 0.3456709 , 0.4619398 , -0.4619398] ,\n                     [ 0.2987726 , 0.4903926 , -0.4903926] ,\n                     [ 0.2500000 , 0.5000000 , -0.5000000] ,\n                     [ 0.0000000 , 0.5000000 , -0.5000000] ,\n                     [-0.2500000 , 0.5000000 , -0.5000000] ,\n                     [-0.2987726 , 0.4903926 , -0.4903926] ,\n                     [-0.3456709 , 0.4619398 , -0.4619398] ,\n                     [-0.3888926 , 0.4157348 , -0.4157348] ,\n                     [-0.4267767 , 0.3535534 , -0.3535534] ,\n                     [-0.4578674 , 0.2777851 , -0.2777851] ,\n                     [-0.4809699 , 0.1913417 , -0.1913417] ,\n                     [-0.4951963 , 0.0975452 , -0.0975452] ,\n                     [-0.5000000 , 0.0000000 ,  0.0000000]])}\n\n    return [curve[n] for n in name]\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.SystemWithBattery","title":"SystemWithBattery","text":"<pre><code>SystemWithBattery(aircraft)\n</code></pre> <p>               Bases: <code>Component</code></p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/system.py</code> <pre><code>def __init__(self, aircraft):\n    super(SystemWithBattery, self).__init__(aircraft)\n\n    self.wiring_efficiency = aircraft.get_init(self,\"wiring_efficiency\")\n    self.wiring_pw_density = aircraft.get_init(self,\"wiring_pw_density\")\n\n    self.cooling_efficiency = aircraft.get_init(self,\"cooling_efficiency\")\n    self.cooling_pw_density = aircraft.get_init(self,\"cooling_pw_density\")\n\n    self.battery_density = aircraft.get_init(self,\"battery_density\")\n    self.battery_energy_density = aircraft.get_init(self,\"battery_energy_density\")\n\n    self.power_chain_efficiency = None\n\n    self.power_chain_mass = None\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.SystemWithBattery-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.SystemWithBattery.eval_geometry","title":"eval_geometry","text":"<pre><code>eval_geometry()\n</code></pre> <p>Estimates the geometry of the component from the aircraft requirements and statistical design laws.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/system.py</code> <pre><code>def eval_geometry(self):\n    self.frame_origin = [0., 0., 0.]\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.SystemWithBattery.eval_mass","title":"eval_mass","text":"<pre><code>eval_mass()\n</code></pre> <p>Estimates the geometry of the component from the aircraft requirements and statistical design laws.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/system.py</code> <pre><code>def eval_mass(self):\n    mtow = self.aircraft.weight_cg.mtow\n    body_cg = self.aircraft.airframe.body.cg\n    wing_cg = self.aircraft.airframe.wing.cg\n    horizontal_stab_cg = self.aircraft.airframe.horizontal_stab.cg\n    vertical_stab_cg = self.aircraft.airframe.vertical_stab.cg\n    nacelle_cg = self.aircraft.airframe.nacelle.cg\n    landing_gear_cg = self.aircraft.airframe.landing_gear.cg\n    n_engine = self.aircraft.power_system.n_engine\n\n    self.power_chain_efficiency =   self.wiring_efficiency * self.cooling_efficiency \\\n                                  * self.aircraft.airframe.nacelle.controller_efficiency \\\n                                  * self.aircraft.airframe.nacelle.motor_efficiency\n\n    elec_power_max = self.aircraft.power_system.reference_power / self.power_chain_efficiency\n\n    self.power_chain_mass = (1./self.wiring_pw_density + 1./self.cooling_pw_density) * elec_power_max\n\n    power_elec_cg = 0.70*nacelle_cg + 0.30*body_cg\n\n    self.mass = 0.545*mtow**0.8  + self.power_chain_mass  # global mass of all systems\n\n    self.cg =   0.40*body_cg \\\n              + 0.20*wing_cg \\\n              + 0.10*landing_gear_cg \\\n              + 0.05*horizontal_stab_cg \\\n              + 0.05*vertical_stab_cg \\\n              + 0.10*nacelle_cg \\\n              + 0.10*power_elec_cg\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.SystemWithBattery.get_aero_length","title":"get_aero_length","text":"<pre><code>get_aero_length()\n</code></pre> <p>The characteristic aerodynamic length of the component (used for Reynolds number estimations for example).</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_aero_length(self):\n    \"\"\"The characteristic aerodynamic length of the component (used for Reynolds number estimations for example).\"\"\"\n    return self.aero_length\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.SystemWithBattery.get_cg_mwe","title":"get_cg_mwe","text":"<pre><code>get_cg_mwe()\n</code></pre> <p>Returns the position of the center of gravity of the manufacturer empty aircraft</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_cg_mwe(self):\n    \"\"\"Returns the position of the center of gravity of the manufacturer empty aircraft\"\"\"\n    return self.cg\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.SystemWithBattery.get_cg_owe","title":"get_cg_owe","text":"<pre><code>get_cg_owe()\n</code></pre> <p>Returns the position of the center of gravity of the operational empty aircraft</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_cg_owe(self):\n    \"\"\"Returns the position of the center of gravity of the operational empty aircraft\"\"\"\n    return self.cg\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.SystemWithBattery.get_form_factor","title":"get_form_factor","text":"<pre><code>get_form_factor()\n</code></pre> <p>Form factor used to estimate form drag.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_form_factor(self):\n    \"\"\"Form factor used to estimate form drag.\"\"\"\n    return self.form_factor\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.SystemWithBattery.get_inertia_tensor","title":"get_inertia_tensor","text":"<pre><code>get_inertia_tensor()\n</code></pre> <p>returns the inertia matrix of the component, if implemented.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_inertia_tensor(self):\n    \"\"\"returns the inertia matrix of the component, if implemented.\"\"\"\n    return self.inertia_tensor\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.SystemWithBattery.get_mass_mwe","title":"get_mass_mwe","text":"<pre><code>get_mass_mwe()\n</code></pre> <p>Returns the Manufacturer's Weight Empty, the mass (kg) of the component</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_mass_mwe(self):\n    \"\"\"Returns the *Manufacturer's Weight Empty*, the mass (kg) of the component\"\"\"\n    return self.mass\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.SystemWithBattery.get_mass_owe","title":"get_mass_owe","text":"<pre><code>get_mass_owe()\n</code></pre> <p>Returns the Operating Weight Empty, the mass (kg) of the component. Can differ from MWE for some components</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_mass_owe(self):\n    \"\"\"Returns the *Operating Weight Empty*, the mass (kg) of the component. Can differ from MWE for some components\"\"\"\n    return self.mass\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.SystemWithBattery.get_net_wet_area","title":"get_net_wet_area","text":"<pre><code>get_net_wet_area()\n</code></pre> <p>The net wet area of the component in contact with outer airflow, 0 if the component has no aerodynamic surface.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_net_wet_area(self):\n    \"\"\"The net wet area of the component in contact with outer airflow, 0 if the component has no aerodynamic surface.\"\"\"\n    return self.net_wet_area\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.SystemWithBattery.get_this_shape","title":"get_this_shape","text":"<pre><code>get_this_shape(name)\n</code></pre> <p>Contour curves for 3 view drawing nose1 : modern nose (A220, A350, 787) nose3 : classical Airbus nose nose2 : symetrical nose cone1 : classical tail cone cone2 : symetrical cone section : circle</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_this_shape(self, name): # TODO: is the docstring up to date ?\n    \"\"\"Contour curves for 3 view drawing\n    nose1 : modern nose (A220, A350, 787)\n    nose3 : classical Airbus nose\n    nose2 : symetrical nose\n    cone1 : classical tail cone\n    cone2 : symetrical cone\n    section : circle\n    \"\"\"\n    curve = {\n    \"nose1\":np.array([[ 0.0000 , 0.3339 , 0.3339 , 0.0000 ,  0.0000 ] ,\n                      [ 0.0050 , 0.3848 , 0.3084 , 0.0335 , -0.0335 ] ,\n                      [ 0.0150 , 0.4253 , 0.2881 , 0.0652 , -0.0652 ] ,\n                      [ 0.0500 , 0.5033 , 0.2490 , 0.1101 , -0.1101 ] ,\n                      [ 0.1000 , 0.5811 , 0.2100 , 0.1585 , -0.1585 ] ,\n                      [ 0.1800 , 0.6808 , 0.1600 , 0.2215 , -0.2215 ] ,\n                      [ 0.2773 , 0.7704 , 0.1151 , 0.2859 , -0.2859 ] ,\n                      [ 0.4191 , 0.8562 , 0.0721 , 0.3624 , -0.3624 ] ,\n                      [ 0.5610 , 0.9198 , 0.0402 , 0.4211 , -0.4211 ] ,\n                      [ 0.7738 , 0.9816 , 0.0092 , 0.4761 , -0.4761 ] ,\n                      [ 0.9156 , 0.9962 , 0.0019 , 0.4976 , -0.4976 ] ,\n                      [ 1.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ]]),\n\n    \"nose2\":np.array([[ 0.0000 , 0.5000 ,  0.5000 , 0.0000 ,  0.0000 ] ,\n                      [ 0.0050 , 0.5335 ,  0.4665 , 0.0335 , -0.0335 ] ,\n                      [ 0.0191 , 0.5646 ,  0.4354 , 0.0646 , -0.0646 ] ,\n                      [ 0.0624 , 0.6196 ,  0.3804 , 0.1196 , -0.1196 ] ,\n                      [ 0.1355 , 0.6878 ,  0.3122 , 0.1878 , -0.1878 ] ,\n                      [ 0.1922 , 0.7297 ,  0.2703 , 0.2297 , -0.2297 ] ,\n                      [ 0.2773 , 0.7859 ,  0.2141 , 0.2859 , -0.2859 ] ,\n                      [ 0.4191 , 0.8624 ,  0.1376 , 0.3624 , -0.3624 ] ,\n                      [ 0.5610 , 0.9211 ,  0.0789 , 0.4211 , -0.4211 ] ,\n                      [ 0.7738 , 0.9761 ,  0.0239 , 0.4761 , -0.4761 ] ,\n                      [ 0.9156 , 0.9976 ,  0.0024 , 0.4976 , -0.4976 ] ,\n                      [ 1.0000 , 1.0000 ,  0.0000 , 0.5000 , -0.5000 ]]),\n\n    \"nose3\":np.array([[ 0.0000 , 0.4453 , 0.4453 , 0.0000 ,  0.0000 ] ,\n                      [ 0.0050 , 0.4733 , 0.4112 , 0.0335 , -0.0335 ] ,\n                      [ 0.0191 , 0.5098 , 0.3833 , 0.0646 , -0.0646 ] ,\n                      [ 0.0624 , 0.5718 , 0.3188 , 0.1196 , -0.1196 ] ,\n                      [ 0.1355 , 0.6278 , 0.2531 , 0.1878 , -0.1878 ] ,\n                      [ 0.1922 , 0.7263 , 0.2142 , 0.2297 , -0.2297 ] ,\n                      [ 0.2773 , 0.8127 , 0.1631 , 0.2859 , -0.2859 ] ,\n                      [ 0.4191 , 0.8906 , 0.0962 , 0.3624 , -0.3624 ] ,\n                      [ 0.5610 , 0.9392 , 0.0536 , 0.4211 , -0.4211 ] ,\n                      [ 0.7738 , 0.9818 , 0.0122 , 0.4761 , -0.4761 ] ,\n                      [ 0.9156 , 0.9976 , 0.0025 , 0.4976 , -0.4976 ] ,\n                      [ 1.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ]]),\n\n    \"nose4\":np.array([[ 0.0000, 0.3700, 0.3700, 0.0000,  0.0000 ] ,\n                      [ 0.0050, 0.4200, 0.3200, 0.0335, -0.0335 ] ,\n                      [ 0.0150, 0.4500, 0.2900, 0.0652, -0.0652 ] ,\n                      [ 0.0500, 0.5000, 0.2400, 0.1200, -0.1200 ] ,\n                      [ 0.1000, 0.5500, 0.1900, 0.1750, -0.1750 ] ,\n                      [ 0.1800, 0.6000, 0.1400, 0.2400, -0.2400 ] ,\n                      [ 0.2773, 0.6450, 0.1000, 0.3000, -0.3000 ] ,\n                      [ 0.4191, 0.7000, 0.0500, 0.3700, -0.3700 ] ,\n                      [ 0.5610, 0.7550, 0.0250, 0.4300, -0.4300 ] ,\n                      [ 0.6200, 0.7800, 0.0180, 0.4500, -0.4500 ] ,\n                      [ 0.7700, 0.9700, 0.0090, 0.4850, -0.4850 ] ,\n                      [ 0.8100, 0.9900, 0.0060, 0.4900, -0.4900 ] ,\n                      [ 0.9100, 0.9970, 0.0030, 0.4976, -0.4976 ] ,\n                      [ 1.0000, 1.0000, 0.0000, 0.5000, -0.5000 ]]),\n\n    \"cone1\":np.array([[ 0.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ] ,\n                      [ 0.0213 , 1.0000 , 0.0082 , 0.5000 , -0.5000 ] ,\n                      [ 0.0638 , 1.0000 , 0.0230 , 0.4956 , -0.4956 ] ,\n                      [ 0.1064 , 1.0000 , 0.0393 , 0.4875 , -0.4875 ] ,\n                      [ 0.1489 , 1.0000 , 0.0556 , 0.4794 , -0.4794 ] ,\n                      [ 0.1915 , 1.0000 , 0.0786 , 0.4720 , -0.4720 ] ,\n                      [ 0.2766 , 1.0000 , 0.1334 , 0.4566 , -0.4566 ] ,\n                      [ 0.3617 , 1.0000 , 0.1964 , 0.4330 , -0.4330 ] ,\n                      [ 0.4894 , 1.0000 , 0.3024 , 0.3822 , -0.3822 ] ,\n                      [ 0.6170 , 1.0000 , 0.4159 , 0.3240 , -0.3240 ] ,\n                      [ 0.7447 , 1.0000 , 0.5374 , 0.2577 , -0.2577 ] ,\n                      [ 0.8723 , 1.0000 , 0.6627 , 0.1834 , -0.1834 ] ,\n                      [ 0.8936 , 0.9963 , 0.6901 , 0.1679 , -0.1679 ] ,\n                      [ 0.9149 , 0.9881 , 0.7139 , 0.1524 , -0.1524 ] ,\n                      [ 0.9362 , 0.9800 , 0.7413 , 0.1333 , -0.1333 ] ,\n                      [ 0.9574 , 0.9652 , 0.7687 , 0.1097 , -0.1097 ] ,\n                      [ 0.9787 , 0.9533 , 0.8043 , 0.0788 , -0.0788 ] ,\n                      [ 0.9894 , 0.9377 , 0.8280 , 0.0589 , -0.0589 ] ,\n                      [ 1.0000 , 0.9103 , 0.8784 , 0.0162 , -0.0162 ]]),\n\n    \"cone2\":np.array([[ 0.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ] ,\n                      [ 0.0213 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ] ,\n                      [ 0.0638 , 0.9956 , 0.0044 , 0.4956 , -0.4956 ] ,\n                      [ 0.1064 , 0.9875 , 0.0125 , 0.4875 , -0.4875 ] ,\n                      [ 0.1489 , 0.9794 , 0.0206 , 0.4794 , -0.4794 ] ,\n                      [ 0.1915 , 0.9720 , 0.0280 , 0.4720 , -0.4720 ] ,\n                      [ 0.2766 , 0.9566 , 0.0434 , 0.4566 , -0.4566 ] ,\n                      [ 0.3617 , 0.9330 , 0.0670 , 0.4330 , -0.4330 ] ,\n                      [ 0.4894 , 0.8822 , 0.1178 , 0.3822 , -0.3822 ] ,\n                      [ 0.6170 , 0.8240 , 0.1760 , 0.3240 , -0.3240 ] ,\n                      [ 0.7447 , 0.7577 , 0.2423 , 0.2577 , -0.2577 ] ,\n                      [ 0.8723 , 0.6834 , 0.3166 , 0.1834 , -0.1834 ] ,\n                      [ 0.8936 , 0.6679 , 0.3321 , 0.1679 , -0.1679 ] ,\n                      [ 0.9149 , 0.6524 , 0.3476 , 0.1524 , -0.1524 ] ,\n                      [ 0.9362 , 0.6333 , 0.3667 , 0.1333 , -0.1333 ] ,\n                      [ 0.9574 , 0.6097 , 0.3903 , 0.1097 , -0.1097 ] ,\n                      [ 0.9787 , 0.5788 , 0.4212 , 0.0788 , -0.0788 ] ,\n                      [ 0.9894 , 0.5589 , 0.4411 , 0.0589 , -0.0589 ] ,\n                      [ 1.0000 , 0.5162 , 0.4838 , 0.0162 , -0.0162 ]]),\n\n    \"sec1\":np.array([[  0.5000000 , 0.0000000 ,  0.0000000 ] ,\n                     [  0.4903926 , 0.0975452 , -0.0975452 ] ,\n                     [  0.4619398 , 0.1913417 , -0.1913417 ] ,\n                     [  0.4157348 , 0.2777851 , -0.2777851 ] ,\n                     [  0.3535534 , 0.3535534 , -0.3535534 ] ,\n                     [  0.2777851 , 0.4157348 , -0.4157348 ] ,\n                     [  0.1913417 , 0.4619398 , -0.4619398 ] ,\n                     [  0.0975452 , 0.4903926 , -0.4903926 ] ,\n                     [  0.0000000 , 0.5000000 , -0.5000000 ] ,\n                     [- 0.0975452 , 0.4903926 , -0.4903926 ] ,\n                     [- 0.1913417 , 0.4619398 , -0.4619398 ] ,\n                     [- 0.2777851 , 0.4157348 , -0.4157348 ] ,\n                     [- 0.3535534 , 0.3535534 , -0.3535534 ] ,\n                     [- 0.4157348 , 0.2777851 , -0.2777851 ] ,\n                     [- 0.4619398 , 0.1913417 , -0.1913417 ] ,\n                     [- 0.4903926 , 0.0975452 , -0.0975452 ] ,\n                     [- 0.5000000 , 0.0000000 ,  0.0000000 ]]),\n\n    \"sec2\":np.array([[ 0.5000000 , 0.0000000 ,  0.0000000] ,\n                     [ 0.4951963 , 0.0975452 , -0.0975452] ,\n                     [ 0.4809699 , 0.1913417 , -0.1913417] ,\n                     [ 0.4578674 , 0.2777851 , -0.2777851] ,\n                     [ 0.4267767 , 0.3535534 , -0.3535534] ,\n                     [ 0.3888926 , 0.4157348 , -0.4157348] ,\n                     [ 0.3456709 , 0.4619398 , -0.4619398] ,\n                     [ 0.2987726 , 0.4903926 , -0.4903926] ,\n                     [ 0.2500000 , 0.5000000 , -0.5000000] ,\n                     [ 0.0000000 , 0.5000000 , -0.5000000] ,\n                     [-0.2500000 , 0.5000000 , -0.5000000] ,\n                     [-0.2987726 , 0.4903926 , -0.4903926] ,\n                     [-0.3456709 , 0.4619398 , -0.4619398] ,\n                     [-0.3888926 , 0.4157348 , -0.4157348] ,\n                     [-0.4267767 , 0.3535534 , -0.3535534] ,\n                     [-0.4578674 , 0.2777851 , -0.2777851] ,\n                     [-0.4809699 , 0.1913417 , -0.1913417] ,\n                     [-0.4951963 , 0.0975452 , -0.0975452] ,\n                     [-0.5000000 , 0.0000000 ,  0.0000000]])}\n\n    return [curve[n] for n in name]\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.SystemWithFuelCell","title":"SystemWithFuelCell","text":"<pre><code>SystemWithFuelCell(aircraft)\n</code></pre> <p>               Bases: <code>Component</code></p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/system.py</code> <pre><code>def __init__(self, aircraft):\n    super(SystemWithFuelCell, self).__init__(aircraft)\n\n    self.wiring_efficiency = aircraft.get_init(self,\"wiring_efficiency\")\n    self.wiring_pw_density = aircraft.get_init(self,\"wiring_pw_density\")\n\n    self.compressor_over_pressure = aircraft.get_init(self,\"compressor_over_pressure\")\n    self.compressor_efficiency = aircraft.get_init(self,\"compressor_efficiency\")\n    self.compressor_pw_density = aircraft.get_init(self,\"compressor_pw_density\")\n\n    self.cooling_power_index = aircraft.get_init(self,\"cooling_power_index\")\n    self.cooling_gravimetric_index = aircraft.get_init(self,\"cooling_gravimetric_index\")\n\n    self.fuel_cell_pw_density = aircraft.get_init(self,\"fuel_cell_pw_density\")\n    self.fuel_cell_efficiency = aircraft.get_init(self,\"fuel_cell_efficiency\")\n\n    self.fuel_cell_output_power_ref = None\n    self.compressor_power_ref = None\n    self.cooler_power_ref = None\n    self.heat_power_ref = None\n\n    self.power_chain_efficiency = None\n    self.global_energy_density = None\n\n    self.fuel_cell_mass = None\n    self.compressor_mass = None\n    self.cooling_mass = None\n    self.power_chain_mass = None\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.SystemWithFuelCell-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.SystemWithFuelCell.eval_geometry","title":"eval_geometry","text":"<pre><code>eval_geometry()\n</code></pre> <p>Estimates the geometry of the component from the aircraft requirements and statistical design laws.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/system.py</code> <pre><code>def eval_geometry(self):\n    reference_power = self.aircraft.power_system.reference_power\n    n_engine = self.aircraft.power_system.n_engine\n\n    self.power_chain_efficiency =   self.wiring_efficiency \\\n                                  * self.aircraft.airframe.nacelle.controller_efficiency \\\n                                  * self.aircraft.airframe.nacelle.motor_efficiency\n\n    # Fuell cell stack is designed for take off\n    disa = self.aircraft.requirement.take_off.disa\n    altp = self.aircraft.requirement.take_off.altp\n\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n\n    required_power = n_engine * reference_power / self.power_chain_efficiency\n\n    dict = self.eval_fuel_cell_power(required_power,pamb,tamb)\n\n    self.fuel_cell_output_power_ref = dict[\"fuel_cell_power\"]\n    self.compressor_power_ref = dict[\"compressor_power\"]\n    self.cooling_power_ref = dict[\"cooling_power\"]\n\n    # Heat dissipated by wiring and nacelles must be added to heat dissipated by fuell cells\n    self.heat_power_ref = dict[\"heat_power\"] + n_engine*reference_power*(1. - self.wiring_efficiency +\n                                                                         1. - self.aircraft.airframe.nacelle.controller_efficiency +\n                                                                         1. - self.aircraft.airframe.nacelle.motor_efficiency)\n\n    self.frame_origin = [0., 0., 0.]\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.SystemWithFuelCell.eval_mass","title":"eval_mass","text":"<pre><code>eval_mass()\n</code></pre> <p>Estimates the geometry of the component from the aircraft requirements and statistical design laws.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/system.py</code> <pre><code>def eval_mass(self):\n    reference_power = self.aircraft.power_system.reference_power\n\n    mtow = self.aircraft.weight_cg.mtow\n    body_cg = self.aircraft.airframe.body.cg\n    wing_cg = self.aircraft.airframe.wing.cg\n    horizontal_stab_cg = self.aircraft.airframe.horizontal_stab.cg\n    vertical_stab_cg = self.aircraft.airframe.vertical_stab.cg\n    nacelle_cg = self.aircraft.airframe.nacelle.cg\n    landing_gear_cg = self.aircraft.airframe.landing_gear.cg\n    n_engine = self.aircraft.power_system.n_engine\n\n    self.fuel_cell_mass = self.fuel_cell_output_power_ref / self.fuel_cell_pw_density\n    self.compressor_mass = self.compressor_power_ref / self.compressor_pw_density\n    self.cooling_mass = self.heat_power_ref / self.cooling_gravimetric_index\n\n    self.power_chain_mass =   self.fuel_cell_mass \\\n                            + self.compressor_mass \\\n                            + self.fuel_cell_output_power_ref/self.wiring_pw_density \\\n                            + self.cooling_mass\n\n    power_elec_cg = 0.30*nacelle_cg + 0.70*body_cg\n\n    self.mass = 0.545*mtow**0.8  + self.power_chain_mass  # global mass of all systems\n\n    self.cg =   0.40*body_cg \\\n              + 0.20*wing_cg \\\n              + 0.10*landing_gear_cg \\\n              + 0.05*horizontal_stab_cg \\\n              + 0.05*vertical_stab_cg \\\n              + 0.10*nacelle_cg \\\n              + 0.10*power_elec_cg\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.SystemWithFuelCell.get_aero_length","title":"get_aero_length","text":"<pre><code>get_aero_length()\n</code></pre> <p>The characteristic aerodynamic length of the component (used for Reynolds number estimations for example).</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_aero_length(self):\n    \"\"\"The characteristic aerodynamic length of the component (used for Reynolds number estimations for example).\"\"\"\n    return self.aero_length\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.SystemWithFuelCell.get_cg_mwe","title":"get_cg_mwe","text":"<pre><code>get_cg_mwe()\n</code></pre> <p>Returns the position of the center of gravity of the manufacturer empty aircraft</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_cg_mwe(self):\n    \"\"\"Returns the position of the center of gravity of the manufacturer empty aircraft\"\"\"\n    return self.cg\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.SystemWithFuelCell.get_cg_owe","title":"get_cg_owe","text":"<pre><code>get_cg_owe()\n</code></pre> <p>Returns the position of the center of gravity of the operational empty aircraft</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_cg_owe(self):\n    \"\"\"Returns the position of the center of gravity of the operational empty aircraft\"\"\"\n    return self.cg\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.SystemWithFuelCell.get_form_factor","title":"get_form_factor","text":"<pre><code>get_form_factor()\n</code></pre> <p>Form factor used to estimate form drag.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_form_factor(self):\n    \"\"\"Form factor used to estimate form drag.\"\"\"\n    return self.form_factor\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.SystemWithFuelCell.get_inertia_tensor","title":"get_inertia_tensor","text":"<pre><code>get_inertia_tensor()\n</code></pre> <p>returns the inertia matrix of the component, if implemented.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_inertia_tensor(self):\n    \"\"\"returns the inertia matrix of the component, if implemented.\"\"\"\n    return self.inertia_tensor\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.SystemWithFuelCell.get_mass_mwe","title":"get_mass_mwe","text":"<pre><code>get_mass_mwe()\n</code></pre> <p>Returns the Manufacturer's Weight Empty, the mass (kg) of the component</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_mass_mwe(self):\n    \"\"\"Returns the *Manufacturer's Weight Empty*, the mass (kg) of the component\"\"\"\n    return self.mass\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.SystemWithFuelCell.get_mass_owe","title":"get_mass_owe","text":"<pre><code>get_mass_owe()\n</code></pre> <p>Returns the Operating Weight Empty, the mass (kg) of the component. Can differ from MWE for some components</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_mass_owe(self):\n    \"\"\"Returns the *Operating Weight Empty*, the mass (kg) of the component. Can differ from MWE for some components\"\"\"\n    return self.mass\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.SystemWithFuelCell.get_net_wet_area","title":"get_net_wet_area","text":"<pre><code>get_net_wet_area()\n</code></pre> <p>The net wet area of the component in contact with outer airflow, 0 if the component has no aerodynamic surface.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_net_wet_area(self):\n    \"\"\"The net wet area of the component in contact with outer airflow, 0 if the component has no aerodynamic surface.\"\"\"\n    return self.net_wet_area\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.SystemWithFuelCell.get_this_shape","title":"get_this_shape","text":"<pre><code>get_this_shape(name)\n</code></pre> <p>Contour curves for 3 view drawing nose1 : modern nose (A220, A350, 787) nose3 : classical Airbus nose nose2 : symetrical nose cone1 : classical tail cone cone2 : symetrical cone section : circle</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_this_shape(self, name): # TODO: is the docstring up to date ?\n    \"\"\"Contour curves for 3 view drawing\n    nose1 : modern nose (A220, A350, 787)\n    nose3 : classical Airbus nose\n    nose2 : symetrical nose\n    cone1 : classical tail cone\n    cone2 : symetrical cone\n    section : circle\n    \"\"\"\n    curve = {\n    \"nose1\":np.array([[ 0.0000 , 0.3339 , 0.3339 , 0.0000 ,  0.0000 ] ,\n                      [ 0.0050 , 0.3848 , 0.3084 , 0.0335 , -0.0335 ] ,\n                      [ 0.0150 , 0.4253 , 0.2881 , 0.0652 , -0.0652 ] ,\n                      [ 0.0500 , 0.5033 , 0.2490 , 0.1101 , -0.1101 ] ,\n                      [ 0.1000 , 0.5811 , 0.2100 , 0.1585 , -0.1585 ] ,\n                      [ 0.1800 , 0.6808 , 0.1600 , 0.2215 , -0.2215 ] ,\n                      [ 0.2773 , 0.7704 , 0.1151 , 0.2859 , -0.2859 ] ,\n                      [ 0.4191 , 0.8562 , 0.0721 , 0.3624 , -0.3624 ] ,\n                      [ 0.5610 , 0.9198 , 0.0402 , 0.4211 , -0.4211 ] ,\n                      [ 0.7738 , 0.9816 , 0.0092 , 0.4761 , -0.4761 ] ,\n                      [ 0.9156 , 0.9962 , 0.0019 , 0.4976 , -0.4976 ] ,\n                      [ 1.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ]]),\n\n    \"nose2\":np.array([[ 0.0000 , 0.5000 ,  0.5000 , 0.0000 ,  0.0000 ] ,\n                      [ 0.0050 , 0.5335 ,  0.4665 , 0.0335 , -0.0335 ] ,\n                      [ 0.0191 , 0.5646 ,  0.4354 , 0.0646 , -0.0646 ] ,\n                      [ 0.0624 , 0.6196 ,  0.3804 , 0.1196 , -0.1196 ] ,\n                      [ 0.1355 , 0.6878 ,  0.3122 , 0.1878 , -0.1878 ] ,\n                      [ 0.1922 , 0.7297 ,  0.2703 , 0.2297 , -0.2297 ] ,\n                      [ 0.2773 , 0.7859 ,  0.2141 , 0.2859 , -0.2859 ] ,\n                      [ 0.4191 , 0.8624 ,  0.1376 , 0.3624 , -0.3624 ] ,\n                      [ 0.5610 , 0.9211 ,  0.0789 , 0.4211 , -0.4211 ] ,\n                      [ 0.7738 , 0.9761 ,  0.0239 , 0.4761 , -0.4761 ] ,\n                      [ 0.9156 , 0.9976 ,  0.0024 , 0.4976 , -0.4976 ] ,\n                      [ 1.0000 , 1.0000 ,  0.0000 , 0.5000 , -0.5000 ]]),\n\n    \"nose3\":np.array([[ 0.0000 , 0.4453 , 0.4453 , 0.0000 ,  0.0000 ] ,\n                      [ 0.0050 , 0.4733 , 0.4112 , 0.0335 , -0.0335 ] ,\n                      [ 0.0191 , 0.5098 , 0.3833 , 0.0646 , -0.0646 ] ,\n                      [ 0.0624 , 0.5718 , 0.3188 , 0.1196 , -0.1196 ] ,\n                      [ 0.1355 , 0.6278 , 0.2531 , 0.1878 , -0.1878 ] ,\n                      [ 0.1922 , 0.7263 , 0.2142 , 0.2297 , -0.2297 ] ,\n                      [ 0.2773 , 0.8127 , 0.1631 , 0.2859 , -0.2859 ] ,\n                      [ 0.4191 , 0.8906 , 0.0962 , 0.3624 , -0.3624 ] ,\n                      [ 0.5610 , 0.9392 , 0.0536 , 0.4211 , -0.4211 ] ,\n                      [ 0.7738 , 0.9818 , 0.0122 , 0.4761 , -0.4761 ] ,\n                      [ 0.9156 , 0.9976 , 0.0025 , 0.4976 , -0.4976 ] ,\n                      [ 1.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ]]),\n\n    \"nose4\":np.array([[ 0.0000, 0.3700, 0.3700, 0.0000,  0.0000 ] ,\n                      [ 0.0050, 0.4200, 0.3200, 0.0335, -0.0335 ] ,\n                      [ 0.0150, 0.4500, 0.2900, 0.0652, -0.0652 ] ,\n                      [ 0.0500, 0.5000, 0.2400, 0.1200, -0.1200 ] ,\n                      [ 0.1000, 0.5500, 0.1900, 0.1750, -0.1750 ] ,\n                      [ 0.1800, 0.6000, 0.1400, 0.2400, -0.2400 ] ,\n                      [ 0.2773, 0.6450, 0.1000, 0.3000, -0.3000 ] ,\n                      [ 0.4191, 0.7000, 0.0500, 0.3700, -0.3700 ] ,\n                      [ 0.5610, 0.7550, 0.0250, 0.4300, -0.4300 ] ,\n                      [ 0.6200, 0.7800, 0.0180, 0.4500, -0.4500 ] ,\n                      [ 0.7700, 0.9700, 0.0090, 0.4850, -0.4850 ] ,\n                      [ 0.8100, 0.9900, 0.0060, 0.4900, -0.4900 ] ,\n                      [ 0.9100, 0.9970, 0.0030, 0.4976, -0.4976 ] ,\n                      [ 1.0000, 1.0000, 0.0000, 0.5000, -0.5000 ]]),\n\n    \"cone1\":np.array([[ 0.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ] ,\n                      [ 0.0213 , 1.0000 , 0.0082 , 0.5000 , -0.5000 ] ,\n                      [ 0.0638 , 1.0000 , 0.0230 , 0.4956 , -0.4956 ] ,\n                      [ 0.1064 , 1.0000 , 0.0393 , 0.4875 , -0.4875 ] ,\n                      [ 0.1489 , 1.0000 , 0.0556 , 0.4794 , -0.4794 ] ,\n                      [ 0.1915 , 1.0000 , 0.0786 , 0.4720 , -0.4720 ] ,\n                      [ 0.2766 , 1.0000 , 0.1334 , 0.4566 , -0.4566 ] ,\n                      [ 0.3617 , 1.0000 , 0.1964 , 0.4330 , -0.4330 ] ,\n                      [ 0.4894 , 1.0000 , 0.3024 , 0.3822 , -0.3822 ] ,\n                      [ 0.6170 , 1.0000 , 0.4159 , 0.3240 , -0.3240 ] ,\n                      [ 0.7447 , 1.0000 , 0.5374 , 0.2577 , -0.2577 ] ,\n                      [ 0.8723 , 1.0000 , 0.6627 , 0.1834 , -0.1834 ] ,\n                      [ 0.8936 , 0.9963 , 0.6901 , 0.1679 , -0.1679 ] ,\n                      [ 0.9149 , 0.9881 , 0.7139 , 0.1524 , -0.1524 ] ,\n                      [ 0.9362 , 0.9800 , 0.7413 , 0.1333 , -0.1333 ] ,\n                      [ 0.9574 , 0.9652 , 0.7687 , 0.1097 , -0.1097 ] ,\n                      [ 0.9787 , 0.9533 , 0.8043 , 0.0788 , -0.0788 ] ,\n                      [ 0.9894 , 0.9377 , 0.8280 , 0.0589 , -0.0589 ] ,\n                      [ 1.0000 , 0.9103 , 0.8784 , 0.0162 , -0.0162 ]]),\n\n    \"cone2\":np.array([[ 0.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ] ,\n                      [ 0.0213 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ] ,\n                      [ 0.0638 , 0.9956 , 0.0044 , 0.4956 , -0.4956 ] ,\n                      [ 0.1064 , 0.9875 , 0.0125 , 0.4875 , -0.4875 ] ,\n                      [ 0.1489 , 0.9794 , 0.0206 , 0.4794 , -0.4794 ] ,\n                      [ 0.1915 , 0.9720 , 0.0280 , 0.4720 , -0.4720 ] ,\n                      [ 0.2766 , 0.9566 , 0.0434 , 0.4566 , -0.4566 ] ,\n                      [ 0.3617 , 0.9330 , 0.0670 , 0.4330 , -0.4330 ] ,\n                      [ 0.4894 , 0.8822 , 0.1178 , 0.3822 , -0.3822 ] ,\n                      [ 0.6170 , 0.8240 , 0.1760 , 0.3240 , -0.3240 ] ,\n                      [ 0.7447 , 0.7577 , 0.2423 , 0.2577 , -0.2577 ] ,\n                      [ 0.8723 , 0.6834 , 0.3166 , 0.1834 , -0.1834 ] ,\n                      [ 0.8936 , 0.6679 , 0.3321 , 0.1679 , -0.1679 ] ,\n                      [ 0.9149 , 0.6524 , 0.3476 , 0.1524 , -0.1524 ] ,\n                      [ 0.9362 , 0.6333 , 0.3667 , 0.1333 , -0.1333 ] ,\n                      [ 0.9574 , 0.6097 , 0.3903 , 0.1097 , -0.1097 ] ,\n                      [ 0.9787 , 0.5788 , 0.4212 , 0.0788 , -0.0788 ] ,\n                      [ 0.9894 , 0.5589 , 0.4411 , 0.0589 , -0.0589 ] ,\n                      [ 1.0000 , 0.5162 , 0.4838 , 0.0162 , -0.0162 ]]),\n\n    \"sec1\":np.array([[  0.5000000 , 0.0000000 ,  0.0000000 ] ,\n                     [  0.4903926 , 0.0975452 , -0.0975452 ] ,\n                     [  0.4619398 , 0.1913417 , -0.1913417 ] ,\n                     [  0.4157348 , 0.2777851 , -0.2777851 ] ,\n                     [  0.3535534 , 0.3535534 , -0.3535534 ] ,\n                     [  0.2777851 , 0.4157348 , -0.4157348 ] ,\n                     [  0.1913417 , 0.4619398 , -0.4619398 ] ,\n                     [  0.0975452 , 0.4903926 , -0.4903926 ] ,\n                     [  0.0000000 , 0.5000000 , -0.5000000 ] ,\n                     [- 0.0975452 , 0.4903926 , -0.4903926 ] ,\n                     [- 0.1913417 , 0.4619398 , -0.4619398 ] ,\n                     [- 0.2777851 , 0.4157348 , -0.4157348 ] ,\n                     [- 0.3535534 , 0.3535534 , -0.3535534 ] ,\n                     [- 0.4157348 , 0.2777851 , -0.2777851 ] ,\n                     [- 0.4619398 , 0.1913417 , -0.1913417 ] ,\n                     [- 0.4903926 , 0.0975452 , -0.0975452 ] ,\n                     [- 0.5000000 , 0.0000000 ,  0.0000000 ]]),\n\n    \"sec2\":np.array([[ 0.5000000 , 0.0000000 ,  0.0000000] ,\n                     [ 0.4951963 , 0.0975452 , -0.0975452] ,\n                     [ 0.4809699 , 0.1913417 , -0.1913417] ,\n                     [ 0.4578674 , 0.2777851 , -0.2777851] ,\n                     [ 0.4267767 , 0.3535534 , -0.3535534] ,\n                     [ 0.3888926 , 0.4157348 , -0.4157348] ,\n                     [ 0.3456709 , 0.4619398 , -0.4619398] ,\n                     [ 0.2987726 , 0.4903926 , -0.4903926] ,\n                     [ 0.2500000 , 0.5000000 , -0.5000000] ,\n                     [ 0.0000000 , 0.5000000 , -0.5000000] ,\n                     [-0.2500000 , 0.5000000 , -0.5000000] ,\n                     [-0.2987726 , 0.4903926 , -0.4903926] ,\n                     [-0.3456709 , 0.4619398 , -0.4619398] ,\n                     [-0.3888926 , 0.4157348 , -0.4157348] ,\n                     [-0.4267767 , 0.3535534 , -0.3535534] ,\n                     [-0.4578674 , 0.2777851 , -0.2777851] ,\n                     [-0.4809699 , 0.1913417 , -0.1913417] ,\n                     [-0.4951963 , 0.0975452 , -0.0975452] ,\n                     [-0.5000000 , 0.0000000 ,  0.0000000]])}\n\n    return [curve[n] for n in name]\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.SystemWithLaplaceFuelCell","title":"SystemWithLaplaceFuelCell","text":"<pre><code>SystemWithLaplaceFuelCell(aircraft)\n</code></pre> <p>               Bases: <code>Component</code></p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/system.py</code> <pre><code>def __init__(self, aircraft):\n    super(SystemWithLaplaceFuelCell, self).__init__(aircraft)\n\n    self.wiring_efficiency = aircraft.get_init(self,\"wiring_efficiency\")\n    self.wiring_pw_density = aircraft.get_init(self,\"wiring_pw_density\")\n\n\n\n\n\n    self.fuel_cell_output_power_ref = None\n    self.compressor_power_ref = None\n    self.cooler_power_ref = None\n    self.heat_power_ref = None\n\n    self.fuel_cell_system_mass = None\n    self.cooling_mass = None\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.SystemWithLaplaceFuelCell-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.SystemWithLaplaceFuelCell.eval_geometry","title":"eval_geometry","text":"<pre><code>eval_geometry()\n</code></pre> <p>Estimates the geometry of the component from the aircraft requirements and statistical design laws.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/system.py</code> <pre><code>def eval_geometry(self):\n    reference_power = self.aircraft.power_system.reference_power\n    n_engine = self.aircraft.power_system.n_engine\n\n    self.power_chain_efficiency =   self.wiring_efficiency \\\n                                  * self.aircraft.airframe.nacelle.controller_efficiency \\\n                                  * self.aircraft.airframe.nacelle.motor_efficiency\n\n    required_power = n_engine * reference_power / self.power_chain_efficiency\n\n    # Fuell cell stack is designed for cruise\n    disa = self.aircraft.requirement.cruise_disa\n    altp = self.aircraft.requirement.cruise_altp\n    mach = self.aircraft.requirement.cruise_mach\n    mass = self.ktow*self.aircraft.weight_cg.mtow\n\n    pamb,tamb,tstd,dtodz = earth.atmosphere(altp, disa)\n\n    dict = self.eval_fuel_cell_power(required_power,pamb,tamb)\n\n    self.fuel_cell_output_power_ref = dict[\"fuel_cell_power\"]\n    self.compressor_power_ref = dict[\"compressor_power\"]\n    self.cooling_power_ref = dict[\"cooling_power\"]\n\n    # Heat dissipated by wiring and nacelles must be added to heat dissipated by fuell cells\n    self.heat_power_ref = dict[\"heat_power\"] + n_engine*reference_power*(1. - self.wiring_efficiency +\n                                                                         1. - self.aircraft.airframe.nacelle.controller_efficiency +\n                                                                         1. - self.aircraft.airframe.nacelle.motor_efficiency)\n\n    self.frame_origin = [0., 0., 0.]\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.SystemWithLaplaceFuelCell.eval_mass","title":"eval_mass","text":"<pre><code>eval_mass()\n</code></pre> <p>Estimates the geometry of the component from the aircraft requirements and statistical design laws.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/system.py</code> <pre><code>def eval_mass(self):\n    reference_power = self.aircraft.power_system.reference_power\n\n    mtow = self.aircraft.weight_cg.mtow\n    body_cg = self.aircraft.airframe.body.cg\n    wing_cg = self.aircraft.airframe.wing.cg\n    horizontal_stab_cg = self.aircraft.airframe.horizontal_stab.cg\n    vertical_stab_cg = self.aircraft.airframe.vertical_stab.cg\n    nacelle_cg = self.aircraft.airframe.nacelle.cg\n    landing_gear_cg = self.aircraft.airframe.landing_gear.cg\n    n_engine = self.aircraft.power_system.n_engine\n\n    # self.fuel_cell_mass =\n    # self.compressor_mass =\n    # self.cooling_mass =\n    #\n    # self.power_chain_mass =\n\n    power_elec_cg = 0.30*nacelle_cg + 0.70*body_cg\n\n    self.mass = 0.545*mtow**0.8  + self.power_chain_mass  # global mass of all systems\n\n    self.cg =   0.40*body_cg \\\n              + 0.20*wing_cg \\\n              + 0.10*landing_gear_cg \\\n              + 0.05*horizontal_stab_cg \\\n              + 0.05*vertical_stab_cg \\\n              + 0.10*nacelle_cg \\\n              + 0.10*power_elec_cg\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.SystemWithLaplaceFuelCell.get_aero_length","title":"get_aero_length","text":"<pre><code>get_aero_length()\n</code></pre> <p>The characteristic aerodynamic length of the component (used for Reynolds number estimations for example).</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_aero_length(self):\n    \"\"\"The characteristic aerodynamic length of the component (used for Reynolds number estimations for example).\"\"\"\n    return self.aero_length\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.SystemWithLaplaceFuelCell.get_cg_mwe","title":"get_cg_mwe","text":"<pre><code>get_cg_mwe()\n</code></pre> <p>Returns the position of the center of gravity of the manufacturer empty aircraft</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_cg_mwe(self):\n    \"\"\"Returns the position of the center of gravity of the manufacturer empty aircraft\"\"\"\n    return self.cg\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.SystemWithLaplaceFuelCell.get_cg_owe","title":"get_cg_owe","text":"<pre><code>get_cg_owe()\n</code></pre> <p>Returns the position of the center of gravity of the operational empty aircraft</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_cg_owe(self):\n    \"\"\"Returns the position of the center of gravity of the operational empty aircraft\"\"\"\n    return self.cg\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.SystemWithLaplaceFuelCell.get_form_factor","title":"get_form_factor","text":"<pre><code>get_form_factor()\n</code></pre> <p>Form factor used to estimate form drag.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_form_factor(self):\n    \"\"\"Form factor used to estimate form drag.\"\"\"\n    return self.form_factor\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.SystemWithLaplaceFuelCell.get_inertia_tensor","title":"get_inertia_tensor","text":"<pre><code>get_inertia_tensor()\n</code></pre> <p>returns the inertia matrix of the component, if implemented.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_inertia_tensor(self):\n    \"\"\"returns the inertia matrix of the component, if implemented.\"\"\"\n    return self.inertia_tensor\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.SystemWithLaplaceFuelCell.get_mass_mwe","title":"get_mass_mwe","text":"<pre><code>get_mass_mwe()\n</code></pre> <p>Returns the Manufacturer's Weight Empty, the mass (kg) of the component</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_mass_mwe(self):\n    \"\"\"Returns the *Manufacturer's Weight Empty*, the mass (kg) of the component\"\"\"\n    return self.mass\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.SystemWithLaplaceFuelCell.get_mass_owe","title":"get_mass_owe","text":"<pre><code>get_mass_owe()\n</code></pre> <p>Returns the Operating Weight Empty, the mass (kg) of the component. Can differ from MWE for some components</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_mass_owe(self):\n    \"\"\"Returns the *Operating Weight Empty*, the mass (kg) of the component. Can differ from MWE for some components\"\"\"\n    return self.mass\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.SystemWithLaplaceFuelCell.get_net_wet_area","title":"get_net_wet_area","text":"<pre><code>get_net_wet_area()\n</code></pre> <p>The net wet area of the component in contact with outer airflow, 0 if the component has no aerodynamic surface.</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_net_wet_area(self):\n    \"\"\"The net wet area of the component in contact with outer airflow, 0 if the component has no aerodynamic surface.\"\"\"\n    return self.net_wet_area\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/airframe/system/#lh2pac.marilib.aircraft.airframe.system.SystemWithLaplaceFuelCell.get_this_shape","title":"get_this_shape","text":"<pre><code>get_this_shape(name)\n</code></pre> <p>Contour curves for 3 view drawing nose1 : modern nose (A220, A350, 787) nose3 : classical Airbus nose nose2 : symetrical nose cone1 : classical tail cone cone2 : symetrical cone section : circle</p> Source code in <code>src/lh2pac/marilib/aircraft/airframe/component.py</code> <pre><code>def get_this_shape(self, name): # TODO: is the docstring up to date ?\n    \"\"\"Contour curves for 3 view drawing\n    nose1 : modern nose (A220, A350, 787)\n    nose3 : classical Airbus nose\n    nose2 : symetrical nose\n    cone1 : classical tail cone\n    cone2 : symetrical cone\n    section : circle\n    \"\"\"\n    curve = {\n    \"nose1\":np.array([[ 0.0000 , 0.3339 , 0.3339 , 0.0000 ,  0.0000 ] ,\n                      [ 0.0050 , 0.3848 , 0.3084 , 0.0335 , -0.0335 ] ,\n                      [ 0.0150 , 0.4253 , 0.2881 , 0.0652 , -0.0652 ] ,\n                      [ 0.0500 , 0.5033 , 0.2490 , 0.1101 , -0.1101 ] ,\n                      [ 0.1000 , 0.5811 , 0.2100 , 0.1585 , -0.1585 ] ,\n                      [ 0.1800 , 0.6808 , 0.1600 , 0.2215 , -0.2215 ] ,\n                      [ 0.2773 , 0.7704 , 0.1151 , 0.2859 , -0.2859 ] ,\n                      [ 0.4191 , 0.8562 , 0.0721 , 0.3624 , -0.3624 ] ,\n                      [ 0.5610 , 0.9198 , 0.0402 , 0.4211 , -0.4211 ] ,\n                      [ 0.7738 , 0.9816 , 0.0092 , 0.4761 , -0.4761 ] ,\n                      [ 0.9156 , 0.9962 , 0.0019 , 0.4976 , -0.4976 ] ,\n                      [ 1.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ]]),\n\n    \"nose2\":np.array([[ 0.0000 , 0.5000 ,  0.5000 , 0.0000 ,  0.0000 ] ,\n                      [ 0.0050 , 0.5335 ,  0.4665 , 0.0335 , -0.0335 ] ,\n                      [ 0.0191 , 0.5646 ,  0.4354 , 0.0646 , -0.0646 ] ,\n                      [ 0.0624 , 0.6196 ,  0.3804 , 0.1196 , -0.1196 ] ,\n                      [ 0.1355 , 0.6878 ,  0.3122 , 0.1878 , -0.1878 ] ,\n                      [ 0.1922 , 0.7297 ,  0.2703 , 0.2297 , -0.2297 ] ,\n                      [ 0.2773 , 0.7859 ,  0.2141 , 0.2859 , -0.2859 ] ,\n                      [ 0.4191 , 0.8624 ,  0.1376 , 0.3624 , -0.3624 ] ,\n                      [ 0.5610 , 0.9211 ,  0.0789 , 0.4211 , -0.4211 ] ,\n                      [ 0.7738 , 0.9761 ,  0.0239 , 0.4761 , -0.4761 ] ,\n                      [ 0.9156 , 0.9976 ,  0.0024 , 0.4976 , -0.4976 ] ,\n                      [ 1.0000 , 1.0000 ,  0.0000 , 0.5000 , -0.5000 ]]),\n\n    \"nose3\":np.array([[ 0.0000 , 0.4453 , 0.4453 , 0.0000 ,  0.0000 ] ,\n                      [ 0.0050 , 0.4733 , 0.4112 , 0.0335 , -0.0335 ] ,\n                      [ 0.0191 , 0.5098 , 0.3833 , 0.0646 , -0.0646 ] ,\n                      [ 0.0624 , 0.5718 , 0.3188 , 0.1196 , -0.1196 ] ,\n                      [ 0.1355 , 0.6278 , 0.2531 , 0.1878 , -0.1878 ] ,\n                      [ 0.1922 , 0.7263 , 0.2142 , 0.2297 , -0.2297 ] ,\n                      [ 0.2773 , 0.8127 , 0.1631 , 0.2859 , -0.2859 ] ,\n                      [ 0.4191 , 0.8906 , 0.0962 , 0.3624 , -0.3624 ] ,\n                      [ 0.5610 , 0.9392 , 0.0536 , 0.4211 , -0.4211 ] ,\n                      [ 0.7738 , 0.9818 , 0.0122 , 0.4761 , -0.4761 ] ,\n                      [ 0.9156 , 0.9976 , 0.0025 , 0.4976 , -0.4976 ] ,\n                      [ 1.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ]]),\n\n    \"nose4\":np.array([[ 0.0000, 0.3700, 0.3700, 0.0000,  0.0000 ] ,\n                      [ 0.0050, 0.4200, 0.3200, 0.0335, -0.0335 ] ,\n                      [ 0.0150, 0.4500, 0.2900, 0.0652, -0.0652 ] ,\n                      [ 0.0500, 0.5000, 0.2400, 0.1200, -0.1200 ] ,\n                      [ 0.1000, 0.5500, 0.1900, 0.1750, -0.1750 ] ,\n                      [ 0.1800, 0.6000, 0.1400, 0.2400, -0.2400 ] ,\n                      [ 0.2773, 0.6450, 0.1000, 0.3000, -0.3000 ] ,\n                      [ 0.4191, 0.7000, 0.0500, 0.3700, -0.3700 ] ,\n                      [ 0.5610, 0.7550, 0.0250, 0.4300, -0.4300 ] ,\n                      [ 0.6200, 0.7800, 0.0180, 0.4500, -0.4500 ] ,\n                      [ 0.7700, 0.9700, 0.0090, 0.4850, -0.4850 ] ,\n                      [ 0.8100, 0.9900, 0.0060, 0.4900, -0.4900 ] ,\n                      [ 0.9100, 0.9970, 0.0030, 0.4976, -0.4976 ] ,\n                      [ 1.0000, 1.0000, 0.0000, 0.5000, -0.5000 ]]),\n\n    \"cone1\":np.array([[ 0.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ] ,\n                      [ 0.0213 , 1.0000 , 0.0082 , 0.5000 , -0.5000 ] ,\n                      [ 0.0638 , 1.0000 , 0.0230 , 0.4956 , -0.4956 ] ,\n                      [ 0.1064 , 1.0000 , 0.0393 , 0.4875 , -0.4875 ] ,\n                      [ 0.1489 , 1.0000 , 0.0556 , 0.4794 , -0.4794 ] ,\n                      [ 0.1915 , 1.0000 , 0.0786 , 0.4720 , -0.4720 ] ,\n                      [ 0.2766 , 1.0000 , 0.1334 , 0.4566 , -0.4566 ] ,\n                      [ 0.3617 , 1.0000 , 0.1964 , 0.4330 , -0.4330 ] ,\n                      [ 0.4894 , 1.0000 , 0.3024 , 0.3822 , -0.3822 ] ,\n                      [ 0.6170 , 1.0000 , 0.4159 , 0.3240 , -0.3240 ] ,\n                      [ 0.7447 , 1.0000 , 0.5374 , 0.2577 , -0.2577 ] ,\n                      [ 0.8723 , 1.0000 , 0.6627 , 0.1834 , -0.1834 ] ,\n                      [ 0.8936 , 0.9963 , 0.6901 , 0.1679 , -0.1679 ] ,\n                      [ 0.9149 , 0.9881 , 0.7139 , 0.1524 , -0.1524 ] ,\n                      [ 0.9362 , 0.9800 , 0.7413 , 0.1333 , -0.1333 ] ,\n                      [ 0.9574 , 0.9652 , 0.7687 , 0.1097 , -0.1097 ] ,\n                      [ 0.9787 , 0.9533 , 0.8043 , 0.0788 , -0.0788 ] ,\n                      [ 0.9894 , 0.9377 , 0.8280 , 0.0589 , -0.0589 ] ,\n                      [ 1.0000 , 0.9103 , 0.8784 , 0.0162 , -0.0162 ]]),\n\n    \"cone2\":np.array([[ 0.0000 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ] ,\n                      [ 0.0213 , 1.0000 , 0.0000 , 0.5000 , -0.5000 ] ,\n                      [ 0.0638 , 0.9956 , 0.0044 , 0.4956 , -0.4956 ] ,\n                      [ 0.1064 , 0.9875 , 0.0125 , 0.4875 , -0.4875 ] ,\n                      [ 0.1489 , 0.9794 , 0.0206 , 0.4794 , -0.4794 ] ,\n                      [ 0.1915 , 0.9720 , 0.0280 , 0.4720 , -0.4720 ] ,\n                      [ 0.2766 , 0.9566 , 0.0434 , 0.4566 , -0.4566 ] ,\n                      [ 0.3617 , 0.9330 , 0.0670 , 0.4330 , -0.4330 ] ,\n                      [ 0.4894 , 0.8822 , 0.1178 , 0.3822 , -0.3822 ] ,\n                      [ 0.6170 , 0.8240 , 0.1760 , 0.3240 , -0.3240 ] ,\n                      [ 0.7447 , 0.7577 , 0.2423 , 0.2577 , -0.2577 ] ,\n                      [ 0.8723 , 0.6834 , 0.3166 , 0.1834 , -0.1834 ] ,\n                      [ 0.8936 , 0.6679 , 0.3321 , 0.1679 , -0.1679 ] ,\n                      [ 0.9149 , 0.6524 , 0.3476 , 0.1524 , -0.1524 ] ,\n                      [ 0.9362 , 0.6333 , 0.3667 , 0.1333 , -0.1333 ] ,\n                      [ 0.9574 , 0.6097 , 0.3903 , 0.1097 , -0.1097 ] ,\n                      [ 0.9787 , 0.5788 , 0.4212 , 0.0788 , -0.0788 ] ,\n                      [ 0.9894 , 0.5589 , 0.4411 , 0.0589 , -0.0589 ] ,\n                      [ 1.0000 , 0.5162 , 0.4838 , 0.0162 , -0.0162 ]]),\n\n    \"sec1\":np.array([[  0.5000000 , 0.0000000 ,  0.0000000 ] ,\n                     [  0.4903926 , 0.0975452 , -0.0975452 ] ,\n                     [  0.4619398 , 0.1913417 , -0.1913417 ] ,\n                     [  0.4157348 , 0.2777851 , -0.2777851 ] ,\n                     [  0.3535534 , 0.3535534 , -0.3535534 ] ,\n                     [  0.2777851 , 0.4157348 , -0.4157348 ] ,\n                     [  0.1913417 , 0.4619398 , -0.4619398 ] ,\n                     [  0.0975452 , 0.4903926 , -0.4903926 ] ,\n                     [  0.0000000 , 0.5000000 , -0.5000000 ] ,\n                     [- 0.0975452 , 0.4903926 , -0.4903926 ] ,\n                     [- 0.1913417 , 0.4619398 , -0.4619398 ] ,\n                     [- 0.2777851 , 0.4157348 , -0.4157348 ] ,\n                     [- 0.3535534 , 0.3535534 , -0.3535534 ] ,\n                     [- 0.4157348 , 0.2777851 , -0.2777851 ] ,\n                     [- 0.4619398 , 0.1913417 , -0.1913417 ] ,\n                     [- 0.4903926 , 0.0975452 , -0.0975452 ] ,\n                     [- 0.5000000 , 0.0000000 ,  0.0000000 ]]),\n\n    \"sec2\":np.array([[ 0.5000000 , 0.0000000 ,  0.0000000] ,\n                     [ 0.4951963 , 0.0975452 , -0.0975452] ,\n                     [ 0.4809699 , 0.1913417 , -0.1913417] ,\n                     [ 0.4578674 , 0.2777851 , -0.2777851] ,\n                     [ 0.4267767 , 0.3535534 , -0.3535534] ,\n                     [ 0.3888926 , 0.4157348 , -0.4157348] ,\n                     [ 0.3456709 , 0.4619398 , -0.4619398] ,\n                     [ 0.2987726 , 0.4903926 , -0.4903926] ,\n                     [ 0.2500000 , 0.5000000 , -0.5000000] ,\n                     [ 0.0000000 , 0.5000000 , -0.5000000] ,\n                     [-0.2500000 , 0.5000000 , -0.5000000] ,\n                     [-0.2987726 , 0.4903926 , -0.4903926] ,\n                     [-0.3456709 , 0.4619398 , -0.4619398] ,\n                     [-0.3888926 , 0.4157348 , -0.4157348] ,\n                     [-0.4267767 , 0.3535534 , -0.3535534] ,\n                     [-0.4578674 , 0.2777851 , -0.2777851] ,\n                     [-0.4809699 , 0.1913417 , -0.1913417] ,\n                     [-0.4951963 , 0.0975452 , -0.0975452] ,\n                     [-0.5000000 , 0.0000000 ,  0.0000000]])}\n\n    return [curve[n] for n in name]\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/design/","title":"Design","text":""},{"location":"reference/lh2pac/marilib/aircraft/design/#lh2pac.marilib.aircraft.design","title":"design","text":""},{"location":"reference/lh2pac/marilib/aircraft/design/process/","title":"Process","text":""},{"location":"reference/lh2pac/marilib/aircraft/design/process/#lh2pac.marilib.aircraft.design.process","title":"process","text":"<p>:author: Conceptual Airplane Design &amp; Operations (CADO team)          Nicolas PETEILH, Pascal ROCHES, Nicolas MONROLIN, Thierry DRUOT          Aircraft &amp; Systems, Air Transport Departement, ENAC</p> <p>The main design processes are defined in this module:</p> <ul> <li>Multidisciplanary Design Analysis</li> <li>Mulitdisciplinary Design Feasible</li> </ul> <p>Allow you to draw design space charts.</p> <p>.. todo: improve documentation</p>"},{"location":"reference/lh2pac/marilib/aircraft/design/process/#lh2pac.marilib.aircraft.design.process-classes","title":"Classes","text":""},{"location":"reference/lh2pac/marilib/aircraft/design/process/#lh2pac.marilib.aircraft.design.process.Optimizer","title":"Optimizer","text":"<pre><code>Optimizer()\n</code></pre> <p>               Bases: <code>object</code></p> <p>A container for the optimization procedure. The optimizer will prevent any optimization routine to run twice the MDA at the same point. The computed_points dictionnary has the foolowing keys and values: :</p> <pre><code>* key: the position of the computed point as a key \"(x,y)\" a\n* value : the value of the criterion and contraints list.\n</code></pre> Source code in <code>src/lh2pac/marilib/aircraft/design/process.py</code> <pre><code>def __init__(self):\n    self.computed_points = {}  # store the points that are already evaluated (to avoid running mda twice during optimization)\n    self.check_for_doublon = True # should the optimizer check if points were already been computed before calling eval_optim_data\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/design/process/#lh2pac.marilib.aircraft.design.process.Optimizer-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/aircraft/design/process/#lh2pac.marilib.aircraft.design.process.Optimizer.custom_descent_search","title":"custom_descent_search","text":"<pre><code>custom_descent_search(\n    cost_fun, x0, delta=0.02, delta_end=0.005, pen=1000000.0\n)\n</code></pre> <p>A custom minimization method limited to 2 parameters problems (x1,x2).     This method is based on mximum descent algorythm.</p> <pre><code>    1. Evaluate cost function (with constraint penalisation) on 3 points.\n\n(-1,0)    (0,0)         + : computed points\n   +-------+\n           |\n           |\n           +\n         (0,-1)\n\n    2. Compute the 2D gradient of the cost function (taking into account penalized constraints).\n    3. Build a linear approximation of the cost function based on the the gradient.\n    4. Extrapolate the cost function on the gradient direction step by step until cost increases\n    5. Reduce the step size 'delta' by a factor 2 and restart from step 1.\n</code></pre> <p>The algorythm ends when the step is small enough. More precisely when the relative step delta (percentage of initial starting point x0) is smaller than delta_end.</p> <pre><code>:param cost_fun: a function that returns the criterion to be minimized and the constraints value for given\n                values of the parameters. In MARILib, cost and constraints are evaluated simultaneously.\n:param x0: a list of the two initial parameter values (x1,x2).\n:param delta: the relative step for initial pattern size : 0&lt; delta &lt; 1.\n    :Example: If delta = 0.05, the pattern size will be 5% of the magnitude of x0 values.\n:param delta_end: the relative step for for algorythm ending.\n:param pen: penalisation factor to multiply the constraint value. The constraint is negative when unsatisfied.\n    :Example: This algorythm minimizes the modified cost function : criterion + pen*constraint\n</code></pre> Source code in <code>src/lh2pac/marilib/aircraft/design/process.py</code> <pre><code>def custom_descent_search(self,cost_fun, x0, delta=0.02, delta_end=0.005, pen=1e6):\n    \"\"\" A custom minimization method limited to 2 parameters problems (x1,x2).\n    This method is based on mximum descent algorythm.\n\n        1. Evaluate cost function (with constraint penalisation) on 3 points.\n\n    (-1,0)    (0,0)         + : computed points\n       +-------+\n               |\n               |\n               +\n             (0,-1)\n\n        2. Compute the 2D gradient of the cost function (taking into account penalized constraints).\n        3. Build a linear approximation of the cost function based on the the gradient.\n        4. Extrapolate the cost function on the gradient direction step by step until cost increases\n        5. Reduce the step size 'delta' by a factor 2 and restart from step 1.\n\nThe algorythm ends when the step is small enough.\nMore precisely when the relative step delta (percentage of initial starting point x0) is smaller than delta_end.\n\n    :param cost_fun: a function that returns the criterion to be minimized and the constraints value for given\n                    values of the parameters. In MARILib, cost and constraints are evaluated simultaneously.\n    :param x0: a list of the two initial parameter values (x1,x2).\n    :param delta: the relative step for initial pattern size : 0&lt; delta &lt; 1.\n        :Example: If delta = 0.05, the pattern size will be 5% of the magnitude of x0 values.\n    :param delta_end: the relative step for for algorythm ending.\n    :param pen: penalisation factor to multiply the constraint value. The constraint is negative when unsatisfied.\n        :Example: This algorythm minimizes the modified cost function : criterion + pen*constraint\n    \"\"\"\n    points = {}  # initialize the list of computed points (delta unit coordinate)\n\n    print(\"x0 \", x0)\n    if not isinstance(x0, type(np.array)):\n        x0 = np.array(list(x0))\n\n    def custom_cost(x):\n        crt, cst = cost_fun(x)\n        return crt - sum([c*pen for c in cst if c&lt;0])\n\n    xy = np.array([0, 0])  # set initial value in delta coordinates\n    xy_ref = xy\n    points[(0, 0)] = custom_cost(x0)  # put initial point in the points dict\n\n    scale = delta * x0  # one unit displacement of xy corresponds to delta0*x0 displacement in real x\n    k = 0\n    while delta &gt;= delta_end:\n        print(\"Iter %d, delta = %f\" % (k, delta))\n        current_points = []\n        for step in [(0, 0), (-1, 0), (0, -1)]:\n            xy = xy_ref + np.array(step) / 2 ** k  # move current location by a step\n            x = x0 + xy * scale\n            # print(x)\n            if tuple(xy) not in points.keys():  # this value is not already computed\n                crt = custom_cost(x)\n                points[tuple(xy)] = crt\n                current_points.append([xy[0], xy[1], crt])\n            else:\n                current_points.append([xy[0], xy[1], points[tuple(xy)]])\n\n        # Find the equation of the plan passing through the 3 points\n        zgradient, extrapolator = self.update_interpolator_and_gradient(current_points)\n        xy = xy_ref\n        crt_old = points[tuple(xy)] + 1  # set initialy criter_old &gt; criter\n        crt = points[tuple(xy)]\n        while crt &lt; crt_old:  # descent search\n            crt_old = crt\n            xy_ref = xy\n            xy = xy - zgradient / 2 ** k\n            x = x0 + xy * scale\n            crt = custom_cost(x)\n            points[tuple(xy)] = crt\n            print(\"\\t\", x)\n\n        k += 1\n        delta = delta / 2.\n\n    res = \"---- Custom descent search ----\\n&gt;Number of evaluations : %d\" %len(points)\n    return res\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/design/process/#lh2pac.marilib.aircraft.design.process.Optimizer.eval_optim_data","title":"eval_optim_data","text":"<pre><code>eval_optim_data(\n    x_in, aircraft, var, cst, cst_mag, crt, crt_mag\n)\n</code></pre> <p>Compute criterion and constraints.</p> Source code in <code>src/lh2pac/marilib/aircraft/design/process.py</code> <pre><code>def eval_optim_data(self,x_in,aircraft,var,cst,cst_mag,crt,crt_mag):\n    \"\"\"Compute criterion and constraints.\n    \"\"\"\n    for k, key in enumerate(var):  # Put optimization variables in aircraft object\n        exec(key + \" = x_in[k]\")\n\n    mda(aircraft)  # Run MDA\n\n    constraint = np.zeros(len(cst))\n    for k, key in enumerate(cst):  # put optimization variables in aircraft object\n        constraint[k] = eval(key) / eval(cst_mag[k])\n\n    criterion = eval(crt) / crt_mag\n\n    self.computed_points[tuple(x_in)] = [criterion, constraint]\n\n    return criterion,constraint\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/design/process/#lh2pac.marilib.aircraft.design.process.Optimizer.eval_optim_data_checked","title":"eval_optim_data_checked","text":"<pre><code>eval_optim_data_checked(\n    x_in, aircraft, var, cst, cst_mag, crt, crt_mag\n)\n</code></pre> <p>Compute criterion and constraints and check that it was not already computed.</p> Source code in <code>src/lh2pac/marilib/aircraft/design/process.py</code> <pre><code>def eval_optim_data_checked(self,x_in,aircraft,var,cst,cst_mag,crt,crt_mag):\n    \"\"\"Compute criterion and constraints and check that it was not already computed.\n    \"\"\"\n    in_key = tuple(x_in)\n    if self.check_for_doublon:\n\n        if in_key not in self.computed_points.keys(): # check if this point has not been already evaluated\n            criterion,constraint = self.eval_optim_data(x_in,aircraft,var,cst,cst_mag,crt,crt_mag)\n\n        else:\n            criterion = self.computed_points[in_key][0]\n            constraint = self.computed_points[in_key][1]\n\n    else:\n        criterion, constraint = self.eval_optim_data(x_in, aircraft, var, cst, cst_mag, crt, crt_mag)\n\n    print(\"--&gt;Design point:\", x_in)\n    print(\"Criterion :\", criterion)\n    print(\"Constraints :\", constraint)\n    return criterion,constraint\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/design/process/#lh2pac.marilib.aircraft.design.process.Optimizer.grid_minimum_search","title":"grid_minimum_search","text":"<pre><code>grid_minimum_search(cost_fun, x0, delta=0.02, pen=500000.0)\n</code></pre> <p>A custom minimization method limited to 2 parameters problems (x1,x2). This method uses a custom pattern search algorithm that requires a minimum number of call to the cost function. It takes advantage of the prior knowledge of the problem:</p> <pre><code>1. Evaluate cost function (with constraint penalisation) at current point : coordinate (0,0)\n2. Evaluate, if not already done, the cost function in three other points to draw a square area of side1 :\n   coordinates (-1,0), (0,-1) relatively to current point\n3. Build a linear approximation of the cost function based on the the 3 previous points.\n4. Extrapolate the cost function on the surrounding points:\n\no------o-------o------o\n|                     |     o : extrapolated points\n|   (-1,0)   (0,0)    |     + : computed points\no      +-------+      o\n|      |       |      |\n|      |       |      |\no      o-------+      o\n|            (0,-1)   |\n|                     |\no------o-------o------o\n\n5. Find the square cell (among the 9 cells defined by computed and extrapolated points)\nwith minimal average criterion value\nCrt  = cost_function(x1,y1) - sum(unsatisfied constraints)\n    * If current cell is minimum : STOP (or refine of asked so)\n    * Else : move current point to the top right corner of the new candidate cell and go back to step 1.\n</code></pre> <p>:param cost_fun: a function that returns the criterion to be minimized and the constraints value for given                 value of the parameters : length-2 tuple (x1,x2). :param x0: a list of the two initial parameter values (x1,x2). :param args: list of additional argument for cost_fun. :param delta: the relative step for initial pattern size : 0&lt; delta &lt; 1.     :Example: If delta = 0.05, the pattern size will be 5% of the magnitude of x0 values. :param pen: penalisation factor to multiply the constraint value. The constraint is negative when unsatisfied.     :Example: This algorythm minimizes the modified cost function : criterion + pen*constraint</p> Source code in <code>src/lh2pac/marilib/aircraft/design/process.py</code> <pre><code>def grid_minimum_search(cost_fun,x0,delta=0.02,pen=5e5):\n    \"\"\" A custom minimization method limited to 2 parameters problems (x1,x2).\n    This method uses a custom pattern search algorithm that requires a minimum number of call to the cost function.\n    It takes advantage of the prior knowledge of the problem:\n\n        1. Evaluate cost function (with constraint penalisation) at current point : coordinate (0,0)\n        2. Evaluate, if not already done, the cost function in three other points to draw a square area of side1 :\n           coordinates (-1,0), (0,-1) relatively to current point\n        3. Build a linear approximation of the cost function based on the the 3 previous points.\n        4. Extrapolate the cost function on the surrounding points:\n\n        o------o-------o------o\n        |                     |     o : extrapolated points\n        |   (-1,0)   (0,0)    |     + : computed points\n        o      +-------+      o\n        |      |       |      |\n        |      |       |      |\n        o      o-------+      o\n        |            (0,-1)   |\n        |                     |\n        o------o-------o------o\n\n        5. Find the square cell (among the 9 cells defined by computed and extrapolated points)\n        with minimal average criterion value\n        Crt  = cost_function(x1,y1) - sum(unsatisfied constraints)\n            * If current cell is minimum : STOP (or refine of asked so)\n            * Else : move current point to the top right corner of the new candidate cell and go back to step 1.\n\n    :param cost_fun: a function that returns the criterion to be minimized and the constraints value for given\n                    value of the parameters : length-2 tuple (x1,x2).\n    :param x0: a list of the two initial parameter values (x1,x2).\n    :param args: list of additional argument for cost_fun.\n    :param delta: the relative step for initial pattern size : 0&lt; delta &lt; 1.\n        :Example: If delta = 0.05, the pattern size will be 5% of the magnitude of x0 values.\n    :param pen: penalisation factor to multiply the constraint value. The constraint is negative when unsatisfied.\n        :Example: This algorythm minimizes the modified cost function : criterion + pen*constraint\n    \"\"\"\n\n    # TODO\n    raise NotImplementedError\n    return\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/design/process/#lh2pac.marilib.aircraft.design.process.Optimizer.mdf","title":"mdf","text":"<pre><code>mdf(\n    aircraft,\n    var,\n    var_bnd,\n    cst,\n    cst_mag,\n    crt,\n    method=\"trust-constr\",\n)\n</code></pre> <p>Run the Multidisciplinary Design Feasible procedure for a given aircraft. The minimization procedure finds the minimal value of a given criteria with respect to given design variables, and given constraints.</p> <p>Ex: minimize the MTOW with respect to reference thrust and wing area.</p> <p>:param method: {'trust-constr','custom'} default is 'trust-constr'.</p> <pre><code>   * 'trust-constr' refers to the method :meth:`mdf_scipy_trust_constraint` which uses scipy.\n   * 'custom' refers to the method :meth:`custom_descent_search` with a kind of descent search algorythm.\n       Recquires less evaluations and is often faster.\n</code></pre> Source code in <code>src/lh2pac/marilib/aircraft/design/process.py</code> <pre><code>def mdf(self,aircraft,var,var_bnd,cst,cst_mag,crt,method='trust-constr'):\n    \"\"\"Run the Multidisciplinary Design Feasible procedure for a given aircraft.\n     The minimization procedure finds the minimal value of a given criteria with respect to given design variables,\n     and given constraints.\n\n     Ex: minimize the MTOW with respect to reference thrust and wing area.\n\n     :param method: {'trust-constr','custom'} default is 'trust-constr'.\n\n            * 'trust-constr' refers to the method :meth:`mdf_scipy_trust_constraint` which uses scipy.\n            * 'custom' refers to the method :meth:`custom_descent_search` with a kind of descent search algorythm.\n                Recquires less evaluations and is often faster.\n    \"\"\"\n    self.reset()\n    start_value = np.zeros(len(var))\n    for k, key in enumerate(var):  # put optimization variables in aircraft object\n        exec(\"start_value[k] = eval(key)\")\n    print(\"--------------------------------------------------------------\")\n    print(\"start_value = \", start_value)\n    print(\"--------------------------------------------------------------\")\n\n    crt_mag, unused = self.eval_optim_data(start_value, aircraft, var, cst, cst_mag, crt, 1.)\n\n    if method == 'trust-constr':\n        res = self.scipy_trust_constraint(aircraft,start_value,var,var_bnd,cst,cst_mag,crt,crt_mag)\n\n    elif method == 'custom':\n        cost_const = lambda x_in: self.eval_optim_data(x_in, aircraft, var, cst, cst_mag, crt, 1.)\n        res = self.custom_descent_search(cost_const,start_value)\n\n    print(res)\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/design/process/#lh2pac.marilib.aircraft.design.process.Optimizer.reset","title":"reset","text":"<pre><code>reset()\n</code></pre> <p>Empty the computed_points dict</p> Source code in <code>src/lh2pac/marilib/aircraft/design/process.py</code> <pre><code>def reset(self):\n    \"\"\"Empty the computed_points dict\n    \"\"\"\n    self.computed_points = {}\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/design/process/#lh2pac.marilib.aircraft.design.process.Optimizer.scipy_trust_constraint","title":"scipy_trust_constraint","text":"<pre><code>scipy_trust_constraint(\n    aircraft,\n    start_value,\n    var,\n    var_bnd,\n    cst,\n    cst_mag,\n    crt,\n    crt_mag,\n)\n</code></pre> <p>Run the trust-constraint minimization procedure :func:<code>scipy.optimize.minimize</code> to minimize a given criterion and satisfy given constraints for a given aircraft.</p> Source code in <code>src/lh2pac/marilib/aircraft/design/process.py</code> <pre><code>def scipy_trust_constraint(self,aircraft,start_value,var,var_bnd,cst,cst_mag,crt,crt_mag):\n    \"\"\"\n    Run the trust-constraint minimization procedure :func:`scipy.optimize.minimize` to minimize a given criterion\n    and satisfy given constraints for a given aircraft.\n    \"\"\"\n    def cost(x,*args):\n        return self.eval_optim_data_checked(x,*args)[0]\n\n    def constraints(x):\n        return self.eval_optim_data_checked(x,aircraft,var,cst,cst_mag,crt,crt_mag)[1]\n\n    res = minimize(cost, start_value, args=(aircraft,var,cst,cst_mag,crt,crt_mag,),\n                   constraints=NonlinearConstraint(fun=constraints,\n                                                   lb=0., ub=np.inf, jac='3-point'),\n                   method=\"trust-constr\", jac=\"3-point\", bounds=var_bnd, hess=SR1(), hessp=None,\n                   options={'maxiter':500,'xtol':1.e-6})\n                   #options={'maxiter':500,'xtol': np.linalg.norm(start_value)*0.01,\n                   #         'initial_tr_radius': np.linalg.norm(start_value)*0.05 })\n    return res\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/design/process/#lh2pac.marilib.aircraft.design.process.Optimizer.update_interpolator_and_gradient","title":"update_interpolator_and_gradient","text":"<pre><code>update_interpolator_and_gradient(threePoints)\n</code></pre> <p>Compute the plane equation through three points. Returns the gradient vector and interpolator function. :param xxx : a three point matrix [[x1,y1,z1],[x2,y2,z2],[x3,y3,z3]]</p> Source code in <code>src/lh2pac/marilib/aircraft/design/process.py</code> <pre><code>def update_interpolator_and_gradient(self,threePoints):\n    \"\"\"\n    Compute the plane equation through three points.\n    Returns the gradient vector and interpolator function.\n    :param xxx : a three point matrix [[x1,y1,z1],[x2,y2,z2],[x3,y3,z3]]\n    \"\"\"\n    a, b, c = np.linalg.solve(threePoints,\n                              [1, 1, 1])  # find the coefficient of the plan passing through the 3 points\n    extrapolator = lambda x, y: (1. - a * x - b * y) / c\n    zgradient = np.array([-a / c, -b / c]) / np.linalg.norm([-a / c, -b / c])\n    return zgradient, extrapolator\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/design/process/#lh2pac.marilib.aircraft.design.process-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/aircraft/design/process/#lh2pac.marilib.aircraft.design.process.eval_this","title":"eval_this","text":"<pre><code>eval_this(aircraft, design_variables)\n</code></pre> <p>Evaluate the current value of the design variables of the aircraft :param aircraft: the aircraft being designed :param design_variables: a list of string path to the variables. Example : ::         design_variables = [\"aircraft.airframe.nacelle.reference_thrust\",                             \"aircraft.airframe.wing.area\"] :return: the value of the designed variables</p> Source code in <code>src/lh2pac/marilib/aircraft/design/process.py</code> <pre><code>def eval_this(aircraft,design_variables):\n    \"\"\"Evaluate the current value of the design variables of the aircraft\n    :param aircraft: the aircraft being designed\n    :param design_variables: a list of string path to the variables. Example : ::\n            design_variables = [\"aircraft.airframe.nacelle.reference_thrust\",\n                                \"aircraft.airframe.wing.area\"]\n    :return: the value of the designed variables\n    \"\"\"\n    res = []\n    for str in design_variables:\n        res.append(eval(str))\n    return res\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/design/process/#lh2pac.marilib.aircraft.design.process.mda","title":"mda","text":"<pre><code>mda(aircraft, mass_mission_matching=True)\n</code></pre> <p>Perform Multidsciplinary_Design_Analysis All coupling constraints are solved in a relevent order</p> Source code in <code>src/lh2pac/marilib/aircraft/design/process.py</code> <pre><code>def mda(aircraft, mass_mission_matching=True):\n    \"\"\"Perform Multidsciplinary_Design_Analysis\n    All coupling constraints are solved in a relevent order\n    \"\"\"\n    # aircraft.airframe.geometry_analysis()     # Without statistical empennage sizing\n    aircraft.airframe.statistical_pre_design()  # With statistical empennage sizing\n\n    # aircraft.weight_cg.mass_analysis()      # Without MZFW - MLW coupling\n    aircraft.weight_cg.mass_pre_design()    # With MZFW - MLW coupling\n\n    aircraft.aerodynamics.aerodynamic_analysis()\n\n    aircraft.handling_quality.analysis()\n    # aircraft.handling_quality.optimization()        # Perform optimization instead of analysis\n\n    if mass_mission_matching==True:\n        aircraft.performance.mission.mass_mission_adaptation()\n\n    aircraft.performance.mission.payload_range()\n\n    aircraft.performance.analysis()\n\n    aircraft.economics.operating_cost_analysis()\n\n    aircraft.environment.fuel_efficiency_metric()\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/design/process/#lh2pac.marilib.aircraft.design.process.mda_hq","title":"mda_hq","text":"<pre><code>mda_hq(aircraft)\n</code></pre> <p>Perform Multidsciplinary_Design_Analysis All coupling constraints are solved in a relevent order</p> Source code in <code>src/lh2pac/marilib/aircraft/design/process.py</code> <pre><code>def mda_hq(aircraft):\n    \"\"\"Perform Multidsciplinary_Design_Analysis\n    All coupling constraints are solved in a relevent order\n    \"\"\"\n    # aircraft.airframe.geometry_analysis()\n    aircraft.airframe.statistical_pre_design()\n\n    # aircraft.weight_cg.mass_analysis()\n    aircraft.weight_cg.mass_pre_design()\n\n    aircraft.aerodynamics.aerodynamic_analysis()\n\n    # aircraft.handling_quality.analysis()\n    aircraft.handling_quality.optimization()        # Perform optimization instead of analysis\n\n    aircraft.performance.mission.mass_mission_adaptation()\n\n    aircraft.performance.mission.payload_range()\n\n    aircraft.performance.analysis()\n\n    aircraft.economics.operating_cost_analysis()\n\n    aircraft.environment.fuel_efficiency_metric()\n\n    aircraft.power_system.thrust_analysis()\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/design/process/#lh2pac.marilib.aircraft.design.process.mda_plus","title":"mda_plus","text":"<pre><code>mda_plus(aircraft)\n</code></pre> <p>Solves coupling between MTOW and OWE</p> Source code in <code>src/lh2pac/marilib/aircraft/design/process.py</code> <pre><code>def mda_plus(aircraft):\n    \"\"\"Solves coupling between MTOW and OWE\n    \"\"\"\n    dist = aircraft.requirement.design_range\n    kdist = aircraft.requirement.max_fuel_range_factor\n\n    def fct(x):\n        aircraft.airframe.tank.mfw_factor = x[0]\n        mda(aircraft)\n        max_fuel_range = aircraft.performance.mission.max_fuel.range\n        return dist*kdist - max_fuel_range\n\n    x_ini = aircraft.airframe.tank.mfw_factor\n    output_dict = fsolve(fct, x0=x_ini, args=(), full_output=True)\n    if (output_dict[2]!=1): raise Exception(\"Convergence problem\")\n\n    aircraft.airframe.tank.mfw_factor = output_dict[0][0]\n    mda(aircraft)\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/tool/","title":"Tool","text":""},{"location":"reference/lh2pac/marilib/aircraft/tool/#lh2pac.marilib.aircraft.tool","title":"tool","text":""},{"location":"reference/lh2pac/marilib/aircraft/tool/configuration/","title":"Configuration","text":""},{"location":"reference/lh2pac/marilib/aircraft/tool/configuration/#lh2pac.marilib.aircraft.tool.configuration","title":"configuration","text":"<p>Created on Thu Jan 20 20:20:20 2020</p> <p>:author: Conceptual Airplane Design &amp; Operations (CADO team)          Nicolas PETEILH, Pascal ROCHES, Nicolas MONROLIN, Thierry DRUOT          Aircraft &amp; Systems, Air Transport Departement, ENAC</p>"},{"location":"reference/lh2pac/marilib/aircraft/tool/dictionary/","title":"Dictionary","text":""},{"location":"reference/lh2pac/marilib/aircraft/tool/dictionary/#lh2pac.marilib.aircraft.tool.dictionary","title":"dictionary","text":"<p>:author: DRUOT Thierry, MONROLIN Nicolas</p>"},{"location":"reference/lh2pac/marilib/aircraft/tool/drawing/","title":"Drawing","text":""},{"location":"reference/lh2pac/marilib/aircraft/tool/drawing/#lh2pac.marilib.aircraft.tool.drawing","title":"drawing","text":"<p>Created on Thu Jan 24 23:22:21 2019</p> <p>:author: DRUOT Thierry, PETEILH Nicolas and MONROLIN Nicolas</p>"},{"location":"reference/lh2pac/marilib/aircraft/tool/drawing/#lh2pac.marilib.aircraft.tool.drawing-classes","title":"Classes","text":""},{"location":"reference/lh2pac/marilib/aircraft/tool/drawing/#lh2pac.marilib.aircraft.tool.drawing.Drawing","title":"Drawing","text":"<pre><code>Drawing(aircraft)\n</code></pre> <p>               Bases: <code>object</code></p> Source code in <code>src/lh2pac/marilib/aircraft/tool/drawing.py</code> <pre><code>def __init__(self, aircraft):\n    self.aircraft = aircraft\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/tool/drawing/#lh2pac.marilib.aircraft.tool.drawing.Drawing-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/aircraft/tool/drawing/#lh2pac.marilib.aircraft.tool.drawing.Drawing.get_3d_curves","title":"get_3d_curves","text":"<pre><code>get_3d_curves()\n</code></pre> <p>Build 3D curves to print the plane</p> Source code in <code>src/lh2pac/marilib/aircraft/tool/drawing.py</code> <pre><code>def get_3d_curves(self):\n    \"\"\"\n    Build 3D curves to print the plane\n    \"\"\"\n    component = {\n        \"name\": self.aircraft.name,\n        \"surface\": [],\n        \"body\": [],\n        \"nacelle\": [],\n    }\n\n    for comp in self.aircraft.airframe:\n        data = comp.sketch_3view()\n        if data is not None:\n            typ = comp.get_component_type()\n            if typ in [\"wing\", \"htp\", \"vtp\"]:\n                component[\"surface\"].append(\n                    {\"le\": data[\"le\"], \"te\": data[\"te\"], \"toc\": data[\"toc\"]}\n                )\n            elif typ in [\"body\", \"wing_pod_tank\", \"piggyback_tank\"]:\n                component[\"body\"].append(\n                    {\"xz\": data[\"body_xz\"], \"xy\": data[\"body_xy\"]}\n                )\n            if typ == \"piggyback_tank\":  # Treat Piggy Back exception\n                pyl_data = comp.pylon_sketch()\n                component[\"surface\"].append(\n                    {\n                        \"le\": pyl_data[\"fle\"],\n                        \"te\": pyl_data[\"fte\"],\n                        \"toc\": pyl_data[\"toc\"],\n                    }\n                )\n                component[\"surface\"].append(\n                    {\n                        \"le\": pyl_data[\"ble\"],\n                        \"te\": pyl_data[\"bte\"],\n                        \"toc\": pyl_data[\"toc\"],\n                    }\n                )\n\n    for comp in self.aircraft.airframe:\n        if issubclass(type(comp), Nacelle):\n            data = comp.sketch_3view()\n            component[\"nacelle\"].append(\n                {\"le\": data[\"fle\"], \"te\": data[\"fte\"], \"toc\": data[\"toc\"]}\n            )\n            component[\"nacelle\"].append(\n                {\"le\": data[\"cle\"], \"te\": data[\"cte\"], \"toc\": data[\"toc\"]}\n            )\n            if comp.get_component_type() in [\n                \"body_nacelle\",\n                \"body_tail_nacelle\",\n                \"pod_tail_nacelle\",\n                \"piggyback_tail_nacelle\",\n            ]:\n                component[\"surface\"].append(\n                    {\"le\": data[\"s1le\"], \"te\": data[\"s1te\"], \"toc\": data[\"toc\"]}\n                )\n                component[\"surface\"].append(\n                    {\"le\": data[\"s2le\"], \"te\": data[\"s2te\"], \"toc\": data[\"toc\"]}\n                )\n\n    return component\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/tool/drawing/#lh2pac.marilib.aircraft.tool.drawing.Drawing.payload_range","title":"payload_range","text":"<pre><code>payload_range(window_title)\n</code></pre> <p>Print the payload - range diagram</p> Source code in <code>src/lh2pac/marilib/aircraft/tool/drawing.py</code> <pre><code>def payload_range(self, window_title):\n    \"\"\"\n    Print the payload - range diagram\n    \"\"\"\n    plot_title = self.aircraft.name\n\n    payload = [\n        self.aircraft.performance.mission.max_payload.payload,\n        self.aircraft.performance.mission.max_payload.payload,\n        self.aircraft.performance.mission.max_fuel.payload,\n        0.0,\n    ]\n\n    range = [\n        0.0,\n        unit.NM_m(self.aircraft.performance.mission.max_payload.range),\n        unit.NM_m(self.aircraft.performance.mission.max_fuel.range),\n        unit.NM_m(self.aircraft.performance.mission.zero_payload.range),\n    ]\n\n    nominal = [\n        self.aircraft.performance.mission.nominal.payload,\n        unit.NM_m(self.aircraft.performance.mission.nominal.range),\n    ]\n\n    fig, axes = plt.subplots(1, 1)\n    fig.canvas.set_window_title(window_title)\n    fig.suptitle(plot_title, fontsize=14)\n\n    plt.plot(range, payload, linewidth=2, color=\"blue\")\n    plt.scatter(range[1:], payload[1:], marker=\"+\", c=\"orange\", s=100)\n    plt.scatter(nominal[1], nominal[0], marker=\"o\", c=\"green\", s=50)\n\n    plt.grid(True)\n\n    plt.ylabel(\"Payload (kg)\")\n    plt.xlabel(\"Range (NM)\")\n\n    plt.show()\n</code></pre>"},{"location":"reference/lh2pac/marilib/aircraft/tool/drawing/#lh2pac.marilib.aircraft.tool.drawing.Drawing.view_3d","title":"view_3d","text":"<pre><code>view_3d(title='')\n</code></pre> <p>Build a 3 views drawing of the airplane</p> Source code in <code>src/lh2pac/marilib/aircraft/tool/drawing.py</code> <pre><code>def view_3d(self, title=\"\"):\n    \"\"\"\n    Build a 3 views drawing of the airplane\n    \"\"\"\n    plot_title = title or self.aircraft.name\n\n    # Drawing_ box\n    # -----------------------------------------------------------------------------------------------------------\n    fig, axes = plt.subplots(1, 1)\n    fig.suptitle(plot_title, fontsize=14)\n    axes.set_aspect(\"equal\", \"box\")\n    plt.plot(\n        np.array([0, 100, 100, 0, 0]), np.array([0, 0, 100, 100, 0])\n    )  # Draw a square box of 100m side\n\n    xTopView = 50 - (\n        self.aircraft.airframe.wing.mac_loc[0]\n        + 0.25 * self.aircraft.airframe.wing.mac\n    )\n    yTopView = 50\n\n    xSideView = 50 - (\n        self.aircraft.airframe.wing.mac_loc[0]\n        + 0.25 * self.aircraft.airframe.wing.mac\n    )\n    ySideView = 82\n\n    xFrontView = 50\n    yFrontView = 10\n\n    ref = {\n        \"xy\": [xTopView, yTopView],\n        \"yz\": [xFrontView, yFrontView],\n        \"xz\": [xSideView, ySideView],\n    }\n\n    low, l1, l2, l3, l4, l5, high = 0, 1, 2, 3, 4, 5, 6\n\n    # Draw components\n    # -----------------------------------------------------------------------------------------------------------\n    zframe = {\n        \"xy\": {\"body\": l2, \"wing\": l1, \"htp\": l1, \"vtp\": l3},  # top\n        \"yz\": {\"body\": l4, \"wing\": l3, \"htp\": l1, \"vtp\": l2},  # front\n        \"xz\": {\"body\": l2, \"wing\": l3, \"htp\": l3, \"vtp\": l1},\n    }  # side\n\n    if self.aircraft.arrangement.wing_attachment == \"high\":\n        zframe[\"xy\"][\"body\"] = l1\n        zframe[\"xy\"][\"wing\"] = l2\n\n    if self.aircraft.arrangement.stab_architecture == \"t_tail\":\n        zframe[\"xy\"][\"htp\"] = l3\n        zframe[\"xy\"][\"vtp\"] = l1\n\n    if self.aircraft.arrangement.stab_architecture == \"h_tail\":\n        zframe[\"xz\"][\"htp\"] = l1\n        zframe[\"xz\"][\"vtp\"] = l3\n\n    for comp in self.aircraft.airframe:\n        data = comp.sketch_3view()\n        if data is not None:\n            typ = comp.get_component_type()\n            if typ in [\"body\", \"wing\", \"htp\", \"vtp\"]:\n                for view in [\"xy\", \"yz\", \"xz\"]:\n                    plt.fill(\n                        ref[view][0] + data[view][0:, 0],\n                        ref[view][1] + data[view][0:, 1],\n                        color=\"white\",\n                        zorder=zframe[view][typ],\n                    )  # draw mask\n                    plt.plot(\n                        ref[view][0] + data[view][0:, 0],\n                        ref[view][1] + data[view][0:, 1],\n                        color=\"grey\",\n                        zorder=zframe[view][typ],\n                    )  # draw contour\n\n    # Draw tanks\n    # -----------------------------------------------------------------------------------------------------------\n    #                            top        front    side\n    zpod = {\n        \"wing_pod_tank\": {\"xy\": l3, \"yz\": l4, \"xz\": l4},\n        \"piggyback_tank\": {\"xy\": high, \"yz\": l4, \"xz\": l2},\n    }\n\n    for comp in self.aircraft.airframe:\n        if issubclass(type(comp), Pod):\n            pod = comp.sketch_3view()\n            typ = comp.get_component_type()\n            if (\n                typ == \"wing_pod_tank\"\n                and self.aircraft.airframe.tank.frame_origin[2]\n                &lt; self.aircraft.airframe.tank.wing_axe_z\n            ):\n                zpod[\"wing_pod_tank\"][\"xy\"] = low\n            for view in [\"xy\", \"yz\", \"xz\"]:\n                plt.fill(\n                    ref[view][0] + pod[view][0:, 0],\n                    ref[view][1] + pod[view][0:, 1],\n                    color=\"white\",\n                    zorder=zpod[typ][view],\n                )  # draw mask\n                plt.plot(\n                    ref[view][0] + pod[view][0:, 0],\n                    ref[view][1] + pod[view][0:, 1],\n                    color=\"grey\",\n                    zorder=zpod[typ][view],\n                )  # draw contour\n            # print(typ,zpod[typ][\"xy\"],zframe[\"xy\"][\"wing\"])\n            if typ == \"wing_pod_tank\" and zframe[\"xy\"][\"wing\"] &lt; zpod[typ][\"xy\"]:\n                data = self.aircraft.airframe.wing.sketch_3view()\n                view = \"xz_tip\"\n                plt.fill(\n                    ref[\"xz\"][0] + data[view][0:, 0],\n                    ref[\"xz\"][1] + data[view][0:, 1],\n                    color=\"white\",\n                    zorder=high,\n                )  # draw mask\n                plt.plot(\n                    ref[\"xz\"][0] + data[view][0:, 0],\n                    ref[\"xz\"][1] + data[view][0:, 1],\n                    color=\"grey\",\n                    zorder=high,\n                )  # draw contour\n\n    # Draw nacelles\n    # -----------------------------------------------------------------------------------------------------------\n    #                                  top        front     side\n    znac = {\n        \"wing_nacelle\": {\"xy\": low, \"yz\": l4, \"xz\": high},\n        \"body_nacelle\": {\"xy\": l3, \"yz\": l1, \"xz\": high},\n        \"body_tail_nacelle\": {\"xy\": l1, \"yz\": low, \"xz\": low},\n        \"pod_tail_nacelle\": {\"xy\": l4, \"yz\": low, \"xz\": l5},\n        \"piggyback_tail_nacelle\": {\"xy\": high, \"yz\": low, \"xz\": l2},\n    }\n\n    for comp in self.aircraft.airframe:\n        if issubclass(type(comp), Nacelle):\n            nacelle = comp.sketch_3view()\n            typ = comp.get_component_type()\n            for view in [\"xy\", \"yz\", \"xz\"]:\n                plt.fill(\n                    ref[view][0] + nacelle[view][0:, 0],\n                    ref[view][1] + nacelle[view][0:, 1],\n                    color=\"white\",\n                    zorder=znac[typ][view],\n                )  # draw mask\n                plt.plot(\n                    ref[view][0] + nacelle[view][0:, 0],\n                    ref[view][1] + nacelle[view][0:, 1],\n                    color=\"grey\",\n                    zorder=znac[typ][view],\n                )  # draw contour\n            # plt.fill(ref[view][0]+nacelle[\"disk\"][0:,0], ref[\"disk\"][1]+nacelle[view][0:,1], color=\"white\", zorder=znac[typ][\"yz\"])    # draw mask\n            plt.plot(\n                ref[\"yz\"][0] + nacelle[\"disk\"][0:, 0],\n                ref[\"yz\"][1] + nacelle[\"disk\"][0:, 1],\n                color=\"grey\",\n                zorder=znac[typ][\"yz\"],\n            )  # draw contour\n\n    plt.show()\n    return\n</code></pre>"},{"location":"reference/lh2pac/marilib/airship/","title":"Airship","text":""},{"location":"reference/lh2pac/marilib/airship/#lh2pac.marilib.airship","title":"airship","text":""},{"location":"reference/lh2pac/marilib/airship/airship/","title":"Airship","text":""},{"location":"reference/lh2pac/marilib/airship/airship/#lh2pac.marilib.airship.airship","title":"airship","text":"<p>Created on November 20 20:20:20 2020 @author: Thierry DRUOT</p>"},{"location":"reference/lh2pac/marilib/airship/airship/#lh2pac.marilib.airship.airship-classes","title":"Classes","text":""},{"location":"reference/lh2pac/marilib/airship/airship/#lh2pac.marilib.airship.airship.Airship","title":"Airship","text":"<pre><code>Airship(\n    phd,\n    ne=6,\n    payload=10000.0,\n    range=unit.m_NM(1000.0),\n    altp=unit.m_ft(10000.0),\n    disa=0.0,\n    speed=unit.mps_kmph(100.0),\n)\n</code></pre> <p>               Bases: <code>object</code></p> <p>Airship object</p> Source code in <code>src/lh2pac/marilib/airship/airship.py</code> <pre><code>def __init__(self, phd, ne=6, payload=10000., range=unit.m_NM(1000.), altp=unit.m_ft(10000.), disa=0., speed=unit.mps_kmph(100.)):\n    self.phd = phd\n\n    self.payload = payload      # Design mission payload\n    self.range = range          # Design mission range\n    self.cruise_altp = altp     # Reference cruise altitude\n    self.cruise_disa = disa     # Reference standard temperature shift in cruise\n    self.cruise_speed = speed   # Cruise speed\n\n    self.length_o_width_ratio = 4.3  # Length over width ratio\n    self.length_o_height_ratio = 4.3 # Length over height ratio, WARNING l/h MUST BE HIGHER THAN l/w\n\n    self.length = None          # Length of the ellipsoide\n    self.width = None           # Width of the ellipsoide\n    self.height = None          # Height of the ellipsoide\n    self.gross_volume = None    # Total internal gross volume\n    self.gross_area = None      # External area\n\n    self.n_fin = 3                      # Number of fins\n    self.fin_area = None                # Area of one fin\n    self.fin_gravimetric_index = 5.0    # kg/m2, Mass of structure over total gross area\n\n    self.gondola_gravimetric_index = 0.450  # kg/kg, Mass of structure over max payload mass\n    self.gondola_volumetric_index = 0.020   # m3/kg, Volume of structure over max payload mass\n    self.envelop_gravimetric_index = 0.900  # kg/m2, Mass of structure over total gross area\n    self.envelop_volumetric_index = 0.005   # m3/m3, Volume of structure over total gross volume\n    self.buoyancy_reserve = 0.05            # m3/m3, Remaining air ballast volume over He volume at cruise altitude\n    self.operational_weight_factor = 0.045  # Fraction of the mtow which is not compensated\n\n    self.he_max_volume = None       # Max He volume\n    self.he_max_mass = None         # Max He mass\n    self.air_max_volume = None      # Max air volume in the ballasts\n\n    self.envelop_mass = None        # Mass of the envelop\n    self.gondola_mass = None        # Mass of the gondola\n    self.fin_mass = None            # Mass of the fins\n    self.owe = None                 # Design mission Operating Empty Weight (without He)\n    self.mtow = None                # Design mission Maximum Take Off Weight (without He)\n    self.operational_weight = None  # Uncompensated weight\n\n    self.reference_area = None      # Aerodynamic reference area\n    self.envelop_form_factor = 1.05 # Envelop form factor for drag estimation\n    self.fin_form_factor = 1.15     # Fin form factor for drag estimation\n\n    self.fuel_factor = 0.20         # fraction of mission fuel for reserve\n\n    # Propulsion system\n    #---------------------------------------------------------------------------------------------------------------\n    self.propulsion = Propulsion(phd, ne)\n\n    # Power system\n    #---------------------------------------------------------------------------------------------------------------\n    self.power = Power(phd)\n\n    # Tank system\n    #---------------------------------------------------------------------------------------------------------------\n    self.tank = Tank(phd)\n\n    # Design the airship\n    #---------------------------------------------------------------------------------------------------------------\n    self.design()\n</code></pre>"},{"location":"reference/lh2pac/marilib/airship/airship/#lh2pac.marilib.airship.airship.Airship-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/airship/airship/#lh2pac.marilib.airship.airship.Airship.buoyancy_force","title":"buoyancy_force","text":"<pre><code>buoyancy_force(he_mass, pamb, tamb)\n</code></pre> <p>Compute the buoyancy force in given conditions</p> Source code in <code>src/lh2pac/marilib/airship/airship.py</code> <pre><code>def buoyancy_force(self, he_mass,pamb,tamb):\n    \"\"\"Compute the buoyancy force in given conditions\n    \"\"\"\n    g = 9.80665\n    rho_he = self.phd.gas_density(pamb,tamb,gas=\"helium\")\n    rho_air = self.phd.gas_density(pamb,tamb,gas=\"air\")\n    he_volume = he_mass / rho_he\n    air_mass = rho_air * he_volume\n    force = (air_mass - he_mass)*g\n    return force\n</code></pre>"},{"location":"reference/lh2pac/marilib/airship/airship/#lh2pac.marilib.airship.airship.Airship.design","title":"design","text":"<pre><code>design()\n</code></pre> <p>This method designs the airship according to TLARs</p> Source code in <code>src/lh2pac/marilib/airship/airship.py</code> <pre><code>def design(self):\n    \"\"\"This method designs the airship according to TLARs\n    \"\"\"\n    def fct(X):\n        length, power, h2_mass = X\n        self.eval_design(length, power, h2_mass)\n        cst = self.eval_design_constraints()\n        return [cst[\"power\"], cst[\"energy\"], cst[\"buoyancy\"]]\n\n    Xini = [50., 1.e5, 500.]\n\n    out_dict = fsolve(fct, x0=Xini, args=(), full_output=True)\n    if (out_dict[2]!=1): raise Exception(\"Convergence problem\")\n    length, power, h2_mass = altg = out_dict[0]\n\n    self.eval_design(length, power, h2_mass)\n</code></pre>"},{"location":"reference/lh2pac/marilib/airship/airship/#lh2pac.marilib.airship.airship.Airship.eval_design","title":"eval_design","text":"<pre><code>eval_design(length, power, h2_mass)\n</code></pre> <p>Compute geometrical datasc</p> Source code in <code>src/lh2pac/marilib/airship/airship.py</code> <pre><code>def eval_design(self, length, power, h2_mass):\n    \"\"\"Compute geometrical datasc\n    \"\"\"\n    if min(self.length_o_width_ratio,self.length_o_height_ratio)&lt;2.:\n        raise Exception(\"length_o_width and length_o_height must be higher or equal to 2.\")\n    elif self.length_o_width_ratio &gt; self.length_o_height_ratio:\n        raise Exception(\"length_o_width must be lower than length_o_height\")\n\n    self.length = length                # Length of the ellipsoide\n\n    self.fin_area = (0.80 * self.length) / self.n_fin\n\n    self.width = self.length / self.length_o_width_ratio\n    self.height = self.length / self.length_o_height_ratio\n\n    nose_dict = self.half_ellipsoide(self.width, self.height, 1.0)\n    tail_dict = self.half_ellipsoide(self.width, self.height, 2.0)\n    cyl_length = self.length - nose_dict[\"length\"] - tail_dict[\"length\"]\n    cyl_dict = self.cylinder(self.width, self.height, cyl_length)\n\n    self.gross_volume = nose_dict[\"volume\"] + cyl_dict[\"volume\"] + tail_dict[\"volume\"]\n\n    self.gross_area = nose_dict[\"area\"] + cyl_dict[\"area\"] + tail_dict[\"area\"]\n\n    self.reference_area = 0.25 * np.pi * self.length * self.width\n\n    # Propulsion system design\n    self.propulsion.design(power)\n\n    # Power system design\n    output_power = self.propulsion.get_max_power()\n    pamb,tamb,g = phd.atmosphere(0., 25.)\n    self.power.design(pamb,tamb,output_power)\n\n    # Tank system design\n    self.tank.design(h2_mass)\n\n    # max He volume corresponds to max internal volume minus structure volume, buoyancy reserve, payload volume, fuel tank volume\n    self.he_max_volume =   (1. - self.envelop_volumetric_index - self.buoyancy_reserve) * self.gross_volume \\\n                         - self.gondola_volumetric_index * self.payload \\\n                         - self.power.get_volume() \\\n                         - self.tank.get_volume()\n\n    # Max He volume is computed at cruise altitude and high temperature\n    pamb1,tamb1,g = phd.atmosphere(self.cruise_altp, 25.)\n    self.he_max_mass = self.he_max_volume * phd.gas_density(pamb1,tamb1, gas=\"helium\")\n\n    # Max air volume is computed at sea level and low temperature\n    pamb0,tamb0,g = phd.atmosphere(0., -35.)\n    he_min_volume = self.he_max_mass / phd.gas_density(pamb0,tamb0, gas=\"helium\")\n    self.air_max_volume = self.he_max_volume - he_min_volume\n\n    self.envelop_mass = self.gross_area * self.envelop_gravimetric_index\n    self.gondola_mass = self.payload * self.gondola_gravimetric_index\n    self.fin_mass = self.n_fin * self.fin_area * self.fin_gravimetric_index\n\n    self.owe =   self.envelop_mass \\\n               + self.gondola_mass \\\n               + self.fin_mass \\\n               + self.propulsion.get_mass() \\\n               + self.power.get_mass() \\\n               + self.tank.get_mass()\n\n    self.mtow = self.owe + self.payload + h2_mass\n\n    self.operational_weight = self.mtow * self.operational_weight_factor\n</code></pre>"},{"location":"reference/lh2pac/marilib/airship/airship/#lh2pac.marilib.airship.airship.Airship.eval_design_constraints","title":"eval_design_constraints","text":"<pre><code>eval_design_constraints()\n</code></pre> <p>Evaluate the 3 design constraints that applies on the airship</p> Source code in <code>src/lh2pac/marilib/airship/airship.py</code> <pre><code>def eval_design_constraints(self):\n    \"\"\"Evaluate the 3 design constraints that applies on the airship\n    \"\"\"\n    # Cruise power constraint\n    pamb,tamb,g = phd.atmosphere(self.cruise_altp, self.cruise_disa)\n    thrust = self.drag_force(pamb,tamb,self.cruise_speed) / self.propulsion.n_engine\n    cr_shaft_power = self.propulsion.req_power(self.cruise_speed, thrust)\n\n    # Take off power constraint\n    pamb,tamb,g = phd.atmosphere(0., 0.)\n    thrust = 1.05 * self.operational_weight * g\n    to_shaft_power = self.propulsion.req_power(self.cruise_speed, thrust)\n\n    # Energy constraint\n    req_power = self.propulsion.req_power(self.cruise_speed, thrust)\n    total_req_power = req_power * self.propulsion.n_engine\n    fuel_flow = self.power.fuel_flow(pamb, tamb, self.cruise_speed, total_req_power)\n    time = self.range / self.cruise_speed\n    fuel_mass = fuel_flow * time * (1.+self.fuel_factor)\n\n    # Buoyancy constraint\n    buoyancy = self.buoyancy_force(self.he_max_mass,pamb,tamb)\n    mass = self.mtow\n\n    return {\"power\": self.propulsion.engine_power - max(cr_shaft_power,to_shaft_power),\n            \"energy\": self.tank.h2_max_mass - fuel_mass,\n            \"buoyancy\": buoyancy - mass*g}\n</code></pre>"},{"location":"reference/lh2pac/marilib/airship/airship/#lh2pac.marilib.airship.airship.Airship.print","title":"print","text":"<pre><code>print()\n</code></pre> <p>Print all airship data</p> Source code in <code>src/lh2pac/marilib/airship/airship.py</code> <pre><code>def print(self):\n    \"\"\"Print all airship data\n    \"\"\"\n    print(\"\")\n    print(\"Airship\")\n    print(\"-------------------------------------------------------------------\")\n    print(\"Payload = \", \"%.0f\"%self.payload, \" kg\")\n    print(\"Range = \", \"%.0f\"%unit.NM_m(self.range), \" NM\")\n    print(\"Cruise altitude = \", \"%.0f\"%unit.ft_m(self.cruise_altp), \" ft\")\n    print(\"Cruise disa = \", \"%.0f\"%self.cruise_disa, \" K\")\n    print(\"Cruise speed = \", \"%.0f\"%unit.kmph_mps(self.cruise_speed), \" km/h\")\n    print(\"Reserve fuel factor = \", \"%.2f\"%self.fuel_factor)\n    print(\"\")\n    print(\"Envelop length = \", \"%.0f\"%self.length, \" m\")\n    print(\"Envelop widdh = \", \"%.1f\"%self.width, \" m\")\n    print(\"Envelop height = \", \"%.1f\"%self.height, \" m\")\n    print(\"Envelop gross area = \", \"%.0f\"%self.gross_area, \" m2\")\n    print(\"Envelop gross volume = \", \"%.0f\"%self.gross_volume, \" m3\")\n    print(\"Reference area = \", \"%.0f\"%self.reference_area, \" m2\")\n    print(\"\")\n    print(\"Number of fins = \", self.n_fin)\n    print(\"One fin area = \", \"%.0f\"%self.fin_area, \" m2\")\n    print(\"\")\n    print(\"Maximum volume of ballonets = \", \"%.0f\"%self.air_max_volume, \" m3\")\n    print(\"Maximum volume of Helium = \", \"%.0f\"%self.he_max_volume, \" m3\")\n    print(\"Maximum mass of Helium = \", \"%.0f\"%self.he_max_mass, \" kg\")\n    print(\"\")\n    print(\"Total envelop mass = \", \"%.0f\"%self.envelop_mass, \" kg\")\n    print(\"Total gondola mass = \", \"%.0f\"%self.gondola_mass, \" kg\")\n    print(\"Total fin mass = \", \"%.0f\"%self.fin_mass, \" kg\")\n    print(\"Operating weight empty (without He) = \", \"%.0f\"%self.owe, \" kg\")\n    print(\"Maximum take off weight (without He) = \", \"%.0f\"%self.mtow, \" kg\")\n    print(\"Operational (uncompensated) weight (with He) = \", \"%.0f\"%self.operational_weight, \" kg\")\n\n    self.propulsion.print()\n    self.power.print()\n    self.tank.print()\n</code></pre>"},{"location":"reference/lh2pac/marilib/airship/airship/#lh2pac.marilib.airship.airship.Power","title":"Power","text":"<pre><code>Power(phd)\n</code></pre> <p>               Bases: <code>object</code></p> <p>Power object</p> Source code in <code>src/lh2pac/marilib/airship/airship.py</code> <pre><code>def __init__(self, phd):\n    self.phd = phd\n\n    self.output_power = None            # Total required power\n    self.fuel_cell_ref_power = None     # Fuel cell design power\n    self.compressor_ref_power = None    # Compressor design power\n    self.cooling_ref_power = None       # Cooling system design power\n    self.heat_ref_power = None          # Dissipated heat power at design point\n\n    self.fuel_cell_gravimetric_index = 2.e3     # W/kg, Power density of fuel cell stacks\n    self.fuel_cell_efficiency = 0.50            # Fuel cell efficiency\n\n    self.compressor_gravimetric_index = 1.e3    # W/kg, Power density of the air compressor\n    self.compressor_over_pressure = 1.e5        # Pa, Compressor over pressure\n    self.compressor_efficiency = 0.80           # Air compressor efficiency\n\n    self.cooling_gravimetric_index = 5.e3       # W/kg, Dissipated power over cooling system mass\n    self.cooling_power_index = 0.005            # W/W, Required cooling system power over dissipated power\n\n    self.total_volumetric_index = 500.e3        # W/m3, Total power density of the power system\n\n    self.fuel_cell_mass = None          # Mass of the fuel cell stack\n    self.compressor_mass = None         # Mass of the air compressor\n    self.cooling_mass = None            # Mass of the cooling system\n\n    self.power_system_volume = None     # Volume of the power system\n    self.power_system_mass = None       # Mass of the power system including fuel cell stacks\n</code></pre>"},{"location":"reference/lh2pac/marilib/airship/airship/#lh2pac.marilib.airship.airship.Power-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/airship/airship/#lh2pac.marilib.airship.airship.Power.fuel_cell_power","title":"fuel_cell_power","text":"<pre><code>fuel_cell_power(output_power, pamb, tamb)\n</code></pre> <p>Compute the power delivered by fuel cell stack according to required power and ambiant conditions</p> Source code in <code>src/lh2pac/marilib/airship/airship.py</code> <pre><code>def fuel_cell_power(self, output_power,pamb,tamb):\n    \"\"\"Compute the power delivered by fuel cell stack according to required power and ambiant conditions\n    \"\"\"\n    r,gam,Cp,Cv = self.phd.gas_data()\n\n    fuel_heat = self.phd.fuel_heat(\"liquid_h2\")\n\n    # air_mass_flow = fuel_cell_power * relative_air_mass_flow\n    st_mass_ratio = self.phd.stoichiometry(\"air\",\"hydrogen\")\n    relative_fuel_flow = (1./self.fuel_cell_efficiency) / fuel_heat\n    relative_air_mass_flow = relative_fuel_flow * st_mass_ratio\n    relative_compressor_power = (1./self.compressor_efficiency)*(relative_air_mass_flow*Cv)*tamb*(((pamb+self.compressor_over_pressure)/pamb)**((gam-1.)/gam)-1.)\n\n    # heat_power = fuel_cell_power * relative_heat_power\n    relative_heat_power = (1.-self.fuel_cell_efficiency)/self.fuel_cell_efficiency\n    relative_cooling_power = relative_heat_power*self.cooling_power_index\n\n    fuel_cell_power = output_power / (1. - relative_compressor_power - relative_cooling_power)\n    fuel_flow = fuel_cell_power * relative_fuel_flow\n\n    compressor_power = fuel_cell_power * relative_compressor_power\n    heat_power = fuel_cell_power * relative_heat_power\n    cooling_power = heat_power * self.cooling_power_index\n\n    return {\"fuel_cell_power\":fuel_cell_power,\n            \"compressor_power\":compressor_power,\n            \"cooling_power\":cooling_power,\n            \"heat_power\":heat_power,\n            \"fuel_flow\":fuel_flow}\n</code></pre>"},{"location":"reference/lh2pac/marilib/airship/airship/#lh2pac.marilib.airship.airship.Propulsion","title":"Propulsion","text":"<pre><code>Propulsion(phd, ne)\n</code></pre> <p>               Bases: <code>object</code></p> <p>Propulsion object</p> Source code in <code>src/lh2pac/marilib/airship/airship.py</code> <pre><code>def __init__(self, phd, ne):\n    self.phd = phd\n\n    self.n_engine = ne                  # Number of engines\n    self.engine_power = None            # Engine shaft power\n    self.total_ref_max_power = None     # Rrequired total ref power\n\n    self.nacelle_propulsive_efficiency = 0.80   # Thrust*TAS / shaft_power, propeller efficiency\n    self.nacelle_gravimetric_index = 3.e3       # W/kg, Power density of electric motors\n\n    self.motor_gravimetric_index = 5.e3         # W/kg, Power density of electric motors\n    self.motor_efficiency = 0.95                # Electric motors efficiency\n\n    self.inverter_gravimetric_index = 25.e3     # W/kg, Power density of inverters\n    self.inverter_efficiency = 0.995            # Inverter efficiency\n\n    self.wiring_gravimetric_index = 20.e3       # W/kg, Power density of wiring\n    self.wiring_efficiency = 0.995              # Wiring efficiency\n\n    self.motor_mass = None          # Mass of the engines\n    self.nacelle_mass = None        # Mass of the nacelles and mountings\n</code></pre>"},{"location":"reference/lh2pac/marilib/airship/airship/#lh2pac.marilib.airship.airship.Tank","title":"Tank","text":"<pre><code>Tank(phd)\n</code></pre> <p>               Bases: <code>object</code></p> <p>Tank object</p> Source code in <code>src/lh2pac/marilib/airship/airship.py</code> <pre><code>def __init__(self, phd):\n    self.phd = phd\n\n    self.h2_max_mass = None                     # Mass of liquid hydrogen stored in the cryogenic tank\n\n    self.h2_tank_gravimetric_index = 0.2    # kgH2/(kgH2+kgTank), Tank gravimetric index\n    self.h2_tank_volumetric_index = 50.     # kgH2/(m3H2+m3Tank), Tank volumetric index\n\n    self.tank_volume = None                 # Cryogenic tank volume\n    self.tank_mass = None                   # Cryogenic tank mass\n</code></pre>"},{"location":"reference/lh2pac/marilib/airship/airship_old/","title":"Airship old","text":""},{"location":"reference/lh2pac/marilib/airship/airship_old/#lh2pac.marilib.airship.airship_old","title":"airship_old","text":"<p>Created on November 20 20:20:20 2020 @author: Thierry DRUOT</p>"},{"location":"reference/lh2pac/marilib/airship/airship_old/#lh2pac.marilib.airship.airship_old-classes","title":"Classes","text":""},{"location":"reference/lh2pac/marilib/airship/airship_old/#lh2pac.marilib.airship.airship_old.Airship","title":"Airship","text":"<pre><code>Airship(\n    phd,\n    payload=10000.0,\n    range=unit.m_NM(1000.0),\n    altp=unit.m_ft(10000.0),\n    disa=0.0,\n    speed=unit.mps_kmph(100.0),\n)\n</code></pre> <p>               Bases: <code>object</code></p> <p>Airship object</p> Source code in <code>src/lh2pac/marilib/airship/airship_old.py</code> <pre><code>def __init__(self, phd, payload=10000., range=unit.m_NM(1000.), altp=unit.m_ft(10000.), disa=0., speed=unit.mps_kmph(100.)):\n    self.phd = phd\n\n    self.payload = payload      # Design mission payload\n    self.range = range          # Design mission range\n    self.cruise_altp = altp     # Reference cruise altitude\n    self.cruise_disa = disa     # Reference standard temperature shift in cruise\n    self.cruise_speed = speed   # Cruise speed\n\n    self.length_o_width_ratio = 3.  # Length over width ratio\n    self.length_o_height_ratio = 4. # Length over height ratio, WARNING l/h MUST BE HIGHER THAN l/w\n\n    self.length = None          # Length of the ellipsoide\n    self.width = None           # Width of the ellipsoide\n    self.height = None          # Height of the ellipsoide\n    self.gross_volume = None    # Total internal gross volume\n    self.gross_area = None      # External area\n\n    self.n_fin = 4              # Number of fins\n    self.fin_area = None        # Area of one fin\n\n    self.gondola_gravimetric_index = 0.200  # kg/kg, Mass of structure over max payload mass\n    self.gondola_volumetric_index = 0.020   # m3/kg, Volume of structure over max payload mass\n    self.envelop_gravimetric_index = 0.500  # kg/m2, Mass of structure over total gross area\n    self.envelop_volumetric_index = 0.020   # m3/m3, Volume of structure over total gross volume\n    self.buoyancy_reserve = 0.05            # m3/m3, Remaining air ballast volume over He volume at cruise altitude\n\n    self.he_max_volume = None       # Max He volume\n    self.he_max_mass = None         # Max He mass\n    self.air_max_volume = None      # Max air volume in the ballasts\n\n    self.envelop_mass = None        # Mass of the envelop\n    self.gondola_mass = None        # Mass of the gondola\n    self.owe = None                 # Design mission Operating Empty Weight\n    self.mtow = None                # Design mission Maximum Take Off Weight\n\n    self.reference_area = None      # Aerodynamic reference area\n    self.envelop_form_factor = 1.05 # Envelop form factor for drag estimation\n    self.fin_form_factor = 1.15     # Fin form factor for drag estimation\n\n    self.fuel_mission = None        # Design mission fuel\n    self.fuel_reserve = None        # Design mission reserve fuel\n    self.fuel_factor = 0.15         # fraction of mission fuel for reserve\n\n    # Propulsion system\n    #---------------------------------------------------------------------------------------------------------------\n    self.n_engine = None                # Number of engines\n    self.engine_power = None            # Engine shaft power\n\n    self.nacelle_propulsive_efficiency = 0.80   # Thrust*TAS / shaft_power, propeller efficiency\n    self.nacelle_gravimetric_index = 10.e3      # W/kg, Power density of electric motors\n\n    self.motor_gravimetric_index = 15.e3        # W/kg, Power density of electric motors\n    self.motor_efficiency = 0.95                # Electric motors efficiency\n\n    self.inverter_gravimetric_index = 25.e3     # W/kg, Power density of inverters\n    self.inverter_efficiency = 0.995            # Inverter efficiency\n\n    self.wiring_gravimetric_index = 20.e3       # W/kg, Power density of wiring\n    self.wiring_efficiency = 0.995              # Wiring efficiency\n\n    self.engine_mass = None             # Mass of the engines\n    self.nacelle_mass = None            # Nacelle and mountings mass\n\n    # Power system\n    #---------------------------------------------------------------------------------------------------------------\n    self.required_power = None          # Total required power\n    self.fuel_cell_ref_power = None     # Fuel cell design power\n    self.compressor_ref_power = None    # Compressor design power\n    self.cooling_ref_power = None       # Cooling system design power\n    self.heat_ref_power = None          # Dissipated heat power at design point\n\n    self.fuel_cell_gravimetric_index = 2.e3     # W/kg, Power density of fuel cell stacks\n    self.fuel_cell_efficiency = 0.50            # Fuel cell efficiency\n\n    self.compressor_gravimetric_index = 1.e3    # W/kg, Power density of the air compressor\n    self.compressor_over_pressure = 1.e5        # Pa, Compressor over pressure\n    self.compressor_efficiency = 0.80           # Air compressor efficiency\n\n    self.cooling_gravimetric_index = 5.e3       # W/kg, Dissipated power over cooling system mass\n    self.cooling_power_index = 0.005            # W/W, Required cooling system power over dissipated power\n\n    self.power_system_mass = None       # Mass of power system without motors and fuel cell\n    self.fuel_cell_mass = None          # Mass of the fuel cell stack\n\n    # Tank system\n    #---------------------------------------------------------------------------------------------------------------\n    self.h2_mass = None                     # Mass of liquid hydrogen stored in the cryogenic tank\n\n    self.h2_tank_gravimetric_index = 0.2    # kgH2/(kgH2+kgTank), Tank gravimetric index\n    self.h2_tank_volumetric_index = 0.6     # kgH2/(m3H2+m3Tank), Tank volumetric index\n\n    self.tank_mass = None                   # Cryogenic tank mass\n</code></pre>"},{"location":"reference/lh2pac/marilib/airship/airship_old/#lh2pac.marilib.airship.airship_old.Airship-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/airship/airship_old/#lh2pac.marilib.airship.airship_old.Airship.buoyancy_force","title":"buoyancy_force","text":"<pre><code>buoyancy_force(he_mass, pamb, tamb)\n</code></pre> <p>Compute the buoyancy force in given conditions</p> Source code in <code>src/lh2pac/marilib/airship/airship_old.py</code> <pre><code>def buoyancy_force(self, he_mass,pamb,tamb):\n    \"\"\"Compute the buoyancy force in given conditions\n    \"\"\"\n    g = 9.80665\n    rho_he = self.phd.gas_density(pamb,tamb,gas=\"helium\")\n    rho_air = self.phd.gas_density(pamb,tamb,gas=\"air\")\n    he_volume = he_mass / rho_he\n    air_mass = rho_air * he_volume\n    force = (air_mass - he_mass)*g\n    return force\n</code></pre>"},{"location":"reference/lh2pac/marilib/airship/airship_old/#lh2pac.marilib.airship.airship_old.Airship.eval_design","title":"eval_design","text":"<pre><code>eval_design(length, ne, power, h2_mass)\n</code></pre> <p>Compute geometrical datasc</p> Source code in <code>src/lh2pac/marilib/airship/airship_old.py</code> <pre><code>def eval_design(self, length, ne, power, h2_mass):\n    \"\"\"Compute geometrical datasc\n    \"\"\"\n    if self.length_o_width_ratio &gt; self.length_o_height_ratio:\n        raise Exception(\"length_o_width must be lower than length_o_height\")\n\n    self.n_engine = ne                  # Number of engines\n    self.engine_power = power           # Engine shaft power\n    self.h2_mass = h2_mass              # Mass of liquid hydrogen stored in the cryogenic tank\n\n    self.length = length                # Length of the ellipsoide\n    self.width = self.length / self.length_o_width_ratio\n    self.height = self.length / self.length_o_height_ratio\n\n    self.fin_area = (0.80 * self.length) / self.n_fin\n\n    self.gross_volume = (4./3.)*np.pi*self.length*self.width*self.height\n\n    a, b, c = self.length, self.width, self.height\n    cos_phi = c/a\n    phi = np.arccos(cos_phi)\n    sin_phi = np.sin(phi)\n    k2 = (a**2 * (b**2 - c**2)) / (b**2 * (a**2 - c**2))\n    F = ellipkinc(phi, k2)\n    E = ellipeinc(phi, k2)\n\n    self.gross_area = 2.*np.pi*c**2 + ((2.*np.pi*a*b)/sin_phi) * (E*sin_phi**2 + F*cos_phi**2)\n    self.reference_area = np.pi * a * b\n\n\n\n    # max He volume corresponds to max internal volume minus structure volume, buoyancy reserve, payload volume, fuel tank volume\n    self.max_he_volume =   (1. - self.envelop_volumetric_index - self.buoyancy_reserve) * self.gross_volume \\\n                         - self.gondola_volumetric_index * self.payload \\\n                         - self.h2_mass / self.h2_tank_volumetric_index\n\n    # Max He volume is computed at cruise altitude and high temperature\n    pamb,tamb,g = phd.atmosphere(self.cruise_altp, 25.)\n    self.he_max_mass = self.max_he_volume * phd.gas_density(pamb,tamb, gas=\"helium\")\n\n    # Max air volume is computed at sea level and low temperature\n    pamb0,tamb0,g = phd.atmosphere(0., -35.)\n    he_min_volume = self.he_max_mass / phd.gas_density(pamb0,tamb0, gas=\"helium\")\n    self.air_max_volume = self.max_he_volume - he_min_volume\n\n    self.envelop_mass = self.gross_area * self.envelop_gravimetric_index\n    self.gondola_mass = self.payload * self.gondola_gravimetric_index\n\n\n\n    self.required_power =    self.n_engine * self.engine_power \\\n                          / (self.motor_efficiency * self.inverter_efficiency * self.wiring_efficiency)\n\n    data_dict = self.fuel_cell_power(self.required_power,pamb,tamb)\n\n    self.fuel_cell_ref_power = data_dict[\"fuel_cell_power\"]\n    self.compressor_ref_power = data_dict[\"compressor_power\"]\n    self.cooling_ref_power = data_dict[\"cooling_power\"]\n    self.heat_ref_power = data_dict[\"heat_power\"]\n\n    self.fuel_cell_mass = self.fuel_cell_ref_power / self.fuel_cell_gravimetric_index\n\n    compressor_mass = self.compressor_ref_power / self.compressor_gravimetric_index\n    cooling_mass = self.heat_ref_power / self.cooling_gravimetric_index\n    wiring_mass = self.fuel_cell_ref_power / self.wiring_gravimetric_index\n    self.power_system_mass = compressor_mass + cooling_mass + wiring_mass\n\n    self.motor_mass = self.n_engine * self.engine_power / self.motor_gravimetric_index\n    self.nacelle_mass = self.n_engine * self.engine_power / self.nacelle_gravimetric_index\n\n    self.tank_mass = self.h2_mass * (1.-self.h2_tank_gravimetric_index)/self.h2_tank_gravimetric_index\n\n    self.owe =   self.envelop_mass \\\n               + self.gondola_mass \\\n               + self.power_system_mass \\\n               + self.nacelle_mass \\\n               + self.motor_mass \\\n               + self.tank_mass\n</code></pre>"},{"location":"reference/lh2pac/marilib/airship/airship_old/#lh2pac.marilib.airship.airship_old.Airship.eval_design_constraints","title":"eval_design_constraints","text":"<pre><code>eval_design_constraints()\n</code></pre> <p>Evaluate the 3 design constraints that applies on the airship</p> Source code in <code>src/lh2pac/marilib/airship/airship_old.py</code> <pre><code>def eval_design_constraints(self):\n    \"\"\"Evaluate the 3 design constraints that applies on the airship\n    \"\"\"\n    # Power constraint\n    pamb,tamb,g = phd.atmosphere(self.cruise_altp, self.cruise_disa)\n    thrust = self.drag_force(pamb,tamb,self.cruise_speed)\n    shaft_power = (thrust / self.n_engine) * self.cruise_speed / self.nacelle_propulsive_efficiency\n\n    # Energy constraint\n    req_power = self.req_power(pamb, tamb, self.cruise_speed, thrust)\n    fuel_flow = self.fuel_flow(pamb, tamb, self.cruise_speed, req_power)\n    time = self.range / self.cruise_speed\n    fuel_mass = fuel_flow * time * (1.+self.fuel_factor)\n\n    # Buoyancy constraint\n    buoyancy = self.buoyancy_force(self.he_max_mass,pamb,tamb)\n    mass = self.owe + self.payload + self.h2_mass\n\n    return {\"power\": self.engine_power - shaft_power,\n            \"energy\": self.h2_mass - fuel_mass,\n            \"buoyancy\": buoyancy - mass*g}\n</code></pre>"},{"location":"reference/lh2pac/marilib/airship/airship_old/#lh2pac.marilib.airship.airship_old.Airship.fuel_cell_power","title":"fuel_cell_power","text":"<pre><code>fuel_cell_power(required_power, pamb, tamb)\n</code></pre> <p>Compute the power delivered by fuel cell stack according to required power and ambiant conditions</p> Source code in <code>src/lh2pac/marilib/airship/airship_old.py</code> <pre><code>def fuel_cell_power(self, required_power,pamb,tamb):\n    \"\"\"Compute the power delivered by fuel cell stack according to required power and ambiant conditions\n    \"\"\"\n    r,gam,Cp,Cv = self.phd.gas_data()\n\n    fuel_heat = self.phd.fuel_heat(\"liquid_h2\")\n\n    # air_mass_flow = fuel_cell_power * relative_air_mass_flow\n    st_mass_ratio = self.phd.stoichiometry(\"air\",\"hydrogen\")\n    relative_fuel_flow = (1./self.fuel_cell_efficiency) / fuel_heat\n    relative_air_mass_flow = relative_fuel_flow * st_mass_ratio\n    relative_compressor_power = (1./self.compressor_efficiency)*(relative_air_mass_flow*Cv)*tamb*(((pamb+self.compressor_over_pressure)/pamb)**((gam-1.)/gam)-1.)\n\n    # heat_power = fuel_cell_power * relative_heat_power\n    relative_heat_power = (1.-self.fuel_cell_efficiency)/self.fuel_cell_efficiency\n    relative_cooling_power = relative_heat_power*self.cooling_power_index\n\n    fuel_cell_power = required_power / (1. - relative_compressor_power - relative_cooling_power)\n    fuel_flow = fuel_cell_power * relative_fuel_flow\n\n    compressor_power = fuel_cell_power * relative_compressor_power\n    heat_power = fuel_cell_power * relative_heat_power\n    cooling_power = heat_power * self.cooling_power_index\n\n    return {\"fuel_cell_power\":fuel_cell_power,\n            \"compressor_power\":compressor_power,\n            \"cooling_power\":cooling_power,\n            \"heat_power\":heat_power,\n            \"fuel_flow\":fuel_flow}\n</code></pre>"},{"location":"reference/lh2pac/marilib/airship/airship_old/#lh2pac.marilib.airship.airship_old.PhysicalData","title":"PhysicalData","text":"<pre><code>PhysicalData()\n</code></pre> <p>               Bases: <code>object</code></p> <p>Standard atmosphere</p> Source code in <code>src/lh2pac/marilib/airship/airship_old.py</code> <pre><code>def __init__(self):\n    pass\n</code></pre>"},{"location":"reference/lh2pac/marilib/airship/airship_old/#lh2pac.marilib.airship.airship_old.PhysicalData-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/airship/airship_old/#lh2pac.marilib.airship.airship_old.PhysicalData.air_viscosity","title":"air_viscosity","text":"<pre><code>air_viscosity(tamb)\n</code></pre> <p>Mixed gas dynamic viscosity, Sutherland's formula WARNING : result will not be accurate if gas is mixing components of too different molecular weights</p> Source code in <code>src/lh2pac/marilib/airship/airship_old.py</code> <pre><code>def air_viscosity(self, tamb):\n    \"\"\"Mixed gas dynamic viscosity, Sutherland's formula\n    WARNING : result will not be accurate if gas is mixing components of too different molecular weights\n    \"\"\"\n    mu0,T0,S = 1.715e-5, 273.15, 110.4\n    mu = (mu0*((T0+S)/(tamb+S))*(tamb/T0)**1.5)\n    return mu\n</code></pre>"},{"location":"reference/lh2pac/marilib/airship/airship_old/#lh2pac.marilib.airship.airship_old.PhysicalData.atmosphere","title":"atmosphere","text":"<pre><code>atmosphere(altp, disa=0.0)\n</code></pre> <p>Ambiant data from pressure altitude from ground to 50 km according to Standard Atmosphere</p> Source code in <code>src/lh2pac/marilib/airship/airship_old.py</code> <pre><code>def atmosphere(self, altp, disa=0.):\n    \"\"\"Ambiant data from pressure altitude from ground to 50 km according to Standard Atmosphere\n    \"\"\"\n    g = 9.80665\n    r = 287.053\n    gam = 1.4\n\n    Z = np.array([0., 11000., 20000., 32000., 47000., 50000.])\n    dtodz = np.array([-0.0065, 0., 0.0010, 0.0028, 0.])\n    P = np.array([101325., 0., 0., 0., 0., 0.])\n    T = np.array([288.15, 0., 0., 0., 0., 0.])\n\n    if (Z[-1] &lt; altp):\n        raise Exception(\"atmosphere, altitude cannot exceed 50km\")\n\n    j = 0\n    while (Z[1+j] &lt;= altp):\n        T[j+1] = T[j] + dtodz[j]*(Z[j+1]-Z[j])\n        if (0. &lt; np.abs(dtodz[j])):\n            P[j+1] = P[j]*(1. + (dtodz[j]/T[j]) * (Z[j+1]-Z[j]))**(-g/(r*dtodz[j]))\n        else:\n            P[j+1] = P[j]*np.exp(-(g/r)*((Z[j+1]-Z[j])/T[j]))\n        j = j + 1\n\n    if (0. &lt; np.abs(dtodz[j])):\n        pamb = P[j]*(1 + (dtodz[j]/T[j])*(altp-Z[j]))**(-g/(r*dtodz[j]))\n    else:\n        pamb = P[j]*np.exp(-(g/r)*((altp-Z[j])/T[j]))\n    tamb = T[j] + dtodz[j]*(altp-Z[j]) + disa\n    return pamb, tamb, g\n</code></pre>"},{"location":"reference/lh2pac/marilib/airship/airship_old/#lh2pac.marilib.airship.airship_old.PhysicalData.fuel_density","title":"fuel_density","text":"<pre><code>fuel_density(fuel_type, press=101325.0)\n</code></pre> <p>Reference fuel density</p> Source code in <code>src/lh2pac/marilib/airship/airship_old.py</code> <pre><code>def fuel_density(self, fuel_type, press=101325.):\n    \"\"\"Reference fuel density\n    \"\"\"\n    if (fuel_type==\"kerosene\"): return 803. # Kerosene : between 775-840 kg/m3\n    elif (fuel_type==\"liquid_h2\"): return 70.8 # Liquid hydrogene\n    elif (fuel_type==\"Compressed_h2\"):\n        p = press*1.e-5\n        return (-3.11480362e-05*p + 7.82320891e-02)*p + 1.03207822e-01 # Compressed hydrogen at 293.15 K\n    elif (fuel_type==\"methane\"): return 422.6 # Liquid methane\n    elif (fuel_type==\"battery\"): return 2800. # Lithium-ion\n    else: raise Exception(\"fuel_type key is unknown\")\n</code></pre>"},{"location":"reference/lh2pac/marilib/airship/airship_old/#lh2pac.marilib.airship.airship_old.PhysicalData.fuel_heat","title":"fuel_heat","text":"<pre><code>fuel_heat(fuel_type)\n</code></pre> <p>Reference fuel lower heating value or battery energy density</p> Source code in <code>src/lh2pac/marilib/airship/airship_old.py</code> <pre><code>def fuel_heat(self, fuel_type):\n    \"\"\"Reference fuel lower heating value or battery energy density\n    \"\"\"\n    if (fuel_type==\"kerosene\"): return 43.1e6 # J/kg, kerosene\n    elif (fuel_type==\"liquid_h2\"): return 121.0e6 # J/kg, liquid hydrogene\n    elif (fuel_type==\"Compressed_h2\"): return 140.0e6 # J/kg, compressed hydrogene\n    elif (fuel_type==\"methane\"): return 50.3e6 # J/kg, Liquid methane\n    elif (fuel_type==\"battery\"): return unit.J_Wh(200.) # J/kg, State of the art for lithium-ion\n    else: raise Exception(\"fuel_type index is out of range\")\n</code></pre>"},{"location":"reference/lh2pac/marilib/airship/airship_old/#lh2pac.marilib.airship.airship_old.PhysicalData.gas_data","title":"gas_data","text":"<pre><code>gas_data(gas='air')\n</code></pre> <p>Gas data for a single gas</p> Source code in <code>src/lh2pac/marilib/airship/airship_old.py</code> <pre><code>def gas_data(self, gas=\"air\"):\n    \"\"\"Gas data for a single gas\n    \"\"\"\n    r = {\"air\" : 287.053 ,\n         \"helium\" : 2077. ,\n         \"hydrogen\" : 4124.\n         }.get(gas, \"Erreur: type of gas is unknown\")\n\n    gam = {\"air\" : 1.40 ,\n           \"helium\" : 1.66 ,\n           \"hydrogen\" : 1.41\n           }.get(gas, \"Erreur: type of gas is unknown\")\n\n    cv = r/(gam-1.)\n    cp = gam*cv\n    return r,gam,cp,cv\n</code></pre>"},{"location":"reference/lh2pac/marilib/airship/airship_old/#lh2pac.marilib.airship.airship_old.PhysicalData.gas_density","title":"gas_density","text":"<pre><code>gas_density(pamb, tamb, gas='air')\n</code></pre> <p>Ideal gas density</p> Source code in <code>src/lh2pac/marilib/airship/airship_old.py</code> <pre><code>def gas_density(self, pamb,tamb, gas=\"air\"):\n    \"\"\"Ideal gas density\n    \"\"\"\n    r,gam,Cp,Cv = self.gas_data(gas)\n    rho = pamb / ( r * tamb )\n    return rho\n</code></pre>"},{"location":"reference/lh2pac/marilib/airship/airship_old/#lh2pac.marilib.airship.airship_old.PhysicalData.reynolds_number","title":"reynolds_number","text":"<pre><code>reynolds_number(pamb, tamb, tas)\n</code></pre> <p>Reynolds number based on Sutherland viscosity model</p> Source code in <code>src/lh2pac/marilib/airship/airship_old.py</code> <pre><code>def reynolds_number(self, pamb,tamb,tas):\n    \"\"\"Reynolds number based on Sutherland viscosity model\n    \"\"\"\n    rho = self.gas_density(pamb,tamb)\n    mu = self.air_viscosity(tamb)\n    re = rho*tas/mu\n    return re\n</code></pre>"},{"location":"reference/lh2pac/marilib/airship/airship_old/#lh2pac.marilib.airship.airship_old.PhysicalData.sound_speed","title":"sound_speed","text":"<pre><code>sound_speed(tamb)\n</code></pre> <p>Sound speed for ideal gas</p> Source code in <code>src/lh2pac/marilib/airship/airship_old.py</code> <pre><code>def sound_speed(self, tamb):\n    \"\"\"Sound speed for ideal gas\n    \"\"\"\n    r,gam,Cp,Cv = self.gas_data()\n    vsnd = np.sqrt( gam * r * tamb )\n    return vsnd\n</code></pre>"},{"location":"reference/lh2pac/marilib/airship/airship_old/#lh2pac.marilib.airship.airship_old.Power","title":"Power","text":"<pre><code>Power(phd)\n</code></pre> <p>               Bases: <code>object</code></p> <p>Power object</p> Source code in <code>src/lh2pac/marilib/airship/airship_old.py</code> <pre><code>def __init__(self, phd):\n    self.phd = phd\n\n    self.required_power = None          # Total required power\n    self.fuel_cell_ref_power = None     # Fuel cell design power\n    self.compressor_ref_power = None    # Compressor design power\n    self.cooling_ref_power = None       # Cooling system design power\n    self.heat_ref_power = None          # Dissipated heat power at design point\n\n    self.fuel_cell_gravimetric_index = 2.e3     # W/kg, Power density of fuel cell stacks\n    self.fuel_cell_efficiency = 0.50            # Fuel cell efficiency\n\n    self.compressor_gravimetric_index = 1.e3    # W/kg, Power density of the air compressor\n    self.compressor_over_pressure = 1.e5        # Pa, Compressor over pressure\n    self.compressor_efficiency = 0.80           # Air compressor efficiency\n\n    self.cooling_gravimetric_index = 5.e3       # W/kg, Dissipated power over cooling system mass\n    self.cooling_power_index = 0.005            # W/W, Required cooling system power over dissipated power\n\n    self.total_volumetric_index = 500.e3        # W/m3, Total power density of the power system\n\n    self.fuel_cell_mass = None          # Mass of the fuel cell stack\n    self.compressor_mass = None         # Mass of the air compressor\n    self.cooling_mass = None            # Mass of the cooling system\n\n    self.power_system_volume = None     # Volume of the power system\n    self.power_system_mass = None       # Mass of the power system including fuel cell stacks\n</code></pre>"},{"location":"reference/lh2pac/marilib/airship/airship_old/#lh2pac.marilib.airship.airship_old.Power-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/airship/airship_old/#lh2pac.marilib.airship.airship_old.Power.fuel_cell_power","title":"fuel_cell_power","text":"<pre><code>fuel_cell_power(required_power, pamb, tamb)\n</code></pre> <p>Compute the power delivered by fuel cell stack according to required power and ambiant conditions</p> Source code in <code>src/lh2pac/marilib/airship/airship_old.py</code> <pre><code>def fuel_cell_power(self, required_power,pamb,tamb):\n    \"\"\"Compute the power delivered by fuel cell stack according to required power and ambiant conditions\n    \"\"\"\n    r,gam,Cp,Cv = self.phd.gas_data()\n\n    fuel_heat = self.phd.fuel_heat(\"liquid_h2\")\n\n    # air_mass_flow = fuel_cell_power * relative_air_mass_flow\n    st_mass_ratio = self.phd.stoichiometry(\"air\",\"hydrogen\")\n    relative_fuel_flow = (1./self.fuel_cell_efficiency) / fuel_heat\n    relative_air_mass_flow = relative_fuel_flow * st_mass_ratio\n    relative_compressor_power = (1./self.compressor_efficiency)*(relative_air_mass_flow*Cv)*tamb*(((pamb+self.compressor_over_pressure)/pamb)**((gam-1.)/gam)-1.)\n\n    # heat_power = fuel_cell_power * relative_heat_power\n    relative_heat_power = (1.-self.fuel_cell_efficiency)/self.fuel_cell_efficiency\n    relative_cooling_power = relative_heat_power*self.cooling_power_index\n\n    fuel_cell_power = required_power / (1. - relative_compressor_power - relative_cooling_power)\n    fuel_flow = fuel_cell_power * relative_fuel_flow\n\n    compressor_power = fuel_cell_power * relative_compressor_power\n    heat_power = fuel_cell_power * relative_heat_power\n    cooling_power = heat_power * self.cooling_power_index\n\n    return {\"fuel_cell_power\":fuel_cell_power,\n            \"compressor_power\":compressor_power,\n            \"cooling_power\":cooling_power,\n            \"heat_power\":heat_power,\n            \"fuel_flow\":fuel_flow}\n</code></pre>"},{"location":"reference/lh2pac/marilib/airship/airship_old/#lh2pac.marilib.airship.airship_old.Propulsion","title":"Propulsion","text":"<pre><code>Propulsion(phd, ne=6.0, power=unit.W_kW(40.0))\n</code></pre> <p>               Bases: <code>object</code></p> <p>Propulsion object</p> Source code in <code>src/lh2pac/marilib/airship/airship_old.py</code> <pre><code>def __init__(self, phd, ne=6., power=unit.W_kW(40.)):\n    self.phd = phd\n\n    self.n_engine = None                # Number of engines\n    self.engine_power = None            # Engine shaft power\n\n    self.nacelle_propulsive_efficiency = 0.80   # Thrust*TAS / shaft_power, propeller efficiency\n    self.nacelle_gravimetric_index = 10.e3      # W/kg, Power density of electric motors\n\n    self.motor_gravimetric_index = 15.e3        # W/kg, Power density of electric motors\n    self.motor_efficiency = 0.95                # Electric motors efficiency\n\n    self.inverter_gravimetric_index = 25.e3     # W/kg, Power density of inverters\n    self.inverter_efficiency = 0.995            # Inverter efficiency\n\n    self.wiring_gravimetric_index = 20.e3       # W/kg, Power density of wiring\n    self.wiring_efficiency = 0.995              # Wiring efficiency\n\n    self.motor_mass = None          # Mass of the engines\n    self.nacelle_mass = None        # Mass of the nacelles and mountings\n\n    self.design(ne, power)\n</code></pre>"},{"location":"reference/lh2pac/marilib/airship/airship_old/#lh2pac.marilib.airship.airship_old.Tank","title":"Tank","text":"<pre><code>Tank(phd, h2_mass)\n</code></pre> <p>               Bases: <code>object</code></p> <p>Tank object</p> Source code in <code>src/lh2pac/marilib/airship/airship_old.py</code> <pre><code>def __init__(self, phd, h2_mass):\n    self.phd = phd\n\n    self.h2_mass = None                     # Mass of liquid hydrogen stored in the cryogenic tank\n\n    self.h2_tank_gravimetric_index = 0.2    # kgH2/(kgH2+kgTank), Tank gravimetric index\n    self.h2_tank_volumetric_index = 0.6     # kgH2/(m3H2+m3Tank), Tank volumetric index\n\n    self.tank_volume = None                 # Cryogenic tank volume\n    self.tank_mass = None                   # Cryogenic tank mass\n\n    self.design(h2_mass)\n</code></pre>"},{"location":"reference/lh2pac/marilib/airship/physical_data/","title":"Physical data","text":""},{"location":"reference/lh2pac/marilib/airship/physical_data/#lh2pac.marilib.airship.physical_data","title":"physical_data","text":"<p>Created on November 20 20:20:20 2020 @author: Thierry DRUOT</p>"},{"location":"reference/lh2pac/marilib/airship/physical_data/#lh2pac.marilib.airship.physical_data-classes","title":"Classes","text":""},{"location":"reference/lh2pac/marilib/airship/physical_data/#lh2pac.marilib.airship.physical_data.PhysicalData","title":"PhysicalData","text":"<pre><code>PhysicalData()\n</code></pre> <p>               Bases: <code>object</code></p> <p>Standard atmosphere</p> Source code in <code>src/lh2pac/marilib/airship/physical_data.py</code> <pre><code>def __init__(self):\n    pass\n</code></pre>"},{"location":"reference/lh2pac/marilib/airship/physical_data/#lh2pac.marilib.airship.physical_data.PhysicalData-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/airship/physical_data/#lh2pac.marilib.airship.physical_data.PhysicalData.air_viscosity","title":"air_viscosity","text":"<pre><code>air_viscosity(tamb)\n</code></pre> <p>Mixed gas dynamic viscosity, Sutherland's formula WARNING : result will not be accurate if gas is mixing components of too different molecular weights</p> Source code in <code>src/lh2pac/marilib/airship/physical_data.py</code> <pre><code>def air_viscosity(self, tamb):\n    \"\"\"Mixed gas dynamic viscosity, Sutherland's formula\n    WARNING : result will not be accurate if gas is mixing components of too different molecular weights\n    \"\"\"\n    mu0,T0,S = 1.715e-5, 273.15, 110.4\n    mu = (mu0*((T0+S)/(tamb+S))*(tamb/T0)**1.5)\n    return mu\n</code></pre>"},{"location":"reference/lh2pac/marilib/airship/physical_data/#lh2pac.marilib.airship.physical_data.PhysicalData.atmosphere","title":"atmosphere","text":"<pre><code>atmosphere(altp, disa=0.0)\n</code></pre> <p>Ambiant data from pressure altitude from ground to 50 km according to Standard Atmosphere</p> Source code in <code>src/lh2pac/marilib/airship/physical_data.py</code> <pre><code>def atmosphere(self, altp, disa=0.):\n    \"\"\"Ambiant data from pressure altitude from ground to 50 km according to Standard Atmosphere\n    \"\"\"\n    g = 9.80665\n    r = 287.053\n    gam = 1.4\n\n    Z = np.array([0., 11000., 20000., 32000., 47000., 50000.])\n    dtodz = np.array([-0.0065, 0., 0.0010, 0.0028, 0.])\n    P = np.array([101325., 0., 0., 0., 0., 0.])\n    T = np.array([288.15, 0., 0., 0., 0., 0.])\n\n    if (Z[-1] &lt; altp):\n        raise Exception(\"atmosphere, altitude cannot exceed 50km\")\n\n    j = 0\n    while (Z[1+j] &lt;= altp):\n        T[j+1] = T[j] + dtodz[j]*(Z[j+1]-Z[j])\n        if (0. &lt; np.abs(dtodz[j])):\n            P[j+1] = P[j]*(1. + (dtodz[j]/T[j]) * (Z[j+1]-Z[j]))**(-g/(r*dtodz[j]))\n        else:\n            P[j+1] = P[j]*np.exp(-(g/r)*((Z[j+1]-Z[j])/T[j]))\n        j = j + 1\n\n    if (0. &lt; np.abs(dtodz[j])):\n        pamb = P[j]*(1 + (dtodz[j]/T[j])*(altp-Z[j]))**(-g/(r*dtodz[j]))\n    else:\n        pamb = P[j]*np.exp(-(g/r)*((altp-Z[j])/T[j]))\n    tamb = T[j] + dtodz[j]*(altp-Z[j]) + disa\n    return pamb, tamb, g\n</code></pre>"},{"location":"reference/lh2pac/marilib/airship/physical_data/#lh2pac.marilib.airship.physical_data.PhysicalData.fuel_density","title":"fuel_density","text":"<pre><code>fuel_density(fuel_type, press=101325.0)\n</code></pre> <p>Reference fuel density</p> Source code in <code>src/lh2pac/marilib/airship/physical_data.py</code> <pre><code>def fuel_density(self, fuel_type, press=101325.):\n    \"\"\"Reference fuel density\n    \"\"\"\n    if (fuel_type==\"kerosene\"): return 803. # Kerosene : between 775-840 kg/m3\n    elif (fuel_type==\"liquid_h2\"): return 70.8 # Liquid hydrogene\n    elif (fuel_type==\"Compressed_h2\"):\n        p = press*1.e-5\n        return (-3.11480362e-05*p + 7.82320891e-02)*p + 1.03207822e-01 # Compressed hydrogen at 293.15 K\n    elif (fuel_type==\"methane\"): return 422.6 # Liquid methane\n    elif (fuel_type==\"battery\"): return 2800. # Lithium-ion\n    else: raise Exception(\"fuel_type key is unknown\")\n</code></pre>"},{"location":"reference/lh2pac/marilib/airship/physical_data/#lh2pac.marilib.airship.physical_data.PhysicalData.fuel_heat","title":"fuel_heat","text":"<pre><code>fuel_heat(fuel_type)\n</code></pre> <p>Reference fuel lower heating value or battery energy density</p> Source code in <code>src/lh2pac/marilib/airship/physical_data.py</code> <pre><code>def fuel_heat(self, fuel_type):\n    \"\"\"Reference fuel lower heating value or battery energy density\n    \"\"\"\n    if (fuel_type==\"kerosene\"): return 43.1e6 # J/kg, kerosene\n    elif (fuel_type==\"liquid_h2\"): return 121.0e6 # J/kg, liquid hydrogene\n    elif (fuel_type==\"Compressed_h2\"): return 140.0e6 # J/kg, compressed hydrogene\n    elif (fuel_type==\"methane\"): return 50.3e6 # J/kg, Liquid methane\n    elif (fuel_type==\"battery\"): return unit.J_Wh(200.) # J/kg, State of the art for lithium-ion\n    else: raise Exception(\"fuel_type index is out of range\")\n</code></pre>"},{"location":"reference/lh2pac/marilib/airship/physical_data/#lh2pac.marilib.airship.physical_data.PhysicalData.gas_data","title":"gas_data","text":"<pre><code>gas_data(gas='air')\n</code></pre> <p>Gas data for a single gas</p> Source code in <code>src/lh2pac/marilib/airship/physical_data.py</code> <pre><code>def gas_data(self, gas=\"air\"):\n    \"\"\"Gas data for a single gas\n    \"\"\"\n    r = {\"air\" : 287.053 ,\n         \"helium\" : 2077. ,\n         \"hydrogen\" : 4124.\n         }.get(gas, \"Erreur: type of gas is unknown\")\n\n    gam = {\"air\" : 1.40 ,\n           \"helium\" : 1.66 ,\n           \"hydrogen\" : 1.41\n           }.get(gas, \"Erreur: type of gas is unknown\")\n\n    cv = r/(gam-1.)\n    cp = gam*cv\n    return r,gam,cp,cv\n</code></pre>"},{"location":"reference/lh2pac/marilib/airship/physical_data/#lh2pac.marilib.airship.physical_data.PhysicalData.gas_density","title":"gas_density","text":"<pre><code>gas_density(pamb, tamb, gas='air')\n</code></pre> <p>Ideal gas density</p> Source code in <code>src/lh2pac/marilib/airship/physical_data.py</code> <pre><code>def gas_density(self, pamb,tamb, gas=\"air\"):\n    \"\"\"Ideal gas density\n    \"\"\"\n    r,gam,Cp,Cv = self.gas_data(gas)\n    rho = pamb / ( r * tamb )\n    return rho\n</code></pre>"},{"location":"reference/lh2pac/marilib/airship/physical_data/#lh2pac.marilib.airship.physical_data.PhysicalData.reynolds_number","title":"reynolds_number","text":"<pre><code>reynolds_number(pamb, tamb, tas)\n</code></pre> <p>Reynolds number based on Sutherland viscosity model</p> Source code in <code>src/lh2pac/marilib/airship/physical_data.py</code> <pre><code>def reynolds_number(self, pamb,tamb,tas):\n    \"\"\"Reynolds number based on Sutherland viscosity model\n    \"\"\"\n    rho = self.gas_density(pamb,tamb)\n    mu = self.air_viscosity(tamb)\n    re = rho*tas/mu\n    return re\n</code></pre>"},{"location":"reference/lh2pac/marilib/airship/physical_data/#lh2pac.marilib.airship.physical_data.PhysicalData.sound_speed","title":"sound_speed","text":"<pre><code>sound_speed(tamb)\n</code></pre> <p>Sound speed for ideal gas</p> Source code in <code>src/lh2pac/marilib/airship/physical_data.py</code> <pre><code>def sound_speed(self, tamb):\n    \"\"\"Sound speed for ideal gas\n    \"\"\"\n    r,gam,Cp,Cv = self.gas_data()\n    vsnd = np.sqrt( gam * r * tamb )\n    return vsnd\n</code></pre>"},{"location":"reference/lh2pac/marilib/airship/trajectory/","title":"Trajectory","text":""},{"location":"reference/lh2pac/marilib/airship/trajectory/#lh2pac.marilib.airship.trajectory","title":"trajectory","text":"<p>Created on November 20 20:20:20 2020 @author: Thierry DRUOT</p>"},{"location":"reference/lh2pac/marilib/airship/trajectory/#lh2pac.marilib.airship.trajectory-classes","title":"Classes","text":""},{"location":"reference/lh2pac/marilib/airship/trajectory/#lh2pac.marilib.airship.trajectory.AirShip","title":"AirShip","text":"<pre><code>AirShip(mass, width)\n</code></pre> <p>               Bases: <code>object</code></p> Source code in <code>src/lh2pac/marilib/airship/trajectory.py</code> <pre><code>def __init__(self, mass, width):\n\n    self.mass = mass\n    self.area_ref = 0.25*np.pi*width**2     # Width is taken as the mean diameter of the airship\n    self.cx = 0.5                           # TODO : check this value\n</code></pre>"},{"location":"reference/lh2pac/marilib/airship/trajectory/#lh2pac.marilib.airship.trajectory.AirShip-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/airship/trajectory/#lh2pac.marilib.airship.trajectory.AirShip.drag","title":"drag","text":"<pre><code>drag(rho, vgnd, wind)\n</code></pre> <p>Compute drag force on the airship</p> Source code in <code>src/lh2pac/marilib/airship/trajectory.py</code> <pre><code>def drag(self,rho,vgnd,wind):\n    \"\"\"Compute drag force on the airship\n    \"\"\"\n    vair = vgnd - wind\n    return -0.5*rho*self.area_ref*self.cx*lin.norm(vair)*vair\n</code></pre>"},{"location":"reference/lh2pac/marilib/airship/trajectory/#lh2pac.marilib.airship.trajectory.AirShip.state_dot","title":"state_dot","text":"<pre><code>state_dot(t, state)\n</code></pre> <p>Compute the derivative of the state vector Note that all speed coordinates are in the local frame X : Eastward, Y : Northward, Z : Upward WARNING : in its present form, vertical acceleration is not correct as buoyancy is not considered</p> Source code in <code>src/lh2pac/marilib/airship/trajectory.py</code> <pre><code>def state_dot(self, t, state):\n    \"\"\"Compute the derivative of the state vector\n    Note that all speed coordinates are in the local frame X : Eastward, Y : Northward, Z : Upward\n    WARNING : in its present form, vertical acceleration is not correct as buoyancy is not considered\n    \"\"\"\n    earth_radius = 6371229.            # From ERA5 doc relative to GRIB2 TODO : Check if GRIB2 are used\n\n    lng,lat,alt,vx,vy,vz = state\n    pamb,tamb,rho,wx,wy,wz = air([lng,lat,alt])\n    vgnd = np.array([vx,vy,vz])\n    wind = np.array([wx,wy,wz])\n    drag = self.drag(rho,vgnd,wind)\n    state_d = np.array([vx/(earth_radius+alt),\n                        vy/(earth_radius+alt),\n                        vz/(earth_radius+alt),\n                        drag[0]/self.mass,\n                        drag[1]/self.mass,\n                        drag[2]/self.mass])\n    return state_d\n</code></pre>"},{"location":"reference/lh2pac/marilib/airship/trajectory/#lh2pac.marilib.airship.trajectory.AirShip.trajectory","title":"trajectory","text":"<pre><code>trajectory(to, t1, dt, pos, spd)\n</code></pre> <p>Compute the trajectory from given position and initial speed and over a given time frame Note that dt is only used to define a time step for trajectory description in the output</p> Source code in <code>src/lh2pac/marilib/airship/trajectory.py</code> <pre><code>def trajectory(self,to,t1,dt,pos,spd):\n    \"\"\"Compute the trajectory from given position and initial speed and over a given time frame\n    Note that dt is only used to define a time step for trajectory description in the output\n    \"\"\"\n    lng,lat,alt = pos   # WARNING lng and lat are in radians, alt is in m above earth radius\n    vx, vy, vz = spd    # WARNING vx, vy and vz represent ground speed and are in m/s\n\n    t_eval = np.linspace(t0,t1,int((t1-t0)/dt))\n    state0 = np.array([lng,lat,alt,vx,vy,vz])\n\n    sol = solve_ivp(self.state_dot, [t0,t1], state0, t_eval=t_eval, method=\"RK45\")\n\n    time = sol.t\n    long = sol.y[0]\n    latt = sol.y[1]\n    altp = sol.y[2]\n\n    return [time,long,latt,altp]\n</code></pre>"},{"location":"reference/lh2pac/marilib/airship/trajectory/#lh2pac.marilib.airship.trajectory-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/airship/trajectory/#lh2pac.marilib.airship.trajectory.air","title":"air","text":"<pre><code>air(pos)\n</code></pre> <p>Simulation of atmospheric data, use interpolation into ERA5 in place</p> Source code in <code>src/lh2pac/marilib/airship/trajectory.py</code> <pre><code>def air(pos):\n    \"\"\"Simulation of atmospheric data, use interpolation into ERA5 in place\n    \"\"\"\n    lng, lat, alt = pos\n    pamb,tamb,rho = atmosphere(alt)     # WARNING : go around as no pressure and temperature are available\n    wx,wy,wz = [10., 0., 0.]            # WARNING : Wind is fixed here : 10 m/s Eastward\n    return pamb,tamb,rho,wx,wy,wz\n</code></pre>"},{"location":"reference/lh2pac/marilib/airship/trajectory/#lh2pac.marilib.airship.trajectory.atmosphere","title":"atmosphere","text":"<pre><code>atmosphere(altp, disa=0.0)\n</code></pre> <p>Ambiant data from pressure altitude from ground to 50 km according to Standard Atmosphere</p> Source code in <code>src/lh2pac/marilib/airship/trajectory.py</code> <pre><code>def atmosphere(altp, disa=0.):\n    \"\"\"Ambiant data from pressure altitude from ground to 50 km according to Standard Atmosphere\n    \"\"\"\n    g = 9.80665\n    r = 287.053\n    gam = 1.4\n\n    Z = np.array([0., 11000., 20000., 32000., 47000., 50000.])\n    dtodz = np.array([-0.0065, 0., 0.0010, 0.0028, 0.])\n    P = np.array([101325., 0., 0., 0., 0., 0.])\n    T = np.array([288.15, 0., 0., 0., 0., 0.])\n\n    if (Z[-1] &lt; altp):\n        raise Exception(\"atmosphere, altitude cannot exceed 50km\")\n\n    j = 0\n    while (Z[1+j] &lt;= altp):\n        T[j+1] = T[j] + dtodz[j]*(Z[j+1]-Z[j])\n        if (0. &lt; np.abs(dtodz[j])):\n            P[j+1] = P[j]*(1. + (dtodz[j]/T[j]) * (Z[j+1]-Z[j]))**(-g/(r*dtodz[j]))\n        else:\n            P[j+1] = P[j]*np.exp(-(g/r)*((Z[j+1]-Z[j])/T[j]))\n        j = j + 1\n\n    if (0. &lt; np.abs(dtodz[j])):\n        pamb = P[j]*(1 + (dtodz[j]/T[j])*(altp-Z[j]))**(-g/(r*dtodz[j]))\n    else:\n        pamb = P[j]*np.exp(-(g/r)*((altp-Z[j])/T[j]))\n    tamb = T[j] + dtodz[j]*(altp-Z[j]) + disa\n    rho = pamb / ( r * tamb )\n    return pamb, tamb, rho\n</code></pre>"},{"location":"reference/lh2pac/marilib/utils/","title":"Utils","text":""},{"location":"reference/lh2pac/marilib/utils/#lh2pac.marilib.utils","title":"utils","text":""},{"location":"reference/lh2pac/marilib/utils/earth/","title":"Earth","text":""},{"location":"reference/lh2pac/marilib/utils/earth/#lh2pac.marilib.utils.earth","title":"earth","text":"<p>Created on Thu Jan 24 23:22:21 2019</p> <p>@author: DRUOT Thierry : original Scilab implementation          PETEILH Nicolas : portage to Python</p>"},{"location":"reference/lh2pac/marilib/utils/earth/#lh2pac.marilib.utils.earth-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/utils/earth/#lh2pac.marilib.utils.earth.air_density","title":"air_density","text":"<pre><code>air_density(pamb, tamb)\n</code></pre> <p>Ideal gas density</p> Source code in <code>src/lh2pac/marilib/utils/earth.py</code> <pre><code>def air_density(pamb,tamb):\n    \"\"\"Ideal gas density\n    \"\"\"\n    r,gam,Cp,Cv = gas_data()\n    rho0 = sea_level_density()\n    rho = pamb / ( r * tamb )\n    sig = rho / rho0\n    return rho, sig\n</code></pre>"},{"location":"reference/lh2pac/marilib/utils/earth/#lh2pac.marilib.utils.earth.altg_from_altp","title":"altg_from_altp","text":"<pre><code>altg_from_altp(altp, disa)\n</code></pre> <p>Geometrical altitude from pressure altitude</p> Source code in <code>src/lh2pac/marilib/utils/earth.py</code> <pre><code>def altg_from_altp(altp,disa):\n    \"\"\"Geometrical altitude from pressure altitude\n    \"\"\"\n    def fct(altg,altp,disa):\n        pamb,tamb,dtodz = atmosphere_geo(altg,disa)\n        zp = pressure_altitude(pamb)\n        return altp-zp\n\n    output_dict = fsolve(fct, x0=altp, args=(altp,disa), full_output=True)\n\n    altg = output_dict[0][0]\n    if (output_dict[2]!=1): raise Exception(\"Convergence problem\")\n\n    return altg\n</code></pre>"},{"location":"reference/lh2pac/marilib/utils/earth/#lh2pac.marilib.utils.earth.atmosphere","title":"atmosphere","text":"<pre><code>atmosphere(altp, disa)\n</code></pre> <p>Pressure and temperature from pressure altitude from ground to 50 km</p> Source code in <code>src/lh2pac/marilib/utils/earth.py</code> <pre><code>def atmosphere(altp,disa):\n    \"\"\"Pressure and temperature from pressure altitude from ground to 50 km\n    \"\"\"\n    g = gravity()\n    R,gam,Cp,Cv = gas_data()\n\n    Z = numpy.array([0., 11000., 20000.,32000., 47000., 50000.])\n    dtodz = numpy.array([-0.0065, 0., 0.0010, 0.0028, 0.])\n\n    P = numpy.array([sea_level_pressure(), 0., 0., 0., 0., 0.])\n    T = numpy.array([sea_level_temperature(), 0., 0., 0., 0., 0.])\n\n    if (Z[-1]&lt;altp):\n        raise Exception(\"atmosphere, altitude cannot exceed 50km\")\n\n    j = 0\n\n    while (Z[1+j]&lt;=altp):\n        T[j+1] = T[j] + dtodz[j]*(Z[j+1]-Z[j])\n        if (0.&lt;numpy.abs(dtodz[j])):\n            P[j+1] = P[j]*(1. + (dtodz[j]/T[j])*(Z[j+1]-Z[j]))**(-g/(R*dtodz[j]))\n        else:\n            P[j+1] = P[j]*numpy.exp(-(g/R)*((Z[j+1]-Z[j])/T[j]))\n        j = j + 1\n\n    if (0.&lt;numpy.abs(dtodz[j])):\n        pamb = P[j]*(1 + (dtodz[j]/T[j])*(altp-Z[j]))**(-g/(R*dtodz[j]))\n    else:\n        pamb = P[j]*numpy.exp(-(g/R)*((altp-Z[j])/T[j]))\n    tstd = T[j] + dtodz[j]*(altp-Z[j])\n    tamb = tstd + disa\n\n    return pamb,tamb,tstd,dtodz[j]\n</code></pre>"},{"location":"reference/lh2pac/marilib/utils/earth/#lh2pac.marilib.utils.earth.atmosphere_geo","title":"atmosphere_geo","text":"<pre><code>atmosphere_geo(altg, disa)\n</code></pre> <p>Pressure and temperature from geometrical altitude from ground to 50 km</p> Source code in <code>src/lh2pac/marilib/utils/earth.py</code> <pre><code>def atmosphere_geo(altg,disa):\n    \"\"\"Pressure and temperature from geometrical altitude from ground to 50 km\n    \"\"\"\n    g = gravity()\n    R,gam,Cp,Cv = gas_data()\n\n    Zi = numpy.array([0., 11000., 20000.,32000., 47000., 50000.])\n    dtodzi = numpy.array([-0.0065, 0., 0.0010, 0.0028, 0.])\n\n    Z = numpy.zeros_like(Zi)\n    dtodz = numpy.zeros_like(dtodzi)\n\n    P = numpy.array([sea_level_pressure(), 0., 0., 0., 0., 0.])\n    T = numpy.array([sea_level_temperature(), 0., 0., 0., 0., 0.])\n\n    K = 1 + disa/T[0]\n    dtodz[0] = dtodzi[0]/K\n    Z[1] = Z[0] + (Zi[1]-Zi[0])*K\n\n    n = len(P)-1\n    j = 0\n\n    while (j&lt;n and Z[1+j]&lt;=altg):\n        T[j+1] = T[j] + dtodz[j]*(Z[j+1]-Z[j])\n        if (0.&lt;numpy.abs(dtodz[j])):\n            P[j+1] = P[j]*(1. + (dtodz[j]/(T[j]+disa))*(Z[j+1]-Z[j]))**(-g/(R*dtodz[j]))\n        else:\n            P[j+1] = P[j]*numpy.exp(-(g/R)*((Z[j+1]-Z[j])/(T[j]+disa)))\n        j = j + 1\n        K = 1 + disa/T[j]\n        dtodz[j] = dtodzi[j]/K\n        Z[j+1] = Z[j] + (Zi[j+1]-Zi[j])*K\n\n    if (Z[1+j]&lt;altg):\n        raise Exception(\"atmosphere_geo, altitude cannot exceed 50km\")\n\n    if (0.&lt;numpy.abs(dtodz[j])):\n        pamb = P[j]*(1 + (dtodz[j]/(T[j]+disa))*(altg-Z[j]))**(-g/(R*dtodz[j]))\n    else:\n        pamb = P[j]*numpy.exp(-(g/R)*((altg-Z[j])/(T[j]+disa)))\n    tamb = T[j] + dtodz[j]*(altg-Z[j]) + disa\n\n    return pamb,tamb,dtodz[j]\n</code></pre>"},{"location":"reference/lh2pac/marilib/utils/earth/#lh2pac.marilib.utils.earth.climb_mode","title":"climb_mode","text":"<pre><code>climb_mode(speed_mode, mach, dtodz, tstd, disa)\n</code></pre> <p>Acceleration factor depending on speed driver ('cas': constant CAS, 'mach': constant Mach) WARNING : input is mach number whatever speed_mode</p> Source code in <code>src/lh2pac/marilib/utils/earth.py</code> <pre><code>def climb_mode(speed_mode,mach,dtodz,tstd,disa):\n    \"\"\"Acceleration factor depending on speed driver ('cas': constant CAS, 'mach': constant Mach)\n    WARNING : input is mach number whatever speed_mode\n    \"\"\"\n    g = gravity()\n    r,gam,Cp,Cv = gas_data()\n\n    if (speed_mode==\"cas\"):\n        fac = (gam-1.)/2.\n        acc_factor = 1. + (((1.+fac*mach**2)**(gam/(gam-1.))-1.)/(1.+fac*mach**2)**(1./(gam-1.))) \\\n                        + ((gam*r)/(2.*g))*(mach**2)*(tstd/(tstd+disa))*dtodz\n    elif (speed_mode==\"mach\"):\n        acc_factor = 1. + ((gam*r)/(2.*g))*(mach**2)*(tstd/(tstd+disa))*dtodz\n    else:\n        raise Exception(\"climb_mode key is unknown\")\n\n    return acc_factor\n</code></pre>"},{"location":"reference/lh2pac/marilib/utils/earth/#lh2pac.marilib.utils.earth.cross_over_altp","title":"cross_over_altp","text":"<pre><code>cross_over_altp(Vcas, mach)\n</code></pre> <p>Altitude where constant calibrated air speed meets constant Mach number, subsonic only</p> Source code in <code>src/lh2pac/marilib/utils/earth.py</code> <pre><code>def cross_over_altp(Vcas,mach):\n    \"\"\"Altitude where constant calibrated air speed meets constant Mach number, subsonic only\n    \"\"\"\n    r,gam,Cp,Cv = gas_data()\n    P0 = sea_level_pressure()\n    vc0 = sea_level_sound_speed()\n    fac = gam/(gam-1)\n\n    pamb = ((1.+((gam-1.)/2.)*(Vcas/vc0)**2)**fac-1.)*P0/((1.+((gam-1.)/2.)*mach**2)**fac-1.)\n\n    altp = pressure_altitude(pamb)\n    return altp\n</code></pre>"},{"location":"reference/lh2pac/marilib/utils/earth/#lh2pac.marilib.utils.earth.emission_index","title":"emission_index","text":"<pre><code>emission_index(fuel_type, compound)\n</code></pre> <p>Various emitted compound depending on energy source</p> Source code in <code>src/lh2pac/marilib/utils/earth.py</code> <pre><code>def emission_index(fuel_type,compound):\n    \"\"\"Various emitted compound depending on energy source\n    \"\"\"\n    if (fuel_type in [\"kerosene\"]):\n        index = {\"CO2\" : 3140./1000.,\n                 \"H2O\" : 1290./1000.,\n                 \"SO2\" : 0.8/1000.,\n                 \"NOx\" : 14./1000.,\n                 \"CO\" : 3./1000.,\n                 \"HC\" : 0.4/1000.,\n                 \"sulfuric_acid\" : 0.04/1000.,\n                 \"nitrous_acid\" : 0.4/1000.,\n                 \"nitric_acid\" : 0.2/1000.,\n                 \"soot\" : 2.5e12}\n        return index.get(compound)\n    elif (fuel_type in [\"liquid_h2\", \"Compressed_h2\"]):\n        index = {\"CO2\" : 0.,\n                 \"H2O\" : 18000./1000.,\n                 \"SO2\" : 0.,\n                 \"NOx\" : 14./1000.,\n                 \"CO\" : 0.,\n                 \"HC\" : 0.,\n                 \"sulfuric_acid\" : 0.,\n                 \"nitrous_acid\" : 0.4/1000.,\n                 \"nitric_acid\" : 0.2/1000.,\n                 \"soot\" : 2.0e12}\n        return index.get(compound)\n    elif (fuel_type in [\"battery\"]):\n        index = {\"CO2\" : 0.,\n                 \"H2O\" : 0.,\n                 \"SO2\" : 0.,\n                 \"NOx\" : 0.,\n                 \"CO\" : 0.,\n                 \"HC\" : 0.,\n                 \"sulfuric_acid\" : 0.,\n                 \"nitrous_acid\" : 0.,\n                 \"nitric_acid\" : 0.,\n                 \"soot\" : 0.}\n        return index.get(compound)\n</code></pre>"},{"location":"reference/lh2pac/marilib/utils/earth/#lh2pac.marilib.utils.earth.fuel_density","title":"fuel_density","text":"<pre><code>fuel_density(fuel_type, press=101325.0)\n</code></pre> <p>Reference fuel density</p> Source code in <code>src/lh2pac/marilib/utils/earth.py</code> <pre><code>def fuel_density(fuel_type, press=101325.):\n    \"\"\"Reference fuel density\n    \"\"\"\n    if (fuel_type==\"kerosene\"):\n        fuel_density = 803. # Kerosene : between 775-840 kg/m3\n    elif (fuel_type==\"gasoline\"):\n        fuel_density = 800.\n    elif (fuel_type==\"liquid_h2\"):\n        fuel_density = 70.8 # Liquid hydrogene\n    elif (fuel_type==\"compressed_h2\"):\n        p = press*1.e-5\n        fuel_density = (-3.11480362e-05*p + 7.82320891e-02)*p + 1.03207822e-01 # Compressed hydrogen at 293.15 K\n    elif (fuel_type==\"methane\"):\n        fuel_density = 422.6 # Liquid methane\n    elif (fuel_type==\"battery\"):\n        fuel_density = 2800. # Lithium-ion\n    else:\n        raise Exception(\"fuel_type key is unknown\")\n    return fuel_density\n</code></pre>"},{"location":"reference/lh2pac/marilib/utils/earth/#lh2pac.marilib.utils.earth.fuel_heat","title":"fuel_heat","text":"<pre><code>fuel_heat(fuel_type)\n</code></pre> <p>Reference fuel lower heating value or battery energy density</p> Source code in <code>src/lh2pac/marilib/utils/earth.py</code> <pre><code>def fuel_heat(fuel_type):\n    \"\"\"Reference fuel lower heating value or battery energy density\n    \"\"\"\n    if (fuel_type==\"kerosene\"):\n        fuel_heat = 43.1e6 # J/kg, kerosene\n    elif (fuel_type==\"gasoline\"):\n        fuel_heat = 46.41e6 # J/kg, kerosene\n    elif (fuel_type==\"liquid_h2\"):\n        fuel_heat = 121.0e6 # J/kg, liquid hydrogene\n    elif (fuel_type==\"compressed_h2\"):\n        fuel_heat = 140.0e6 # J/kg, compressed hydrogene\n    elif (fuel_type==\"methane\"):\n        fuel_heat = 50.3e6 # J/kg, Liquid methane\n    else:\n        raise Exception(\"fuel_type index is out of range\")\n    return fuel_heat\n</code></pre>"},{"location":"reference/lh2pac/marilib/utils/earth/#lh2pac.marilib.utils.earth.gas_data","title":"gas_data","text":"<pre><code>gas_data(gas='air')\n</code></pre> <p>Gas data for a single gas</p> Source code in <code>src/lh2pac/marilib/utils/earth.py</code> <pre><code>def gas_data(gas=\"air\"):\n    \"\"\"Gas data for a single gas\n    \"\"\"\n    r = {\"air\" : 287.053 ,\n         \"argon\" : 208. ,\n         \"carbon_dioxide\" : 188.9 ,\n         \"carbon_monoxide\" : 297. ,\n         \"helium\" : 2077. ,\n         \"hydrogen\" : 4124. ,\n         \"methane\" : 518.3 ,\n         \"nitrogen\" : 296.8 ,\n         \"oxygen\" : 259.8 ,\n         \"propane\" : 189. ,\n         \"sulphur_dioxide\" : 130. ,\n         \"steam\" : 462.\n         }.get(gas, \"Erreur: type of gas is unknown\")\n\n    gam = {\"air\" : 1.40 ,\n           \"argon\" : 1.66 ,\n           \"carbon_dioxide\" : 1.30 ,\n           \"carbon_monoxide\" : 1.40 ,\n           \"helium\" : 1.66 ,\n           \"hydrogen\" : 1.41 ,\n           \"methane\" : 1.32 ,\n           \"nitrogen\" : 1.40 ,\n           \"oxygen\" : 1.40 ,\n           \"propane\" : 1.13 ,\n           \"sulphur_dioxide\" : 1.29 ,\n           \"steam\" : 1.33\n           }.get(gas, \"Erreur: type of gas is unknown\")\n\n    cv = r/(gam-1.)\n    cp = gam*cv\n    return r,gam,cp,cv\n</code></pre>"},{"location":"reference/lh2pac/marilib/utils/earth/#lh2pac.marilib.utils.earth.gas_viscosity","title":"gas_viscosity","text":"<pre><code>gas_viscosity(tamb, gas='air')\n</code></pre> <p>Mixed gas dynamic viscosity, Sutherland's formula WARNING : result will not be accurate if gas is mixing components of too different molecular weights</p> Source code in <code>src/lh2pac/marilib/utils/earth.py</code> <pre><code>def gas_viscosity(tamb, gas=\"air\"):\n    \"\"\"Mixed gas dynamic viscosity, Sutherland's formula\n    WARNING : result will not be accurate if gas is mixing components of too different molecular weights\n    \"\"\"\n    data = {\"air\"             : [1.715e-5, 273.15, 110.4] ,\n            \"ammonia\"         : [0.92e-5, 273.15, 382.9] ,\n            \"argon\"           : [2.10e-5, 273.15, 155.6] ,\n            \"benzene\"         : [0.70e-5, 273.15, 173.1] ,\n            \"carbon_dioxide\"  : [1.37e-5, 273.15, 253.4] ,\n            \"carbon_monoxide\" : [1.66e-5, 273.15,  94.0] ,\n            \"chlorine\"        : [1.23e-5, 273.15, 273.0] ,\n            \"chloroform\"      : [0.94e-5, 273.15, 284.2] ,\n            \"ethylene\"        : [0.97e-5, 273.15, 163.7] ,\n            \"helium\"          : [1.87e-5, 273.15,  69.7] ,\n            \"hydrogen\"        : [0.84e-5, 273.15,  60.4] ,\n            \"methane\"         : [1.03e-5, 273.15, 166.3] ,\n            \"neon\"            : [2.98e-5, 273.15,  80.8] ,\n            \"nitrogen\"        : [1.66e-5, 273.15, 110.9] ,\n            \"nitrous oxide\"   : [1.37e-5, 273.15, 253.4] ,\n            \"oxygen\"          : [1.95e-5, 273.15,  57.9] ,\n            \"steam\"           : [0.92e-5, 273.15, 154.8] ,\n            \"sulphur_dioxide\" : [1.16e-5, 273.15, 482.3] ,\n            \"xenon\"           : [2.12e-5, 273.15, 302.6]\n            }                 #  mu0      T0      S\n    # gas={\"nitrogen\":0.80, \"oxygen\":0.20}\n    # mu = 0.\n    # for g in list(gas.keys()):\n    #     [mu0,T0,S] = data[g]\n    #     mu = mu + gas[g]*(mu0*((T0+S)/(tamb+S))*(tamb/T0)**1.5)\n    mu0,T0,S = data[gas]\n    mu = (mu0*((T0+S)/(tamb+S))*(tamb/T0)**1.5)\n    return mu\n</code></pre>"},{"location":"reference/lh2pac/marilib/utils/earth/#lh2pac.marilib.utils.earth.gravity","title":"gravity","text":"<pre><code>gravity()\n</code></pre> <p>Reference gravity acceleration</p> Source code in <code>src/lh2pac/marilib/utils/earth.py</code> <pre><code>def gravity():\n    \"\"\"Reference gravity acceleration\n    \"\"\"\n    g = 9.80665     # Gravity acceleration at sea level\n    return g\n</code></pre>"},{"location":"reference/lh2pac/marilib/utils/earth/#lh2pac.marilib.utils.earth.mach_from_vcas","title":"mach_from_vcas","text":"<pre><code>mach_from_vcas(pamb, Vcas)\n</code></pre> <p>Mach number from calibrated air speed, subsonic only</p> Source code in <code>src/lh2pac/marilib/utils/earth.py</code> <pre><code>def mach_from_vcas(pamb,Vcas):\n    \"\"\"Mach number from calibrated air speed, subsonic only\n    \"\"\"\n    r,gam,Cp,Cv = gas_data()\n    P0 = sea_level_pressure()\n    vc0 = sea_level_sound_speed()\n    fac = gam/(gam-1.)\n    mach = numpy.sqrt(((((((gam-1.)/2.)*(Vcas/vc0)**2+1)**fac-1.)*P0/pamb+1.)**(1./fac)-1.)*(2./(gam-1.)))\n    return mach\n</code></pre>"},{"location":"reference/lh2pac/marilib/utils/earth/#lh2pac.marilib.utils.earth.mach_from_vtas","title":"mach_from_vtas","text":"<pre><code>mach_from_vtas(altp, disa, vtas)\n</code></pre> <p>True air speed from Mach number, subsonic only</p> Source code in <code>src/lh2pac/marilib/utils/earth.py</code> <pre><code>def mach_from_vtas(altp,disa,vtas):\n    \"\"\"True air speed from Mach number, subsonic only\n    \"\"\"\n    pamb,tamb,tstd,dtodz = atmosphere(altp,disa)\n    vsnd = sound_speed(tamb)\n    mach = vtas/vsnd\n    return mach\n</code></pre>"},{"location":"reference/lh2pac/marilib/utils/earth/#lh2pac.marilib.utils.earth.pressure","title":"pressure","text":"<pre><code>pressure(altp)\n</code></pre> <p>Pressure from pressure altitude from ground to 50 km</p> Source code in <code>src/lh2pac/marilib/utils/earth.py</code> <pre><code>def pressure(altp):\n    \"\"\"Pressure from pressure altitude from ground to 50 km\n    \"\"\"\n    g = gravity()\n    R,gam,Cp,Cv = gas_data()\n\n    Z = numpy.array([0., 11000., 20000.,32000., 47000., 50000.])\n    dtodz = numpy.array([-0.0065, 0., 0.0010, 0.0028, 0.])\n\n    P = numpy.array([sea_level_pressure(), 0., 0., 0., 0., 0.])\n    T = numpy.array([sea_level_temperature(), 0., 0., 0., 0., 0.])\n\n    if (Z[-1]&lt;altp):\n        raise Exception(\"pressure, altitude cannot exceed 50km\")\n\n    j = 0\n\n    while (Z[1+j]&lt;=altp):\n        T[j+1] = T[j] + dtodz[j]*(Z[j+1]-Z[j])\n        if (0.&lt;numpy.abs(dtodz[j])):\n            P[j+1] = P[j]*(1. + (dtodz[j]/T[j])*(Z[j+1]-Z[j]))**(-g/(R*dtodz[j]))\n        else:\n            P[j+1] = P[j]*numpy.exp(-(g/R)*((Z[j+1]-Z[j])/T[j]))\n        j = j + 1\n\n    if (0.&lt;numpy.abs(dtodz[j])):\n        pamb = P[j]*(1 + (dtodz[j]/T[j])*(altp-Z[j]))**(-g/(R*dtodz[j]))\n    else:\n        pamb = P[j]*numpy.exp(-(g/R)*((altp-Z[j])/T[j]))\n\n    return pamb\n</code></pre>"},{"location":"reference/lh2pac/marilib/utils/earth/#lh2pac.marilib.utils.earth.pressure_altitude","title":"pressure_altitude","text":"<pre><code>pressure_altitude(pamb)\n</code></pre> <p>Pressure altitude from ground to 50 km</p> Source code in <code>src/lh2pac/marilib/utils/earth.py</code> <pre><code>def pressure_altitude(pamb):\n    \"\"\"Pressure altitude from ground to 50 km\n    \"\"\"\n    g = gravity()\n    R,gam,Cp,Cv = gas_data()\n\n    Z = numpy.array([0., 11000., 20000.,32000., 47000., 50000.])\n    dtodz = numpy.array([-0.0065, 0., 0.0010, 0.0028, 0.])\n\n    P = numpy.array([sea_level_pressure(), 0., 0., 0., 0., 0.])\n    T = numpy.array([sea_level_temperature(), 0., 0., 0., 0., 0.])\n\n    j = 0\n    n = len(P)-1\n    P[1] = P[0]*(1. + (dtodz[0]/T[0])*(Z[1]-Z[0]))**(-g/(R*dtodz[0]))\n    T[1] = T[0] + dtodz[0]*(Z[1]-Z[0])\n\n    while (j&lt;n and pamb&lt;P[j+1]):\n        j = j + 1\n        T[j+1] = T[j] + dtodz[j]*(Z[j+1]-Z[j])\n        if (0.&lt;numpy.abs(dtodz[j])):\n            P[j+1] = P[j]*(1. + (dtodz[j]/T[j])*(Z[j+1]-Z[j]))**(-g/(R*dtodz[j]))\n        else:\n            P[j+1] = P[j]*numpy.exp(-(g/R)*((Z[j+1]-Z[j])/T[j]))\n\n    if (pamb&lt;P[j+1]):\n        raise Exception(\"pressure_altitude, altitude cannot exceed 50km\")\n\n    if (0.&lt;numpy.abs(dtodz[j])):\n        altp = Z[j] + ((pamb/P[j])**(-(R*dtodz[j])/g) - 1)*(T[j]/dtodz[j])\n    else:\n        altp = Z[j] - (T[j]/(g/R))*numpy.log(pamb/P[j])\n\n    return altp\n</code></pre>"},{"location":"reference/lh2pac/marilib/utils/earth/#lh2pac.marilib.utils.earth.reynolds_number","title":"reynolds_number","text":"<pre><code>reynolds_number(pamb, tamb, mach)\n</code></pre> <p>Reynolds number based on Sutherland viscosity model</p> Source code in <code>src/lh2pac/marilib/utils/earth.py</code> <pre><code>def reynolds_number(pamb,tamb,mach):\n    \"\"\"Reynolds number based on Sutherland viscosity model\n    \"\"\"\n    vsnd = sound_speed(tamb)\n    rho,sig = air_density(pamb,tamb)\n    mu = gas_viscosity(tamb)\n    re = rho*vsnd*mach/mu\n    return re\n</code></pre>"},{"location":"reference/lh2pac/marilib/utils/earth/#lh2pac.marilib.utils.earth.reynolds_number_old","title":"reynolds_number_old","text":"<pre><code>reynolds_number_old(pamb, tamb, mach)\n</code></pre> <p>Reynolds number</p> Source code in <code>src/lh2pac/marilib/utils/earth.py</code> <pre><code>def reynolds_number_old(pamb,tamb,mach):\n    \"\"\"Reynolds number\n    \"\"\"\n    fac = ( 1. + 0.126*mach**2 )\n    re = 47899*pamb*mach*(fac*tamb + 110.4) / (tamb**2 * fac**2.5)\n    return re\n</code></pre>"},{"location":"reference/lh2pac/marilib/utils/earth/#lh2pac.marilib.utils.earth.sea_level_density","title":"sea_level_density","text":"<pre><code>sea_level_density()\n</code></pre> <p>Reference air density at sea level</p> Source code in <code>src/lh2pac/marilib/utils/earth.py</code> <pre><code>def sea_level_density():\n    \"\"\"Reference air density at sea level\n    \"\"\"\n    rho0 = 1.225    # (kg/m3) Air density at sea level\n    return rho0\n</code></pre>"},{"location":"reference/lh2pac/marilib/utils/earth/#lh2pac.marilib.utils.earth.sea_level_pressure","title":"sea_level_pressure","text":"<pre><code>sea_level_pressure()\n</code></pre> <p>Reference air pressure at sea level</p> Source code in <code>src/lh2pac/marilib/utils/earth.py</code> <pre><code>def sea_level_pressure():\n    \"\"\"Reference air pressure at sea level\n    \"\"\"\n    P0 = 101325.    # Pascals\n    return P0\n</code></pre>"},{"location":"reference/lh2pac/marilib/utils/earth/#lh2pac.marilib.utils.earth.sea_level_sound_speed","title":"sea_level_sound_speed","text":"<pre><code>sea_level_sound_speed()\n</code></pre> <p>Reference sound speed at sea level</p> Source code in <code>src/lh2pac/marilib/utils/earth.py</code> <pre><code>def sea_level_sound_speed():\n    \"\"\"Reference sound speed at sea level\n    \"\"\"\n    vc0 = 340.29    # m/s\n    return vc0\n</code></pre>"},{"location":"reference/lh2pac/marilib/utils/earth/#lh2pac.marilib.utils.earth.sea_level_temperature","title":"sea_level_temperature","text":"<pre><code>sea_level_temperature()\n</code></pre> <p>Reference air temperature at sea level</p> Source code in <code>src/lh2pac/marilib/utils/earth.py</code> <pre><code>def sea_level_temperature():\n    \"\"\"Reference air temperature at sea level\n    \"\"\"\n    T0 = 288.15    # Kelvins\n    return T0\n</code></pre>"},{"location":"reference/lh2pac/marilib/utils/earth/#lh2pac.marilib.utils.earth.sound_speed","title":"sound_speed","text":"<pre><code>sound_speed(tamb)\n</code></pre> <p>Sound speed for ideal gas</p> Source code in <code>src/lh2pac/marilib/utils/earth.py</code> <pre><code>def sound_speed(tamb):\n    \"\"\"Sound speed for ideal gas\n    \"\"\"\n    r,gam,Cp,Cv = gas_data()\n    vsnd = numpy.sqrt( gam * r * tamb )\n    return vsnd\n</code></pre>"},{"location":"reference/lh2pac/marilib/utils/earth/#lh2pac.marilib.utils.earth.total_pressure","title":"total_pressure","text":"<pre><code>total_pressure(pamb, mach)\n</code></pre> <p>Stagnation pressure</p> Source code in <code>src/lh2pac/marilib/utils/earth.py</code> <pre><code>def total_pressure(pamb,mach):\n    \"\"\"Stagnation pressure\n    \"\"\"\n    r,gam,Cp,Cv = gas_data()\n    ptot = pamb*(1+((gam-1.)/2.)*mach**2)**(gam/(gam-1.))\n    return ptot\n</code></pre>"},{"location":"reference/lh2pac/marilib/utils/earth/#lh2pac.marilib.utils.earth.total_temperature","title":"total_temperature","text":"<pre><code>total_temperature(tamb, mach)\n</code></pre> <p>Stagnation temperature</p> Source code in <code>src/lh2pac/marilib/utils/earth.py</code> <pre><code>def total_temperature(tamb,mach):\n    \"\"\"Stagnation temperature\n    \"\"\"\n    r,gam,Cp,Cv = gas_data()\n    ttot = tamb*(1.+((gam-1.)/2.)*mach**2)\n    return ttot\n</code></pre>"},{"location":"reference/lh2pac/marilib/utils/earth/#lh2pac.marilib.utils.earth.vcas_from_mach","title":"vcas_from_mach","text":"<pre><code>vcas_from_mach(pamb, mach)\n</code></pre> <p>Calibrated air speed from Mach number, subsonic only</p> Source code in <code>src/lh2pac/marilib/utils/earth.py</code> <pre><code>def vcas_from_mach(pamb,mach):\n    \"\"\"Calibrated air speed from Mach number, subsonic only\n    \"\"\"\n    r,gam,Cp,Cv = gas_data()\n    P0 = sea_level_pressure()\n    vc0 = sea_level_sound_speed()\n    fac = gam/(gam-1.)\n    vcas = vc0*numpy.sqrt((2./(gam-1.))*((((pamb/P0)*((1.+((gam-1.)/2.)*mach**2)**fac-1.))+1.)**(1./fac)-1.))\n    return vcas\n</code></pre>"},{"location":"reference/lh2pac/marilib/utils/earth/#lh2pac.marilib.utils.earth.vtas_from_mach","title":"vtas_from_mach","text":"<pre><code>vtas_from_mach(altp, disa, mach)\n</code></pre> <p>True air speed from Mach number, subsonic only</p> Source code in <code>src/lh2pac/marilib/utils/earth.py</code> <pre><code>def vtas_from_mach(altp,disa,mach):\n    \"\"\"True air speed from Mach number, subsonic only\n    \"\"\"\n    pamb,tamb,tstd,dtodz = atmosphere(altp,disa)\n    vsnd = sound_speed(tamb)\n    vtas = vsnd*mach\n    return vtas\n</code></pre>"},{"location":"reference/lh2pac/marilib/utils/earth/#lh2pac.marilib.utils.earth.vtas_from_vcas","title":"vtas_from_vcas","text":"<pre><code>vtas_from_vcas(altp, disa, vcas)\n</code></pre> <p>True air speed from calibrated air speed, subsonic only</p> Source code in <code>src/lh2pac/marilib/utils/earth.py</code> <pre><code>def vtas_from_vcas(altp,disa,vcas):\n    \"\"\"True air speed from calibrated air speed, subsonic only\n    \"\"\"\n    pamb,tamb,tstd,dtodz = atmosphere(altp,disa)\n    mach = mach_from_vcas(pamb,vcas)\n    vsnd = sound_speed(tamb)\n    vtas = vsnd*mach\n    return vtas\n</code></pre>"},{"location":"reference/lh2pac/marilib/utils/math/","title":"Math","text":""},{"location":"reference/lh2pac/marilib/utils/math/#lh2pac.marilib.utils.math","title":"math","text":"<p>A math toolbox for MARILib</p> <p>:author: DRUOT Thierry, original Scilab implementation</p> <p>:author: ROCHES Pascal, portage to Python</p>"},{"location":"reference/lh2pac/marilib/utils/math/#lh2pac.marilib.utils.math-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/utils/math/#lh2pac.marilib.utils.math.lin_interp_1d","title":"lin_interp_1d","text":"<pre><code>lin_interp_1d(x, X, Y)\n</code></pre> <p>linear interpolation without any control</p> <p>:param x: current position :param X: array of the abscissa of the known points :param Y: array of the known values at given abscissa :return: y the interpolated value of Y at x</p> Source code in <code>src/lh2pac/marilib/utils/math.py</code> <pre><code>def lin_interp_1d(x,X,Y):\n    \"\"\"linear interpolation without any control\n\n    :param x: current position\n    :param X: array of the abscissa of the known points\n    :param Y: array of the known values at given abscissa\n    :return: y the interpolated value of Y at x\n\n    \"\"\"\n    n = np.size(X)\n    for j in range(1,n):\n        if x&lt;X[j] :\n            y = Y[j-1]+(Y[j]-Y[j-1])*(x-X[j-1])/(X[j]-X[j-1])\n            return y\n    y = Y[n-2]+(Y[n-1]-Y[n-2])*(x-X[n-2])/(X[n-1]-X[n-2])\n    return y\n</code></pre>"},{"location":"reference/lh2pac/marilib/utils/math/#lh2pac.marilib.utils.math.maximize_1d","title":"maximize_1d","text":"<pre><code>maximize_1d(xini, dx, *fct)\n</code></pre> <p>Optimize 1 single variable, no constraint.</p> <p>:param xini: initial value of the variable. :param dx: fixed search step. :param fct: function with the signature : ['function_name',a1,a2,a3,...,an] and function_name(x,a1,a2,a3,...,an).</p> Source code in <code>src/lh2pac/marilib/utils/math.py</code> <pre><code>def maximize_1d(xini,dx,*fct):\n    \"\"\"Optimize 1 single variable, no constraint.\n\n    :param xini: initial value of the variable.\n    :param dx: fixed search step.\n    :param fct: function with the signature : ['function_name',a1,a2,a3,...,an] and function_name(x,a1,a2,a3,...,an).\n\n    \"\"\"\n    n = len(fct[0])\n\n    X0 = xini\n    Y0 = fct[0][0](X0,*fct[0][1:n])\n\n    X1 = X0+dx\n    Y1 = fct[0][0](X1,*fct[0][1:n])\n\n    if Y0&gt;Y1:\n        dx = -dx\n        X0,X1 = X1,X0\n\n    X2 = X1+dx\n    Y2 = fct[0][0](X2,*fct[0][1:n])\n\n    while Y1&lt;Y2:\n        X0 = X1\n        X1 = X2\n        X2 = X2+dx\n        Y0 = Y1\n        Y1 = Y2\n        Y2 = fct[0][0](X2,*fct[0][1:n])\n\n    X = np.array([X0,X1,X2])\n    Y = np.array([Y0,Y1,Y2])\n\n    A = vander3(X)     # [X**2, X, numpy.ones(3)]\n    C = trinome(A,Y)\n\n    xres = -C[1]/(2.*C[0])\n    yres = fct[0][0](xres,*fct[0][1:n])\n\n    rc = 1\n\n    return (xres,yres,rc)\n</code></pre>"},{"location":"reference/lh2pac/marilib/utils/math/#lh2pac.marilib.utils.math.trinome","title":"trinome","text":"<pre><code>trinome(A, Y)\n</code></pre> <p>calculate trinome coefficients from 3 given points A = [X2, X, 1] (Vandermonde matrix)</p> Source code in <code>src/lh2pac/marilib/utils/math.py</code> <pre><code>def trinome(A,Y):\n    \"\"\"calculate trinome coefficients from 3 given points\n    A = [X2, X, 1] (Vandermonde matrix)\n    \"\"\"\n    X = np.array([A[0][1], A[1][1], A[2][1]])\n    X2 = np.array([A[0][0], A[1][0], A[2][0]])\n\n    det = X2[0]*(X[1]-X[2])-X2[1]*(X[0]-X[2])+X2[2]*(X[0]-X[1])\n\n    adet = Y[0]*(X[1]-X[2])-Y[1]*(X[0]-X[2])+Y[2]*(X[0]-X[1])\n\n    bdet = X2[0]*(Y[1]-Y[2])-X2[1]*(Y[0]-Y[2])+X2[2]*(Y[0]-Y[1])\n\n    cdet =  X2[0]*(X[1]*Y[2]-X[2]*Y[1])-X2[1]*(X[0]*Y[2]-X[2]*Y[0]) \\\n          + X2[2]*(X[0]*Y[1]-X[1]*Y[0])\n\n    if det!=0:\n        C = np.array([adet/det, bdet/det, cdet/det])\n    elif X[0]!=X[2]:\n        C = np.array([0., Y[0]-Y[2], Y[2]*X[0]-Y[0]*X[2]/(X[0]-X[2])])\n    else:\n        C = np.array([0., 0., (Y[0]+Y[1]+Y[2])/3.])\n\n    return C\n</code></pre>"},{"location":"reference/lh2pac/marilib/utils/math/#lh2pac.marilib.utils.math.vander3","title":"vander3","text":"<pre><code>vander3(X)\n</code></pre> <p>Return the vandermonde matrix of a dim 3 array A = [X^2, X, 1]</p> Source code in <code>src/lh2pac/marilib/utils/math.py</code> <pre><code>def vander3(X):\n    \"\"\"Return the vandermonde matrix of a dim 3 array A = [X^2, X, 1]\n    \"\"\"\n    V = np.array([[X[0]**2, X[0], 1.],\n                  [X[1]**2, X[1], 1.],\n                  [X[2]**2, X[2], 1.]])\n    return V\n</code></pre>"},{"location":"reference/lh2pac/marilib/utils/read_write/","title":"Read write","text":""},{"location":"reference/lh2pac/marilib/utils/read_write/#lh2pac.marilib.utils.read_write","title":"read_write","text":"<p>Fonctionalities to read and write Marilib object in human readable format or binary format. The class :class:<code>MarilibIO</code> contains several methods:</p> <ul> <li>to convert an complex object into a human readable string (JSON format)</li> <li>to write this JSON readable format in a text file</li> <li>to write an exact copy of the object in a binary file (pickle)</li> <li>to load an object from a binary file (pickle)</li> </ul> <p>Use case::</p> <pre><code>my_plane = Aircraft(\"This_plane\")\n# ... Do some stuff on my_plane\n\nio = MarilibIO()\nprint(io.to_string(my_plane)) # print a veeery long string\nio.to_json_file(my_plane,\"my_plane\")  # write into the text file \"my_plane.json\"\nio.to_binary_file(my_plane, \"my_plane\")  # save into the binary file \"my_plane.pkl\"\n</code></pre> <p>.. note::     The JSON format is very convenient to explore the numerous variable inside a complex object such as     :class:<code>marilib.aircraft.aircraft_root.Aircraft</code> but it is not an exact copy of the object, which is why you will not     find a <code>read_json_file</code> method. To save your results, you shoudl rather use :meth:<code>MarilibIO.to_binary_file</code>     and :meth:<code>MarilibIO.from_binary_file</code>.</p> <p>:author: DRUOT Thierry, MONROLIN Nicolas</p>"},{"location":"reference/lh2pac/marilib/utils/read_write/#lh2pac.marilib.utils.read_write-classes","title":"Classes","text":""},{"location":"reference/lh2pac/marilib/utils/read_write/#lh2pac.marilib.utils.read_write.MarilibIO","title":"MarilibIO","text":"<pre><code>MarilibIO()\n</code></pre> <p>               Bases: <code>object</code></p> <p>A collection of Input and Ouput functions for MARILib objects.</p> <p>1) Human readable format : uses JSON-like encoding and decoding functions adapted to MARILib objects. 2) Binary exact copy : uses pickle.</p> Source code in <code>src/lh2pac/marilib/utils/read_write.py</code> <pre><code>def __init__(self):\n    self.datadict = DATA_DICT # default units and variable description dict\n</code></pre>"},{"location":"reference/lh2pac/marilib/utils/read_write/#lh2pac.marilib.utils.read_write.MarilibIO-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/utils/read_write/#lh2pac.marilib.utils.read_write.MarilibIO.from_binary_file","title":"from_binary_file","text":"<pre><code>from_binary_file(filename)\n</code></pre> <p>Load a .pkl file as a python object</p> <p>:param filename: the binary filepath :return: the object</p> Source code in <code>src/lh2pac/marilib/utils/read_write.py</code> <pre><code>def from_binary_file(self, filename):\n    \"\"\"Load a .pkl file as a python object\n\n    :param filename: the binary filepath\n    :return: the object\n    \"\"\"\n    with open(filename, 'rb') as f:\n        obj = pickle.load(f)\n\n    return obj\n</code></pre>"},{"location":"reference/lh2pac/marilib/utils/read_write/#lh2pac.marilib.utils.read_write.MarilibIO.from_json_file","title":"from_json_file","text":"<pre><code>from_json_file(filename)\n</code></pre> <p>Reads a JSON file and parse it into a dict.</p> <p>.. warning::         The JSON format is not an exact copy of the original object. in the following sequence, <code>aircraft2</code> is         a dictionary which contains truncated values of the original <code>aircraft1</code>::</p> <pre><code>        aircraft1 =  Aircraft()\n        io = MarilibIO()\n        io.to_json_file(\"my_plane\")\n        aircraft2 = io.from_json_file(\"my_plane\")\n</code></pre> <p>:param filename: the file to parse :return: mydict : a customized dictionary, where values can be accessed like object attributes.</p> <pre><code>            Example::\n\n                aircraft2 = io.from_json_file(\"my_plane\")\n                assert(aircraft2['name'] == aircraft2.name)\n</code></pre> Source code in <code>src/lh2pac/marilib/utils/read_write.py</code> <pre><code>def from_json_file(self,filename):\n    \"\"\"Reads a JSON file and parse it into a dict.\n\n    .. warning::\n            The JSON format is not an exact copy of the original object. in the following sequence, `aircraft2` is\n            a dictionary which contains truncated values of the original `aircraft1`::\n\n                aircraft1 =  Aircraft()\n                io = MarilibIO()\n                io.to_json_file(\"my_plane\")\n                aircraft2 = io.from_json_file(\"my_plane\")\n\n    :param filename: the file to parse\n    :return: mydict : a customized dictionary, where values can be accessed like object attributes.\n\n                    Example::\n\n                        aircraft2 = io.from_json_file(\"my_plane\")\n                        assert(aircraft2['name'] == aircraft2.name)\n\n    \"\"\"\n    try:  # Add .json extension if necessary\n        last_point_position = filename.rindex(r'\\.')\n        filename = filename[:last_point_position]+\".json\"\n    except ValueError:  # dot pattern not found\n        filename = filename + \".json\"\n\n    with open(filename, 'r') as f:\n        mydict = MyDict(json.loads(f.read()))\n\n    return mydict\n</code></pre>"},{"location":"reference/lh2pac/marilib/utils/read_write/#lh2pac.marilib.utils.read_write.MarilibIO.marilib_encoding","title":"marilib_encoding","text":"<pre><code>marilib_encoding(o)\n</code></pre> <p>Default encoding function for MARILIB objects of non primitive types (int,float,list,string,tuple,dict)</p> <ul> <li>Skips <code>self.aircraft</code> entries to avoid circular reference</li> <li>Converts numpy array to list.</li> <li>Convert to default units described in <code>DATA_DICT</code></li> <li>Add a short description of each variable, found in <code>DATA_DICT</code></li> </ul> <p>:param o: the object to encode :return: the attribute dict</p> Source code in <code>src/lh2pac/marilib/utils/read_write.py</code> <pre><code>def marilib_encoding(self, o):\n    \"\"\"Default encoding function for MARILIB objects of non primitive types (int,float,list,string,tuple,dict)\n\n    * Skips `self.aircraft` entries to avoid circular reference\n    * Converts numpy array to list.\n    * Convert to default units described in `DATA_DICT`\n    * Add a short description of each variable, found in `DATA_DICT`\n\n    :param o: the object to encode\n    :return: the attribute dict\n\n    \"\"\"\n    if isinstance(o, type(np.array([]))):  # convert numpy arrays to list\n        return o.tolist()\n\n    json_dict = copy.deepcopy(o.__dict__) #  Store the public attributes, raises an AttributeError if no __dict__ is found.\n    try:\n        del json_dict['aircraft']  # Try to delete the 'aircraft' entry to avoid circular reference\n    except KeyError:\n        pass  # There was no aircraft entry =&gt; nothing to do\n\n    for key,value in json_dict.items():\n        if key in self.datadict.keys():  # if entry found in DATA_DICT, add units and docstring\n            try:\n                unit = self.datadict[key]['unit']\n                text = self.datadict[key]['txt']\n                json_dict[key] = [convert_to(unit, value), unit, text]\n            except KeyError:\n                json_dict[key] = [value, f\"WARNING: conversion to ({unit}) failed. {text}\"]\n                print(\"WARNING : unknwon unit \"+str(unit))\n        elif key == \"name\":\n            pass\n        # TODO : check that the key is in DATA_DICT\n        elif type(value) in (int,float,bool,str,list,tuple): # if not a dict, should be in the data_dict\n            print(\"Salut Thierry, tu as oublie de mettre a jour le DATA_DICT: %s n'existe pas !\" %key)\n\n    return json_dict\n</code></pre>"},{"location":"reference/lh2pac/marilib/utils/read_write/#lh2pac.marilib.utils.read_write.MarilibIO.to_binary_file","title":"to_binary_file","text":"<pre><code>to_binary_file(obj, filename)\n</code></pre> <p>Save the obj as a binary file .pkl</p> <p>:param obj: the object to save :param filename: the path :return: None</p> Source code in <code>src/lh2pac/marilib/utils/read_write.py</code> <pre><code>def to_binary_file(self,obj,filename):\n    \"\"\"Save the obj as a binary file .pkl\n\n    :param obj: the object to save\n    :param filename: the path\n    :return: None\n    \"\"\"\n    try:  # Add .pkl extension if not specified\n        last_point_position = filename.rindex(r'\\.')\n        filename = filename[:last_point_position]+\".pkl\"\n    except ValueError:  # pattern not found\n        filename = filename + \".pkl\"\n\n    with open(filename,'wb') as f:\n        pickle.dump(obj,f)\n    return\n</code></pre>"},{"location":"reference/lh2pac/marilib/utils/read_write/#lh2pac.marilib.utils.read_write.MarilibIO.to_json_file","title":"to_json_file","text":"<pre><code>to_json_file(object, filename, datadict=None)\n</code></pre> <p>Save a MARILib object in a human readable format: The object is serialized into a customized JSON-like string.</p> <p>:param object: the object to save :param filename: name of the file, optional. Ex: myObjCollection/marilib_obj.json :param datadict: argument for to_string(). The default datadict is DATA_DICT. :return: None</p> Source code in <code>src/lh2pac/marilib/utils/read_write.py</code> <pre><code>def to_json_file(self,object,filename,datadict=None):\n    \"\"\"Save a MARILib object in a human readable format:\n    The object is serialized into a customized JSON-like string.\n\n    :param object: the object to save\n    :param filename: name of the file, optional. Ex: myObjCollection/marilib_obj.json\n    :param datadict: argument for to_string(). The default datadict is DATA_DICT.\n    :return: None\n    \"\"\"\n    try:  # Add .json extension if necessary\n        last_point_position = filename.rindex(r'\\.')\n        filename = filename[:last_point_position]+\".json\"\n    except ValueError:  # pattern not found\n        filename = filename + \".json\"\n    with open(filename,'w') as f:\n        f.write(self.to_string(object,datadict=datadict))\n    return None\n</code></pre>"},{"location":"reference/lh2pac/marilib/utils/read_write/#lh2pac.marilib.utils.read_write.MarilibIO.to_string","title":"to_string","text":"<pre><code>to_string(marilib_object, datadict=None)\n</code></pre> <p>Build a human readable string output of the object in a JSON-like format. It uses :meth:<code>marilib_encoding</code> to serialize the object into a dictionary.</p> <p>:param marilib_object: the object to print :param datadict: a dictionary that give the unit and a description of each variable.     Example of datadict::</p> <pre><code>    datadict = {\n                 \"MTO\": {\"unit\":\"no_dim\", \"txt\":\"Max Takeoff rating factor\"},\n                 \"cg\": {\"unit\":\"m\", \"txt\":\"Position of the center of gravity\"}\n                }\n\n.. note::\n    by default it uses the value given during the last call. If no previous call, default is `DATA_DICT`\n    defined in `marilib.aircraft.tool.module_read_write.py`\n</code></pre> <p>:return: a customized JSON-like formatted string</p> <pre><code>.. warning::\n    Numpy arrays and lists are rewritten on one line only.It does not strictly follow the JSON standard\n</code></pre> Source code in <code>src/lh2pac/marilib/utils/read_write.py</code> <pre><code>def to_string(self,marilib_object,datadict=None):\n    \"\"\"Build a human readable string output of the object in a JSON-like format.\n    It uses :meth:`marilib_encoding` to serialize the object into a dictionary.\n\n    :param marilib_object: the object to print\n    :param datadict: a dictionary that give the unit and a description of each variable.\n        Example of datadict::\n\n            datadict = {\n                         \"MTO\": {\"unit\":\"no_dim\", \"txt\":\"Max Takeoff rating factor\"},\n                         \"cg\": {\"unit\":\"m\", \"txt\":\"Position of the center of gravity\"}\n                        }\n\n        .. note::\n            by default it uses the value given during the last call. If no previous call, default is `DATA_DICT`\n            defined in `marilib.aircraft.tool.module_read_write.py`\n\n    :return: a customized JSON-like formatted string\n\n        .. warning::\n            Numpy arrays and lists are rewritten on one line only.It does not strictly follow the JSON standard\n\n    \"\"\"\n    # Set the new data dict if one is provided\n    if (datadict is not None):\n        self.datadict = datadict\n\n    json_string = json.dumps(marilib_object, indent=4, default=self.marilib_encoding)\n    output = re.sub(r'\\[\\s+', '[', json_string)  # remove spaces after an opening bracket\n    output = re.sub(r'(?&lt;!\\}),\\s+(?!\\s*\".*\":)', ', ', output)  # remove spaces after comma not followed by \".*\":\n    output = re.sub(r'\\s+\\]', ']', output)  # remove white spaces before a closing bracket\n    # reformat floats\n    float_pattern = re.compile(r'\\d+\\.\\d+')\n    floats = (float(f) for f in float_pattern.findall(output))  # detect all floats in the json string\n    output_parts = float_pattern.split(output)  # split output around floats\n    output = ''  # init output\n    # number_format = \"%0.\"+int(STANDARD_FORMAT)+\"g\" # TODO: allow format change\n    for part,val in zip(output_parts[:-1],floats):  # reconstruct output with proper float format\n        output += part + \"%0.6g\" % float(val)  # reformat with 6 significant digits max\n    return output + output_parts[-1]\n</code></pre>"},{"location":"reference/lh2pac/marilib/utils/read_write/#lh2pac.marilib.utils.read_write.MyDict","title":"MyDict","text":"<pre><code>MyDict(*args, **kwargs)\n</code></pre> <p>               Bases: <code>dict</code></p> <p>A customized dictionary class to convert a MARILib json dict to an \"aircraft-like\" object. Converts all data to SI units. Attributes can be accessed by two manners::</p> <pre><code>obj = mydict['airframe']['wing']\n</code></pre> <p>is equivalent to::</p> <pre><code>obj = mydict.airframe.wing\n</code></pre> Source code in <code>src/lh2pac/marilib/utils/read_write.py</code> <pre><code>def __init__(self,*args,**kwargs):\n    super(MyDict,self).__init__(*args,**kwargs)\n    self.__dict__ = self\n    for key,val in self.__dict__.items(): # recursively converts all items of type 'dict' to 'MyDict'\n        if isinstance(val, dict):\n            self.__dict__[key] = MyDict(val)\n        elif isinstance(val, list): # if list, extract value and convert to SI unit\n            self.__dict__[key] = convert_from(val[1],val[0])\n        elif key == 'name': # skip the 'name' entry which is of type string\n            pass\n        elif isinstance(val, type(None)):\n            print(\"WARNING in MyDict: %s is 'None'\" %key)\n            self.__dict__[key] = None\n        else:\n            raise AttributeError(\"Unknown type, should be list or dict but type of %s is %s\" % (key, type(val)))\n</code></pre>"},{"location":"reference/lh2pac/marilib/utils/read_write/#lh2pac.marilib.utils.read_write-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/utils/unit/","title":"Unit","text":""},{"location":"reference/lh2pac/marilib/utils/unit/#lh2pac.marilib.utils.unit","title":"unit","text":"<p>Created on Thu Jan 24 23:22:21 2019</p> <p>@author: DRUOT Thierry : original Scilab implementation          PETEILH Nicolas : portage to Python</p>"},{"location":"reference/lh2pac/marilib/utils/unit/#lh2pac.marilib.utils.unit-functions","title":"Functions","text":""},{"location":"reference/lh2pac/marilib/utils/unit/#lh2pac.marilib.utils.unit.convert_from","title":"convert_from","text":"<pre><code>convert_from(ulab, val)\n</code></pre> <p>Convert val expressed in ulab to corresponding standard unit :param ulab: unit label. ex: 'NM' for Nautical miles :param val: the value to convert to SI units :return: val converted to SI units</p> Source code in <code>src/lh2pac/marilib/utils/unit.py</code> <pre><code>def convert_from(ulab, val):\n    \"\"\"Convert val expressed in ulab to corresponding standard unit\n    :param ulab: unit label. ex: 'NM' for Nautical miles\n    :param val: the value to convert to SI units\n    :return: val converted to SI units\n    \"\"\"\n\n    if isinstance(val, (type(None), str)):\n        return val\n    if isinstance(val, list):\n        return [convert_from(ulab, v) for v in val]\n    if isinstance(val, tuple):\n        return (convert_from(ulab, v) for v in val)\n    if isinstance(val, numpy.ndarray):\n        return numpy.array([convert_from(ulab, v) for v in val])\n    if isinstance(val, dict):\n        dic_val = deepcopy(val)\n        for k, v in dic_val.items():\n            dic_val[k] = convert_from(ulab, v)\n        return dic_val\n    return val * UNIT[ulab]\n</code></pre>"},{"location":"report/","title":"Report","text":""},{"location":"report/conclusion/","title":"Conclusion","text":""},{"location":"report/introduction/","title":"Introduction","text":""},{"location":"report/part1/","title":"Surrogate modeling and optimization","text":""},{"location":"report/part2/","title":"Surrogate modeling and uncertainty quantification","text":""},{"location":"report/part3/","title":"Surrogate modeling and robust optimization","text":""},{"location":"utils/installation/","title":"Installation","text":""},{"location":"utils/installation/#git","title":"Git","text":""},{"location":"utils/installation/#clone-only-once","title":"Clone (only once)","text":"<p>In your favorite working directory, e.g. <code>\"my_wd\"</code>,</p> <pre><code>git clone git@gitlab.com:MatthiasDeLozzo/lh2pac.git\n</code></pre> <p>This will create a directory <code>\"lh2pac\"</code> in <code>\"my_wd\"</code>.</p>"},{"location":"utils/installation/#create-a-working-branch-only-once","title":"Create a working branch (only once)","text":"<p>In the directory <code>\"lh2pac\"</code>:</p> <pre><code>git checkout origin/modia2024 -b my_modia2024  \n</code></pre>"},{"location":"utils/installation/#rebase-your-working-branch","title":"Rebase your working branch","text":"<p>From time to time,  I can update the git project with miscellaneous information;  you will then have to rebase your branch.</p> <p>Make sure you are on <code>my_modia2024</code>;  otherwise: <code>git checkout my_modia2024</code>.</p> <p>In the directory <code>\"my_wd/lh2pac\"</code>:</p> <pre><code>git fetch origin\ngit rebase origin/modia2024\n</code></pre>"},{"location":"utils/installation/#create-a-virtual-environment-only-once","title":"Create a virtual environment (only once)","text":"<p>In the directory <code>\"lh2pac\"</code>:</p> LinuxWindows <pre><code>python -m venv .venv\nsource .venv/bin/activate\npip install --editable .\nsource .venv/bin/deactivate\n</code></pre> <pre><code>python -m venv .venv\n.venv\\Scripts\\activate.bat\npip install --editable .\n.venv\\Scripts\\deactivate.bat\n</code></pre>"},{"location":"utils/installation/#configure-your-ide-only-once","title":"Configure your IDE (only once)","text":"<p>Select the Python interpreter: </p> LinuxWindows <p><code>\"my_wd/lh2pac/.venv/bin/python\"</code></p> <p><code>\"lh2pac\\.venv\\Scripts\\python.exe\"</code></p>"},{"location":"utils/installation/#use-your-virtual-environment-in-a-python-console","title":"Use your virtual environment in a Python console","text":"<p>In the directory <code>\"lh2pac\"</code>:</p> LinuxWindows <pre><code>source .venv/bin/activate\n</code></pre> <pre><code>.venv\\Scripts\\activate.bat\n</code></pre> <p>and use Python as usual.</p>"},{"location":"utils/installation/#compile-the-documentation","title":"Compile the documentation","text":""},{"location":"utils/installation/#compile-each-time-you-save-a-file-temporary-doc","title":"Compile each time you save a file (temporary doc)","text":"LinuxWindows <pre><code>mkdocs serve\n</code></pre> <pre><code>mkdocs.exe serve\n</code></pre> <p>The documentation is generated and can be accessed at a local domain, e.g. http://127.0.0.1:8000.</p> <p>Then, every time you save a file, the documentation will be updated automatically.</p>"},{"location":"utils/installation/#compile-permanent-doc","title":"Compile (permanent doc)","text":"<p>The previous command does not save the website; to do so, use the following command.</p> LinuxWindows <pre><code>mkdocs build\n</code></pre> <pre><code>mkdocs.exe build\n</code></pre>"},{"location":"utils/markdown/","title":"Introduction to the markdown syntax","text":"<p>markdown is an easy-to-read, what-you-see-is-what-you-get plaintext markup syntax and parser system. This is the plaintext markup language used by mkdocs, the generator of the current HTML project. Here is a short but normally sufficient introduction to markdown. For a deeper insight,  please refer to this markdown presentation. and to this Material-for-MkDocs page.</p>"},{"location":"utils/markdown/#sections","title":"Sections","text":"<p>Split a page into sections:</p> <pre><code>    # Main title\n\n    ## Sub-title\n\n    ### Sub-sub-title\n</code></pre>"},{"location":"utils/markdown/#paragraphs","title":"Paragraphs","text":"<p>Separate paragraph with blank lines.</p> <pre><code>    This is a paragraph.\n    This is the same paragraph.\n\n    This is a new paragraph separated from the previous one with a blank line.\n</code></pre> <p>This is a paragraph. This is the same paragraph.</p> <p>This is a new paragraph separated from the previous one with a blank line.</p>"},{"location":"utils/markdown/#text-formatting","title":"Text formatting","text":"<p>Surround a text with one asterisk and without whitespace between the text and the asterisk.</p> <pre><code>    Put a expression in *italics*.\n\n    Put a expression in **bold**.\n\n    Cannot but an expression both in ***italics and bold***.\n</code></pre> <p>Put an expression in italics.</p> <p>Put an expression in bold.</p> <p>Cannot but an expression both in italics and bold.</p>"},{"location":"utils/markdown/#hyperlink","title":"Hyperlink","text":"<p>Use <code>[expression](url)</code>.</p> <p>This is a hyperlink to an external content: DuckDuckGo.</p>"},{"location":"utils/markdown/#lists","title":"Lists","text":""},{"location":"utils/markdown/#unnumbered-list","title":"Unnumbered list","text":"<pre><code>    - An item.\n    - Another item.\n\n       * A sub-item (pay attention to the indentation: 4 spaces).\n       * Another sub-item.\n\n    - Another item\n      written on two lines.\n\n       1. A first sub-item (pay attention to the indentation: 4 spaces).\n       2. A second sub-item.\n</code></pre> <ul> <li>An item.</li> <li> <p>Another item.</p> </li> <li> <p>A sub-item (pay attention to the indentation: 4 spaces).</p> </li> <li> <p>Another sub-item.</p> </li> <li> <p>Another item   written on two lines.</p> </li> <li> <p>A first sub-item (pay attention to the indentation: 4 spaces).</p> </li> <li>A second sub-item.</li> </ul>"},{"location":"utils/markdown/#numbered-list","title":"Numbered list","text":"<pre><code>    1. An item.\n    1. A second item.\n\n        - A sub-item (pay attention to the indentation: 4 spaces).\n        - Another sub-item.\n\n    1. A third item\n       written on two lines.\n\n        1. A first sub-item (pay attention to the indentation: 4 spaces).\n        1. A second sub-item.\n</code></pre> <ol> <li>An item.</li> <li> <p>A second item.</p> <ul> <li>A sub-item (pay attention to the indentation: 4 spaces).</li> <li>Another sub-item.</li> </ul> </li> <li> <p>A third item    written on two lines.</p> <ol> <li>A first sub-item (pay attention to the indentation: 4 spaces).</li> <li>A second sub-item.</li> </ol> </li> </ol>"},{"location":"utils/markdown/#code-insertion","title":"Code insertion","text":"<pre><code>    Insert inline code: `y = f(x)`\n</code></pre> <p>Insert inline code: <code>y = f(x)</code></p> <p>Insert a block code using triple backquotes:</p> <pre><code>    ```python\n\n       def f(x):\n          return 2*x\n    ```\n</code></pre> <pre><code>   def f(x):\n      return 2*x\n</code></pre>"},{"location":"utils/markdown/#image-insertion","title":"Image insertion","text":"<p>Warning</p> <p>Use of relative file paths.</p> <pre><code>![gemseo](../images/gemseo.png)\n</code></pre> <p></p>"},{"location":"utils/markdown/#latex-based-mathematics","title":"LaTeX-based mathematics","text":"<p>Warning</p> <p>Do not hesitate to refresh your browser if the equations are not displayed. </p> <pre><code>    Einstein wrote $E=mc^2$.\n</code></pre> <p>Einstein wrote \\(E=mc^2\\).</p> <pre><code>    $$\n    \\begin{align}\n       (a + b)^2  &amp;=  (a + b)(a + b) \\\\\n                  &amp;=  a^2 + 2ab + b^2\n    \\end{align}       \n    $$\n</code></pre> \\[ \\begin{align}    (a + b)^2  &amp;=  (a + b)(a + b) \\\\               &amp;=  a^2 + 2ab + b^2 \\end{align} \\] <p><pre><code>    $$(a - b)^2 = a^2 - 2ab + b^2$$\n</code></pre> $$ (a - b)^2 = a^2 - 2ab + b^2 $$</p>"},{"location":"utils/markdown/#admonitions","title":"Admonitions","text":"<p>Here are a few qualifiers.  Other are available here.</p> <pre><code>    !!! note\n\n       This is a *note* block.\n\n    !!! note \"Custom title\"\n\n       This is a *note* block with a custom title.       \n\n    !!! seealso\n\n       This is a *seealso* block.\n\n    !!! warning\n\n       This is a *warning* block.\n</code></pre> <p>Note</p> <p>This is a note block.</p> <p>Custom title</p> <p>This is a note block with a custom title.       </p> <p>Seealso</p> <p>This is a seealso block.</p> <p>Warning</p> <p>This is a warning block.</p>"},{"location":"utils/markdown/#citation","title":"Citation","text":"<p>GEMSEO<sup>1</sup> is an open source software to solve multidisciplinary problem.</p> <ol> <li> <p>Gallard, F., Vanaret, C., Gu\u00e9not, D, et al., GEMS: A Python Library for Automation of Multidisciplinary Design Optimization Process Generation. In : 2018 AIAA/ASCE/AHS/ASC Structures, Structural Dynamics, and Materials Conference. 2018. p. 0657.\u00a0\u21a9</p> </li> </ol>"}]}